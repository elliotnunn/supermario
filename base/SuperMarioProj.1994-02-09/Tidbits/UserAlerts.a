;
;	File:		UserAlerts.a
;
;	Contains:	deep shit alerts (for after booting)
;
;	Copyright:	© 1984-1991, 1993 by Apple Computer, Inc., all rights reserved.
;
;   This file is used in these builds: BigBang
;
;	Change History (most recent first):
;
;	   <SM2>	 8/25/93	BH		Added stuff for manual-eject drive support and tweaked the old
;									disk-switch alert a bit.  The changes are all conditionalized
;									with hasManEject.  There is probably a better way to do this,
;									but this stuff needs somewhere to go for now.
;		<18>	 6/12/91	LN		removed #include 'HardwareEqu.a'
;		<17>	  3/4/91	dba		dty: get rid of SysVers conditionals
;		<16>	  2/7/91	dnf		kst, #79676: Use dsRecoverVCBPtr to draw the name of the volume
;									that we're attempting disk recovery on.
;		<15>	 1/14/91	stb		& mda; Add culprit name to generic crash dialog
;		<14>	 1/14/91	stb		& PKE; tweak error messages; restore A5, SR, and SP for forced
;									exits and clear MacJmp to prevent reentrancy <dfh>
;		<13>	12/15/90	stb		& KSM; improve the dsBufPtrTooLow message. add a <dfh> change to
;									DoExitToShell to clear debugger flag. add a template for
;									dsMemFullErr which show INIT or app name.
;		<12>	11/21/90	csd		& gbm; Remove the conditionals around the non-Shutdown manager
;									code because we still need it for errors that happen before the
;									Shutdown Manager is installed.
;		<11>	11/15/90	stb		& JDR; add alert for dsBufPtrTooLow
;		<10>	  9/6/90	DTY		changed the wording of the shutdown messages.  The old message
;									seemed to imply that there was a safe and an unsafe way to turn
;									off a Macintosh.
;		 <9>	 6/11/90	DDG		NEEDED FOR SIXPACK: Fixed previous comment.
;		 <8>	 6/11/90	DDG		NEEDED FOR SIXPACK: Fixed the dsNoFPU error to not spill over the
;									end of the dialog.
;		 <7>	  6/1/90	PKE		DARIN IS A BAD DOG. In <5>, he changed the symbol name
;									UImpTrapNumber to UnimplementedTrapNumber, but didn’t change the
;									reference to it, thus breaking the SixPack build. Fixed it.
;		 <6>	 5/31/90	DDG		Added a generic system error (dsNoFPU) for ericksons and elsies
;									that don’t have floating point chips.
;		 <5>	 5/30/90	dba		add alert for forced quit
;		 <4>	 1/30/90	dba		get rid of warnings when assembling; put in fancier messages;
;									fix bug #34819 by reaching down the stack to restore the value
;									of CurMap for the convenience of applications with ResumeProcs
;		 <3>	 1/12/90	CCH		added include of “HardwarePrivateEqu.a”
;		 <2>	12/28/89	dba		changed PROC to MAIN so we get dead code stripping; got rid of
;									the grayed resume button
;	   <1.4>	10/11/89	dba		reformatted file; added new ShutDown Manager “user choice”
;									alerts; improved icons
;	   <1.3>	 8/15/89	dba		OK FOR 6.0.4: get rid of Resume button in “can’t load the
;									application: Finder”
;	   <1.2>	 8/11/89	dba		NEEDED FOR 6.0.4: changed text for alerts; improved ShutDown
;									code used when ShutDown Manager is not present; added duplicate
;									button lists to handle case where ResumeProc is not NIL; added
;									system version to text of some alerts
;	   <1.1>	 5/15/89	CCH		Added alert for memory parity error. (#101)
;	   <1.0>	11/16/88	CCH		Added to EASE.
;				 8/16/88	dba		changed procs 98 and 99 to avoid collision with errors 98 and 99
;									proc 98 is now proc 1098; proc 99 is now proc 1099 this caused a
;									crash after “force-launching” a document from the Finder
;				 3/20/88	EKH		Added SysErr #98 (dsNoPatch) for RomNoPatch, so it has it's very
;									own SysErr number.
;				  1/7/88	EKH		Added Alert for "needed resource can't be loaded" error at boot
;									time (SysErr #99). This error is generated by PTCH id -1, and
;									anyone else who can not load a "do or die" resource from the
;									system file. <S355 EKH>
;				 3/30/87	jdt		Moved HD20 startup alert here from the boot alert table.
;				  3/5/87	LAK		<S088> Launch errors (System Error ID 26) modified to explain
;									that the application could not be opened and allow return to
;									Finder. Specifically, added Alert 26, Text 47, Icon 39, Procs
;									98-99, Button List 74, and String 81. Changed ShutDown alert
;									text from “power off your machine” to “turn off your Macintosh”;
;									it now shares icon 39 with launch fail alert. This file may now
;									be built as an INIT 31 file for testing (see below for sample
;									build code).
;				 12/1/86	jdt		Removed the installation code as this is now a DSAT resource.
;				  9/9/86	DLD		Changed the PowerOff Icon's bits.
;				  9/3/86	DLD		Made Reset call ShutDown if Possible.
;				  9/3/86	DLD		Added the ShutDown Alert
;				  9/2/86	DLD		Added Align 0 before ResumeString to avoid word alignment on new
;									assembler.
;				  8/4/86	DLD		Converted source to MPW.
;				 4/14/84	SC		mercilessly chopped out stuff, added RESET
;				 2/23/84	AJH		tweaked disk switch alert
;
;	NOTE: UserAlerts is loaded before PTCHs on Mac Plus and SE ROMs ($75 and $276).
;		  (BootAlerts is active while PTCHs are loaded on all other ROMs.)
;

			string asis

			load 'StandardEqu.d'
			include 'ShutDownEqu.a'
			include 'HardwarePrivateEqu.a'
			include 'GestaltEqu.a'			;													<14>
			include	'FileMgrPrivate.a'

ShutDownTrapNumber		equ		$95			; _ShutDown
UnimplementedTrapNumber	equ		$9F			; _Unimplemented

; ——————————————————————————————————————————————————————————————————————————————————————————————————

UserAlerts	main	export

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; Icon numbering:
;
;	The internal icon numbers are also used as resource IDs for color icons,
;	so they must be assigned like all other reserved resource IDs.
;	Also, like all the other numbers below, they must steer clear of system errors.
;	For this reason we use negative numbers lower than -10000.

dsiBomb					equ		-16397
dsiStop					equ		-16400

dsiDiskSwap				equ		-16398
dsiNote					equ		-16399
dsiInsertDisk			equ		-16398	; <SM1> <BH 25Aug93> yes, this is the same as dsiDiskSwap
dsiRemoveDisk			equ		-16401	; <SM1> <BH 25Aug93>

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; Numbering scheme:
;
;	These IDs must not conflict with actual system errors.
;	For this reason, we use negative numbers lower than -10000 (we start at -20000).

; for text

dstMissingPatch			equ		-20000
dstParityError			equ		-20001
dstSystemDamaged		equ		-20002

dstApplicationBusy		equ		-20100
dstFinderMissing		equ		-20101
dstGeneralError			equ		-20102
dstInsertDisk			equ		-20103
dstShutDownOrRestart	equ		-20104
dstSwitchOff			equ		-20105
dstSwitchOffOrRestart	equ		-20106
dstForcedQuit			equ		-20107
dstMemFullErr			equ		-20108
dstRemoveDisk			equ		-20109	; <SM1> <BH 25Aug93>
dstDirtyDisk			equ		-20110	; <SM1> <BH 25Aug93>

; for procedures

dspRestart				equ		-21000

dspDrawApplicationName	equ		-21100
dspDrawDiskName			equ		-21101
dspExitToShell			equ		-21102
dspGeneralError			equ		-21103
dspResume				equ		-21104
dspShutDown				equ		-21105
dspStackSniffError		equ		-21106
dspDrawForcedQuitMessage equ	-21107
dspDrawCurrentName		equ		-21108
dspDrawRmvDsk			equ		-21109	; <SM1> <BH 25Aug93>
dspDrawDirtyDsk			equ		-21110	; <SM1> <BH 25Aug93>
dspDrawNameStr			equ		-21111	; <SM1> <BH 25Aug93>

; for button lists

dsbRestart				equ		-22001	; also uses -22000

dsbFinder				equ		-22101	; also uses -22100
dsbRestartResume		equ		-22103	; also uses -22102
dsbShutDownOrRestart	equ		-22105	; also uses -22104
dsbCancelOrQuit			equ		-22107	; also uses -22106

; for button strings

dssRestart				equ		-23000

dssFinder				equ		-23100
dssResume				equ		-23101
dssShutDown				equ		-23102
dssQuit					equ		-23103
dssCancel				equ		-23104

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; Entry count: bump 1 for each new item.

	IF NOT hasManEject THEN
	NumEntries: set 47
		; 11 alerts
		; 10 texts
		;  4 icons
		;  8 button lists
		;  5 button strings
		;  9 procs
	ELSE						; if hasManEject
		NumEntries: set 52		; 13 + 9 + 5 + 8 + 5 + 12
	ENDIF
	
			dc.w	NumEntries

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; Alert definitions.
;
; 	(word)	error ID
;	(word)	10 (length of remaining items)
;	(word)	primary text definition ID
;	(word)	secondary text definition ID
;	(word)	icon definition ID
;	(word)	procedure definition ID
;	(word)	button definition ID

			; system error (handles cases not covered below)

			dc.w	dsSysErr,10,dstGeneralError,0,dsiBomb,dspGeneralError,dsbRestartResume

			; other errors

	IF hasManEject THEN														; <SM1> <BH 25Aug93>
			dc.w	dsRemoveDisk,10,0,0,dsiRemoveDisk,dspDrawRmvDsk,0		; eject request
			dc.w	dsDirtyDisk,10,0,0,dsiInsertDisk,dspDrawDirtyDsk,0		; ejected dirty
			dc.w	dsReinsert,10,0,0,dsiInsertDisk,dspDrawDiskName,0		; new disk-switch
	ELSE
			dc.w	dsReinsert,10,dstInsertDisk,0,dsiDiskSwap,dspDrawDiskName,0
	ENDIF
	
			dc.w	dsStknHeap,10,dstGeneralError,0,dsiBomb,dspStackSniffError,dsbRestartResume

			; Startup, INITs, or apps ate too much of BufPtr space or the current heap

			dc.w	dsMemFullErr,10,dstMemFullErr,0,dsiBomb,dspDrawCurrentName,dsbShutDownOrRestart

			; ShutDown Manager support

			dc.w	shutDownAlert,10,dstSwitchOff,0,dsiNote,0,dsbRestart
			dc.w	dsShutDownOrRestart,10,dstShutDownOrRestart,0,dsiNote,0,dsbShutDownOrRestart
			dc.w	dsSwitchOffOrRestart,10,dstSwitchOffOrRestart,0,dsiNote,0,dsbRestart

			; Forced Quit for MultiFinder

			dc.w	dsForcedQuit,10,dstForcedQuit,0,dsiStop,dspDrawForcedQuitMessage,dsbCancelOrQuit

			; errors in both BootAlerts and UserAlerts

			dc.w	dsBadPatch,10,dstSystemDamaged,0,dsiStop,0,dsbRestart
			dc.w	dsNoPatch,10,dstMissingPatch,0,dsiStop,0,dsbRestart
			dc.w	dsParityErr,10,dstParityError,0,dsiBomb,0,dsbRestart

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; Text definitions.
;
; 	(word)		text definition ID
;	(word)		length of rest of definition
;	(long)		location (point) - global coordinates
;	(??)		ASCII text
;	(byte)		null character

GeneralErrorMessage
			dc.w	dstGeneralError,@end-@rest
@rest
			dc.w	94,114
			DC.B	'Sorry, a system error occurred.'
			DC.B	0
			align
@end

	IF NOT hasManEject THEN		; Drawn by proc below in man-eject systems <SM1> <BH 25Aug93>
InsertDiskMessage
			dc.w	dstInsertDisk,@end-@rest
@rest
			dc.w	30,75
			DC.B	'Please insert the disk:'
			DC.B	0
			align
@end
	ENDIF	; NOT hasManEject
	
SwitchOffMessage
			dc.w	dstSwitchOff,@end-@rest
@rest
			dc.w	94,114
			DC.B	'It is now safe to switch off your Macintosh.'
			DC.B	0
			align
@end

SwitchOffOrRestartMessage
			dc.w	dstSwitchOffOrRestart,@end-@rest
@rest
			dc.w	94,114
			dc.b	'It is now safe to switch off your Macintosh./'
			dc.b	'If you wish to continue using your Macintosh,/'
			dc.b	'press Restart.'
			dc.b	0
			align
@end

ShutDownOrRestartMessage
			dc.w	dstShutDownOrRestart,@end-@rest
@rest
			dc.w	94,114
			dc.b	'If you wish to continue using your Macintosh,/'
			dc.b	'press Restart.  If not, press Shut Down.'
			dc.b	0
			align
@end

SystemDamagedMessage
			dc.w	dstSystemDamaged,@end-@rest
@rest
			dc.w	94,114
			DC.B	'The “System” file on this startup disk may be/'
			dc.b	'damaged.  The Installer can be used to repair this/'
			dc.b	'disk.'
			DC.B	0
			align
@end

MissingPatchMessage
			dc.w	dstMissingPatch,@end-@rest
@rest
			dc.w	94,114
			DC.B    'This startup disk was created with “Minimal”/'
			dc.b	'software and will not work on this Macintosh/'
			dc.b	'model.  Use the Installer to update this disk for/'
			dc.b	'this model.'
			DC.B	0
			align
@end

ParityErrorMessage
			dc.w	dstParityError,@end-@rest
@rest
			dc.w	94,114
			DC.B    'Sorry, a system error occurred./'
			DC.B    '/'
			DC.B    '  RAM parity'
			DC.B	0
			align
@end

ForcedQuitMessage
			dc.w	dstForcedQuit,@end-@rest
@rest
			dc.w	94+14,114
			dc.b	'Unsaved changes will be lost./'
			dc.b	0
			align
@end

SomebodyAteAlltheRAMMessage
			dc.w	dstMemFullErr,@end-@rest
@rest
			dc.w	94,114
			dc.b	'Not enough memory is available while using/'
			dc.b	0
			align
@end

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; icon definitions
;
; 	(word)		icon definition ID (used as resource ID for cicn)
;	(word)		length of rest of definition
;	(8 bytes)	location (rectangle) - global coordinates
;	(128 bytes)	icon data

; Susan’s bomb icon

BombIcon
			dc.w	dsiBomb,@end-@rest
@rest
			dc.w	81,60,113,92
			dc.l	$00000808, $00000010, $00000420, $00008040
			dc.l	$00002200, $00000800, $001F002A, $0020C700
			dc.l	$00403800, $00400020, $00400910, $03F81008
			dc.l	$03F82104, $03F80000, $0FFE0100, $3FFF8000
			dc.l	$3FFF8000, $7FFFC000, $7FFFC000, $FFFDE000
			dc.l	$FFFFE000, $FFFEE000, $FFFEE000, $FFFEE000
			dc.l	$FFFFE000, $FFFDE000, $7FFFC000, $7FF7C000
			dc.l	$3FFF8000, $3FFF8000, $0FFE0000, $03F80000
@end

; disk-switched icon

	IF NOT hasManEject THEN	; <SM1> <BH 25Aug93>
							; The disk-switch icon for manual-eject systems is different
DiskSwapIcon
			dc.w	dsiDiskSwap,@end-@rest
@rest
			dc.w	20,24,52,56
			dc.l	$002ADE00, $00800100, $00000080, $01000080
			dc.l	$000003E0, $010001C0, $00000080, $00000000
			dc.l	$FFF83FFC, $88A44452, $88A24451, $88224411
			dc.l	$8FE247F1, $80024001, $80024001, $9FF24FF9
			dc.l	$A00A5005, $A00A5005, $A00A5005, $A00A5005
			dc.l	$A00A5005, $A00A5005, $FFFE7FFF, $00000000
			dc.l	$01000000, $03800080, $07C00000, $01000080
			dc.l	$01000000, $00800100, $007B5400, $00000000
@end

	ELSE					; Disk insert and remove icons for manual-eject systems

DiskInsertIcon				; Used by both disk-switch and manual-eject stuff
			dc.w	dsiInsertDisk,@end-@rest
@rest
			dc.w	12,20,44,52
			dc.l	$00000000, $00000000, $00000000, $0001FFF0
			dc.l	$00011148, $00411144, $00E11044, $01F11FC4
			dc.l	$03F90004, $00E10004, $00E13FE4, $00E14014
			dc.l	$00E14014, $00E14C14, $00E15214, $00016214
			dc.l	$00014414, $0001CFFC, $00008920, $00008620
			dc.l	$00008020, $00008020, $00008020, $00008040
			dc.l	$00008080, $00008100, $00010200, $00010400
			dc.l	$0003FC00, $0003FC00, $0003FC00, $00000000
@end

DiskRemoveIcon
			dc.w	dsiRemoveDisk,@end-@rest
@rest
			dc.w	12,20,44,52
			dc.l	$00000000, $00000000, $00000000, $0001FFF0
			dc.l	$00011148, $00E11144, $00E11044, $00E11FC4
			dc.l	$00E10004, $00E10004, $00E13FE4, $03F94014
			dc.l	$01F14014, $00E14C14, $00415214, $00016214
			dc.l	$00014414, $0001CFFC, $00008920, $00008620
			dc.l	$00008020, $00008020, $00008020, $00008040
			dc.l	$00008080, $00008100, $00010200, $00010400
			dc.l	$0003FC00, $0003FC00, $0003FC00, $00000000
@end

	ENDIF	; NOT hasManEject

; stop icon

DSStopIcon
			dc.w	dsiStop,@end-@rest
@rest
			dc.w	81,60,113,92
			dc.l	$00FFFF00, $01FFFF80, $03FFFFC0, $07FEFFE0
			dc.l	$0FFC7FF0, $1FEC67F8, $3FC447FC, $7FC447FE
			dc.l	$FF4447FF, $FE4447FF, $FE4447FF, $FE4447FF
			dc.l	$FE4447FF, $FE4447FF, $FE40071F, $FE00061F
			dc.l	$FE00061F, $FE00043F, $FE00003F, $FE00007F
			dc.l	$FE00007F, $FE0000FF, $FE0000FF, $FE0001FF
			dc.l	$FE0001FF, $7E0403FE, $3F0207FC, $1FFFFFF8
			dc.l	$0FFFFFF0, $07FFFFE0, $03FFFFC0, $01FFFF80
@end

; note icon

DSNoteIcon
			dc.w	dsiNote,@end-@rest
@rest
			dc.w	81,60,113,92
			dc.l	$FFFFFFFF, $807FFFFF, $807FFFFF, $807FFFFF
			dc.l	$807FFFFF, $807FC0FF, $887F003F, $887E001F
			dc.l	$887C000F, $80780007, $80780007, $80700003
			dc.l	$8071DDC3, $80700003, $80700003, $8071DD43
			dc.l	$80700003, $80700003, $8071D703, $80700003
			dc.l	$87F00003, $81F1EEC3, $81F00007, $81F00007
			dc.l	$81F0000F, $81E0001F, $8F80007F, $81FFFFFF
			dc.l	$81FFFFFF, $81FFFFFF, $81FFFFFF, $FFFFFFFF
@end

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; button lists
;
;	(word)		button definition ID
;	(word)		length of rest of definition
;	(word)		number of buttons
;	(word)		string ID
;	(4 words)	button location (rectangle)
;	(word)		procedure definition ID
;

; Restart button list
;	this is the copy used if there is no ResumeProc
;	note that these two are identical

RestartButtons1
			dc.w	dsbRestart,@end-@rest
@rest
			dc.w	1
			dc.w	dssRestart,154,404,174,463,dspRestart
@end

; Restart button list
;	this is the copy used if there is a ResumeProc
;	note that these two are identical

RestartButtons2
			dc.w	dsbRestart+1,@end-@rest
@rest
			dc.w	1
			dc.w	dssRestart,154,404,174,463,dspRestart
@end

; Restart/Resume button list
;	this is the copy used if there is no ResumeProc

RestartResumeButtons1
			dc.w	dsbRestartResume,@end-@rest
@rest
			dc.w	1
			dc.w	dssRestart,154,404,174,463,dspRestart
@end

; Restart/Resume button list
;	this is the copy used if there is a ResumeProc
;	it includes a Resume button

RestartResumeButtons2
			dc.w	dsbRestartResume+1,@end-@rest
@rest
			dc.w	2
			dc.w	dssRestart,154,404,174,463,dspRestart
			dc.w	dssResume,154,325,174,392,dspResume
@end

; ShutDown button list
;	This is the copy used if there is no ResumeProc.
;	Note that these two are identical.

ShutDownOrRestartButtons1
			dc.w	dsbShutDownOrRestart,@end-@rest
@rest
			dc.w	2					; 2 buttons
			dc.w	dssShutDown,154,384,174,463,dspShutDown	; Shut Down button
			dc.w	dssRestart,154,313,174,372,dspRestart	; Restart button
@end

; ShutDown button list
;	This is the copy used if there is a ResumeProc.
;	Note that these two are identical.

ShutDownOrRestartButtons2
			dc.w	dsbShutDownOrRestart+1,@end-@rest
@rest
			dc.w	2					; 2 buttons
			dc.w	dssShutDown,154,384,174,463,dspShutDown	; Shut Down button
			dc.w	dssRestart,154,313,174,372,dspRestart	; Restart button
@end

; Cancel or Quit button list
;	This is the copy used if there is no ResumeProc.
;	Note that these two are identical.

CancelOrQuitButtons1
			dc.w	dsbCancelOrQuit,@end-@rest
@rest
			dc.w	2					; 2 buttons
			dc.w	dssCancel,154,411,174,463,0				; Cancel button
			dc.w	dssQuit,154,324,174,399,dspExitToShell	; Quit button
@end

; Cancel or Quit button list
;	This is the copy used if there is a ResumeProc.
;	Note that these two are identical.

CancelOrQuitButtons2
			dc.w	dsbCancelOrQuit+1,@end-@rest
@rest
			dc.w	2					; 2 buttons
			dc.w	dssCancel,154,411,174,463,0				; Cancel button
			dc.w	dssQuit,154,324,174,399,dspExitToShell	; Quit button
@end

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; button strings
;
; 	(word)		string ID
;	(word)		length of string (rounded to next word)
;	(??)		ASCII characters
;
;	strings must be padded to even lengths with spaces since they are drawn

			dc.w	dssRestart,8
			DC.B	'Restart '

			dc.w	dssResume,8
			DC.B	'Continue'

			dc.w	dssShutDown,10
			dc.b	'Shut Down '

			dc.w	dssCancel,6
			dc.b	'Cancel'

			dc.w	dssQuit,10
			dc.b	'Force Quit'

; ——————————————————————————————————————————————————————————————————————————————————————————————————
;
; Procedures.
;
; 	(word)		Procedure definition id
;	(word)		length of rest of definition
;	(??)		procedure code.

; —————————————————————————————————————————————————
;
; DoRestart is used to restart.

			dc.w	dspRestart,EndDoRestart-DoRestart

DoRestart

; restart the machine, first try to use the shutdown manager, then do our own restart
; on machines with a boot 2 resource, we always have a ShutDown Manager before UserAlerts is active

			bsr.s	ShutDownManagerInstalled	; is there a ShutDown Manager?
			bz.s	@noShutDownManager

			_SDRestart					; use the ShutDown Manager

; This code is executed on machines without ShutDown Managers.

@noShutDownManager
			bsr.s	DoUnmount			; unmount all of the volumes

			Move.L	ROMBase,a0			; point to the ROM
			Lea		ROMHeader.ReStart(a0),a0	; point to the restart routine

			btst	#6,ROM85			; old machines only need reset
			bz.s	@tooNewForReset
			reset
@tooNewForReset

			Jmp		(a0)				; exit thru the restart routine

; ShutDownManagerInstalled
;
;	This determines if the ShutDown Manager is installed.
;	It returns NZ if there is a ShutDown Manager and Z if there is not.

ShutDownManagerInstalled
			Move.W	#UnimplementedTrapNumber, D0	; get UnImpCore
			_GetTrapAddress
			Move.L	A0, A1							; saves result
			Move.W	#ShutDownTrapNumber, D0			; get ShutDown
			_GetTrapAddress
			Cmp.L	A0, A1							; compares the two
			rts

; The following routines (DoUnmount and ZapVCBQueue) are copied from the ShutDown Manager:
;
; DoUnmount - Unmount all of the Volumes on line, so the disks will be
;		updated before our power off.
;
;		Entry:	No parameters.

DoUnmount
			Sub		#IOQElSize,SP				; allocate pBlock

; Go through the VCB Queue to Flush and eject all volumes.

		  	Move.L	SP,A0						; point to the parameter block.
			Clr.L	ioVNPtr(A0)
			Clr.W	ioRefNum(A0)
			Move.L	VCBQHdr+QHead,A1			; get the queue header
			Move.L	VCBQHdr+QTail,D2			; get the tail too.
			Beq.S	@AllFlushed
			Bsr.S	ZapVCBQueue					; wipe out the whole Queue

@AllFlushed
		  	Add		#IOQElSize,SP				; deallocate pBlock
		  	Rts

; ZapVCBQueue - This ReEntrant routine goes through the VCB Queue, and calls
;			UnmountVol for each entry.
;		Entry:	A0 - IOParam Block
;				A1 - Pointer to current Entry
;				D2 - Tail entry Pointer.
;		Exit:	A1 - Pointer to next Entry.
;				D1 - Preserved.

ZapVCBQueue
			Move.W	D1,-(SP)			; save for re-entrancy.

			Move.W	vcbVRefNum(A1),D1	; get a VRefNum
			Move.L	QLink(A1),-(SP)		; go on to the next VCB
			Cmp.L	D2,A1
			Move.L	(SP)+,A1
			Beq.S	@FlushTime			; have we reached the end?
			Bsr.S	ZapVCBQueue			; not yet, save the VRefNum, call self.
@FlushTime
			Move.W	D1,ioVRefNum(A0)	; set up the refNum in the PBlock.
			_Eject
			_HUnmountVol				; shut the volume down.
			Move.W	(SP)+,D1			; restore crucial VRefNum
			Rts							; for reentrancy.

EndDoRestart

; —————————————————————————————————————————————————
;
; DoResume is used for Resume.

			dc.w	dspResume,EndDoResume-DoResume

DoResume
			move.l	GrafSize+140(sp),CurMap	; restore top resource map (see StartAlert.a)
			MOVE.L	CurrentA5,a5			; restore A5
			MOVE.L	CurStackBase,sp			; restore stack
			MOVE.L	ResumeProc,a0			; call that resume proc
			JMP		(a0)
EndDoResume

; —————————————————————————————————————————————————
;
; DoStackSniffButtons is used for the stack overflow case.
;	Otherwise it is like DoSystemErrorButtons.

			dc.w	dspStackSniffError,EndDoStackSniffButtons-DoStackSniffButtons

DoStackSniffButtons
			MOVE.L	(SP)+,A0				; get return address
			MOVE.L	CurStackBase,SP     	; reset the stack
			MOVE.L	A0,-(SP)				; restore return address
			BRA.S	DoSystemErrorButtons	; go print the ID
EndDoStackSniffButtons

; —————————————————————————————————————————————————
;
; DoSystemErrorButtons is used for system errors.
;	It prints the ID of the DS alert.

			dc.w	dspGeneralError,EndDoSystemErrorButtons-DoSystemErrorButtons

DoSystemErrorButtons
			moveq	#0,d3
			move.w	DSErrCode,d3		; get the error code
			cmp.w	#100,d3				; is it too high to display?
			bhs.s	@done

			bsr		DrawCurrentName		; draw the current name and the optional extensions msg	<15>

			MOVE.L	#((94+28)<<16)+130,-(SP)	; push location of third line
			_MoveTo						;move the pen

			moveq	#0,d0
			lea		MessagesTable,a0	; point to the table of messages
@next
			tst.b	(a0)				; end of table?
			bz.s	@doNumberedMessage
			cmp.b	(a0)+,d3			; is this the message?
			beq.s	@foundMessage
			move.b	(a0)+,d0			; get length byte of string
			add.w	d0,a0				; advance to next message in table
			bra.s	@next

@drawDigit
			or.w	#$30,d3				; turn into ASCII
			move.w	d3,-(SP)			; push it
			_DrawChar
			rts

@foundMessage
			move.l	a0,-(sp)			; display the message
			_DrawString
			bra.s	@done

@doNumberedMessage
			pea		NumberedMessage		; display the message
			_DrawString
			divu	#10,d3				; divide by 10
			bz.s	@oneDigit
			bsr.s	@drawDigit
@oneDigit
			swap	d3					; get remainder
			bsr.s	@drawDigit

@done
			RTS

			string	pascal

NumberedMessage
			dc.b	'error type '
			align
MessagesTable
			dc.b	1,'bus error'
			dc.b	2,'address error'
			dc.b	3,'illegal instruction'
			dc.b	4,'divide by zero'
			dc.b	5,'CHK error'
			dc.b	6,'numeric overflow'
			dc.b	10,'bad F-Line instruction'						;							<14>
			dc.b	12,'unimplemented trap'
			dc.b	13,'unserviceable interrupt'
			dc.b	14,'Device Manager error'
			dc.b	15,'Segment Loader error'
			dc.b	16,'SANE error'
			dc.b	17,'List Manager not present'
			dc.b	18,'BitEdit not present'
			dc.b	19,'Disk Initialization package not present'
			dc.b	20,'Standard File not present'
			dc.b	21,'SANE not present'
			dc.b	22,'SANE transcendental functions not present'
			dc.b	23,'International Utilities not present'
			dc.b	24,'Binary-Decimal Conversion package not present'
			dc.b	27,'file system map inconsistent'
			dc.b	28,'stack collision with heap'
			dc.b	33,'Memory Manager error'
			dc.b	51,'unserviceable slot interrupt'
			dc.b	81,'bad SANE opcode'
			dc.b	84,'menu purged while in use'
			dc.b	85,'couldn’t load MBDF'
			dc.b	86,'couldn’t find hierarchical menu’s parent'
			dc.b	87,'couldn’t load WDEF'
			dc.b	88,'couldn’t load CDEF'
			dc.b	90,'floating point coprocessor not installed'
			dc.b	0
			align

			string	asis

EndDoSystemErrorButtons

	IF NOT hasManEject THEN	; This proc has been replaced for man-eject systems <SM1> <BH 25Aug93>
; —————————————————————————————————————————————————
;
; DrawDiskName is used to by the disk switch alert
;	to draw the name of the volume needed.

			dc.w	dspDrawDiskName,EndDrawDiskName-DrawDiskName

DrawDiskName
			MOVE.L	#$0033004B,-(SP)				;push pen position
			_MoveTo									;position the pen

			movea.l	FSVarsPtr,a1						;get address of HFS variable area	<16>
			move.l	FSVars.dsRecoverNamePtr(a1), -(sp)	;grab our target volume's name		<16>
			_DrawString

			rts
EndDrawDiskName
	
	ELSE

; The following procedures are used to draw the various disk-insertion and disk-removal
; syserr messages for manual-eject systems.  The old DrawDiskName has been superseded by
; the one below for these systems.

; These constants are used by the disk-message-drawing code that follows
TextTop		EQU		24
TextEdge	EQU		72
LineHeight	EQU		16

;________________________________________________________________________________
; DrawNameStr is used by the following three procs to draw the name of the disk
; they need in their alert boxes.  A pointer to the string to draw as the name is
; passed on top of the stack.  The strings included in this proc are also used by
; the other procs.
;________________________________________________________________________________
			dc.w	dspDrawNameStr,EndDrawNameStr-DrawNameStr
DrawNameStr
			MOVEA.L	(SP)+,A0		; pop return addr
			MOVE.L	(SP)+,D0		; and parameter
			MOVEM.L	A0/D0,-(SP)		; swap them on the stack
			
			MOVE.W	#210,-(SP)									; “
			MOVE.L	#((TextTop+LineHeight)<<16)+TextEdge,-(SP)	; start of second line
			_MoveTo												; go there
			_DrawChar											; draw “
			
			_DrawString											; draw name (already on stack)
			
			MOVE.W	#211,-(SP)									; ”
			MOVE.W	#46,-(SP)									; .
			_DrawChar											; draw .
			_DrawChar											; draw ”
			
			RTS
			
; These strings are used by the disk-message-drawing procedures
				STRING	pascal
InsertString	DC.B	'Please insert the disk'
RemoveString	DC.B	'Please remove the disk'
UpdateString1	DC.B	'It needs to be updated'
UpdateString2	DC.B	'before you remove it.'
FromString		DC.B	'from drive '
				STRING	asis
				ALIGN
EndDrawNameStr

; DrawDiskName draws the message "Please insert the disk 'xxxx'"  It is used by both
; the old disk-switch syserr and the new manual-eject error for ejected dirty disks.
; It gets the disk name from the dsRecoverNamePtr field of the filesystem vars as the
; old disk-switch code did.
			dc.w	dspDrawDiskName,EndDrawDiskName-DrawDiskName
DrawDiskName
			PEA		InsertString						; "Please insert the disk"
			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)		; start of top line
			_MoveTo										; go there
			_DrawString									; draw message
			
			MOVEA.L	FSVarsPtr,A1
			MOVE.L	FSVars.dsRecoverNamePtr(A1),-(SP)	; get name string
			BSR		DrawNameStr							; draw it on second line
			
			RTS
EndDrawDiskName


; DrawDirtyDisk draws the same message as DrawDiskName and adds "It needs to be updated
; before you remove it" below.  It is used to request the return of a manually-ejected
; dirty disk.
			dc.w	dspDrawDirtyDsk,EndDrawDirtyDsk-DrawDirtyDsk
DrawDirtyDsk
			PEA		UpdateString2									; "before you remove it."
			MOVE.L	#((TextTop+3*LineHeight)<<16)+TextEdge,-(SP)	; start of fourth line
			PEA		UpdateString1									; "It needs to be updated"
			MOVE.L	#((TextTop+2*LineHeight)<<16)+TextEdge,-(SP)	; start of third line
			PEA		InsertString									; "Please insert the disk"
			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)					; start of top line
			_MoveTo													; go there
			_DrawString												; draw "Please insert..."
			_MoveTo													; go to third line
			_DrawString												; draw "It needs..."
			_MoveTo													; go to fourth line
			_DrawString												; draw "before you..."
			
			MOVEA.L	FSVarsPtr,A1
			MOVE.L	FSVars.dsRecoverNamePtr(A1),-(SP)	; get name string
			BSR		DrawNameStr							; draw it on second line
			
			RTS
EndDrawDirtyDsk


; DrawRmvDsk draws the message "Please remove the disk 'xxxx' from drive y."  It is used
; by the _Eject trap to get the user to eject a disk from a manual-eject drive.  The name
; and drive number are pointed to by the dsRecoverNamePtr field of the filesystem vars used
; by the disk-insertion procs.  If no name is available, the name ptr is set to nil and the
; proc does not draw it, producing "Please remove the disk from drive y."  There is always
; a drive number available.
			dc.w	dspDrawRmvDsk,EndDrawRmvDsk-DrawRmvDsk
DrawRmvDsk
			MOVEA.L	FSVarsPtr,A1
			MOVEA.L	FSVars.dsRecoverNamePtr(A1),A1	; A1 -> struct { short drvNum; char *diskName; }
			
			PEA		RemoveString									; "Please remove the disk"
			MOVE.L	#(TextTop<<16)+TextEdge,-(SP)					; start of top line
			MOVE.W	#46,-(SP)										; .
			MOVE.W	(A1),D0											; drive number
			OR.B	#$30,D0											; ASCII equivalent
			MOVE.W	D0,-(SP)
			PEA		FromString										; "from drive "
			MOVE.L	#((TextTop+LineHeight)<<16)+TextEdge,-(SP)		; start of second line
			
			TST.L	2(A1)											; disk name OK?
			BEQ.S	@drawfrom										; no: skip to "from drive"
			MOVE.L	2(A1),-(SP)										; get disk name
			BSR		DrawNameStr										; draw it on second line
			MOVE.L	#((TextTop+2*LineHeight)<<16)+TextEdge,(SP)		; start of third line for "from..."
			
@drawfrom	_MoveTo													; go to proper line
			_DrawString												; draw "from drive "
			_DrawChar												; draw number
			_DrawChar												; draw .
			_MoveTo													; go to top line
			_DrawString												; draw "Please remove..."
			
			RTS
EndDrawRmvDsk

	ENDIF	; hasManEject

; —————————————————————————————————————————————————
;
; DrawCurrentName is used to draw the name of the INIT or application which ate up too much memory.

; Use the INIT name pointed to by CurApName+4 if we’re at INIT time.  Otherwise, use CurApName.
; If the name looks bogus, don’t draw a name.
;
; If we’re at INIT time, also draw the disableExtensionMsg


			dc.w	dspDrawCurrentName,EndDrawCurrentName-DrawCurrentName

DrawCurrentName
			MOVE.L	#((94+28-14)<<16)+114,-(SP)	; push location of second line
			_MoveTo								; position the pen

			tst.b	CurApName			; are we at boot time?
			bmi.s	@getINITName		; negative could never be right if an application name was here
@getApplicationName
			lea		CurApName,a2		; push ptr to application name
			bra.s	@drawString

@getINITName
			move.l	CurApName+4,d0		; go get the pointer to the INIT name
			bmi.s	@noName				; negative?  Not valid.

			btst	#0,d0				; is it odd?
			bne.s	@noName				; Not valid

			move.l	MemTop,d1			; is it below the top of the boot globals (barrier)?
			lsr.l	#1,d1				; MemTop/2
			add.w	#1024,d1			;          + 1K
			cmp.l	d0,d1				; namePtr < barrier ?
			bls.s	@noName				; no?  Not valid.

			move.l	d0,a2				; namePtr

@drawString								; namePtr in a0
			cmp.b	#32,(a2)			; StringLength(namePtr^) < 32?
			bhs.s	@noName				; no?  Not valid.

			pea		@prefix				;																<15>
			_DrawString					;																<15>

			move.l	a2,-(sp)			; push the INIT name pointer

			_DrawString					; draw it on second line

			pea		@suffix
			_DrawString

@noName									;																<15>
			tst.b	CurApName			; are we at boot time?
			bpl.s	@allDone			; not, so leave

			MOVE.L	#((94+28+14)<<16)+114,-(SP)	; push location of fourth line
			_MoveTo								; position the pen
			pea		@disableExtensionMsg1
			_DrawString
			MOVE.L	#((94+28+28)<<16)+114,-(SP)	; push location of fourth line
			_MoveTo								; position the pen
			pea		@disableExtensionMsg2
			_DrawString

@allDone
			RTS

	string pascal

@prefix		dc.b	'“'
@suffix		dc.b	'”'
			align
@disableExtensionMsg1
			dc.b	'To temporarily turn off extensions, restart and'
			align
@disableExtensionMsg2
			dc.b	'hold down the shift key.'
			align

	string asis

EndDrawCurrentName


; —————————————————————————————————————————————————
;
; DoExitToShell is used to return to the Finder and/or kill an application.

			dc.w	dspExitToShell,EndExitToShell-DoExitToShell

DoExitToShell

; Clear MacJmp flag that is used to detect reentrancy, since no one else will do it						<14>
			move.b	MacJmpFlag,d0					; get possible debugger flag word
			cmp.b	#-1,d0							; is this an implemented flag byte?
			bne.s	UseMacJmpFlag					; if so, use it
			bclr	#7,MacJmp						; NOT in debugger any longer
			bra.s	MacJmpOK						; rejoin
UseMacJmpFlag
			bclr	#7,MacJmpFlag					; NOT in debugger any longer
MacJmpOK

; This is for boneheads who patch ExitToShell and expect A5 to have something meaningful in it			<14>
; (e.g. all apps built with Think C)
			move.l	CurrentA5,A5					; set a5 to the application's value of it

; With VM on, there is only a single, limited supervisor stack and it is not what we normally want		<14>
; to use as a stack.  The ExitToShell is a transition from the world of interrupt and error handling
; back to the normal world of applications.  Therefore, we need to switch back to user mode and the
; user stack.
; NOTE: The Process Manager switches to its own stack (but doesn't switch modes).  Application patches
; to ExitToShell, though, may use the stack extensively (e.g. to close windows) before calling through.
; The order here is important.  We don’t want to set the Supervisor stack pointer to CurStackBase.  That
; would be interesting, but not right.  So we must clear Supervisor mode first, then set the stack.

			move.l	#gestaltVMAttr,d0				; pass selector for VM attributes
			_Gestalt								; ask system about VM
			tst.w	d0
			bne.s	@stackAndModeOK					; if there was an error, forget it
			move.l	a0,d0
			btst	#gestaltVMPresent,d0
			beq.s	@stackAndModeOK					; if VM isn’t present, we shouldn't change mode/stacks
			andi	#$DFFF,SR						; turn off Supervisor mode.  Do this first, or we’ll reset
													;  the wrong stack pointer.  This is ~(1<<13)
			move.l	CurStackBase,sp					; reset the stack to a safe place so we can bail out cleanly
@stackAndModeOK

			_ExitToShell							; terminate this application (finally!)
EndExitToShell

; —————————————————————————————————————————————————
;
; ShutDown is used by the ShutDown Manager’s “user choice” alert to turn off the machine.

			dc.w	dspShutDown,EndDoShutDown-DoShutDown

DoShutDown
			bsr.s	ShutDownManagerInstalled		; is there a ShutDown Manager?				<14>
			bz.s	@noShutDownManager				;											<14>

; *** Figure out why we have to do this!														<14>
			clr.l	DSErrCode						; Voodoo black magic						<14>
			_SDPowerOff

@noShutDownManager									;											<14>
			moveq	#shutDownAlert,d0				;											<14>
			clr.l	ResumeProc						; don’t show resume button					<14>
			_SysError								;											<14>

EndDoShutDown

; —————————————————————————————————————————————————
;
; DrawForcedQuitMessage is used to draw the message for dsForcedQuit, since the message needs
;	to include the name of the application. It also forces the Window Mgr. to update the screen
;	where the forced quit alert appears by accumulating the rectangle of the alert into the
;	SysErrorUpdateRect. This is required, since otherwise no one will erase the alert.

			dc.w	dspDrawForcedQuitMessage,EndDrawForcedQuitMessage-DrawForcedQuitMessage

DrawForcedQuitMessage
			move.l	#(94<<16)+114,-(SP)	; push location of third line
			_MoveTo						; position the pen

			pea		@prefix
			_DrawString

			PEA		CurApName			; push ptr to application name
			_DrawString					; draw it on second line

			pea		@suffix
			_DrawString

; now accumulate into the SysErrorUpdateRect

			move.l	DSAlertRect+botRight,-(sp)	; move the rect onto the stack
			move.l	DSAlertRect+topLeft,-(sp)

			and.w	#$7FFF,top(sp)		; clear the high bit of top (which is usually set)

			move.l	sp,-(sp)			; union this into the SysErrorUpdateRect
			move.l	ExpandMem,a0
			pea		ExpandMemRec.SysErrorUpdateRect(a0)	; into this rect
			move.l	(sp),-(sp)			; same rect is destination
			_UnionRect

			addq	#8,sp				; get rid of the rect from the stack

			rts

	string pascal

@prefix		dc.b	'Force “'
@suffix		dc.b	'” to quit?'
			align

	string asis

EndDrawForcedQuitMessage

; ——————————————————————————————————————————————————————————————————————————————————————————————————

			end
