;
;	File:		IconUtils.a
;
;	Contains:	Assembler portion of utilities for plotting color icons.
;				Includes dispatcher.
;
;	Written by:	David Collins
;
;	Copyright:	© 1990-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM5>	  6/3/93	PN		In routines GetIconCacheData and SetIconCacheData the input
;									parameters are 8 bytes. In returning from the routines, 6 was
;									added to stack pointer and left 2 bytes on the stack. Correction
;									is made by adding 8 to stack pointer.
;	   <SM4>	11/19/92	RB		Set ROMMapInsert to MapTrue just before doing some GetResource
;									calls so that we look in ROM first.
;		<28>	  7/1/92	DC		#1032893 <csd>: Replaced the Psychotic Farmer fix to the listed
;									bug with the CubeE fix which is more robust and correct and
;									makes the world safe for Tsunami.
;		<27>	 3/20/92	DC		Removed GetGlobalPtr in future versions to take advantage of
;									GetExpandMem macro.
;		<26>	 3/19/92	DC		Changed references to printerPortCache in the globalIconData
;									structure to a separate ExpandMem reference.
;		<25>	10/29/91	DC		Rolled out all post-7.0 changes by one huge conditional for
;									Cube-E.
;		<24>	 9/27/91	DC		Fixed a bug in Get/SetIconDevice. Still treated icon globals as
;									a handle as opposed to a Ptr.
;		<23>	 8/30/91	DC		Removed GetGlobalHandle (no longer used). Added patches to
;									printing traps to intercept the creation of grafports used for
;									printing.
;		<22>	  3/5/91	DC		dba, #84160:  Added GetGlobalHandle
;		<21>	11/29/90	DC		ngk - Added GetIconDevice. Changed the internal name of
;									SetIconDevice from SetIconDevice.
;		<20>	11/27/90	DC		NGK - Added dispatch info for PlotIconHandle PlotSICNHandle and
;									PlotCIconHandle
;		<19>	 9/15/90	DC		Fixed bug in SetIconDevice
;		<18>	 7/30/90	gbm		axe warnings
;		<17>	 7/26/90	DC		Fixed some dumb bugs.
;		<16>	 7/25/90	DC		added Get/Set cache proc/data (untested)
;		<15>	 7/23/90	DC		added default label usin in PlotIconSuite glue
;		<14>	  7/5/90	DC		Added hit-testing and region-producing
;		<13>	 6/29/90	DC		Fixed ShouldPlotDeep() to not check a GrafPort's bit-depth.
;									Added GetLabel and SetLabel
;		<12>	 6/13/90	DC		Adding an install proc to set up global color icon data
;		<11>	  6/7/90	ngk		Added END to end of file to suppress warning
;		<10>	 5/31/90	DC		Changed sicn to icm#
;		 <9>	 5/30/90	DC		Changed name of interface from IconUtils.a to Icons.a
;		 <8>	 5/22/90	DC		Made IconCache a subclass of IconSuite.
;		 <7>	  5/4/90	DC		Added many routines NewIconSuite, ForEachIconDo, etc.
;		 <6>	 4/18/90	DC		Use typeTable for mapping of IconType values to corresponding
;									ResType
;		 <5>	 4/10/90	DC		Fixed dispatcher so that it dispatches as opposed to crashing
;		 <4>	  4/9/90	DC		Fixed ShouldPlotDeep
;		 <1>	  4/7/90	DC		first checked in
;
;	To Do:
;

;	this is a big conditional used to protect Cube-E from all my post-7.0 changes.  I thought
;	this was the safest way to roll back completely to 7.0.  The code in the else clause of this
;	conditional is the entirety (minus header comments) of version 64 of IconUtils.c, which is 
;	the version that went into 7.0 final.

	IF TheFuture THEN

				LOAD		'StandardEqu.d'
				INCLUDE		'InternalMacros.a'
				INCLUDE 	'LinkedPatchMacros.a'
				INCLUDE		'IconUtilsPriv.a'
				INCLUDE		'ToolUtils.a'
	
;----------------------------------------------------------------------------------
;	IconDispatch - dispatcher for all Icon utilities.
;----------------------------------------------------------------------------------

IconDispatch	BeginDispatcher	$ABC9,(Plus,SE,II,Portable,IIci)

		DispatchSelectors __PlotIconID=selectPlotIconID
		DispatchSelectors __GetIconSuite=selectGetIconSuite
		DispatchSelectors __DisposeIconSuite=selectDisposeIconSuite
		DispatchSelectors __PlotIconSuite=selectPlotIconSuite
		
		DispatchSelectors __MakeIconCache=selectMakeIconCache
		DispatchSelectors __PlotIconMethod=selectPlotIconMethod
		DispatchSelectors __LoadIconCache=selectLoadIconCache
		DispatchSelectors __NewIconSuite=selectNewIconSuite
		
		DispatchSelectors __AddIconToSuite=selectAddIconToSuite
		DispatchSelectors __GetIconFromSuite=selectGetIconFromSuite
		DispatchSelectors __ForEachIconDo=selectForEachIconDo
		DispatchSelectors __GetLabel=selectGetLabel
		
		DispatchSelectors __SetLabel=selectSetLabel
		DispatchSelectors __PtInIconID=selectPtInIconID
		DispatchSelectors __PtInIconSuite=selectPtInIconSuite
		DispatchSelectors __PtInIconMethod=selectPtInIconMethod
		
		DispatchSelectors __RectInIconID=selectRectInIconID
		DispatchSelectors __RectInIconSuite=selectRectInIconSuite
		DispatchSelectors __RectInIconMethod=selectRectInIconMethod
		DispatchSelectors __IconIDToRgn=selectIconIDToRgn
		
		DispatchSelectors __IconSuiteToRgn=selectIconSuiteToRgn
		DispatchSelectors __IconMethodToRgn=selectIconMethodToRgn
		DispatchSelectors __SetSuiteLabel=selectSetSuiteLabel
		DispatchSelectors __GetSuiteLabel=selectGetSuiteLabel
		
		DispatchSelectors __SetIconDevice=selectSetIconDevice
		DispatchSelectors __GetIconCacheData=selectGetIconCacheData
		DispatchSelectors __SetIconCacheData=selectSetIconCacheData
		DispatchSelectors __GetIconCacheProc=selectGetIconCacheProc
		
		DispatchSelectors __SetIconCacheProc=selectSetIconCacheProc
		DispatchSelectors __PlotIconHandle=selectPlotIconHandle
		DispatchSelectors __PlotSICNHandle=selectPlotSICNHandle
		DispatchSelectors __PlotCIconHandle=selectPlotCIconHandle
		
		DispatchSelectors __GetIconDevice=selectGetIconDevice
		DispatchSelectors __UpdateIconGlobals=selectUpdateIconGlobals

				EndDispatcher
				
;----------------------------------------------------------------------------------
;	typeTable - a table that maps icontype values to the corresponding ResType.
;----------------------------------------------------------------------------------

				PROC
				CASE	ON
				EXPORT	typeTable
typeTable
				CASE	OFF
				DC.L	Large1BitMask
				DC.L	Large4BitData
				DC.L	Large8BitData
				DC.L	Small1BitMask
				DC.L	Small4BitData
				DC.L	Small8BitData
				DC.L	Mini1BitMask
				DC.L	Mini4BitData
				DC.L	Mini8BitData
				CASE	ON
				
				ENDPROC

;----------------------------------------------------------------------------------
;	FromResource is a call-back of the kind used by PlotIconGeneric, IconToRgnGeneric
;	and HitTestIconGeneric (See IconUtils.c).  It is used to implement PlotIconID,
;	PtInIconID, RectInIconID and IconIDtoRgn.
;----------------------------------------------------------------------------------

FromResource	PROC	EXPORT
				IMPORT	typeTable
			MOVE.W	$A(SP), D0			;	get the icon type
			MOVE.L	$4(SP), D1			;	get the icon data
			SUBQ	#$4, SP				;	Make Room for return parameter
			ASL.W	#$2, D0				;	get index into type table
			LEA		typeTable, A1		;	get the table of resTypes
			MOVE.L	$00(A1,D0.W), -(SP)	;	push the icon type
			MOVE.W	D1, -(SP)			;	push the icon id
			MOVE.W	#MAPTRUE,ROMMAPINSERT	; look in ROM first							<SM4> rb
			_GetResource				;	call GetResource
			MOVE.L	(A7)+, D0			;	pop the handle into D0 for return
			RTS							;	return
				ENDPROC
				
;----------------------------------------------------------------------------------
;	The following block implements PlotIconID, PlotIconSuite and LoadIconCache
;----------------------------------------------------------------------------------

				PROC

				EXPORT	__PLOTICONID
				EXPORT	__PLOTICONSUITE
				EXPORT	__LOADICONCACHE
				IMPORT	PLOTICONGENERIC		;	defined in IconUtils.c
				IMPORT	FromResource
				IMPORT	FromSuite			;	defined in IconUtils.c
defaultID		EQU		2
suiteHandle		EQU		4
transform		EQU		8
labelMask		EQU		$0F00
						
__PLOTICONID
		MOVEQ		#0, D1				;	record a true value for "dontDraw"
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		MOVE.W		(A7)+, D0			;	Pop the Id off the stack
		EXT.L		D0					;	Extend the id to a long
		MOVE.L		D0, -(A7)			;	Push it back on the stack as a refcon for PlotIconGeneric
		PEA			FromResource		;	Push the address of FromResource
		BRA.S		COMMON				;	go to common code

__LOADICONCACHE
		MOVEQ		#1, D1				;	record a true value for "dontDraw"
		BRA.S		POPRETURN			;	go to the save return address code
		
__PLOTICONSUITE
		MOVE.W		transform(A7), D1	;	Get the current transform
		ANDI.W		#labelMask, D1		;	check if there is a specified label
		BNE.S		SETFLAG				;	if there is, plot normally
		MOVEA.L		suiteHandle(A7), A0	;	Get a handle to the suite
		MOVEA.L		(A0), A0			;	Get a pointer to the suite
		MOVE.W		defaultID(A0), D0	;	Get the default label
		BEQ.S		SETFLAG				;	if there is no default, plot normally
		OR.W		D0,transform(A7)	;	replace label with the new value
SETFLAG
		MOVEQ		#0, D1				;	record a false value for "dontDraw"
		
POPRETURN
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		PEA			FromSuite			;	Push the address of FromSuite (the suite handle is already on the stack)

COMMON
		MOVE.W		D1,-(A7)			;	Push the "dontDraw" value
		MOVE.L		A0, -(A7)			;	Re-push the return address
		JMP			PLOTICONGENERIC		;	Jump to PlotIconGeneric
		
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements IconIdToRgn and IconSuiteToRgn
;----------------------------------------------------------------------------------

				PROC
				EXPORT	__ICONIDTORGN
				EXPORT	__ICONSUITETORGN
				IMPORT	ICONTORGNGENERIC			
				IMPORT	FromResource
				IMPORT	FromSuite

__ICONIDTORGN				
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		MOVE.W		(A7)+, D0			;	Pop the Id off the stack
		EXT.L		D0					;	Extend the id to a long
		MOVE.L		D0, -(A7)			;	Push it back on the stack as a refcon for PlotIconGeneric
		PEA			FromResource		;	Push the address of FromResource
		BRA.S		COMMON				;	go to common code
		
__ICONSUITETORGN
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		PEA			FromSuite			;	Push the address of FromSuite (the suite handle is already on the stack)
		
COMMON
		MOVE.L		A0, -(A7)			;	Re-push the return address
		JMP			ICONTORGNGENERIC	;	Jump to IconToRgnGeneric
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements PtInIconID, PtInIconSuite, RectInIconID and
;	RectInIconSuite
;----------------------------------------------------------------------------------
				
				PROC
				EXPORT	__PTINICONID
				EXPORT	__PTINICONSUITE
				EXPORT	__RECTINICONID
				EXPORT	__RECTINICONSUITE
				IMPORT	HITTESTICONGENERIC		;	defined in IconUtils.c
				IMPORT	FromResource
				IMPORT	FromSuite				;	defined in IconUtils.c
						
__RECTINICONID
		MOVEQ		#1, D1				;	record that this is a rect call
		BRA.S		IDCODE
__PTINICONID
		MOVEQ		#0, D1				;	record that this is a point call

IDCODE	
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		MOVE.W		(A7)+, D0			;	Pop the Id off the stack
		EXT.L		D0					;	Extend the id to a long
		MOVE.L		D0, -(A7)			;	Push it back on the stack as a refcon for PlotIconGeneric
		PEA			FromResource		;	Push the address of FromResource
		BRA.S		COMMON				;	go to common code

__RECTINICONSUITE
		MOVEQ		#1, D1				;	record that this is a rect call
		BRA.S		SUITECODE
__PTINICONSUITE
		MOVEQ		#0, D1				;	record that this is a point call

SUITECODE
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		PEA			FromSuite			;	Push the address of FromSuite (the suite handle is already on the stack)

COMMON
		MOVE.W		D1,-(A7)			;	Push the IsRect value
		MOVE.L		A0, -(A7)			;	Re-push the return address
		JMP			HITTESTICONGENERIC	;	Jump to HitTestIconGeneric
		
				ENDPROC
				
;----------------------------------------------------------------------------------
;	FromMethod is a call-back of the kind used by PlotIconGeneric, IconToRgnGeneric
;	and HitTestIconGeneric (See IconUtils.c).  It is used to implement PlotIconMethod,
;	PtInIconMethod, RectInIconMethod and IconMethodtoRgn.
;----------------------------------------------------------------------------------

FromMethod		PROC	EXPORT
				IMPORT	typeTable
			MOVE.W	$A(SP), D0			;	get the icon type
			MOVEA.L	$4(SP), A0			;	get the icon data
			SUBQ	#$4, SP				;	Make Room for return parameter
			ASL.W	#$2, D0				;	get index into type table
			LEA		typeTable, A1		;	get the table of resTypes
			MOVE.L	$00(A1,D0.W), -(SP)	;	push the icon type 
			MOVE.L	(A0)+,-(SP)			;	push the method data
			MOVE.L	(A0), A0			;	get the address of the IconGetter
			JSR		(A0)				;	call the IconGetter
			MOVE.L	(A7)+, D0			;	pop the handle into D0 for return
			RTS							;	return
				ENDPROC
				
;----------------------------------------------------------------------------------
;	PlotIconMethod
;----------------------------------------------------------------------------------

__PLOTICONMETHOD	PROC	EXPORT
				IMPORT	FromMethod
				IMPORT	PLOTICONGENERIC		;	defined in IconUtils.c

			LEA		$14(SP), A0			;	Point to just beyond the rect parameter
			LEA		4(SP), A1			;	Get the address of the Method and its data
			SUBQ	#2, SP				;	Make room for return value
			MOVE.L	-(A0), -(SP)		;	Repush the rect parameter
			MOVE.L	-(A0), -(SP)		;	Repush the alignment and transform
			MOVE.L	A1, -(SP)			;	push a ptr to the method data
			PEA		FromMethod			;	push the method handler
			CLR.W	-(SP)				;	push a false for dontDraw parameter and allocate for return value
			JSR		PLOTICONGENERIC		;	Jump to PLOTICONGENERIC
			MOVE.W	(SP)+, D0			;	Get return value
			MOVEA.L	(SP), A0			;	Get return address
			LEA		$14(SP), SP			;	Pop the parameters
			MOVE.W	D0, (SP)			;	place the return value
			JMP		(A0)				;	RETURN
				ENDPROC
				
;----------------------------------------------------------------------------------
;	IconMethodToRgn
;----------------------------------------------------------------------------------

__ICONMETHODTORGN	PROC	EXPORT
				IMPORT	FromMethod
				IMPORT	ICONTORGNGENERIC		;	defined in IconUtils.c

			LEA		$16(SP), A0			;	Point to just beyond the rect parameter
			LEA		$4(SP), A1			;	Get the address of the Method and its data
			SUBQ	#$2, SP				;	Make room for return value
			MOVE.L	-(A0), -(SP)		;	Repush the RgnHandle parameter
			MOVE.L	-(A0), -(SP)		;	Repush the DestRect
			MOVE.W	-(A0), -(SP)		;	Repush the alignment
			MOVE.L	A1, -(SP)			;	push a ptr to the method data
			PEA		FromMethod			;	push the method handler
			JSR		ICONTORGNGENERIC	;	Call common icon to rgn code
			MOVE.W	(SP)+, D0			;	Get return value
			MOVEA.L	(SP), A0			;	Get return address
			LEA		$16(SP), SP			;	Pop the parameters
			MOVE.W	D0, (SP)			;	place the return value
			JMP		(A0)				;	RETURN
				ENDPROC
				
;----------------------------------------------------------------------------------
;	The following block implements PtInIconMethod and RectInIconMethod
;----------------------------------------------------------------------------------

				PROC
isAPoint		EQU	0
isARect			EQU	1
				EXPORT	__PTINICONMETHOD
				EXPORT	__RECTINICONMETHOD
				IMPORT	FromMethod
				IMPORT	HITTESTICONGENERIC		;	defined in IconUtils.c
				
__RECTINICONMETHOD
			MOVEQ	#isARect, D0		;	record that this is a rect test
			BRA.S	COMMON
			
__PTINICONMETHOD
			MOVEQ	#isAPoint, D0		;	record that this is a point test
				
COMMON			
			LEA		$16(SP), A0			;	Load A0 with address just after all params
			LEA		$4(SP),	A1			;	Get the address of the method data
			SUBQ	#$2, SP				;	make room for return value
			MOVE.L	-(A0), -(SP)		;	repush the test data (point or rect ptr)
			MOVE.L	-(A0), -(SP)		;	repush the icon dest rect
			MOVE.W	-(A0), -(SP)		;	repush the alignment
			MOVE.L	A1, -(SP)			;	push a pointer to the method data
			PEA		FromMethod			;	push the method handler
			MOVE.W	D0, -(SP)			;	push the point/rect identifier
			JSR		HITTESTICONGENERIC	;	jsr to HitTestIconGeneric
			MOVE.W	(SP)+, D0			;	pop the return value
			MOVEA.L	(SP), A0			;	pop	the return address
			LEA		$16(SP), SP			;	pop the remaining parameters
			MOVE.W	D0, (SP)			;	return the error
			JMP		(A0)				;	return
				
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements AddIconToSuite and GetIconFromSuite
;----------------------------------------------------------------------------------

				PROC

paramErr		EQU		-50
				IMPORT	EDITICONSUITE	;	defined IconUtils.c
				EXPORT	__ADDICONTOSUITE, __GETICONFROMSUITE
				
__ADDICONTOSUITE
		MOVEQ	#1, D1					;	Store a code indicating __AddIconToSuite
		BRA.S	COMMON					;	Branch to Common code
__GETICONFROMSUITE
		MOVEQ	#0, D1					;	Store a code indicating __GetIconFromSuite
COMMON	MOVEA.L	(SP), A0				;	Get the return address
		MOVE.L	D1, (SP)				;	Place the routine flag at the top of the stack
		MOVE.L	A0, -(SP)				;	Push the return address
		JMP		EDITICONSUITE
		
				ENDPROC
				
;----------------------------------------------------------------------------------
;	pascal void AdjustRgn(RgnHandle, Rect *from, Rect *to);
;	
;	exactly like MapRgn except it checks if the from and to rect are the same width
;	and height.  If they are the same width and height, it calls OffsetRgn (much cheaper).
;	It is NOT a general purpose routine.  It makes use of the fact that "from" has (0,0)
;	for a top left point.
;----------------------------------------------------------------------------------
				
ADJUSTRGN			PROC	EXPORT
TO					EQU		$4
FROM				EQU		$8
MASKRGN				EQU		$C

		MOVEA.L		TO(A7), A0			;	Get a pointer to the "to" Rect
		MOVEA.L		FROM(A7), A1		;	Get pointer to the "from" Rect
		ADDQ.L		#4, A1				;	A1 is now a pointer to the "bottom" coordinate of "from"
		
		MOVE.L		MASKRGN(A7), -(A7)	;	re-push the RgnHandle for the call to offset or map
		
		;	Get the top left point of "to" into D0.  This is also the offset of "to" from
		;	"from" because we know that "from"'s upper left is (0, 0).
		
		MOVE.L		(A0)+, D0			;	Move the top left point of "to" into D0

		;	The following code gets the difference between the bottom right point
		;	of the "to" Rect and the bottom right point of the "from" rect and
		;	stores it as a Point in D1
		
		MOVE.L		(A0), D1			;	Move the bottom right point of "to" into D1
		SWAP		D1					;	Get the bottom value into the low word of D1
		SUB.W		(A1)+, D1			;	Subtract the bottom value of "from"
		SWAP		D1					;	Get the right value of "to" into low word of D1
		SUB.W		(A1), D1			;	Subtract the right value of "from"

		;	If the two difference points are the same, then the rectangles are equivalent
		;	but offset from one another, in which case we call OffsetRgn.
		
		CMP.L		D0, D1
		BNE.S		DOMAP
		
		TST.L		D0					;	Are the Rects Identical?
		BNE.S		OFFSET				;	No, do the offset rgn.
		ADDQ.L		#4, A7				;	Yes, pop the rgn handle and leave
		BRA.S		LEAVE
		
OFFSET	MOVE.L		D0, -(A7)			;	Push the difference point
		_OffsetRgn						;	trap to OffsetRgn
		BRA.S		LEAVE				;	exit the routine

DOMAP	SUBQ.L		#$6, A1				;	Rewind A1 to point at "from"
		MOVE.L		A1, -(A7)			;	push a pointer to the "from" rect
		SUBQ.L		#$4, A0				;	Rewind A0 to point at "to"
		MOVE.L		A0, -(A7)			;	push a Pointer to the "to" rect
		_MapRgn							;	trap to MapRgn
		
LEAVE	MOVEA.L		(A7)+, A0			;	Get return address
		MOVEQ		#$C, D0				;	Clean up stack
		ADD.L		D0, A7
		JMP			(A0)				;	return
		RTS
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements GetIconCacheData, SetIconCacheData, GetIconCacheProc
;	and SetIconCacheProc
;----------------------------------------------------------------------------------
				
		CASE	OFF
				PROC
THEDATA			EQU		4				;	offset on the stack of data/proc
THECACHE		EQU		8				;	offset on the stack of the cache
				EXPORT	__GetIconCacheData, __SetIconCacheData
				EXPORT	__GetIconCacheProc, __SetIconCacheProc
				
__GetIconCacheData
		MOVEQ	#0, D0					;	record that this is a get call
		BRA.S	COMMONDATA				;	Go to the common call for Get/Set Data
		
__SetIconCacheData
		MOVEQ	#1, D0					;	record that this is a set call
		BRA.S	COMMONDATA				;	Go to the common call for Get/Set Data
		
__GetIconCacheProc
		MOVEQ	#0, D0					;	record that this is a get call
		BRA.S	COMMONPROC				;	Go to the common call for Get/Set Proc
		
__SetIconCacheProc
		MOVEQ	#1, D0					;	record that this is a set call
		
COMMONPROC
		MOVEQ	#IconCache.userMethod, D1	;	record the offset of the procPtr
		
COMMONDATA
		MOVEQ	#IconCache.userPtr, D1	;	record the offset of the data
		
COMMON	MOVEA.L	THECACHE(SP), A0		;	Get the handle to the cache
		MOVEA.L	(A0), A0				;	Get the ptr to the cache
		TST.W	IconSuite.theType(A0)	;	check if it is a cache
		BNE.S	ISSUITE					;	exit with paramErr
		MOVE.W	#paramErr, D0			;	record the error
		BRA.S	EXIT					;	cleanup and exit
ISSUITE	ADDA.L	D1, A0					;	A1 now points to data or proc as apropriate
		TST.L	D0						;	check if this is a get or set call…
		BEQ.S	GETCODE					;	and branch as appropriate.
		MOVE.L	THEDATA(SP), (A0)		;	set the apropriate member
		BRA.S	EXITOK					;	Exit without error.
GETCODE	MOVEA.L	THEDATA(SP), A1			;	get the address to return data in
		MOVE.L	(A0), (A1)				;	return the data
EXITOK	MOVEQ	#noErr, D0				;	record no error.
EXIT	MOVEA.L	(SP)+, A0				;	Pop return address into A0
		ADDQ.L	#8, SP					;	Point stack at return value <PN>
		MOVE.W	D0, (SP)				;	put return value on the stack
		JMP		(A0)					;	return
		
				ENDPROC
				
;----------------------------------------------------------------------------------
;	The following block implements SetIconDevice and GetIconDevice
;----------------------------------------------------------------------------------
				
				PROC
				EXPORT	__SetIconDevice
				EXPORT	__GetIconDevice
				
__GetIconDevice
		MOVEQ	#1, D0									;	Set flag indicating this is a GetIconDevice call
		BRA.S	COMMON
__SetIconDevice
		CLR.L	D0										;	Set flag indicating this is a SetIconDevice call

COMMON
		MOVEA.L	4(SP),	A1								;	Get the parameter
		CMPI.W	#$3FFF, ROM85							;	Bail if not color QuickDraw
		BGT.S	CHECK_AND_EXIT
		MOVE.L	EXPANDMEM, A0							;	point to expandMem
		MOVEA.L	ExpandMemRec.emIconCluts(A0), A0		;	Get pointer to our globals
		TST.L	D0										;	Is this a get or a set call?
		BEQ.S	SET

		MOVE.L	GlobalIconData.virtualScreen(A0), (A1)	;	Stuff the variable parameter with the current icon device
		BRA.S	EXIT

SET		MOVE.L	A1, GlobalIconData.virtualScreen(A0)	;	Stuff the right field with the imput data
		BRA.S	EXIT
		
CHECK_AND_EXIT
		TST.L	D0
		BEQ.S	EXIT
		CLR.L	(A1)

EXIT	MOVEA.L	(SP), A1
		ADDQ.L	#$8, SP									;	pop the parameters and return address
		JMP		(A1)									;	return 
				ENDPROC
				
;	here begins the 7.0 version of the code

	ELSE
				
				LOAD		'StandardEqu.d'
				INCLUDE		'InternalMacros.a'
				INCLUDE 	'LinkedPatchMacros.a'
				INCLUDE		'IconUtilsPriv.a'
				INCLUDE		'ToolUtils.a'
	
;----------------------------------------------------------------------------------
;	IconDispatch - dispatcher for all Icon utilities.
;----------------------------------------------------------------------------------

IconDispatch	BeginDispatcher	$ABC9,(Plus,SE,II,Portable,IIci)

		DispatchSelectors __PlotIconID=selectPlotIconID
		DispatchSelectors __GetIconSuite=selectGetIconSuite
		DispatchSelectors __DisposeIconSuite=selectDisposeIconSuite
		DispatchSelectors __PlotIconSuite=selectPlotIconSuite
		DispatchSelectors __MakeIconCache=selectMakeIconCache
		DispatchSelectors __PlotIconMethod=selectPlotIconMethod
		DispatchSelectors __LoadIconCache=selectLoadIconCache
		DispatchSelectors __NewIconSuite=selectNewIconSuite
		DispatchSelectors __AddIconToSuite=selectAddIconToSuite
		
		DispatchSelectors __GetIconFromSuite=selectGetIconFromSuite
		DispatchSelectors __ForEachIconDo=selectForEachIconDo
		DispatchSelectors __GetLabel=selectGetLabel
		DispatchSelectors __SetLabel=selectSetLabel
		DispatchSelectors __PtInIconID=selectPtInIconID
		DispatchSelectors __PtInIconSuite=selectPtInIconSuite
		DispatchSelectors __PtInIconMethod=selectPtInIconMethod
		DispatchSelectors __RectInIconID=selectRectInIconID
		DispatchSelectors __RectInIconSuite=selectRectInIconSuite
		DispatchSelectors __RectInIconMethod=selectRectInIconMethod
		DispatchSelectors __IconIDToRgn=selectIconIDToRgn
		DispatchSelectors __IconSuiteToRgn=selectIconSuiteToRgn
		DispatchSelectors __IconMethodToRgn=selectIconMethodToRgn
		DispatchSelectors __SetSuiteLabel=selectSetSuiteLabel
		DispatchSelectors __GetSuiteLabel=selectGetSuiteLabel
		DispatchSelectors __SetIconDevice=selectSetIconDevice
		DispatchSelectors __GetIconCacheData=selectGetIconCacheData
		DispatchSelectors __SetIconCacheData=selectSetIconCacheData
		DispatchSelectors __GetIconCacheProc=selectGetIconCacheProc
		DispatchSelectors __SetIconCacheProc=selectSetIconCacheProc
		
		DispatchSelectors __PlotIconHandle=selectPlotIconHandle
		DispatchSelectors __PlotSICNHandle=selectPlotSICNHandle
		DispatchSelectors __PlotCIconHandle=selectPlotCIconHandle
		DispatchSelectors __GetIconDevice=selectGetIconDevice

				EndDispatcher
				
;----------------------------------------------------------------------------------
;	typeTable - a table that maps icontype values to the corresponding ResType.
;----------------------------------------------------------------------------------

				PROC
				CASE	ON
				EXPORT	typeTable
typeTable
				CASE	OFF
				DC.L	Large1BitMask
				DC.L	Large4BitData
				DC.L	Large8BitData
				DC.L	Small1BitMask
				DC.L	Small4BitData
				DC.L	Small8BitData
				DC.L	Mini1BitMask
				DC.L	Mini4BitData
				DC.L	Mini8BitData
				CASE	ON
				
				ENDPROC

;----------------------------------------------------------------------------------
;	GetGlobalPtr and GetGlobalHandle are utilities which return either a pointer or
;	handle to the icon utilities global block
;----------------------------------------------------------------------------------

GetGlobalPtr	PROC	EXPORT
				CASE	OFF
		WITH	ExpandMemRec
		MOVE.L	ExpandMem, A0
		MOVE.L	emIconCluts(A0), A0
		MOVE.L	(A0), D0
		ENDWITH
		RTS
				CASE	ON
				ENDPROC
				
GetGlobalHandle	PROC	EXPORT
				CASE	OFF
		WITH	ExpandMemRec
		MOVE.L	ExpandMem, A0
		MOVE.L	emIconCluts(A0), D0
		ENDWITH
		RTS
				CASE	ON
				ENDPROC

;----------------------------------------------------------------------------------
;	FromResource is a call-back of the kind used by PlotIconGeneric, IconToRgnGeneric
;	and HitTestIconGeneric (See IconUtils.c).  It is used to implement PlotIconID,
;	PtInIconID, RectInIconID and IconIDtoRgn.
;----------------------------------------------------------------------------------

FromResource	PROC	EXPORT
				IMPORT	typeTable
			MOVE.W	$A(SP), D0			;	get the icon type
			MOVE.L	$4(SP), D1			;	get the icon data
			SUBQ	#$4, SP				;	Make Room for return parameter
			ASL.W	#$2, D0				;	get index into type table
			LEA		typeTable, A1		;	get the table of resTypes
			MOVE.L	$00(A1,D0.W), -(SP)	;	push the icon type
			MOVE.W	D1, -(SP)			;	push the icon id
			MOVE.W	#MAPTRUE,ROMMAPINSERT	; look in ROM first								<SM4> rb
			_GetResource				;	call GetResource
			MOVE.L	(A7)+, D0			;	pop the handle into D0 for return
			RTS							;	return
				ENDPROC
				
;----------------------------------------------------------------------------------
;	The following block implements PlotIconID, PlotIconSuite and LoadIconCache
;----------------------------------------------------------------------------------

				PROC

				EXPORT	__PLOTICONID
				EXPORT	__PLOTICONSUITE
				EXPORT	__LOADICONCACHE
				IMPORT	PLOTICONGENERIC		;	defined in IconUtils.c
				IMPORT	FromResource
				IMPORT	FromSuite			;	defined in IconUtils.c
defaultID		EQU		2
suiteHandle		EQU		4
transform		EQU		8
labelMask		EQU		$0F00
						
__PLOTICONID
		MOVEQ		#0, D1				;	record a true value for "dontDraw"
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		MOVE.W		(A7)+, D0			;	Pop the Id off the stack
		EXT.L		D0					;	Extend the id to a long
		MOVE.L		D0, -(A7)			;	Push it back on the stack as a refcon for PlotIconGeneric
		PEA			FromResource		;	Push the address of FromResource
		BRA.S		COMMON				;	go to common code

__LOADICONCACHE
		MOVEQ		#1, D1				;	record a true value for "dontDraw"
		BRA.S		POPRETURN			;	go to the save return address code
		
__PLOTICONSUITE
		MOVE.W		transform(A7), D1	;	Get the current transform
		ANDI.W		#labelMask, D1		;	check if there is a specified label
		BNE.S		SETFLAG				;	if there is, plot normally
		MOVEA.L		suiteHandle(A7), A0	;	Get a handle to the suite
		MOVEA.L		(A0), A0			;	Get a pointer to the suite
		MOVE.W		defaultID(A0), D0	;	Get the default label
		BEQ.S		SETFLAG				;	if there is no default, plot normally
		OR.W		D0,transform(A7)	;	replace label with the new value
SETFLAG
		MOVEQ		#0, D1				;	record a false value for "dontDraw"
		
POPRETURN
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		PEA			FromSuite			;	Push the address of FromSuite (the suite handle is already on the stack)

COMMON
		MOVE.W		D1,-(A7)			;	Push the "dontDraw" value
		MOVE.L		A0, -(A7)			;	Re-push the return address
		JMP			PLOTICONGENERIC		;	Jump to PlotIconGeneric
		
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements IconIdToRgn and IconSuiteToRgn
;----------------------------------------------------------------------------------

				PROC
				EXPORT	__ICONIDTORGN
				EXPORT	__ICONSUITETORGN
				IMPORT	ICONTORGNGENERIC			
				IMPORT	FromResource
				IMPORT	FromSuite

__ICONIDTORGN				
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		MOVE.W		(A7)+, D0			;	Pop the Id off the stack
		EXT.L		D0					;	Extend the id to a long
		MOVE.L		D0, -(A7)			;	Push it back on the stack as a refcon for PlotIconGeneric
		PEA			FromResource		;	Push the address of FromResource
		BRA.S		COMMON				;	go to common code
		
__ICONSUITETORGN
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		PEA			FromSuite			;	Push the address of FromSuite (the suite handle is already on the stack)
		
COMMON
		MOVE.L		A0, -(A7)			;	Re-push the return address
		JMP			ICONTORGNGENERIC	;	Jump to IconToRgnGeneric
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements PtInIconID, PtInIconSuite, RectInIconID and
;	RectInIconSuite
;----------------------------------------------------------------------------------
				
				PROC
				EXPORT	__PTINICONID
				EXPORT	__PTINICONSUITE
				EXPORT	__RECTINICONID
				EXPORT	__RECTINICONSUITE
				IMPORT	HITTESTICONGENERIC		;	defined in IconUtils.c
				IMPORT	FromResource
				IMPORT	FromSuite				;	defined in IconUtils.c
						
__RECTINICONID
		MOVEQ		#1, D1				;	record that this is a rect call
		BRA.S		IDCODE
__PTINICONID
		MOVEQ		#0, D1				;	record that this is a point call

IDCODE	
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		MOVE.W		(A7)+, D0			;	Pop the Id off the stack
		EXT.L		D0					;	Extend the id to a long
		MOVE.L		D0, -(A7)			;	Push it back on the stack as a refcon for PlotIconGeneric
		PEA			FromResource		;	Push the address of FromResource
		BRA.S		COMMON				;	go to common code

__RECTINICONSUITE
		MOVEQ		#1, D1				;	record that this is a rect call
		BRA.S		SUITECODE
__PTINICONSUITE
		MOVEQ		#0, D1				;	record that this is a point call

SUITECODE
		MOVEA.L		(A7)+, A0			;	Save the return address in A0
		PEA			FromSuite			;	Push the address of FromSuite (the suite handle is already on the stack)

COMMON
		MOVE.W		D1,-(A7)			;	Push the IsRect value
		MOVE.L		A0, -(A7)			;	Re-push the return address
		JMP			HITTESTICONGENERIC	;	Jump to HitTestIconGeneric
		
				ENDPROC
				
;----------------------------------------------------------------------------------
;	FromMethod is a call-back of the kind used by PlotIconGeneric, IconToRgnGeneric
;	and HitTestIconGeneric (See IconUtils.c).  It is used to implement PlotIconMethod,
;	PtInIconMethod, RectInIconMethod and IconMethodtoRgn.
;----------------------------------------------------------------------------------

FromMethod		PROC	EXPORT
				IMPORT	typeTable
			MOVE.W	$A(SP), D0			;	get the icon type
			MOVEA.L	$4(SP), A0			;	get the icon data
			SUBQ	#$4, SP				;	Make Room for return parameter
			ASL.W	#$2, D0				;	get index into type table
			LEA		typeTable, A1		;	get the table of resTypes
			MOVE.L	$00(A1,D0.W), -(SP)	;	push the icon type 
			MOVE.L	(A0)+,-(SP)			;	push the method data
			MOVE.L	(A0), A0			;	get the address of the IconGetter
			JSR		(A0)				;	call the IconGetter
			MOVE.L	(A7)+, D0			;	pop the handle into D0 for return
			RTS							;	return
				ENDPROC
				
;----------------------------------------------------------------------------------
;	PlotIconMethod
;----------------------------------------------------------------------------------

__PLOTICONMETHOD	PROC	EXPORT
				IMPORT	FromMethod
				IMPORT	PLOTICONGENERIC		;	defined in IconUtils.c

			LEA		$14(SP), A0			;	Point to just beyond the rect parameter
			LEA		4(SP), A1			;	Get the address of the Method and its data
			SUBQ	#2, SP				;	Make room for return value
			MOVE.L	-(A0), -(SP)		;	Repush the rect parameter
			MOVE.L	-(A0), -(SP)		;	Repush the alignment and transform
			MOVE.L	A1, -(SP)			;	push a ptr to the method data
			PEA		FromMethod			;	push the method handler
			CLR.W	-(SP)				;	push a false for dontDraw parameter and allocate for return value
			JSR		PLOTICONGENERIC		;	Jump to PLOTICONGENERIC
			MOVE.W	(SP)+, D0			;	Get return value
			MOVEA.L	(SP), A0			;	Get return address
			LEA		$14(SP), SP			;	Pop the parameters
			MOVE.W	D0, (SP)			;	place the return value
			JMP		(A0)				;	RETURN
				ENDPROC
				
;----------------------------------------------------------------------------------
;	IconMethodToRgn
;----------------------------------------------------------------------------------

__ICONMETHODTORGN	PROC	EXPORT
				IMPORT	FromMethod
				IMPORT	ICONTORGNGENERIC		;	defined in IconUtils.c

			LEA		$16(SP), A0			;	Point to just beyond the rect parameter
			LEA		$4(SP), A1			;	Get the address of the Method and its data
			SUBQ	#$2, SP				;	Make room for return value
			MOVE.L	-(A0), -(SP)		;	Repush the RgnHandle parameter
			MOVE.L	-(A0), -(SP)		;	Repush the DestRect
			MOVE.W	-(A0), -(SP)		;	Repush the alignment
			MOVE.L	A1, -(SP)			;	push a ptr to the method data
			PEA		FromMethod			;	push the method handler
			JSR		ICONTORGNGENERIC	;	Call common icon to rgn code
			MOVE.W	(SP)+, D0			;	Get return value
			MOVEA.L	(SP), A0			;	Get return address
			LEA		$16(SP), SP			;	Pop the parameters
			MOVE.W	D0, (SP)			;	place the return value
			JMP		(A0)				;	RETURN
				ENDPROC
				
;----------------------------------------------------------------------------------
;	The following block implements PtInIconMethod and RectInIconMethod
;----------------------------------------------------------------------------------

				PROC
isAPoint		EQU	0
isARect			EQU	1
				EXPORT	__PTINICONMETHOD
				EXPORT	__RECTINICONMETHOD
				IMPORT	FromMethod
				IMPORT	HITTESTICONGENERIC		;	defined in IconUtils.c
				
__RECTINICONMETHOD
			MOVEQ	#isARect, D0		;	record that this is a rect test
			BRA.S	COMMON
			
__PTINICONMETHOD
			MOVEQ	#isAPoint, D0		;	record that this is a point test
				
COMMON			
			LEA		$16(SP), A0			;	Load A0 with address just after all params
			LEA		$4(SP),	A1			;	Get the address of the method data
			SUBQ	#$2, SP				;	make room for return value
			MOVE.L	-(A0), -(SP)		;	repush the test data (point or rect ptr)
			MOVE.L	-(A0), -(SP)		;	repush the icon dest rect
			MOVE.W	-(A0), -(SP)		;	repush the alignment
			MOVE.L	A1, -(SP)			;	push a pointer to the method data
			PEA		FromMethod			;	push the method handler
			MOVE.W	D0, -(SP)			;	push the point/rect identifier
			JSR		HITTESTICONGENERIC	;	jsr to HitTestIconGeneric
			MOVE.W	(SP)+, D0			;	pop the return value
			MOVEA.L	(SP), A0			;	pop	the return address
			LEA		$16(SP), SP			;	pop the remaining parameters
			MOVE.W	D0, (SP)			;	return the error
			JMP		(A0)				;	return
				
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements AddIconToSuite and GetIconFromSuite
;----------------------------------------------------------------------------------

				PROC

paramErr		EQU		-50
				IMPORT	EDITICONSUITE	;	defined IconUtils.c
				EXPORT	__ADDICONTOSUITE, __GETICONFROMSUITE
				
__ADDICONTOSUITE
		MOVEQ	#1, D1					;	Store a code indicating __AddIconToSuite
		BRA.S	COMMON					;	Branch to Common code
__GETICONFROMSUITE
		MOVEQ	#0, D1					;	Store a code indicating __GetIconFromSuite
COMMON	MOVEA.L	(SP), A0				;	Get the return address
		MOVE.L	D1, (SP)				;	Place the routine flag at the top of the stack
		MOVE.L	A0, -(SP)				;	Push the return address
		JMP		EDITICONSUITE
		
				ENDPROC
				
;----------------------------------------------------------------------------------
;	pascal void AdjustRgn(RgnHandle, Rect *from, Rect *to);
;	
;	exactly like MapRgn except it checks if the from and to rect are the same width
;	and height.  If they are the same width and height, it calls OffsetRgn (much cheaper).
;	It is NOT a general purpose routine.  It makes use of the fact that "from" has (0,0)
;	for a top left point.
;----------------------------------------------------------------------------------
				
ADJUSTRGN			PROC	EXPORT
TO					EQU		$4
FROM				EQU		$8
MASKRGN				EQU		$C

		MOVEA.L		TO(A7), A0			;	Get a pointer to the "to" Rect
		MOVEA.L		FROM(A7), A1		;	Get pointer to the "from" Rect
		ADDQ.L		#4, A1				;	A1 is now a pointer to the "bottom" coordinate of "from"
		
		MOVE.L		MASKRGN(A7), -(A7)	;	re-push the RgnHandle for the call to offset or map
		
		;	Get the top left point of "to" into D0.  This is also the offset of "to" from
		;	"from" because we know that "from"'s upper left is (0, 0).
		
		MOVE.L		(A0)+, D0			;	Move the top left point of "to" into D0

		;	The following code gets the difference between the bottom right point
		;	of the "to" Rect and the bottom right point of the "from" rect and
		;	stores it as a Point in D1
		
		MOVE.L		(A0), D1			;	Move the bottom right point of "to" into D1
		SWAP		D1					;	Get the bottom value into the low word of D1
		SUB.W		(A1)+, D1			;	Subtract the bottom value of "from"
		SWAP		D1					;	Get the right value of "to" into low word of D1
		SUB.W		(A1), D1			;	Subtract the right value of "from"

		;	If the two difference points are the same, then the rectangles are equivalent
		;	but offset from one another, in which case we call OffsetRgn.
		
		CMP.L		D0, D1
		BNE.S		DOMAP
		
		TST.L		D0					;	Are the Rects Identical?
		BNE.S		OFFSET				;	No, do the offset rgn.
		ADDQ.L		#4, A7				;	Yes, pop the rgn handle and leave
		BRA.S		LEAVE
		
OFFSET	MOVE.L		D0, -(A7)			;	Push the difference point
		_OffsetRgn						;	trap to OffsetRgn
		BRA.S		LEAVE				;	exit the routine

DOMAP	SUBQ.L		#$6, A1				;	Rewind A1 to point at "from"
		MOVE.L		A1, -(A7)			;	push a pointer to the "from" rect
		SUBQ.L		#$4, A0				;	Rewind A0 to point at "to"
		MOVE.L		A0, -(A7)			;	push a Pointer to the "to" rect
		_MapRgn							;	trap to MapRgn
		
LEAVE	MOVEA.L		(A7)+, A0			;	Get return address
		MOVEQ		#$C, D0				;	Clean up stack
		ADD.L		D0, A7
		JMP			(A0)				;	return
		RTS
				ENDPROC

;----------------------------------------------------------------------------------
;	The following block implements GetIconCacheData, SetIconCacheData, GetIconCacheProc
;	and SetIconCacheProc
;----------------------------------------------------------------------------------
				
		CASE	OFF
				PROC
THEDATA			EQU		4				;	offset on the stack of data/proc
THECACHE		EQU		8				;	offset on the stack of the cache
				EXPORT	__GetIconCacheData, __SetIconCacheData
				EXPORT	__GetIconCacheProc, __SetIconCacheProc
				
__GetIconCacheData
		MOVEQ	#0, D0					;	record that this is a get call
		BRA.S	COMMONDATA				;	Go to the common call for Get/Set Data
		
__SetIconCacheData
		MOVEQ	#1, D0					;	record that this is a set call
		BRA.S	COMMONDATA				;	Go to the common call for Get/Set Data
		
__GetIconCacheProc
		MOVEQ	#0, D0					;	record that this is a get call
		BRA.S	COMMONPROC				;	Go to the common call for Get/Set Proc
		
__SetIconCacheProc
		MOVEQ	#1, D0					;	record that this is a set call
		
COMMONPROC
		MOVEQ	#IconCache.userMethod, D1	;	record the offset of the procPtr
		
COMMONDATA
		MOVEQ	#IconCache.userPtr, D1	;	record the offset of the data
		
COMMON	MOVEA.L	THECACHE(SP), A0		;	Get the handle to the cache
		MOVEA.L	(A0), A0				;	Get the ptr to the cache
		TST.W	IconSuite.theType(A0)	;	check if it is a cache
		BNE.S	ISSUITE					;	exit with paramErr
		MOVE.W	#paramErr, D0			;	record the error
		BRA.S	EXIT					;	cleanup and exit
ISSUITE	ADDA.L	D1, A0					;	A1 now points to data or proc as apropriate
		TST.L	D0						;	check if this is a get or set call…
		BEQ.S	GETCODE					;	and branch as appropriate.
		MOVE.L	THEDATA(SP), (A0)		;	set the apropriate member
		BRA.S	EXITOK					;	Exit without error.
GETCODE	MOVEA.L	THEDATA(SP), A1			;	get the address to return data in
		MOVE.L	(A0), (A1)				;	return the data
EXITOK	MOVEQ	#noErr, D0				;	record no error.
EXIT	MOVEA.L	(SP)+, A0				;	Pop return address into A0
		ADDQ.L	#8, SP					;	Point stack at return value <PN>
		MOVE.W	D0, (SP)				;	put return value on the stack
		JMP		(A0)					;	return
		
				ENDPROC
				
;----------------------------------------------------------------------------------
;	The following block implements SetIconDevice and GetIconDevice
;----------------------------------------------------------------------------------
				
				PROC
				EXPORT	__SetIconDevice
				EXPORT	__GetIconDevice
				
__GetIconDevice
		MOVEQ	#1, D0									;	Set flag indicating this is a GetIconDevice call
		BRA.S	COMMON
__SetIconDevice
		CLR.L	D0										;	Set flag indicating this is a SetIconDevice call

COMMON
		MOVEA.L	4(SP),	A1								;	Get the parameter
		CMPI.W	#$3FFF, ROM85							;	Bail if not color QuickDraw
		BGT.S	CHECK_AND_EXIT
		MOVE.L	EXPANDMEM, A0							;	point to expandMem
		MOVEA.L	ExpandMemRec.emIconCluts(A0), A0		;	Get Handle to our globals
		MOVEA.L	(A0), A0								;	Get pointer
		TST.L	D0										;	Is this a get or a set call?
		BEQ.S	SET

		MOVE.L	GlobalIconData.virtualScreen(A0), (A1)	;	Stuff the variable parameter with the current icon device
		BRA.S	EXIT

SET		MOVE.L	A1, GlobalIconData.virtualScreen(A0)	;	Stuff the right field with the imput data
		BRA.S	EXIT
		
CHECK_AND_EXIT
		TST.L	D0
		BEQ.S	EXIT
		CLR.L	(A1)

EXIT	MOVEA.L	(SP), A1
		ADDQ.L	#$8, SP									;	pop the parameters and return address
		JMP		(A1)									;	return 
				ENDPROC

	ENDIF
	
		END		; of file 