;
;	File:		FPOPS.a
;
;	Contains:	xxx put contents here xxx
;
;	Written by:	The Apple Numerics Group
;
;	Copyright:	© 1990-1993 by Apple Computer, Inc., all rights reserved.
;
;   This file is used in these builds:   Mac32
;
;	Change History (most recent first):
;
;		<SM2>	 2/3/93		CSS		Update from Horror:
;		<H2>	 9/29/92	BG		Rolling in Jon Okada's latest fixes.
;		 <1>	11/14/90	BG		Added to BBS for the first time.
;
;	To Do:
;


;-----------------------------------------------------------
; PACK4 FP operations for MC68020
; Copyright Apple Computer, Inc., 1983,1984,1985,1989,1990,1991,1992,1993
; All rights reserved
;-----------------------------------------------------------

;  CHANGE LOG:
;  23 Mar 92	JPO	Modified subroutines IPALIGN and IALIGN to fix rounding
;			error for FTINTX and FRINTX when rounding precision is 
;			less than extended.

;-----------------------------------------------------------
; Entry points for individual operations or clusters of
; operations with different data formats.
;
; Stack has identical form as at the main entry point of the
; package:
;	ret < opword < addr1 < addr2 < addr3,
; where the number of addresses (1, 2, or 3) depends on the
; operation.
;-----------------------------------------------------------

;-----------------------------------------------------------
; MACRO performs setup with numerous entry points (functions
; which require all D and A registers).
;-----------------------------------------------------------
	MACRO
	FINIT
						
	LINK	A6,#0
	MOVEM.L D0-D7/A0-A4,-(SP) ; save all registers
			
	ENDM




;-----------------------------------------------------------
;-----------------------------------------------------------
; FP ADDITION/SUBTRACTION
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QADDX---Add extended to extended
;-----------------------------------------------------------
QADDX:
	FINIT
	LEA	ADDTOP,A0	; continue below
	BRA	UNPACKXX	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; QADDB---Add non-extended SRC to extended DST
;-----------------------------------------------------------
QADDB:
	FINIT
	LEA	ADDTOP,A0	; continue below
	BRA	UNPACKXB	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; QSUBX---Subtract extended SRC from extended DST
;-----------------------------------------------------------
QSUBX:
	FINIT
	LEA	SUBTOP,A0	; continue below
	BRA	UNPACKXX	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; QSUBB---Subtract non-extended SRC from extended DST
;-----------------------------------------------------------
QSUBB:
	FINIT
	LEA	SUBTOP,A0	; continue below
	BRA	UNPACKXB	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; To subtract, just flip the sign and XOR-sign bits in D6.B
;-----------------------------------------------------------
SUBTOP:
	EORI.B	#$A0,D6
	
;-----------------------------------------------------------
; Add 2 numbers.  Dispatch to one of 9 cases depending on
; class of operands: [finite] number, zero, or infinite.
; NaNs have already been filtered out.
;-----------------------------------------------------------
ADDTOP:
	LEA	FINI2OPS,A0	; finish-up routine
	MOVE.W	ADDCASE(D0),D0	; index to D0
	JMP	ADDTOP(D0)	; do special case
	
ADDCASE:			; DST + SRC

	DC.W	ADDNUM - ADDTOP	; NUM + NUM
	DC.W	ADDS0 - ADDTOP	; NUM + 0
	DC.W	PACKX - ADDTOP	; NUM + INF
	
	DC.W	ADDD0 - ADDTOP	; 0 + NUM
	DC.W	ADD00 - ADDTOP	; 0 + 0
	DC.W	PACKX - ADDTOP	; 0 + INF
	
	DC.W	RDSTSGN- ADDTOP	; INF + NUM
	DC.W	RDSTSGN- ADDTOP	; INF + 0
	DC.W	ADDINF - ADDTOP	; INF + INF
	
;-----------------------------------------------------------
; First align so value in DST position has smaller exponent.
; Then shift with special cases.  "Larger" digits are in D3/A2.
; Assume SRC exponent is "larger", so swap its significand with DST.
;-----------------------------------------------------------
ADDNUM:
	EXG	D4,D3
	EXG	D5,A2
	MOVE.W	A4,D0	; SRC exponent
	SUB.W	A3,D0	; SRC exp - DST exp
	BEQ	ADDEM	; no shift if exponents equal
	BGT.S	@1	; just shift DST in D4/5

;-----------------------------------------------------------
; SRC exp < DST exp, so swap operands.  Move DST sign to bit
; 7 of D6 byte without moving the XOR (bit 5)
;-----------------------------------------------------------
	EXG	D5,A2	; swap significands
	EXG	D4,D3
	MOVEA.L	A3,A4	; larger exponent in A4
	ADD.B	D6,D6	; shift src sign out
	NEG.W	D0	; negate exponent difference
	ASR.B	#1,D6	; duplicate DST sign and restore XOR to bit 5

;-----------------------------------------------------------
; Do fast right shift of D4/D5 into D4/D5/D7.
;-----------------------------------------------------------
@1:
	MOVE.L	D0,D2		; D2 used to dispatch to fast shift routine
	CMPI	#66,D0
	BHI	ADDSHLOTS	; special fast routine if > 66 bits to shift

	ADD	D2,D2		; jmp to appropriate routine
	MOVE	ADDSHCASE(D2),D2	
	JMP	ADDNUM(D2)

ADDSHCASE:
	DC.W	ADDEM	- ADDNUM
	DC.W	ADDSH1	- ADDNUM
	DC.W	ADDSH2	- ADDNUM
	DC.W	ADDSH3	- ADDNUM
	DC.W	ADDSH4	- ADDNUM
	DC.W	ADDSH5	- ADDNUM
	DC.W	ADDSH6	- ADDNUM
	DC.W	ADDSH7	- ADDNUM
	DC.W	ADDSH8	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM

	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH16	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM

	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM

	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH2TO31	- ADDNUM
	DC.W	ADDSH32	- ADDNUM
	DC.W	ADDSH33	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM

	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM

	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM

	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH33TO63	- ADDNUM
	DC.W	ADDSH64	- ADDNUM
	DC.W	ADDSH65	- ADDNUM
	DC.W	ADDSH66	- ADDNUM



ADDSHLOTS:
	MOVEQ	#0,D4
	MOVEQ	#0,D5
	NOT.B	D7
	BRA	ADDEM

ADDSH66:
	OR	D4,D5
	TST.L	D5
	SNE	D7
	LSR.L	#2,D4
	BRA.S	BIGSTICK

ADDSH65:
	OR	D4,D5
	TST.L	D5
	SNE	D7
	LSR.L	#1,D4
	BRA.S	BIGSTICK
			
ADDSH64:
	TST.L	D5
	SNE	D7		; gather stickies
BIGSTICK:
	OR.L	D4,D7
	MOVEQ	#0,D4
	MOVEQ	#0,D5
	BRA	ADDEM		; fix stickies

;-----------------------------------------------------------
; Shift of 33-63 bits
;-----------------------------------------------------------
ADDSH33TO63:
	MOVE.L	D5,D7		; D7 <- D5
	SUBI	#32,D0		; decr shift count by 32
	MOVE.L	D4,D5		; D5 <- D4
	ROR.L	D0,D7		; rotate D7 right by new count
	LSR.L	D0,D5		; shift D5 right by new count
	BFTST	D7{0:D0}	; test for low sticky
	BEQ.S	@3
	ORI	#$FF,D7
@3:
	BFINS	D4,D7{0:D0}	; shift high sticky bits in
	MOVEQ	#0,D4		; zero D4
	BRA	ADDEM		; fix stickies


ADDSH33:
	MOVE.L	D5,D7		; shift right 32 bits
	MOVE.L	D4,D5
	MOVEQ	#0,D4
	LSR.L	#1,D5		; shift right one more bit
	ROXR.L	#1,D7
	SCS	D7		; keep low sticky
	BRA	ADDEM		; fix stickies

ADDSH32:
	MOVE.L	D5,D7		; 32-bit shift is easy
	MOVE.L	D4,D5
	MOVEQ	#0,D4
	BRA	ADDEM		; fix stickies
			
;-----------------------------------------------------------
; Shift of 2-31 bits
;-----------------------------------------------------------
ADDSH2TO31:
	BFINS	D5,D7{0:D0}	; shift bits into D7 from D5
	LSR.L	D0,D5		; shift D5 right
	BFINS	D4,D5{0:D0}	; shift bits into D5 from D4
	LSR.L	D0,D4		; shift D4
	BRA.S	ADDEM	

;-----------------------------------------------------------
; Special quick shift routines
;-----------------------------------------------------------
ADDSH16:
	MOVE.W	D5,D7
	MOVE.W	D4,D5
	CLR.W	D4
	SWAP	D5
	SWAP	D4
	SWAP	D7
	BRA.S	ADDEM
			
ADDSH8:
	BFINS	D5,D7{0:8}
	MOVE.B	D4,D5
	LSR.L	#8,D4
	ROR.L	#8,D5
	BRA.S	ADDEM	

ADDSH7:
	BFINS	D5,D7{0:7}
	LSR.L	#7,D5
	BFINS	D4,D5{0:7}
	LSR.L	#7,D4
	BRA.S	ADDEM	

ADDSH6:
	BFINS	D5,D7{0:6}
	LSR.L	#6,D5
	BFINS	D4,D5{0:6}
	LSR.L	#6,D4
	BRA.S	ADDEM	

ADDSH5:
	BFINS	D5,D7{0:5}
	LSR.L	#5,D5
	BFINS	D4,D5{0:5}
	LSR.L	#5,D4
	BRA.S	ADDEM	

ADDSH4:
	BFINS	D5,D7{0:4}
	LSR.L	#4,D5
	BFINS	D4,D5{0:4}
	LSR.L	#4,D4
	BRA.S	ADDEM	

ADDSH3:
	BFINS	D5,D7{0:3}
	LSR.L	#3,D5
	BFINS	D4,D5{0:3}
	LSR.L	#3,D4
	BRA.S	ADDEM	

ADDSH2:
	BFINS	D5,D7{0:2}
	LSR.L	#2,D5
	BFINS	D4,D5{0:2}
	LSR.L	#2,D4
	BRA.S	ADDEM	

ADDSH1:
	LSR.L	#1,D4
	ROXR.L	#1,D5
	ROXR.L	#1,D7
			
						

;-----------------------------------------------------------
; Operands are now aligned; test for +/- then do it
;-----------------------------------------------------------
ADDEM:
	BTST	#5,D6		; test XOR of signs
	BNE.S	SUBMAG

;-----------------------------------------------------------
; Add magnitudes: add the words and check for carry-out.
;-----------------------------------------------------------
	ADD.L	A2,D5
	ADDX.L	D3,D4
	BCC	COERCE

	ROXR.L	#1,D4		; adjust right
	ROXR.L	#1,D5
	ROXR.L	#1,D7		; no stickies can be lost
	SCS	D1
	OR.B	D1,D7
	ADDQ.L	#1,A4		; bump exponent
@15:
	BRA	COERCE

;-----------------------------------------------------------
; Simplify by subtracting large op in D3,A2 from small in
; D4,5,7 and then checking for special cases.  If zero, jump
; out to 0+0 code.  If greater, flip sign.  If less (usual)
; just negate.
;-----------------------------------------------------------
SUBMAG:
	NOT.B	D6		; assume >, with sign change
	SUB.L	A2,D5
	SUBX.L	D3,D4
	BEQ.S	ZEROSUM		; store zero with sign
	BCC	NORMCOERCE	; got it right

	NEG.L	D7		; flip digits
	NEGX.L	D5
	NEGX.L	D4
	NOT.B	D6		; flip sign back
@7:
	BRA	NORMCOERCE

;-----------------------------------------------------------
; Now set exponent to 0 and fix sign according to rounding
; mode.
; In the special case of two 0's, avoid the underflow.
; Coercion will signal in single/double restriction.
;-----------------------------------------------------------
ADD00:
	BTST	#5,D6		; same sign?
	BEQ	PACKX		; yes, easy
ZEROSUM:
	SUBA.L	A4,A4		; 0 exp
	MOVEA.W	#FPSTATE,A1	; A1 points to environment
	CLR.B	D6		; assume positive
	BTST	#RNDHI,(A1)	; 10 -- RND MINUS
	BEQ.S	ADDQ00
	BTST	#RNDLO,(A1)
	BNE.S	ADDQ00
	NOT.B	D6		; make negative
ADDQ00:
	BRA	PACKX		; don't coerce 0


;-----------------------------------------------------------
; If DST = 0, have result = SRC.  If SRC=0, must set
; result = DST.
;-----------------------------------------------------------
ADDS0:
	MOVE.L	A2,D5		; LO DIGS
	MOVE.L	D3,D4		; HI DIGS
	MOVE.L	A3,A4		; EXP
	ADD.B	D6,D6		; SIGN
ADDD0:
	BRA	COERCE


;-----------------------------------------------------------
; Sum of two INFs depends on their signs.
;-----------------------------------------------------------
ADDINF:
	BTST	#5,D6		; same sign?
	BNE.S	@25
	BRA	PACKX		; yes
@25:
	MOVEQ	#NANADD,D0	; mark error
	BRA	INVALIDOP





;-----------------------------------------------------------
;-----------------------------------------------------------
; FP MULTIPLICATION
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QMULX---Multiply extended with extended
;-----------------------------------------------------------
QMULX:
	FINIT
	LEA	MULTOP,A0	; continue below
	BRA	UNPACKXX	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; QMULB---Multiply non-extended SRC with extended DST
;-----------------------------------------------------------
QMULB:
	FINIT
	LEA	MULTOP,A0	; continue below
	BRA	UNPACKXB	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; Multiply 2 numbers.  Dispatch to one of 9 cases depending on
; class of operands: [finite] number, zero, or infinite.
; NaNs have already been filtered out.
;-----------------------------------------------------------
MULTOP:
	LEA	FINI2OPS,A0	; continuation address
	LSL.B	#2,D6		; get XOR of signs in D6 bit 7

	MOVE.W	MULCASE(D0),D0
	JMP	MULTOP(D0)
	
MULCASE:			; DST * SRC
	DC.W	MULNUM	- MULTOP	; NUM * NUM
	DC.W	PACKX	- MULTOP	; NUM * 0
	DC.W	PACKX	- MULTOP	; NUM * INF

	DC.W	RDST	- MULTOP	;   0 * NUM
	DC.W	PACKX	- MULTOP	;   0 * 0
	DC.W	INVMUL - MULTOP		;   0 * INF

	DC.W	RDST	- MULTOP	; INF * NUM
	DC.W	INVMUL - MULTOP		; INF * 0
	DC.W	PACKX	- MULTOP	; INF * INF



MULNUM:
;-----------------------------------------------------------
; Have: X.XXXXX * Y.YYYYYY --> ZZ.ZZZZZZZ before
; normalization and coercion.  So subtract (bias-1) to
; account for binary point one bit to right.  For example,
; 1 * 1 comes out:  2^1 * 0.10000000... which in turn
; is normalized to  2^0 * 1.000000...
;-----------------------------------------------------------
	ADDA.L	A3,A4		; add exponents
	SUBA.W	#$3FFE,A4	; subtract (bias - 1)

;-----------------------------------------------------------
; Multiply is a D register hog, so some state must be saved.
;
; 64*64 multiply is accomplished in 4 32*32 products, using
; the MULU.L 32*32 instruction of the MC68020.
;
; Special provisions are made for the three special cases:
; both operands have 32 trailing zeros or any one operand
; has 32 trailing zeros.
;
; The basic register mask throughout is:
;	A1: D6 save
;	A2,A3: SRC bits
;	A4: result exponent
;	D0,D1: used to pass operands to 32*32 mult and return results
;	D2,3: DST bits
;	D4,5,7: 64-bit product and round bits
;	D6: zero
;-----------------------------------------------------------

	MOVE.L	D3,D2		; D2 <- DST.HI
	MOVE.L	A2,D3		; D3 <- DST.LO
	MOVEA.L D6,A1		; save D6 in A1
	MOVEA.L D4,A2		; A2 <- SRC.HI
	MOVEA.L	D5,A3		; A3 <- SRC.LO
	MOVEQ	#0,D7		; exact at first
	MOVEQ	#0,D6		; D6 <- 0
			
	MOVE.L	A2,D5		; D4/5 = SRC.HI * DST.HI
	MULU.L	D2,D4:D5
			
	MOVE.L	A3,D7		; SRC.LO * DST.HI
	BEQ.S	HILO		; skip if SRC.LO = 0
	MULU.L	D2,D0:D7	; RESULT.LO in D7
	ADD.L	D0,D5		; RESULT.HI added to D4/5
	ADDX.L	D6,D4
HILO:
	MOVE.L	D3,D0	 	; SRC.HI * DST.LO
	BEQ.S	MULDONE		; done if DST.LO = 0
	MOVE.L	A2,D1
	MULU.L	D0,D0:D1
	ADD.L	D1,D7		; result added to D4/5/7
	ADDX.L	D0,D5
	ADDX.L	D6,D4
			
;-----------------------------------------------------------
; Fourth 32*32 product is SRC.LO * DST.LO.  High result is
; added into D7 with carry propagating through D5/4.  Nonzero
; low result causes low order stickies to be set in D7.
;-----------------------------------------------------------
	MOVE.L	A3,D1		; SRC.LO
	BEQ.S	MULDONE		; done if SRC.LO = 0
	MULU.L	D3,D0:D1
	ADD.L	D0,D7		; add to D7
	ADDX.L	D6,D5		; propagate carry to D4/5
	ADDX.L	D6,D4

	TST.L	D1		; set low sticky if D1 != 0
	SNE	D1
	OR.B	D1,D7
	
;-----------------------------------------------------------
; Clean up after multiplication.  Restore D6.
;-----------------------------------------------------------
MULDONE:
	MOVE.L A1,D6		; restore D6

	BRA	NORMCOERCE	; normalize if necessary & coerce
	

;-----------------------------------------------------------
; Cases 0*INF and INF*0 are invalid operations.
;-----------------------------------------------------------
INVMUL:
	MOVEQ	#NANMUL,D0	; NaN code in D0
	BRA	INVALIDOP	; Output NaN and signal invalid




;-----------------------------------------------------------
;-----------------------------------------------------------
; FP DIVISION
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QDIVX---Divide extended DST by extended SRC
;-----------------------------------------------------------
QDIVX:
	FINIT
	LEA	DIVTOP,A0	; continue below
	BRA	UNPACKXX	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; QDIVB---Divide extended DST by non-extended SRC
;-----------------------------------------------------------
QDIVB:
	FINIT
	LEA	DIVTOP,A0	; continue below
	BRA	UNPACKXB	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; Division.  Dispatch to one of 9 cases depending on
; class of operands: [finite] number, zero, or infinite.
; NaNs have already been filtered out.
;-----------------------------------------------------------
DIVTOP:
	LEA	FINI2OPS,A0	; continuation address
	LSL.B	#2,D6		; XOR of signs in D6 bit 7
	
	MOVE.W	DIVTBL(D0),D0
	JMP	DIVTOP(D0)

DIVTBL:				; DST / SRC
	DC.W	DIVNUM	- DIVTOP	; NUM / NUM
	DC.W	DIVBY0	- DIVTOP	; NUM / 0
	DC.W	DIVBYI	- DIVTOP	; NUM / INF

	DC.W	DIVBYI	- DIVTOP	;   0 / NUM
	DC.W	INVDIV  - DIVTOP	;   0 / 0
	DC.W	DIVBYI	- DIVTOP	;   0 / INF

	DC.W	RDST	- DIVTOP	; INF / NUM
	DC.W	RDST	- DIVTOP	; INF / 0
	DC.W	INVDIV	- DIVTOP	; INF / INF


;-----------------------------------------------------------
; Case NUM/0:  set the DIV-BY-ZERO error bit, stuff INF, pack.
;-----------------------------------------------------------
DIVBY0:
	BSET	#ERRZ+8,D6
	MOVEA.W	#$7FFF,A4	; stuff infinity
	MOVEQ	#0,D4
	MOVEQ	#0,D5
	BRA	PACKX


;-----------------------------------------------------------
; Cases NUM/INF, 0/NUM, and 0/INF:  store zero.
;-----------------------------------------------------------
DIVBYI:
	SUBA.L	A4,A4		; ZERO EXP
	MOVE.L	A4,D4		; AND DIGS...
	MOVE.L	D4,D5
	BRA	PACKX

;-----------------------------------------------------------
; Cases 0/0 and INF/INF:  signal invalid and store NaN.
;-----------------------------------------------------------
INVDIV:
	MOVEQ	#NANDIV,D0	; NaN code in D0
	BRA	INVALIDOP	; output NaN result



;-----------------------------------------------------------
; Dividing numbers involves the nonrestoring divide subroutine
; DIV32 shared with the REMAINDER algorithm.  This subroutine
; essentially calculates 32 bits of quotient of a 64 / 64
; division and also returns a shifted remainder.
;-----------------------------------------------------------
DIVNUM:

;-----------------------------------------------------------
; FIGURE RESULT EXPONENT AS THOUGH DST >= SRC.  WILL COMPUTE
; AN EXTRA QUOTIENT BIT JUST IN CASE DST < SRC, IN WHICH
; CASE EXP WILL BE DECREMENTED.
;-----------------------------------------------------------
	EXG	A3,A4		; SWAP EXPS
	SUBA.L	A3,A4		; DEXP - SEXP
	ADDA.W	#$3FFF,A4	; REBIAS

;-----------------------------------------------------------
; DST >= SRC: 64+1 QUO BITS, LAST IS ROUND.
; DST <  SRC: 64+1 QUO BITS, FIRST IS 1, LAST IS ROUND.
; TRICK: IN ORDER TO GET EXTRA (ROUND) BIT IN D4,5, LET
;	LEADING BIT (KNOWN TO BE 1) BE SHIFTED OUT OF
;	D4,5 DURING DIVISION.  THEN PUT IT BACK ON RETURN.
; USE SPECIAL CASE STARTUP CODE TO DISTINGUISH THE DST < SRC
; CASE THAT REQUIRES TWEAKS OF REMAINDER AND EXPONENT.
;
; Set up funny register mask for nonrestoring division
; A2 - quotient high longword
; A3 - D6 save
; A4 - exponent of result
; D2,D3	- dividend cum shifted remainder
; D4,D5 - divisor
; D1	- holds 0
; scratch registers are D0,D6,D7
; *** NOTE CAN DO BETTER ON FIRST STEP BECAUSE OF TEST ABOVE
;-----------------------------------------------------------
DIVNONRESTORING:
	MOVE.L	D6,A3		; save D6 contents in A3 for duration
	MOVE.L	D3,D2		; D2 <- DST.HI
	MOVE.L	A2,D3		; D3 <- DST.LO
	MOVEQ	#0,D1		; D1 <- 0
	MOVE.L	D2,D6		; save DST.HI for case DST < SRC below
	SUB.L	D5,D3		; get leading 1 bit in quotient via subtraction
	SUBX.L	D4,D2		;   of SRC (divisor) from DST (dividend)
	BCC.S	BGNDV		; DST >= SRC; begin division steps
			
	SUBQ.L	#1,A4		; DST < SRC; decrement exponent and
	ADD.L	A2,D3		;   correct remainder by adding DST to it
	ADDX.L	D6,D2

BGNDV:
	BSR.S	DIV32		; get first quotient longword
	MOVE.L	D0,A2		; save in A2
			
	BSR.S	DIV32		; get second quotient longword
	MOVE.L	D0,D5		; put quotient in D4/D5
	MOVE.L	A2,D4
	MOVE.L	A3,D6		; restore D6

;-----------------------------------------------------------
; Clean up prior to return.
; Remainder is in D2/D3 and shifted quotient is in D4/5.
; Adjust quotient and put round/stickies in D7.
;-----------------------------------------------------------
	MOVEQ	#1,D7		; it's almost zero
	LSR.L	#1,D7		; D7 = 0 and X bit set
	ROXR.L	#1,D4		; shift leading 1 bit into quotient
	ROXR.L	#1,D5
	ROXR.L	#1,D7		; shift round bit into D7.W
	OR.L	D2,D3		; test all remainder bits
	SNE 	D7		; set stickies if nonzero
	BRA 	COERCE		; coerce result


;-----------------------------------------------------------
; Subroutine DIV32 calculates a 32-bit quotient from a 64-bit
; dividend and a 64-bit divisor.  It also returns a shifted
; (by 32 bits) remainder.  This subroutine uses the MULU.L and
; DIVU.L instructions of the MC68020.
;
; D2,D3 - dividend cum shifted remainder
; D1 - bits to be shifted into low half of remainder (usually zero)
; D4,D5 - divisor
; D0 - 32-bit quotient
; D6,D7 - scratch registers
;-----------------------------------------------------------
DIV32:
	DIVU.L	D4,D2:D3	; divide step (64-bit / 32-bit)
	BVS.S	DIVOFL		; rare overflow handler

	MOVE.L	D3,D0		; initialize quotient word
			
	MOVE.L	D3,D7		; multiply quotient by rest
	MULU.L	D5,D6:D7	;   of divisor (32 bits)
			
CTNDIV:
	MOVE.L	D1,D3		; shifted remainder in D1/D2

	SUB.L	D7,D3		; subtract correction from remainder
	SUBX.L	D6,D2
	BCC.S	DIVOK		; OK if no carry
			
ONEMORE:
	SUBQ.L	#1,D0		; correction produced carry; decr quotient
	ADD.L	D5,D3		;   and adjust remainder upward until positive
	ADDX.L	D4,D2
	BCC.S	ONEMORE
			
DIVOK:
	RTS			; return

			
;-----------------------------------------------------------
; Division has produced an overflow (very rare case).  Fix
; it up. 
;-----------------------------------------------------------
DIVOFL:
	MOVE.L	D5,D6		; DIVU.L overflow
	MOVEQ	#0,D7		;   set D6/7 to $100000000 * D5
			
	MOVE.L	D3,D2		;   simulate remainder for quotient of $100000000
	MOVEQ	#0,D0		;   quotient effectively $100000000
	BRA.S	CTNDIV		;   adjust remainder and quotient		



;-----------------------------------------------------------
;-----------------------------------------------------------
; FP REMAINDER
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QREMX---Extended DST REM extended SRC
;-----------------------------------------------------------
QREMX:
	FINIT
	LEA	REMTOP,A0	; continue below
	BRA	UNPACKXX	; unpack opword and operands, NaN check

;-----------------------------------------------------------
; QREMB---Extended DST REM non-extended SRC
;-----------------------------------------------------------
QREMB:
	FINIT
	LEA	REMTOP,A0	; continue below
	BRA	UNPACKXB	; unpack opword and operands, NaN check


;-----------------------------------------------------------
; ******** IMPORTANT STACK DEPENDENCY -- SEE BELOW ********
;
; THE REMAINDER OPERATION DIVIDES DST/SRC TO GET ----ALL---
; QUOTIENT BITS (POSSIBLY THOUSANDS OF THEM) AND THEN
; RETURNS THE RESULTING REMAINDER, REDUCED TO LESS THAN OR
; EQUAL TO (1/2)*DVR.  IT ALSO RETURNS THE SIGN AND LOW
; SEVEN INTEGER QUOTIENT BITS IN REGISTER D0.W AS A
; TWO'S-COMPLEMENT INTEGER.  THIS KLUGE IS
; EXTREMELY USEFUL FOR ELEMENTARY FUNCTION EVALUATION
; WHERE, SAY, REMAINDER BY (PI/4) IS NOT USEFUL WITHOUT
; AN INDICATION OF THE OCTANT (GIVEN BY THE QUOTIENT) AS
; WELL AS THE REMAINDER.
;
; TO GET THE PROPERLY REDUCED QUOTIENT, IT IS EASIEST TO
; DIVIDE ALL THE WAY THROUGH THE FIRST FRACTION QUOTIENT
; BIT, AND THEN PATCH UP.  IF THE QUOTIENT TURNS OUT TO BE
; ZERO, ITS SIGN IS ARBITRARILY SET TO THAT OF THE DST.
;
; Integer quotient reduction is accomplished in one of two
; ways, depending upon the difference in exponent value for
; the two operands.  For small values (< 9) of this difference,
; a standard restoring division algorithm is used.  For larger
; values, repeated calls are made to the DIV32 subroutine,
; which chews off 32 bits of quotient at a time.  In the latter
; case, the original dividend is preshifted to accommodate extra
; bits (MOD 32)
;
; ASSUME THE MASK: DO-ARITHMETIC, WITH D7=0 FOR THE
; CCR AND ROUND INFO.
;
; Some assumptions about the stack are necessary.
; When the registers were saved with the MOVEM.L, D0 was
; left at the top of stack.  Thus, DO.W, which gets the
; integer quotient, is at 2(SP).
;-----------------------------------------------------------

;-----------------------------------------------------------
; DO SOME BOOKKEEPING FIRST.  PLACE DEFAULT 0 QUO IN D0.
; ASSUME THE RESULT WILL HAVE DST SIGN, AND NOTE THAT QUO
; SIGN IS MOVED TO BIT #6 OF D6.
;-----------------------------------------------------------
REMTOP:
	LEA	FINI2OPS,A0	; continuation addr
	CLR.W	2(SP)		; QUO set to 0 (D0.W on stack)

	ADD.B	D6,D6		; move DST sign to D6 bit 7 and
				;   QUO sign to bit 6
	MOVE.W	REMCASE(D0),D0
	JMP	REMTOP(D0)

REMCASE:				; DST REM SRC
	DC.W	REMNUM	- REMTOP	; NUM REM NUM
	DC.W	INVREM  - REMTOP	; NUM REM 0
	DC.W	REMDST	- REMTOP	; NUM REM INF

	DC.W	RDST	- REMTOP	;   0 REM NUM
	DC.W	INVREM  - REMTOP	;   0 REM 0
	DC.W	RDST	- REMTOP	;   0 REM INF

	DC.W	INVREM  - REMTOP	; INF REM NUM
	DC.W	INVREM  - REMTOP	; INF REM 0
	DC.W	INVREM  - REMTOP	; INF REM INF



;-----------------------------------------------------------
;  Invalid REMAINDER operands
;-----------------------------------------------------------
INVREM:
	MOVEQ	#NANREM,D0	; NaN code in D0
	BRA	INVALIDOP	; output NaN result
	

;-----------------------------------------------------------
; DEXP - SEXP + 1 = NUMBER OF INTEGER QUO BITS.	 GET ONE
; MORE TO AID IN ROUNDING.  CASES ON (DEXP - SEXP + 1):
;	>= 0 -- RUN DIVDE AND RESTORE TO GET THOSE BITS
;	<  0 -- DST IS ALREADY LESS THAN HALF SRC, SO JUST
;		COERCE (AND QUO = 0).
;-----------------------------------------------------------
REMNUM:
	MOVE.L	A3,D0		; DST EXP
	ADDQ.L	#1,D0
	SUB.L	A4,D0		; DEXP - SEXP + 1
	BPL.S	REMDIV		; MUST DO IT ALL...
REMDST:
	MOVE.L	D3,D4		; RESULT IS DST
	MOVE.L	A2,D5
	MOVEA.L	A3,A4
	BRA.S	REMFIN

;-----------------------------------------------------------
; Set tentative REM exponent to SEXP-1, since REM will be reduced
; to at most half of SRC.  Then determine from size of exponent 
; difference in D0 which algorithm to use.
;-----------------------------------------------------------
REMDIV:
	SUBQ.L	#1,A4		; tentative exponent
	CMPI.L	#9,D0
	BGT.S	REMSHIFT	; many integer bits to chew off

;-----------------------------------------------------------
; OFF TO RESTORE WITH ITS REGISTER MASK:
;	D0: MAGNITUDE COUNT	D1,D2: DIVIDEND
;	D4,D5: QUOTIENT		D3,A2: DIVISOR
;-----------------------------------------------------------
	MOVE.L	D3,D1		; DST IS DIVIDEND
	MOVE.L	A2,D2
	MOVE.L	D4,D3		; SRC IS DIVISOR
	MOVEA.L	D5,A2
	ADDQ.L	#1,D0		; INITIALIZE LOOP COUNT
	BSR.S	RESTORE

;-----------------------------------------------------------
; AFTER ALL QUOTIENT BITS AND FIRST FRACTION BIT HAVE BEEN
; EVALUATED INTO D4,5 (LEADING BITS ARE LOST OFF THE LEFT)
; THERE ARE THREE CASES ("REM" IS RESULT OF DIV LOOP):
;
;	LOW QUO BIT = 0 --> REM < HALF DVR, ALL DONE
;
;	LOW QUO BIT = 1 AND REM = 0 --> HALF-WAY CASE, WHERE
;		SIGN OF REM (= HALF DIVISOR) IS DETERMINED
;		SO LOW INT QUO BIT WILL BE 0
;
;	LOW QUO BIT = 1 AND REM > 0 --> TRUE REM > HALF DVR,
;		SO FLIP SIGN AND SUBTACT.  THIS IS TRICKY
;		AND RATHER NONINTUITIVE.  THE POINT IS THAT
;		DIVIDING THROUGH TO THE FIRST FRAC QUO BIT
;		REDUCES THE EXP OF REM TO DVR-1; BUT THE
;		DIV ALGORITHM DOES NOT SHIFT ON THE LAST
;		STEP, SO THE REM LINES UP PROPERLY WITH
;		THE DVR FOR THE SUBTRACTION (THOUGH THEIR
;		EXPONENTS SEEM TO DIFFER BY ONE).  AND THE
;		DIV ALGORITHM GUARANTEES THAT THE REM IT
;		LEAVES IS LESS THAN THE DVR, SO THERE CAN
;		BE NO CARRY OUT.
;-----------------------------------------------------------
REMPOSTRESTORING:
	BTST	#0,D5		; LOW QUO BIT
	BEQ.S	REMQUO		; 0 --> JUST STUFF QUO
	TST.L	D1
	BNE.S	@3		; CASE 3
	TST.L	D2
	BNE.S	@3		; CASE 3

	BTST	#1,D5		; CASE 2 DECIDED ON LO INT
	BEQ.S	@5		; IF EVEN, LEAVE QUO BUT SET REM
@3:
	BCHG	#7,D6		; FLIP REM SIGN
	ADDQ.W	#2,D5		; INCREMENT QUO BY 1 (IN SECOND BIT)
@5:
	EXG	D2,A2		; SWAP DVR AND REM
	EXG	D1,D3
	SUB.L	A2,D2		; DVR - REM
	SUBX.L	D3,D1


;-----------------------------------------------------------
; NOW EXTRACT LOW 7 INTEGER BITS (REMEMBER GOT FIRST FRAC),
; NEGATE IF NECESSARY, EXTEND TO WORD, AND STORE.
;-----------------------------------------------------------
REMQUO:
	LSR.B	#1,D5		; KILL FRAC BIT
	BTST	#6,D6		; TEST QUO SIGN
	BEQ.S	@9
	NEG.B	D5
@9:
	EXT.W	D5		; EXTEND SIGNED BYTE TO WORD
	MOVE.W	D5,2(SP)	; STORE IN SAVED D0.W

	MOVE.L	D1,D4		; STUFF REM BITS
	MOVE.L	D2,D5
REMFIN:
	BRA	ZNORMCOERCEX	; STORE THE RESULT


;-----------------------------------------------------------
; ASSUME FUNNY REGISTER MASK: RESTORING-DIVISION
; D0    - QUO BIT COUNT
; D1,2  - DIVIDEND CUM REMAINDER
; D3,A2 - DIVISOR  (CAN ADD, NOT ADDX FROM A-REG)
; D4,5  - WILL BE QUOTIENT
;-----------------------------------------------------------
RESTORE:
	MOVEQ	#0,D4		; CLEAR QUOTIENT
	MOVE.L	D4,D5
	BRA.S	@2		; SKIP SHIFT ON 1ST STEP
@1:
	ADD.L	D5,D5		; SHIFT QUO
	ADDX.L	D4,D4		; IGNORE CARRY ON LAST STEP
	ADD.L	D2,D2		; SHIFT REM
	ADDX.L	D1,D1
	BCS.S	@4		; HAVE TO SUBTRACT
@2:
	CMP.L	D3,D1		; DVD.HI - DVR.HI
	BNE.S	@3
	CMP.L	A2,D2
@3:
	BCS.S	@5		; SKIP SUB IF DVD < DVR
@4:
	ADDQ.B	#1,D5		; SET QUO BIT (NO CARRY)
	SUB.L	A2,D2
	SUBX.L	D3,D1
@5:
	SUBQ.W	#1,D0		; LOOP COUNT
	BNE.S	@1
	RTS



;-----------------------------------------------------------
; Remainder algorithm using DIV32 subroutine handles larger
; exponent differences much faster than RESTORE algorithm.
;
; D2/D3/D1:  dividend/shifted remainder (96 bits)
; D4/D5:     divisor
; D0/D6/D7:  scratch
; A1:	     loop count
;-----------------------------------------------------------
REMSHIFT:
	MOVEA.L	D6,A3		; A3 <- D6 value
	MOVE.L	A2,D1		; D1 <- dividend.LO
	MOVEQ	#0,D2		; D2 <- 0
	MOVEA.L	D0,A2		; A2 <- shift count (∆EXP + 1)
	ANDI.L	#$1F,D0		; D0 <- alignment shift count (0 to 31 possible)
	BEQ.S	@1		; if zero, do first DIV32
				; shift dividend in D3/D1 left into D2/D3/D1
	BFEXTU	D3{0:D0},D2	; shift bits from D3 high to D2	low
	LSL.L	D0,D3		; shift D3 left
	BFEXTU	D1{0:D0},D6	; extract D1 high bits
	LSL.L	D0,D1		; shift D1 left
	OR.L	D6,D3		; insert extracted D1 bits into shifted D3	
	
;-----------------------------------------------------------
; Do initial division of D2:D3:D1 by D4/D5.  32-bit quotient in
; D0, remainder (shifted by 32 bits) in D2/D3.
;-----------------------------------------------------------
@1:
	BSR	DIV32

;-----------------------------------------------------------
; Remaining number of REM steps, if any, are done 32 at a time,
; using DIV32.  Final D0 value is lowest 32 bits of the
; quotient, and the REM result is in D2/D3.
;-----------------------------------------------------------
	MOVE.L	A2,D6		; Get number of remaining 32-bit steps
	BFEXTU	D6{16:11},D6
	BEQ.S	REMDIVDONE	; If zero, clean up

	MOVE.L	D6,A1		; A1 <- # OF 32-bit REM steps
	MOVEQ	#0,D1		; zero trailing remainder bits

REMLP32:
	BSR	DIV32
	SUBQ.L	#1,A1
	MOVE.L	A1,D6
	BNE.S	REMLP32

REMDIVDONE:
	MOVE.L	D2,D1		; remainder to D1/D2
	MOVE.L	D3,D2
	MOVE.L	D4,D3		; divisor to D3/A2
	MOVEA.L	D5,A2
	MOVE.L	D0,D5		; quotient to D5
	MOVE.L	A3,D6		; restore A6
	BRA	REMPOSTRESTORING ; finish up REM

	

;-----------------------------------------------------------
;-----------------------------------------------------------
; FP COMPARISONS---Common entry points for routines which
; signal or do not signal on unordered.
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QCMPX---Compare two extendeds.
;-----------------------------------------------------------
QCMPX:
	FINIT
	LEA	CMPTOP,A0	; continue below
	BRA	UNPACKXX	; unpack opword and operands, unordered check

;-----------------------------------------------------------
; QCMPB---Compare a non-extended SRC with an extended DST
;-----------------------------------------------------------
QCMPB:
	FINIT
	LEA	CMPTOP,A0	; continue below
	BRA	UNPACKXB	; unpack opword and operands, unordered check

;-----------------------------------------------------------
; Comparison.  Dispatch to one of 9 cases depending on
; class of operands: [finite] number, zero, or infinite.
; NaNs have already been filtered out.
;-----------------------------------------------------------
CMPTOP:	
	MOVE.W	CMPCASE(D0),D0
	JMP	CMPTOP(D0)

CMPCASE:				; DST - SRC
	DC.W	CMPNUM	- CMPTOP	; NUM - NUM
	DC.W	CMPS0	- CMPTOP	; NUM - 0
	DC.W	CMPD0	- CMPTOP	; NUM - INF

	DC.W	CMPD0	- CMPTOP	;   0 - NUM
	DC.W	CMP0    - CMPTOP	;   0 - 0
	DC.W	CMPD0	- CMPTOP	;   0 - INF

	DC.W	CMPS0	- CMPTOP	; INF - NUM
	DC.W	CMPS0	- CMPTOP	; INF - 0
	DC.W	CMPINF	- CMPTOP	; INF - INF


;-----------------------------------------------------------
; NUM VS. 0: DISGUISE AS (0 VS. -NUM) AND FALL THROUGH.
;-----------------------------------------------------------
CMPS0:
	ADD.B	D6,D6		; DST SGN -> SRC SLOT
	NOT.B	D6

;-----------------------------------------------------------
; 0 VS. NUM: SIGN OF NUM DETERMINES >.
;-----------------------------------------------------------
CMPD0:
	MOVEQ	#CMPG,D7	; ASSUME >
	TST.B	D6		; TST SRC SIGN
	BMI.S	@1
	MOVEQ	#CMPL,D7	; 0 < POSITIVE
@1:
	BRA	FINICMPS

;-----------------------------------------------------------
; INF VS. INF: EITHER =, OR SAME AS 0 VS. NUM.
;-----------------------------------------------------------
CMPINF:
	BTST	#5,D6		; EQ -> SIGNS =
	BNE.S	CMPD0
CMP0:				; 0 = 0 regardless of sign
	MOVEQ	#CMPE,D7
	BRA	FINICMPS


;-----------------------------------------------------------
; NUM VS. NUM: IF SIGNS DIFFER, SAME AS 0 VS. NUM.
; IF SAME JUST COMPARE THE WORDS, TAKING ACCOUNT FOR COMMON
; SIGN.
;-----------------------------------------------------------
CMPNUM:
	BTST	#5,D6	; NE -> TRIVIAL
	BNE.S	CMPD0

	CMPA.L	A4,A3	; DST - SRC EXP'S
	BGT.S	@1
	BLT.S	@2
	CMP.L	D4,D3	; DST.HI - SRC.HI
	BHI.S	@1	; HI -> UNSIGNED GREATER
	BCS.S	@2	; CS -> UNSIGNED LESS
	CMPA.L	D5,A2
	BEQ.S	CMP0	; THEY ARE =
	BCS.S	@2

;-----------------------------------------------------------
; THEY'RE > UNLESS NEGATIVE.
;-----------------------------------------------------------
@1:
	NOT.B	D6
;-----------------------------------------------------------
; THEY'RE < UNLESS NEGATIVE.
;-----------------------------------------------------------
@2:
	MOVEQ	#CMPL,D7
	TST.B	D6
	BPL	FINICMPS
	MOVEQ	#CMPG,D7
@21:
	BRA	FINICMPS





;-----------------------------------------------------------
;-----------------------------------------------------------
; CONVERSION to extended format
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QX2X---Convert extended to extended
;-----------------------------------------------------------
QX2X:
	FINIT
	LEA	FINI2OPS,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6		; zero D6.LO
	MOVEA.L	LKADR2(A6),A1	; unpack extended SRC
	BSR	UNPXOP
	
C2XCOMMON:	
	MOVEQ	#0,D7		; zero D7
	TST.W	D0		; check if NaN input
	BNE	FPNANOUT	;   output NaN
	
	TST.L	D0		; check if zero or INF
	BEQ	COERCE		; coerce if not
	BRA	PACKX		; pack if zero or INF	
	
;-----------------------------------------------------------
; QB2X---Convert non-extended binary format to extended
;-----------------------------------------------------------
QB2X:
	FINIT
	LEA	FINI2OPS,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6		; zero D6.LO
	MOVE.L	D6,D1		; extract offset from format
	CLR.W	D1		;   code in opword
	ROL.L	#6,D1
	ANDI.W	#$000E,D1
	SUBQ.W	#2,D1
	MOVEA.L	LKADR2(A6),A1	; unpack nonextended SRC
	BSR	UNPBOP
	
	BRA.S	C2XCOMMON
	



;-----------------------------------------------------------
;-----------------------------------------------------------
; FP SQUARE ROOT
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QSQRTX---extended square root of the extended DST operand
;-----------------------------------------------------------
QSQRTX:
	FINIT
	LEA	FINI1OP,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6
	MOVEA.L	LKADR1(A6),A1	; unpack extended DST
	BSR	UNPXOP

	TST.L	D0		; check if finite nonzero input
	BEQ.S	@10		;   yes; check sign next
	
	TST.W	D0		; check if NaN input
	BNE	FPNANOUT	;   yes; output NaN
	BTST	#17,D0		; check if zero
	BNE	PACKX		;   yes; SQRT(+/-0) = +/- 0
	
	TST.B	D6		; INF input
	BPL	PACKX		; pack if +INF
	
@1:
	MOVEQ	#NANSQRT,D0	; invalid op:  SQRT(negative nonzero number)
	BRA	INVALIDOP
	

	
@10:
	TST.B	D6		; test sign of finite, nonzero input
	BMI.S	@1		; negative; invalid op
;--------------------------------------------------------------------
; Square root of a normalized positive extended number is evaluated 
; using a modified version of the K. C. Johnson algorithm.  This bit
; chop method attempts to find the largest extended number whose square
; is no larger than the radicand (operand).  The rood is evaluated to 
; 65 bits in order to determine the rounding bit, and the sticky bit is
; obtained from any residual remainder.
;
; The basic register mask is:
;   radicand/remainder significand:	D1.B	D2	D3
;   square root exponent:		A4.W
;   square root significand:		D0.B	D4	D5
;   loop:  bit mask/counter		D6
;   scratch:				D7
;   D6 save register:			A3
;
; First step is to halve the exponent and adjust the bias, keeping
; track of whether the true exponent is odd or even.  Cases, after
; right shift are:
;	C=1---(2K) + $3FFF -> K + 1FFF, so rebias by $2000
;	C=0---(2K + 1) + $3FFF -> K + 2000, so rebias by $1FFF
;		and shift radicand 1 extra bit left.
;--------------------------------------------------------------------
	MOVE.W	A4,D0		; divide exponent by 2
	ASR.W	#1,D0
	MOVE	SR,D7		; save carry for later
	BCC.S	@2
	ADDQ.W	#1,D0
@2:
	ADDI.W	#$1FFF,D0	; rebias
	MOVEA.W	D0,A4		; store result exponent

;--------------------------------------------------------------------
; Initialize radicand for rooting.  Use A3 as temp for D6
;--------------------------------------------------------------------
	MOVEA.L	D6,A3		; save D6
	MOVE.L	D5,D3		; radicand in D2/D3 initially
	MOVE.L	D4,D2

;--------------------------------------------------------------------
; Now shift radicand to align binary point between D0 and D2.
; Requires 1 shift for even exp, 2 shifts for odd, for which
; we saved flags above in D7.
;--------------------------------------------------------------------
	ADD.L	D3,D3
	ADDX.L	D2,D2
	MOVEQ	#1,D1

	MOVE	D7,CCR		; CARRY=0 -> odd exp -> extra shift
	BCS.S	@4

	ADD.L	D3,D3
	ADDX.L	D2,D2
	ADDX.W	D1,D1

;--------------------------------------------------------------------
; Now initialize remainder by subtracting 1 from D1.B
;--------------------------------------------------------------------
@4:
	SUBQ.W	#1,D1

;--------------------------------------------------------------------
; Initialize root in D0.B (low bit only), D4/D5.  After J
; iterations of the bit chop loop, these 65 bits will hold:
;	<CURRENT ROOT (J BITS)>0, followed by 64 - J zeros.
; At the end of each iteration, bit J+1 (from MSB) is evaluated:
;	<NEW ROOT (J+1 BITS)>0, followed by 63 - J zeros.
;
; Since the root will be normalized, we can bypass the first iteration
; of the loop and initialize the root for the second iteration:
;	D0 <- 1, D4 <- 0, AND D5 <- 0.
;--------------------------------------------------------------------
	MOVEQ	#1,D0
	MOVEQ	#0,D4
	MOVE.L	D4,D5

;--------------------------------------------------------------------
; Initialize bit mask D6 to $40000000
;--------------------------------------------------------------------
	MOVE.L	#$40000000,D6

	BRA.S	@8		; branch into loop

;--------------------------------------------------------------------
; Top of loop for high longword (D4)
;--------------------------------------------------------------------
@6:
	ADD.L	D3,D3		; double remainder
	ADDX.L	D2,D2
	ADDX.W	D1,D1

@8:
	OR.L	D6,D4		; create <CURRENT ROOT>01000....

;--------------------------------------------------------------------
; Try remainder - root (short version since D5 = 0)
;--------------------------------------------------------------------
	SUB.L	D4,D2
	SUBX.W	D0,D1
	BCC.S	@11		; no carry -> new root bit = 1

	ADD.L	D4,D2		; carry -> new root bit = 0
	ADDX.W	D0,D1		; restore previous positive remainder
	EOR.L	D6,D4		; clr final 1 bit in D4
	BRA.S	@12

@11:
	ADD.L	D6,D4

@12:
	LSR.L	#1,D6		; shift mask bit right for next iteration
	BCC.S	@6

;--------------------------------------------------------------------
; Evaluate 33rd bit by brute force (transition between D4 and D5).
; Set D6 = $80000000.
;--------------------------------------------------------------------

	MOVE.L	#$80000000,D6	; D6 <- $80000000
	
	ADD.L	D3,D3		; double remainder
	ADDX.L	D2,D2
	ADDX.W	D1,D1

	SUB.L	D6,D3		; remainder - root
	SUBX.L	D4,D2
	SUBX.W	D0,D1
	BCC.S	@14		; no carry; set D4 bit 0

	ADD.L	D6,D3		; carry; restore positive remainder
	ADDX.L	D4,D2
	ADDX.W	D0,D1
	BRA.S	@16		; D4 bit 0 remains clear

@14:
	ADDQ.W	#1,D4

;--------------------------------------------------------------------
; Quick exit if remainder after 33 bits is zero
;--------------------------------------------------------------------
@16:
	MOVE.L	D3,D7		; current remainder zero?
	OR.W	D1,D7
	OR.L	D2,D7
	BNE.S	@18		; no; do 33 more bits (inexact with sticky set)

	LSR.W	#1,D0		; yes; shift result into D4/D5
	ROXR.L	#1,D4
	ROXR.L	#1,D5
	BRA.S	ROOTDONE	; finish up SQRT with round/stickies clear

;--------------------------------------------------------------------
; Set up for 34th-64th bits of root (D5 bits 31 through 1)
;--------------------------------------------------------------------
@18:
	ROR.L	#1,D6		; bit mask (D6) = $40000000

;--------------------------------------------------------------------
; Loop for root bits 31 through 1 in D5 
;--------------------------------------------------------------------
@20:
	ADD.L	D3,D3		; double remainder
	ADDX.L	D2,D2
	ADDX.W	D1,D1

	OR.L	D6,D5		; create <CURRENT ROOT>010000...

	SUB.L	D5,D3		; remainder - root (wider subtraction)
	SUBX.L	D4,D2
	SUBX.W	D0,D1
	BCC.S	@22		; no carry; new root bit = 1

	ADD.L	D5,D3		; carry; restore positive remainder
	ADDX.L	D4,D2
	ADDX.W	D0,D1
	EOR.L	D6,D5		; zero trailing 1 bit in D5
	BRA.S	@24		; new root bit remains clear

@22:
	ADD.L	D6,D5

@24:
	LSR.L	#1,D6		; update bit mask
	BCC.S	@20

;--------------------------------------------------------------------
; Evaluate round bit by brute force.  First shift root 1 bit right
; into D4/D5.  Next force the setting of the X bit.  Then subtract
; (with extend) D7(zero)/D4/D5 from unshifted remainder in D1/D2/D3.
; Set round bit if no carry results.  Sticky bits will always be set
; because root is irrational.
;--------------------------------------------------------------------
	MOVEQ	#0,D7		; clr D7
	ADDQ.W	#1,D5		; set lowest bit
	LSR.W	#1,D0		; shift 64-bit root into D4/D5,
	ROXR.L	#1,D4		;   setting X bit on final shift
	ROXR.L	#1,D5
	SUBX.L	D5,D3		; subtract root from unshifted remainder
	SUBX.L	D4,D2		;   with initial borrow
	SUBX.W	D7,D1
	BCS.S	@26		; carry -> round bit is zero

	BSET	#31,D7		; no carry -> round bit is one

@26:
	ADD.W	#$00FF,D7	; set sticky bits


ROOTDONE:
	MOVE.L	A3,D6		; restore D6
	BRA	COERCE		; coerce result




			
;-----------------------------------------------------------
;-----------------------------------------------------------
; ROUND TO INTEGER
;-----------------------------------------------------------
;-----------------------------------------------------------
QRINTX:
	FINIT
	LEA	FINI1OP,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6
	MOVEA.L	LKADR1(A6),A1	; unpack extended DST
	BSR	UNPXOP

	TST.L	D0		; check if finite nonzero input
	BEQ.S	@1		;   yes; do rounding
	
	TST.W	D0		; check if NaN input
	BNE	FPNANOUT	;   yes; output NaN
	BRA	PACKX		;   no; zero or INF propagate
		
@1:
	BSR	IPALIGN		; align binary point to right of D5
	BGT.S	RINT1		; shift was done	

COMINT1:			; no shift was done.  Coercion will do rounding.
	BFTST	D1{25:2}	; check rounding precision
	BEQ	COERCEX		;   default (extended)
	BPL	COERCED		;   double
	BRA	COERCES		;   single

RINT1:				; round extended integral value
	BSR	RNDINT
	TST.L	D4		; check if normalized
	BMI	PACKX		; done if so
	
;-----------------------------------------------------------
; After shifting and rounding, may have 0 or unnormalized.  Normalize, then
; stuff result
;-----------------------------------------------------------
COMINT2:
	BFFFO	D4{0:0},D0	; find first one in D4
	BEQ.S	@5		; D4 = 0
	
	SUBA.W	D0,A4		; decrease exponent
	LSL.L	D0,D4		; shift D4 left
	BFEXTU	D5{0:D0},D2	; extract D5 high bits
	LSL.L	D0,D5		; shift D5 left
	OR.L	D2,D4		; put D5 high bits into D4 low
	BRA	PACKX		; stuff result

@5:
	SUBA.W	#32,A4		; D4 = 0, decrease exponent by 32
	EXG	D4,D5		; exchange D4/D5
	BFFFO	D4{0:0},D0	; find first one in D4
	BEQ.S	@7		; zero result
	BMI	PACKX		; normalized; stuff result

	SUBA.W	D0,A4		; subnormal; decrease exponent
	LSL.L	D0,D4		; shift D4 left
	BRA	PACKX		; stuff result

@7:
	SUBA.L	A4,A4		; zero result
	BRA	PACKX		; stuff result




;-----------------------------------------------------------
;-----------------------------------------------------------
; TRUNCATE TO INTEGER
;-----------------------------------------------------------
;-----------------------------------------------------------
QTINTX:
	FINIT
	LEA	FINI1OP,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6
	MOVEA.L	LKADR1(A6),A1	; unpack extended DST
	BSR	UNPXOP

	TST.L	D0		; check if finite nonzero input
	BEQ.S	@1		;   yes; do rounding
	
	TST.W	D0		; check if NaN input
	BNE	FPNANOUT	;   yes; output NaN
	BRA	PACKX		;   no; zero or INF propagate
		
@1:
;-----------------------------------------------------------
; Align binary point to right of D5 and chop to integer value,
; setting INEXACT if necessary.  If number is too big,
; force chop mode and coerce.  IPALIGN places environment in
; D1.W.
;-----------------------------------------------------------
	BSR.S	IPALIGN		; align binary pt to right of D5
	BGT.S	@3		; shift was done

	OR.W	#$6000,D1	; big number, force truncation mode
	BRA	COMINT1

@3:
	TST.L	D7		; flag inexact if any stickies set
	BEQ.S	COMINT2
	BSET	#ERRX+8,D6
	BRA.S	COMINT2		; exit through normalization routine





;-----------------------------------------------------------
; Subroutine IPALIGN sets up binary point no further right than 24,
; 53, 64 bits as specified by the coercion info.  The environment
; word is read into D1.W.  Scratch register are D0/D2
;-----------------------------------------------------------
;IPALIGN:			; old IPALIGN and IALIGN DELETED <3/23/92, JPO>
;	MOVE.W	(FPSTATE).W,D1	; environment in D1
;	BFTST	D1{25:2}	; check rounding precision
;	BEQ.S	IALIGN		;   default (extended)
;	BMI.S	@1		;   single
;
;	MOVEQ	#52,D0		; double precision
;	BRA.S	FINALIGN
;@1:
;	MOVEQ	#23,D0
;	BRA.S	FINALIGN
;IALIGN:
;	MOVEQ	#63,D0
;FINALIGN:
;	MOVEQ	#0,D7		; zero D7
;	ADDI.W	#$3FFF,D0	; adjust exponent
;	MOVE.W	D0,D2		; save possible new exponent
;	SUB.L	A4,D0		; INT exp - exp
;	BGT.S	@7
;	RTS			; return LE in CCR if too big
;@7:
;	MOVEA.W	D2,A4		; use new exponent
;	BSR	RTSHIFT
;	MOVE	#0000,CCR	; fudge CCR = GT
;	RTS


;-----------------------------------------------------------
; Subroutine IPALIGN sets up binary point just to the right of D5
; (64th significand bit) by unnormalizing input value in A4/D4/D5
; if its magnitude is less than a limit determined by the current
; rounding precision.
;
; INPUT:   normalized extended value in A4/D4/D5
; OUTPUT:  CCR value LE (nonzero) and D7 cleared if input too large and 
;          CCR value GT (zero) if right shift took place and
;	     unnormalized (shifted) value in A4/D4/D5 with
;	     fractional stickies in D7.
;	   Environment setting in D1.W in both cases
; USES:  D0
;-----------------------------------------------------------
IPALIGN:			; new IPALIGN and IALIGN ADDED <3/23/92, JPO>
	MOVE.W	(FPSTATE).W,D1	; environment in D1
	BFTST	D1{25:2}	; check rounding precision
	BEQ.B	IALIGN		;   default (extended)
	BMI.B	@1		;   single

	MOVE.W	#$4033,D0	; double precision:  set exponent limit (biased 52)
	BRA.B	@2
@1:				; single precision
	MOVE.W	#$4016,D0	; set exponent limit for single precision (biased 23)
@2:
	MOVEQ	#0,D7		; zero stickies
	CMP.W	A4,D0		; is magnitude small enough for right shifting?
	BGT.B	@3		; yes

	RTS			; no.  return with "LE" in CCR
@3:
	MOVE.W	#$403E,D0	; yes.  D0 <- count for right shifting of
	SUB.W	A4,D0		;   binary point to right of D5
	BRA.B	DOSHIFT

IALIGN:				; extended rounding precision
	MOVE.W	#$403E,D0	; D0 <- exponent limit (biased 63)
	MOVEQ	#0,D7		; zero stickies
	SUB.W	A4,D0		; D0 <- right shift count
	BGT.B	DOSHIFT		; do shift

	RTS			; magnitude too big.  return with "LE" in CCR

DOSHIFT:			; unnormalize via right shift, putting fractional part into D7
	MOVEA.W	#$403E,A4	; set post-shift exponent (biased 63)
	BSR	RTSHIFT		; do the shift (count in D0):  D4/D5 -> D4/D5/D7
	MOVE.W	#$0000,CCR	; fudge "GT" in CCR
	RTS			; return


;-----------------------------------------------------------
; Subroutine RNDINT rounds a subnormal significand in D4/D5
; and D7 (stickies) according to the environment in D1.W
; Scratch register are D0/D2
;-----------------------------------------------------------
RNDINT:
	TST.L	D7		; exact result?
	BNE.S	@1		;   no  
	RTS			;   yes; done.
	
;-----------------------------------------------------------
; Inexact result:  signal and round
;-----------------------------------------------------------
@1:
	BSET	#ERRX+8,D6	; signal inexact
	BFTST	D1{17:2}	; round to nearest?
	BEQ.S	@4		; yes
	BMI.S	@2		; chop or round downward
	
;-----------------------------------------------------------
; Round toward +∞
;-----------------------------------------------------------
	TST.B	D6		; bump significand if positive
	BPL.S	RNDUPI
	RTS			; otherwise, done
	
@2:
	BTST	#13,D1		; chop or round downward?
	BEQ.S	@3		;   downward
	RTS			;   done if chop
	
;-----------------------------------------------------------
; Round toward -∞
;-----------------------------------------------------------
@3:
	TST.B	D6		; bump significand if negative
	BMI.S	RNDUPI
	RTS			; otherwise, return

;-----------------------------------------------------------
; Default rounding (to nearest)
;-----------------------------------------------------------
@4:
	ADD.L	D7,D7		; round bit set?
	BCS.S	@5		; yes
	RTS			; no; done

@5:	
	BNE.S	RNDUPI		; stickies set so round up
	BTST	#0,D5		; halfway case gets bumped
	BNE.S	RNDUPI		;   if lowest SIG bit is 1
	RTS			; otherwise, done
	
RNDUPI:
	MOVEQ	#0,D0		; increment significand
	ADDQ.L	#1,D5
	ADDX.L	D0,D4		; cannot carry out of D4
	RTS			; done
	
	

			
			
;-----------------------------------------------------------
;-----------------------------------------------------------
; CONVERSIONS from extended format
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QX2B---Convert extended SRC to nonextended DST
;-----------------------------------------------------------
QX2B:
	FINIT
	LEA	FINI2OPS,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6		; zero D6.LO
	MOVEA.L	LKADR2(A6),A1	; unpack extended SRC
	BSR	UNPXOP

	MOVEQ	#26,D7		; extract offset from format
	MOVE.L	D6,D1		;   code in opword
	LSR.L	D7,D1
	ANDI.W	#$000E,D1
	SUBQ.W	#2,D1
	MOVEQ	#0,D7
	MOVE.W	X2BCASE(D1),D1	; get addr of specific routine
	JMP	QX2B(D1)	;   and jump there


X2BCASE:
	DC.W	QX2D - QX2B	; double precision
	DC.W	QX2S - QX2B	; single precision
	DC.W	QX2X - QX2B	; ---illegal format
	DC.W	QX2I - QX2B	; int16
	DC.W	QX2L - QX2B	; int32
	DC.W	QX2C - QX2B	; comp




;-----------------------------------------------------------
; QX2D---convert extended SRC to double precision DST
;-----------------------------------------------------------
QX2D:
	MOVEA.L	LKADR1(A6),A2	; A2 <- DST addr for PACKD
	TST.L	D0		; finite nonzero input?
	BEQ.S	@1		; yes; must coerce

	TST.W	D0		; no; is it a NaN?
	BEQ.S	PACKD		;   zero or INF need no coercion

	ANDI.W	#$0F800,D5
	BSR	FPNANIN		; NaN input needs valid code
	BRA.S	PACKD		;   and no coercion

@1:
	MOVE.W	(FPSTATE).W,D1	; D1.W <- environment
	BTST	#6,D1		; Coerce to double precision
	BEQ.S	@3		;   unless single precision is set
	BSR	SCOERCE		;   in the environment
	BRA.S	PACKD

@3:
	BSR	DCOERCE



;-----------------------------------------------------------
; PACKD---pack and deliver a double precision result to (A2)
;-----------------------------------------------------------
PACKD:
	MOVE.W	A4,D3		; D3.W <- exponent
	CMPI.W	#$7FFF,D3	; INF or NAN?
	BNE.S	@1		; no
	MOVE.W	#$4400,D3	; exp too big, will decr below
	BRA.S	@5
@1:
	TST.W	D3		; exp = 0?
	BNE.S	@5
	MOVE.W	#$3C01,D3
@5:
	SUBI.W	#$3C00,D3
	TST.L	D4		; test lead bit
	BMI.S	@7		; decr exp unless normalized
	SUBQ.W	#1,D3
@7:

;-----------------------------------------------------------
; SET UP LOW 32 BITS WITH TRAILING 11 BITS FROM HI BITS.
;-----------------------------------------------------------
	LSR.L	#8,D5		; shift low half right 11 bits
	LSR.L	#3,D5
	BFINS	D4,D5{0:11}	; insert low 11 bits of high half

	LSR.L	#8,D4		; shift high half right 10 bits
	LSR.L	#2,D4
	BFINS	D3,D4{0:11}	; insert exponent, killing lead bit
	ADD.B	D6,D6		; insert sign
	ROXR.L	#1,D4

	MOVE.L	D4,(A2)+	; write result
	MOVE.L	D5,(A2)

	JMP	(A0)		; continuation routine


	
;-----------------------------------------------------------
; QX2S---convert extended SRC to single precision DST
;-----------------------------------------------------------
QX2S:
	MOVEA.L	LKADR1(A6),A2	; A2 <- DST addr for PACKS
	TST.L	D0		; finite nonzero input?
	BEQ.S	@1		; yes; must coerce

	TST.W	D0		; no; is it a NaN?
	BEQ.S	PACKS		;   zero or INF need no coercion

	MOVEQ	#0,D5
	CLR.B	D4
	BSR	FPNANIN		; NaN input needs valid code
	BRA.S	PACKS		;   and no coercion

@1:
	MOVE.W	(FPSTATE).W,D1	; D1.W <- environment
	BSR	SCOERCE		; coerce to single precision



;-----------------------------------------------------------
; PACKS---pack and deliver a single precision result to (A2)
;-----------------------------------------------------------
PACKS:
	MOVE.W	A4,D3		; D3.W <- exponent
	CMPI.W	#$7FFF,D3	; INF or NAN?
	BNE.S	@1		; no
	MOVE.W	#$4080,D3	; exp too big, will decr below
	BRA.S	@5
@1:
	TST.W	D3		; exp = 0?
	BNE.S	@5
	MOVE.W	#$3F81,D3
@5:
	SUBI.W	#$3F80,D3
	ADD.L	D4,D4		; kill lead bit and test
	BCS.S	@7		; decr exponent unless normalized
	SUBQ.W	#1,D3
@7:
	OR.W	D3,D4		; stuff exponent in low bits
	ROR.L	#8,D4		; rotate to high bits
	ADD.B	D6,D6		; insert sign
	ROXR.L	#1,D4
	MOVE.L	D4,(A2)		; deliver result

	JMP	(A0)		; continuation routine


	
;-----------------------------------------------------------
; QX2C---convert extended SRC to comp DST
;-----------------------------------------------------------
QX2C:
	TST.L	D0		; any special input?
	BEQ.S	@3		; no, normalized value

	BTST	#17,D0		; zero?
	BNE.S	PACKC		; yes, deliver it

	TST.B	D0		; NaN input?
	BNE.S	@2		; yes, invalid flag OK

@1:				; invalid result (INF, comp overflow)
	BSET	#ERRI+8,D6	; set invalid flag
	BCLR	#ERRX+8,D6	; clr inexact
@2:
	MOVEQ	#1,D4		; deliver COMP NaN
	MOVEQ	#0,D5
	ROR.L	#1,D4
	BRA.S	PACKC		; deliver result

@3:
	BSR	IALIGN		; align binary point to right of D5
	BLE.S	@1		; overflow

	MOVE.W	(FPSTATE).W,D1	; round to integer value
	BSR	RNDINT

	TST.L	D4		; overflow?
	BMI.S	@1		; yes

	TST.B	D6		; negative?
	BPL.S	PACKC		; no; done
	NEG.L	D5		; yes; make it so
	NEGX.L	D4

PACKC:				; deliver the comp result to DST addr
	MOVEA.L	LKADR1(A6),A2
	MOVE.L	D4,(A2)+
	MOVE.L	D5,(A2)

	JMP	(A0)		; finish up


;-----------------------------------------------------------
; QX2L---convert extended SRC to long integer DST
;-----------------------------------------------------------
QX2L:
	TST.L	D0		; any special input?
	BEQ.S	@3		; no, normalized value

	BTST	#17,D0		; zero?
	BNE.S	PACKL		; yes, deliver it

@1:				; invalid result (INF, NaN, longint overflow)
	MOVEQ	#1,D5		; deliver default result ($80000000)
	BSET	#ERRI+8,D6	; set invalid flag
	ROR.L	#1,D5
	BCLR	#ERRX+8,D6	; clr inexact
	BRA.S	PACKL		; deliver result

@3:
	BSR	IALIGN		; align binary point to right of D5
	BLE.S	@1		; overflow

	MOVE.W	(FPSTATE).W,D1	; round to integer value
	BSR	RNDINT

	TST.L	D4		; overflow?
	BNE.S	@1		; yes

	TST.L	D5
	BPL.S	@5		; no overflow

	NEG.L	D5		; most likely
	BPL.S	@1		; overflow

	TST.B	D6		; $80000000 OK if negative integer
	BPL.S	@1
@5
	TST.B	D6		; negative?
	BPL.S	PACKL		; no; done
	NEG.L	D5		; yes; make it so

PACKL:				; deliver the longint result to DST addr
	MOVEA.L	LKADR1(A6),A2
	MOVE.L	D5,(A2)

	JMP	(A0)		; finish up



;-----------------------------------------------------------
; QX2I---convert extended SRC to 16-bit integer DST
;-----------------------------------------------------------
QX2I:
	TST.L	D0		; any special input?
	BEQ.S	@3		; no, normalized value

	BTST	#17,D0		; zero?
	BNE.S	PACKI		; yes, deliver it

@1:				; invalid result (INF, NaN, overflow)
	MOVE.W	#$8000,D5	; deliver default result ($8000)
	BSET	#ERRI+8,D6	; set invalid flag
	BCLR	#ERRX+8,D6	; clr inexact
	BRA.S	PACKI		; deliver result

@3:
	BSR	IALIGN		; align binary point to right of D5
	BLE.S	@1		; overflow

	MOVE.W	(FPSTATE).W,D1	; round to integer value
	BSR	RNDINT

	TST.L	D4		; overflow?
	BNE.S	@1		; yes

	CMPI.L	#$08000,D5
	BCS.S	@5		; no overflow
	BHI.S	@1		; overflow
	TST.B	D6		; $8000 OK if negative integer
	BPL.S	@1

@5
	TST.B	D6		; negative?
	BPL.S	PACKI		; no; done
	NEG.W	D5		; yes; make it so

PACKI:				; deliver the longint result to DST addr
	MOVEA.L	LKADR1(A6),A2
	MOVE.W	D5,(A2)

	JMP	(A0)		; finish up



;-----------------------------------------------------------
;-----------------------------------------------------------
; QLOGBX---binary logarithm [ DST <- logb(DST) ]
;-----------------------------------------------------------
QLOGBX:
	FINIT
	LEA	FINI1OP,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6
	MOVEA.L	LKADR1(A6),A1	; unpack extended DST
	BSR	UNPXOP
	CLR.B	D6		; sign is irrelevant

	TST.L	D0		; check if finite nonzero input
	BEQ.S	@10		;   yes; evaluate logb
	
	TST.W	D0		; check if NaN input
	BNE	FPNANOUT	;   yes; output NaN

	BTST	#17,D0		; check if zero input
	BEQ	PACKX		;   no; INF propagates (with + sign)
		
;-----------------------------------------------------------
; LOGB(+-0) --> DIV BY ZERO --> ERROR BIT, STUFF -INF, RET.
;-----------------------------------------------------------
	ORI.W	#$0880,D6	; POOR MAN'S BSET'S
 	MOVEA.W	#$7FFF,A4	; BIG EXP
	MOVEQ	#0,D4		; ZERO DIGS
	MOVE.L	D4,D5
	BRA	PACKX

;-----------------------------------------------------------
; LOGB(finite and nonzero) --> exponent, normalized as a
; floating-point number.  Never exceptional.  Uses fast
; normalization.
;-----------------------------------------------------------
@10:
	MOVEQ	#0,D5		; clear the low significant bits
	SUBA.W	#$3FFF,A4	; unbias exponent
	MOVE.L	A4,D4		; move as integer
	BGT.S	@12		; positive
	BLT.S	@11		; negative
	
	SUBA.L	A4,A4		; zero result
	MOVE.L	D5,D4
	BRA	PACKX

@11:
	ORI.B	#$80,D6		; negative; set sign
	NEG.L	D4		; magnitude of value
@12:
	MOVEA.W	#$401E,A4	; exponent = 31, biased
	BFFFO	D4{0:0},D0	; find first one bit in D4
	LSL.L	D0,D4		; shift left to normalize
	SUBA.W	D0,A4		; adjust exponent
	BRA	PACKX



;-----------------------------------------------------------
;-----------------------------------------------------------
; QSCALBX---binary scaling [ DST <- DST * 2**SRC ]
;-----------------------------------------------------------
;-----------------------------------------------------------
QSCALBX:
	FINIT
	LEA	FINI2OPS,A0	; finish up routine
	MOVE.W	LKOP(A6),D6	; get opword into D6.HI
	MOVEQ	#0,D0		;   and zero D0
	SWAP	D6
	CLR.W	D6
	MOVEA.L	LKADR1(A6),A1	; unpack extended DST
	BSR	UNPXOP

	TST.L	D0		; check if finite nonzero input
	BEQ.S	@1		;   yes; evaluate scalb
	
	TST.W	D0		; check if NaN input
	BNE	FPNANOUT	;   yes; output NaN

	BRA	PACKX		; zero and INF propagate with sign

;-----------------------------------------------------------
; SCALB is evaluated by adding the integer adjustment into
; the exponent in A4 and checking for over/underflow via the
; COERCE routine.
;-----------------------------------------------------------
@1:
	MOVEA.L	LKADR2(A6),A2	; SRC addr
	ADDA.W	(A2),A4		; adjust exponent
	MOVEQ	#0,D7		; zero stickies
	BRA	COERCE		; coerce
	


;-----------------------------------------------------------
;-----------------------------------------------------------
; CLASSIFY routines place an integer code of SRC class at
; the DST address.  Classify is unexceptional.  Codes are:
;	SNAN	1
;	QNAN	2
;	INF	3
;	ZERO	4
;	NORMAL	5
;	SUBNORM	6
;-----------------------------------------------------------
;-----------------------------------------------------------

;-----------------------------------------------------------
; QCLASSX---DST <- class of extended SRC
;-----------------------------------------------------------
QCLASSX:
	MOVEM.L	A0/D0-D1,-(SP)	; save small # of registers
	MOVEA.L	22(SP),A0	; SRC addr
	MOVE.W	(A0)+,D0	; get sign/exp in D0.W
	BTST	#5,17(SP)	; 96-bit extended SRC?
	BEQ.S	@1		;   no

	ADDQ	#2,A0		;   yes, bump pointer to significand
@1:
	ADD.L	D0,D0		; sign in D0 bit 16
	LSR.W	#1,D0		; positive exp in D0.W

	BSET	#31,D0		; sign flag is D0 bit 31
	BCLR	#15,D0		; clr sign in exp

	CMPI.W	#$7FFF,D0	; max exp?
	BEQ.S	@5		; yes, NAN or INF class
	
	MOVE.L	(A0)+,D1	; normalized?
	BPL.S	@8		; zero or unnormalized

@2:
	MOVEQ	#5,D1		; NORMAL

@3:
	BTST	#16,D0		; negate class code if 
	BEQ.S	@4		;   sign bit is set
	NEG.W	D1
@4:
	MOVEA.L	18(SP),A0	; DST addr
	MOVE.W	D1,(A0)		; deliver classify result
	MOVEM.L	(SP)+,A0/D0-D1	; restore registers
	RTD	#STKREM2	; done


@5:				; INF or NAN class
	MOVE.L	(A0)+,D1	; read high half of significand
	ADD.L	D1,D1		; clr explicit bit of sig
	LSR.L	#1,D1
	BEQ.S	@7		; INF or SNAN class since sig high is zero

	BTST	#QNANBIT,D1	; QNAN or SNAN
	BEQ.S	@6		; 

	MOVEQ	#2,D1		; QNAN
	BRA.S	@3
@6:
	MOVEQ	#1,D1		; SNAN
	BRA.S	@3

@7:
	MOVE.L	(A0),D1		; INF or SNAN?
	BNE.S	@6		; SNAN

	MOVEQ	#3,D1		; INF
	BRA.S	@3

@8:
	BEQ.S	@11		; ZERO or SUBNORM

@9:
	SUBQ.W	#1,D0		; normalization loop
	ADD.L	D1,D1
	BPL.S	@9

@10:
	TST.W	D0		; negative exponent means SUBNORM
	BPL.S	@2		; nonnegative means NORMAL

	MOVEQ	#6,D1		; SUBNORM
	BRA.S	@3

@11:				; high significand is zero
	SUB.W	#32,D0		; decrease exponent
	MOVE.L	(A0),D1		; D1 <- low significand
	BEQ.S	@12		; ZERO
	BPL.S	@9		; still unnormalized
	BRA.S	@10		; check exponent

@12:
	MOVEQ	#4,D1		; ZERO
	BRA.S	@3
	
	
;-----------------------------------------------------------
; QCLASSB---DST <- class of single/double/comp SRC
; X bit trick thanks to S. McDonald
;-----------------------------------------------------------
QCLASSB:
	MOVEM.L	A0/D0-D1,-(SP)	; save small # of registers
	MOVE.W	16(SP),D0	; D0.W <- opcode
	MOVEA.L	22(SP),A0	; A0 <- SRC addr
	BTST	#11,D0		; double precision classify?
	BNE.S	QCLASSD		; yes
	
	BTST	#13,D0		; classify comp?
	BNE.S	QCLASSC		; yes

;-----------------------------------------------------------
; Classify single precision SRC
;-----------------------------------------------------------
	MOVE.L	(A0),D0		; D0 <- SRC
	ADD.L	D0,D0		; sign in X bit with shifted SRC (S. McDonald)
	BEQ.S	CLBZ		; ZERO

	BFEXTU	D0{0:8},D1	; D1.B <- exponent
	BEQ.S	CLBSUB		; SUBNORMAL

	CMPI.B	#$FF,D1
	BNE.S	CLBN		; NORMAL

	BFTST	D0{8:23}	; NAN or INF
	BEQ.S	CLBI		; INF

	BTST	#23,D0		; SNAN or QNAN
	BNE.S	CLBQN		; QNAN

	BRA.S	CLBSN

;-----------------------------------------------------------
; QCLASSD --- classify double precision SRC
;-----------------------------------------------------------
QCLASSD:
	MOVE.L	(A0)+,D0	; D0 <- high half of SRC
	OR.W	(A0)+,D0	; OR low half of SRC into D0.W
	OR.W	(A0),D0		;   (S. McDonald)
	ADD.L	D0,D0		; save sign in X bit (SRC shifted)
	BEQ.S	CLBZ		; ZERO

	BFEXTU	D0{0:11},D1	; D1 low <- exponent
	BEQ.S	CLBSUB		; SUBNORMAL

	CMPI.W	#$07FF,D1
	BNE.S	CLBN		; NORMAL

	BFTST	D0{11:20}	; NAN or INF
	BEQ.S	CLBI		; INF

	BTST	#20,D0		; SNAN or QNAN
	BEQ.S	CLBSN		; SNAN

CLBQN:
	MOVEQ	#2,D0		; QNAN case
	BRA.S	CLBOUT		; exit

CLBZ:
	MOVEQ	#4,D0		; ZERO case
	BRA.S	CLBOUT

CLBSUB:
	MOVEQ	#6,D0		; SUBNORMAL case
	BRA.S	CLBOUT

CLBN:
	MOVEQ	#5,D0		; NORMAL case

CLBOUT:				; common exit code
	MOVEA.L	18(SP),A0	; DST addr
	ROXR.W	#1,D1		; get sign bit back from X
	BPL.S	@1
	NEG.W	D0		; negate class code if SRC negative
@1:
	MOVE.W	D0,(A0)
	MOVEM.L	(SP)+,A0/D0-D1	; restore registers
	RTD	#STKREM2	; done

CLBI:
	MOVEQ	#3,D0		; INF case
	BRA.S	CLBOUT

CLBSN:
	MOVEQ	#1,D0		; SNAN case
	BRA.S	CLBOUT

;-----------------------------------------------------------
; QCLASSC --- classify comp SRC (only NORM, ZERO, or QNAN
; are possible)
;-----------------------------------------------------------
QCLASSC:
	MOVE.L	(A0)+,D0	; D0 <- high half of comp
	ADD.L	D0,D0		; sign bit shifted out of D0 into X
	OR.L	(A0),D0		; OR in low half of comp
	BNE.S	CLBN		; NORMAL with sign in X

	ADDX.W	D0,D0		; test and clear X bit
	BEQ.S	CLBZ		; ZERO
	BRA.S	CLBQN		; QNAN



;-----------------------------------------------------------
;-----------------------------------------------------------
; QSETENV---set environment to word value at DST addr
;-----------------------------------------------------------
;-----------------------------------------------------------
QSETENV:
	MOVE.L	A0,-(SP)	; save single register
	MOVEA.L	10(SP),A0	; DST addr
	MOVE.W	(A0),(FPSTATE).W	; set environment
	MOVEA.L	(SP)+,A0	; restore register
	RTD	#STKREM1	; done


;-----------------------------------------------------------
;-----------------------------------------------------------
; QGETENV---write environment word to DST addr
;-----------------------------------------------------------
;-----------------------------------------------------------
QGETENV:
	MOVE.L	A0,-(SP)
	MOVEA.L	10(SP),A0
	MOVE.W	(FPSTATE).W,(A0)	; get environment
	MOVEA.L	(SP)+,A0
	RTD	#STKREM1



;-----------------------------------------------------------
;-----------------------------------------------------------
; QSETHV---set haltvector to longword at DST addr
;-----------------------------------------------------------
;-----------------------------------------------------------
QSETHV:
	MOVE.L	A0,-(SP)	; save single register
	MOVEA.L	10(SP),A0	; DST addr
	MOVE.L	(A0),(FPSTATE+2).W	; set haltvector
	MOVEA.L	(SP)+,A0	; restore register
	RTD	#STKREM1	; done


;-----------------------------------------------------------
;-----------------------------------------------------------
; QGETHV---write haltvector to DST addr
;-----------------------------------------------------------
;-----------------------------------------------------------
QGETHV:
	MOVE.L	A0,-(SP)
	MOVEA.L	10(SP),A0
	MOVE.L	(FPSTATE+2).W,(A0)	; get haltvector
	MOVEA.L	(SP)+,A0
	RTD	#STKREM1


;-----------------------------------------------------------
;-----------------------------------------------------------
; QNEG---negate floating point number at DST addr
;-----------------------------------------------------------
;-----------------------------------------------------------
QNEG:
	MOVE.L	A0,-(SP)
	MOVEA.L	10(SP),A0		; DST addr
	BCHG	#7,(A0)			; negate sign bit
	MOVEA.L	(SP)+,A0
	RTD	#STKREM1
	

;-----------------------------------------------------------
;-----------------------------------------------------------
; QABS---absolute value of floating point number at DST addr
;-----------------------------------------------------------
;-----------------------------------------------------------
QABS:
	MOVE.L	A0,-(SP)
	MOVEA.L	10(SP),A0		; DST addr
	BCLR	#7,(A0)			; clear sign bit
	MOVEA.L	(SP)+,A0
	RTD	#STKREM1
	


;-----------------------------------------------------------
;-----------------------------------------------------------
; QCPYSGN---copies sign of DST operand to SRC operand
;-----------------------------------------------------------
;-----------------------------------------------------------
QCPYSGN:
	MOVEM.L	A0,-(SP)	; stack:  A0sv < ret < opword < &DST < &SRC
	MOVEA.L	14(SP),A0	; A0 <- &SRC
	BCLR	#7,(A0)		; clr sign of SRC
	TST.B	([10,SP])	; test sign of DST
	BPL.S	@1

	BSET	#7,(A0)		; DST is negative, so echo sign in SRC
@1:
	MOVEA.L	(SP)+,A0
	RTD	#STKREM2



;-----------------------------------------------------------
;-----------------------------------------------------------
; QPROCENTRY---saves environment word at DST address, then
; sets default environment
;-----------------------------------------------------------
;-----------------------------------------------------------
QPROCENTRY:
	MOVE.L	A0,-(SP)	; stack:  A0sv < ret < opword < &DST
	MOVEA.L	10(SP),A0	; DST addr
	MOVE.W	(FPSTATE).W,(A0)	; save environment in DST
	CLR.W	(FPSTATE).W	; set default environment

	MOVEA.L	(SP)+,A0
	RTD	#STKREM1



;-----------------------------------------------------------
;-----------------------------------------------------------
; QTESTXCP---test an exception whose index is in low byte
; of word DST.  Set result of test (1 for TRUE and 0 for FALSE)
; in high byte of DST.
;-----------------------------------------------------------
;-----------------------------------------------------------
QTESTXCP:
	MOVEM.L	D0/A0,-(SP)
	MOVEA.L	14(SP),A0
	MOVE.W	(A0),D0 	; fetch input index
	BTST	D0,(FPSTATE).W 	; test exception bit in high
	SNE 	D0		;   byte of environment word
	NEG.B	D0
	MOVE.B	D0,(A0) 	; boolean result in DST high byte
	MOVEM.L	(SP)+,D0/A0
	RTD	#STKREM1



;-----------------------------------------------------------
; QSETXCP---set an exception whose index is in low byte
; of word DST and halt if enabled.
;-----------------------------------------------------------
QSETXCP:
	MOVEM.L	D0/D6/A0,-(SP)	; Use 3 register
	MOVE.W	#$0015,D6	; opword into D6.HI
	SWAP	D6
	CLR.W	D6		; clr D6.LO
	MOVEA.L	18(SP),A0	; DST addr
	MOVE.W	(A0),D0 	; fetch exception index
	ADDQ.W	#8,D0		; align to second byte
	BSET	D0,D6		; set exception in D6.W
	MOVE.W	(FPSTATE).W,D0	; environment into D0.W
	BRA.S	FASTFIN		; share back end with PROCEXIT routine


;-----------------------------------------------------------
; QPROCEXIT---restore old environment at DST address with
; current exceptions ORed in.  Halt if any of the current
; exceptions are enabled in the old environment.  Back end
; is shared with SETEXCEPTION routine.
;-----------------------------------------------------------
QPROCEXIT:
	MOVEM.L	D0/D6/A0,-(SP)	; Use 3 registers
	MOVEA.L	18(SP),A0	; old environment addr
	MOVE.W	#$0019,D6	; opword into D6.HI
	SWAP	D6
	MOVE.W	#$1F00,D6	; exception mask in D6.W
	AND.W	($0A4A).W,D6 	; current exceptions in D6.W
	MOVE.W	(A0),D0		; old environment into D0.W for restoration

FASTFIN:
	OR.W	D6,D0		; OR new exceptions with old environment
	MOVE.W	D0,($0A4A).W	; store resulting environment
	LSR.W	#8,D6		; check for halt
	AND.W	D6,D0
	BNE.S	FASTHALT	; handle halt
			
FASTEX:
	MOVE	D0,CCR		; zero CCR
	MOVEM.L	(SP)+,D0/D6/A0	; restore registers
	RTD	#STKREM1	; done

	
;-----------------------------------------------------------
; Fast halt vectoring routine for SETEXCEPTION and PROCEXIT
;-----------------------------------------------------------
FASTHALT:
	LEA	18(SP),A0	; A0 points to DST addr on stack
	CLR.W	-(SP)		; push CCR = 0 below D0 save
	MOVE.W	D0,-(SP)	; push HALT exceptions
	PEA	(SP)		; push MISCHALTINFO record pointer
	MOVE.L	8(A0),-(SP)	; push bogus SRC2 addr
	MOVE.L	4(A0),-(SP)	; push bogus SRC addr
	MOVE.L	(A0),-(SP)	; push DST addr
	SWAP	D6		; push opword
	MOVE.W	D6,-(SP)
	MOVEA.L	($0A4C).W,A0	; call user halt handler
	JSR	(A0)
			
	MOVE.L	(SP)+,D0	; pop HALT exception/CCR off stack
	BRA.S	FASTEX		; exit



;-----------------------------------------------------------
;-----------------------------------------------------------
; QNEXTB---NEXTAFTER function changes the SRC operand by one
; ulp in the direction of the DST operand.  This function
; behaves like nonarithmetic operations, but it may set
; exceptions.  This function calls via BSR routines for
; comparison, multiplication, classification, and conversion.
;-----------------------------------------------------------
;-----------------------------------------------------------
QNEXTB:
	FINIT
	MOVE.W	LKOP(A6),D6	; get opword into D6.W
	MOVEM.L	LKADR1(A6),A1-A2	; A1 <- &DST, A2 <- &SRC

	SUBA.W	#22,SP		; reserve stack for 2 extendeds and one int
	MOVEA.L	SP,A4		; A4 is local frame pointer

	MOVE.W	(FPSTATE).W,D3	; save old environment in D3 for duration
	CLR.W	(FPSTATE).W	; set default environment

	MOVEQ	#0,D2		; zero D2
	MOVE.W	D6,D5		; copy opcode into D5
	ANDI.W	#$3800,D5	; isolate format bits in D5
	BNE.S	@2		; single or double format
	
	MOVE.B	#$20,D2		; isolate FPX96 bit in D2
	AND.B	D6,D2
	BEQ.S	@2		; 80-bit extended
	
	MOVE.W	(A2),2(A2)	; convert 96-bit SRC to 80-bit and
	ADDQ.L	#2,A2		;   update pointer to latter
@2:
	SWAP	D6		; opword in D6.HI like arith ops
	CLR.W	D6		; zero flag and sign bits

;-----------------------------------------------------------
; CONVERT SRC TO EXTENDED
;-----------------------------------------------------------
	PEA	(A2)		; src operand address
	PEA	12(A4)		; stack frame addr
	MOVEQ	#OP2EXT,D0	; convert to 80-bit extended
	OR.W	D5,D0		; ...with format
	MOVE.W	D0,-(SP)
	BSR	FP020
	TST.W	D5		; if extended format, overwrite
	BNE.S	@3		;   SRC with converted SRC to
				;   avoid problem of unnormalized input
	MOVE.L	12(A4),(A2)
	MOVE.L	16(A4),4(A2)
	MOVE.W	20(A4),8(A2)

;-----------------------------------------------------------
; COMPARE SRC WITH ZERO.  IF IT'S EQUAL, ADJUSTMENTS WILL
; BE MADE IN DECREMENT ROUTINES BELOW.
;-----------------------------------------------------------
@3:
	BFEXTU	12(A4){1:15},D1	; extract EXP field from SRC
	OR.L	14(A4),D1	; OR in SIG.HI and SIG.LO
	OR.L	18(A4),D1

	SNE	D4		; D4.BYTE IS 1'S IF SRC IS ZERO

;-----------------------------------------------------------
; CONVERT DST TO EXTENDED
;-----------------------------------------------------------
	PEA	(A1)
	PEA	(A4)
	OR.B	D2,D0		; may be 96-bit DST
	MOVE.W	D0,-(SP)
	BSR	FP020
	
	TST.B	D2		; if 96-bit DST, shrink to 80-bit
	BEQ.S	@4		;   in stack frame
	
	MOVE.L	4(A4),2(A4)
	MOVE.L	8(A4),6(A4)

;-----------------------------------------------------------
; COMPARE THE TWO EXTENDED OPERANDS
;-----------------------------------------------------------
@4:
	PEA	(A4)	; DST OPERAND
	PEA	12(A4)	; SRC OPERAND
	MOVE.W	#OPCMP,-(SP)
	BSR	FP020

;-----------------------------------------------------------
; IF OVERFLOW IS SET, THE OPERANDS ARE UNORDERED, THAT IS,
; ONE OF THEM IS A NAN.  USE THE MULTIPLY OPERATION TO FORCE
; THE PRECEDENT NAN (IF THERE ARE TWO) TO THE SRC
;-----------------------------------------------------------
	BVC.S	NXORD

	PEA	(A4)	; DST OPERAND
	PEA	12(A4)	; SRC OPERAND
	MOVE.W	#OPMUL,-(SP)
	BSR	FP020

;-----------------------------------------------------------
; NOW CONVERT THE PRECEDENT NAN BACK TO INPUT FORMAT.
;-----------------------------------------------------------
	PEA	12(A4)		; SRC OPERAND IS OUTPUT
	PEA	(A2)		; SRC ADDRESS
 	MOVEQ	#OPEXT2,D0	; CVT FROM 80-BIT EXT OPCODE
	OR.W	D5,D0		; OVERLAY THE FORMAT
	MOVE.W	D0,-(SP)
	BSR	FP020
	BRA	NXFIN

;-----------------------------------------------------------
; GET HERE IF THE TWO OPERANDS ARE ORDERED.  IF THEY ARE
; EQUAL, THERE IS NOTHING TO DO; OTHERWISE MUST INC OR DEC
; THE SRC OP AS APPROPRIATE.  NOTE THE ONE *****FUNNY*****
; CASE: IF THE SRC IS ZERO, THEN ITS SIGN MAY BE MISLEADING.
; FOR INSTANCE, NEXT(-0, 3) SHOULD BE +0INC1.  BUT THE MINUS
; SIGN ON 0 CAUSES A DEC TO BE ISSUED INSTEAD.  THE FIX IS
; TO MAKE DEC SMART ENOUGH TO KNOW THAT IF 0 IS DEC-ED, THE
; SIGN SHOULD BE FLIPPED AND THE OPERAND SHOULD BE INC-ED
; INSTEAD.
;-----------------------------------------------------------
NXORD:
	BEQ	NXFIN
	BCC.S	NXGREAT

;-----------------------------------------------------------
; GET HERE WHEN SRC < DST.  INC IF SRC IS +, DEC IF -
;-----------------------------------------------------------
	BTST	#7,(A2)	; SIGN BIT OF SRC OPERAND
	BEQ.S	NXINC
	BRA	NXDEC

;-----------------------------------------------------------
; GET HERE WHEN SRC > DST.  DEC IF SRC IS +, INC IF -
;-----------------------------------------------------------
NXGREAT:
	BTST	#7,(A2)
	BEQ	NXDEC

;-----------------------------------------------------------
; INCREMENT BY A UNIT IN THE LAST PLACE, ACCORDING TO THE
; FORMAT MASK IN D5.  THE FORMAT IS IN BITS $3800.  THE ONLY
; POSSIBLE CASES ARE:
;	$1000 -- SINGLE
;	$0800 -- DOUBLE
;	$0000 -- EXTENDED
;-----------------------------------------------------------
NXINC:
;-----------------------------------------------------------
; SINGLE CASE:
;-----------------------------------------------------------
	BTST	#SRCMD,D5	; TEST $1000 BIT
	BEQ.S	@11

	ADDQ.L	#1,(A2)
	BRA.S	NXERR

;-----------------------------------------------------------
; DOUBLE CASE:
;-----------------------------------------------------------
@11:
	BTST	#SRCLO,D5	; TEST $0800 BIT
	BEQ.S	@15

	ADDQ.L	#1,4(A2)
	BCC.S	@13
	ADDQ.L	#1,(A2)
@13:
	BRA.S	NXERR

;-----------------------------------------------------------
; EXTENDED CASE: BE SURE OUTPUT INFINITY HAS LEADING 0 BIT.
;-----------------------------------------------------------
@15:	
	ADDQ.L	#1,6(A2)
	BCC.S	NXERR
	ADDQ.L	#1,2(A2)
	BCC.S	NXERR
	ROXR	2(A2)
	ADDQ.W	#1,(A2)
	CMPI.W	#$7FFF,(A2)
	BEQ.S	@16
	CMPI.W	#$FFFF,(A2)
	BNE.S	NXERR
@16:
	BCLR	#7,2(A2)	; Clr explicit bit in infinite result
	
;-----------------------------------------------------------
; TEST FOR EXCEPTIONS ACCORDING TO IEEE.  NEXT(HUGE, INF)
; YIELDS INF WITH OVERFLOW AND INEXACT SIGNALED.
; NEXT(TINY, 0) YIELDS SOME DENORMAL WITH UNDERFLOW
; AND INEXACT.  JUST SET THE APPROPRIATE BITS IN D6.LO AND
; EXIT AS THOUGH A TRUE ARITHMETIC OPERATION.  THE FIRST
; STEP IS TO FIND THE CLASS OF THE INC/DEC-ED SRC OPERAND.
;-----------------------------------------------------------
NXERR:
	PEA	(A2)
	PEA	10(A4)		; ADDRESS OF INTEGER
	MOVEQ	#OPCLASS,D0
	OR.W	D5,D0
	MOVE.W	D0,-(SP)
	BSR	FP020

;-----------------------------------------------------------
; KILL THE SIGN OF THE CLASS RESULT AND PLACE IN REGISTER
; THE CODES ARE:
;	1	SNAN -- CAN'T HAPPEN
;	2	QNAN -- CAN'T HAPPEN
;	3	INF -- OVERFLOW AND INEXACT
;	4	ZERO -- UNDERFLOW AND INEXACT
;	5	NORMAL -- OK
;	6	DENORMAL -- UNDERFLOW AND INEXACT
;-----------------------------------------------------------
	MOVE.W	10(A4),D1
	BPL.S	@1

	NEG.W	D1
@1:

;-----------------------------------------------------------
; CHECK FOR INFINITE RESULT (WHICH MUST HAVE COME FROM FIN).
;-----------------------------------------------------------
	CMPI.W	#CLINF,D1
	BNE.S	@3

	ORI.W	#ERRWXO,D6	; SET INEXACT AND OVERFLOW
	BRA.S	NXFIN
@3:
	CMPI.W	#CLNORM,D1
	BEQ.S	NXFIN

	ORI.W	#ERRWXU,D6	; SET INEXACT AND UNDERFLOW

;-----------------------------------------------------------
; EXIT THROUGH POINT IN FPCONTROL AFTER CLEANING STACK
;-----------------------------------------------------------
NXFIN:
	ADDA.W	#22,SP		; RESTORE STACK
	TST.B	D2		; if 96-bit extended result,
	BEQ.S	@1		;   expand result	
	MOVE.W	(A2),-2(A2)
@1:
	MOVE.W	(FPSTATE).W,D7	; D7 <- flags due to conversions
	MOVE.W	D3,(FPSTATE).W	; restore old environment
	OR.W	D7,D6		; OR all flags together
         	BRA	FINI2OPS

;-----------------------------------------------------------
; DECREMENT, WATCHING FOR ZERO VALUE.  BRANCH TREE IS LIKE
; THAT OF INC ABOVE.
;-----------------------------------------------------------
NXDEC:
	BTST	#SRCMD,D5	; CHECK $1000 BIT FOR SINGLE
	BEQ.S	@21

	TST.B	D4		; D4.B IS NON0 IF OPERAND IS
	BNE.S	@201

	BCHG	#7,(A2)
	ADDQ.L	#1,(A2)
	BRA.S	NXERR
@201:
	SUBQ.L	#1,(A2)
	BRA.S	NXERR

;-----------------------------------------------------------
; DOUBLE CASE
;-----------------------------------------------------------
@21:
	BTST	#SRCLO,D5	; CHECK $0800 BIT FOR DOUBLE
	BEQ.S	@25

	TST.B	D4		; D4.B IS NON0 IF OP IS
	BNE.S	@211

	BCHG	#7,(A2)
	ADDQ.W	#1,6(A2)
	BRA.S	NXERR
@211:
	SUBQ.L	#1,4(A2)
	BCC.S	@213

	SUBQ.L	#1,(A2)
@213:
	BRA.S	NXERR

;-----------------------------------------------------------
; EXTENDED CASE
;-----------------------------------------------------------
@25:
	TST.B	D4
	BNE.S	@251

	BCHG	#7,(A2)
	ADDQ.W	#1,8(A2)
	BRA	NXERR
	
@251:
	SUBQ.L	#1,6(A2)	; DEC LOW LONG
	BCC.S	@259		; NO C MEANS FINE
	SUBQ.L	#1,2(A2)
	BMI.S	@257		; MAY HAVE BORROWED

	TST.W	(A2)		; MIN EXP?
	BEQ.S	@259		; YES --> DONE
	CMPI.W	#$8000,(A2)
	BEQ.S	@259

	ADDI.W	#$8000,2(A2)
	BRA.S	@258
@257:
	BCC.S	@259		; NO CARRY --> DONE
@258:
	SUBQ.W	#1,(A2)
@259:
	BRA	NXERR


