;
;	File:		ScriptMgrInit.a (formerly SMgrInit.a)
;
;	Contains:	Script Manager initialization routines and tables.
;
;	Written by:	JDT	Joe Ternasky
;				KWK	Ken Krugler
;				MED	Mark Davis
;				LDC	Lee Collins
;				PKE	Peter Edberg
;
;	Copyright:	© 1986-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	  <SM11>	 5/27/93	CSS		Don't initialize emNumer and emDenom because these are obsolete
;									fields.
;	  <SM10>	 5/21/93	CSS		Initialize some expandmem: emNumer, emDenom, emScriptAppGlobals
;									from ScriptMgrExtTail.a.
;	   <SM9>	 5/21/93	CSS		Rollin from Reality:
;		<33>	 5/19/93	PKE		#1086200: Change roman dispatch table initialization to handle
;									nil entries in romanDispTable by setting the corresponding
;									dispatch table entry to be nil. Then make nil entries in
;									romanDispTable for IsSpecialFont and RawPrinterValues for ROM
;									builds.
;	   <SM8>	 1/27/93	CSS		Rollin fix to auto-install scripts. This fix loads the itlb
;									resource for each script an determines if the auto-install bit
;									(for simple scripts) is set. If it is this patch installs the
;									script. This fixes a bug Radar#1060646 "WorldScript I and/or
;									Cyrillic does not work correctly." Wherein, the Cyrillic script
;									was not installing. Also, fixed the vectors for getscript and
;									setscript for roman scripts to call the new routines
;									"RomanGetScript" and "RomanSetScript." This is per Radar bug
;									#1025998.
;	   <SM7>	12/15/92	CSS		Look for dictionary manager in ROM.
;	   <SM6>	11/19/92	RB		When looking for the standard Chicago font, look in ROM first.
;	   <SM5>	 10/2/92	PN		Add initDictionary to the initialization process
;		<32>	 6/17/92	HA		#1029756,<PKE>: Removing StyledlineBreak  to
;									ScriptMgrExtensions.a.
;		<31>	 6/12/92	FM		More changes to bring the rom build up to date with system 7
;									along w/ additional cleanup:
;									-Combined many of the "if forROM" conditionals in romanDispTable,
;										and utilTableBase, for readability.
;									-Moved PatchTable and PatchTableAUX to ScriptMgrPatch.a since we
;										only need them in system builds. (ScriptMgrPatch.a is only for
;										system builds now)
;									-Added the internal SMgrPostMunging vector so that we can call it from
;										GetOSEvent instead of being so incestuous and JSRing directly
;										into the ScriptMgr.
;									-PrintAction is still conditionalized forRom only because it is in
;										ScriptMgrExtensions.a which isn't linked into 'ptch' 4.
;									-Removed the obsolete FixSMgrWorld vector setup.
;									-Removed the obsolete and already commented out FixSPExtra vector setup.
;									-Removed versionAddress import since it is no longer used.
;
;		<30>	 5/31/92	FM		Made many changes to bring the rom build up to date with system 7
;									-Changed NFindWord to xNFindWord (the C routine).
;									-Added NFindScriptRun, ScriptToRange, xTestLetter, and SCLwrString to
;									   rom dispatch table so we match 7.0
;									-imported NFindScriptRun,ScriptToRange,xTestLetter,SCLwrString
;									   Font2RealScript,RealScript,xNFindWord,TruncString,TruncText
;									   ReplaceText,InitScripts,AddScriptFonts,IsCmdChar,InitScriptApp
;									   CleanupScriptApp,ReInitScripts,FindCharInSet,InitKeybdMenu
;									   SetKbdMenuInfo, and RebuildKeybdMenu for dispatch table.
;									-got rid of use of smgrVersPtch4, romanVersPtch4 since they aren't
;									   in the rom build. Used romanVersPriv and smgrVersPriv instead.
;
;		<29>	 5/19/92	PKE		#1030321,<jh>: Expand dispatch table for private interface to
;									existing NFindScriptRun routine.
;		<28>	 5/14/92	PKE		#1027061,<ha>: Expand dispatch table for new internal
;									ScriptToRange routine that returns resource ID range for a
;									script.
;		<27>	 4/29/92	FM		Get rid of conditionals: SysVers,
;		<26>	 4/22/92	PKE		#1027368,<FM>: For non-ROM builds, we move Roman CharType to
;									ptch 27 for all CPUs and patch it out entirely, so don't put its
;									address in the dispatch table here.
;		<25>	12/10/91	PKE		#1017754: For non-ROM builds, move PrintAction to ptch 27 for
;									all CPUs.
;		<24>	 12/6/91	PKE		#1017161: Expand dispatch table for new private routine
;									TestLetter.
;		<23>	10/23/91	YK		Roll back to revision 21.  <22> was moved into
;									ScriptMgrExtTail.a.
;		<22>	10/23/91	JH		Added InitDictionaryMgr to load the dictionary manager code.
;									Can be found at very end of ScriptInit.
;		<21>	 10/8/91	PKE		For Cube-E (and Bruges): Expand dispatch table for new
;									(currently private) routines RealScript, Font2RealScript,
;									SCLwrString (needed for bugs #1013149, #1012949). Clean up some
;									conditionals, remove code that is conditionalized out.
;		<20>	 1/14/91	PKE		(stb) Expand dispatch table for Kevin’s new private routine
;									FindCharInSet, needed for Dialog Mgr and Finder.
;		<19>	12/14/90	PKE		(DC) Don’t install GetOSEvent patch if A/UX running. Don’t
;									install InitApplZone patch on 7.0 (no longer needed).
;		<18>	12/10/90	PKE		(VL) Expand dispatch table for new private routine
;									ReInitScripts, needed for network booting.
;		<17>	 7/25/90	PKE		Expand dispatch table for new private routines InitScriptApp and
;									CleanupScriptApp.
;		<16>	 7/23/90	PKE		For 7.0, move romanDispTable (table of offsets used to
;									initialize Roman dispatch table) here, so it gets cut back. Use
;									smgrSixPack instead of $606.
;		<15>	 7/20/90	PKE		For 7.0, FixSMgrWorld code is moved into ptch 27, so don’t
;									initialize its vector here.
;		<14>	 7/11/90	PKE		Expand dispatch table for new internal routine _IsCmdChar.
;		<13>	 6/13/90	PKE		Expand dispatch table for new internal routine
;									_RebuildKeybdMenu.
;		<12>	 5/31/90	PKE		Expand dispatch table for new internal routine _SetKbdMenuInfo.
;		<11>	 5/24/90	PKE		For 7.0, moved table of initial values for dispatch table here
;									(from ScriptMgrUtil.a) so it gets cut back.
;		<10>	  5/5/90	PKE		For 7.0, remove InitWindows and InitResources patches.
;		 <9>	 4/10/90	PKE		Used smgrSysVers and smgrROMVers instead of buildLevel. Deleted
;									conditionalized definitions of forRom, SysVers, Scripts604.
;									Started organizing for ROMification of 7.0 extensions. Cleaned
;									up tables at end; removed obsolete test code, deleted doKeyboard
;									symbol and code conditionalized on it. Conditionalized <7> so
;									object compares work against official 6.0.x sources.
;		 <8>	 3/27/90	PKE		Use new conditional flags for gestaltScriptMgr.
;		 <7>	 3/20/90	EMT		Removed unnecessary ROM85 references and oldMacTweek code.
;		 <6>	 3/19/90	PKE		Use new smgrUseDispTablePtr conditional.
;		 <5>	 2/22/90	PKE		Moved FixSpExtra to ptch 27, so don’t initialize sVectFixSpExtra
;									here anymore (see <3>).
;		 <4>	 1/30/90	PKE		NEEDED FOR 6.0.5: Changed conditionals so ROM and System 7 bug
;									fix also goes in System 6.0.5 - high byte of smgrGenFlags should
;									be set from itlc flags.
;		 <3>	 1/11/90	PKE		Initialize new sVectFixSpExtra vector.
;		 <2>	  1/4/90	PKE		Updated conditionals to put SS-6.0.4 changes in 6.0.5 as well as
;									7.0. Updated header to BBS format.
;		 <1>	12/18/89	CCH		Adding for the first time into BBS. Changed include 'inc.sum.a'
;									to load 'StandardEqu.d'. Updated file name references.
;
;	(BBS versions above, EASE versions below)
;	   <3.1>	 9/17/89	PKE		For 7.0, don't install gestaltScriptMgr function here (see 2.5).
;									It has been moved to ptch 27, so we install it there. Delete
;									initialization of new ScriptRecord font/size fields for Roman
;									ScriptRecord (see 2.1); this is now done in ptch 27. Use
;									romanVersPriv/RomanVersPtch4 to set Roman Script System version
;									number, instead of public romanVers.
;	   <3.0>	 9/15/89	PKE		For 7.0, set version number to smgrVersPtch4 when ptch 4 is
;									installed.
;	   <2.9>	 8/28/89	PKE		For 7.0, don't install patches for InitMenus, DrawMenuBar, and
;									InitFonts. These routines will call the Script Manager code
;									through vectors. So, install new vectors for SMgrCalcRect and
;									SMgrInitFonts.
;	   <2.8>	 8/26/89	PKE		Cleaned up conditionals, changing newItl2Tables to buildLevel
;									>= 1. Changed Initialize to SMgrInitialize for System build too.
;									Install SwapIcon, SwapKybd,FixSMgrWorld vectors for System
;									builds too. Omit PatchTable entirely for Rom builds.
;	   <2.7>	 8/25/89	PKE		NEEDED FOR 6.0.4 SCRIPTS BUILD: Don't install TEInit patch for
;									Scripts604, 7.0.  NOTE: May have to add back load 'nEqu.d' when
;									we roll this over to Fiction for 6.0.4 Scripts build.
;	   <2.6>	 8/24/89	PKE		Removed "load 'nEqu.d'" per SES. Removed gratuitous
;									conditionals. Removed local definition of EntryTable macro,
;									include PatchMacs.a instead.
;	   <2.5>	  8/5/89	PKE		NEEDED FOR 6.0.4: Install Gestalt selectors for Script Manager.
;	   <2.4>	 7/10/89	PKE		USE FOR AURORA IF YOU WANT TO DELETE PADDING: Deleted padding
;									words, overpatching is only for hardware-specific stuff. Don't
;									initialize vectors that don't exist in Esprit version of
;									SMgrRecord. Deleted some superfluous 'forPatch' conditionals.
;	   <2.3>	 6/30/89	PKE		NEEDED FOR AURORA: Initialize new internal vectors for
;									SwapIcon,SwapKybd,FixSMgrWorld.
;	   <2.2>	 6/28/89	PKE		NEEDED FOR AURORA ONLY: Add 320 words of padding for
;									overpatching.
;	   <2.1>	 6/23/89	PKE		Initialize new ScriptRecord font/size information for Roman
;									system; skip definition of buildLevel (done in ScriptEqu.priv).
;	   <2.0>	 5/30/89	PKE		(ROM & System 7.0 only) Initialize the keyboard cache at Script
;									Manager init time and copy in KCHR 0.
;	   <1.9>	 4/26/89	PKE		(ROM & 7.0 only) Allocate dispatch tables in RAM for ScriptUtil
;									& RomanUtil; fill in pointer/limit info in SMgr & Script globals
;	   <1.8>	 3/28/89	PKE		Copy script location info from itlc to SMgrRecord at boot time.
;	   <1.7>	 3/13/89	CCH		Commented out references to xUprString, since it's not patched
;									anymore.
;	   <1.6>	  3/5/89	PKE		Add in xKeyTrans patch for Big Bang; change smgrKeyCache to
;									emKeyCache in code conditionalized on doKeyboard & set up
;									ExpandMem pointer as necessary for this. Replace smgrEMOffset
;									references with ExpandMemRec.emIntlGlobals . Correct Big Bang
;									test for SMgr already initialized. Don't set
;									ScriptRecord.scriptBundle.itlbFlags for Roman; it is set
;									properly from itlb for SysVers >= $604.
;	   <1.5>	  3/2/89	CCH		Removed creation of ExpandMem and put it in StartInit.a.
;	   <1.4>	 2/21/89	PKE		Replaced with RomProj version, which already had system and Rom
;									sources merged.
;___________________________________________________________________________________________________
; EASE ROMproj history:
;	   <1.7>	 2/21/89	PKE		Don't do smgrItlRID initialization; change conditionals to add
;									ROM version improvements to Sys $700 version. Fix up includes:
;									always use include 'inc.sum.a'.
;	   <1.6>	 2/14/89	PKE		Updated to use MPW 3.0 final ScriptEqu.a equate names
;	   <1.5>	  2/3/89	PKE		Merged with current system sources (CCH's 01/16-17/1989 merge of
;									6.0.3 and 7.0 sources, done in RES.sys:smgr)
;	   <1.4>	12/15/88	PKE		Check in changes per comment below for 12/14/88:
;				12/14/88	pke		Always check expandMem and set it up if necessary; write
;									SMgrRecord address directly to intlSpec instead of going thru
;									SMgrEMOffset in expandMem; for Rom, skip code that installs
;									patch vectors; write itlc flags data into high byte of
;									smgrGenFlags in SMgrRecord.
;	   <1.3>	11/14/88	CCH		Put semicolons in comments so program would assemble.
;	   <1.2>	11/14/88	PKE		Synchronize EASE and Projector; Get ready to skip PatchTable
;									stuff if forROM; (with MED) use SMgrInitRegs; put in info for
;									xKeyTrans patch roll-in
;	   <1.1>	11/11/88	CCH		Fixed Header.
;	   <1.0>	 11/9/88	CCH		Adding to EASE.
; old EASE ROMproj history:
;	  <•1.6>	10/27/88	(LDC)	Mods by Carl Hewitt and Brian McGhie in the process of putting
;									Script Manager in ROM
;___________________________________________________________________________________________________
; EASE SYSproj history:
;	   <1.3>	 2/14/89	PKE		Updated to use MPW 3.0 final ScriptEqu.a equates
;	   <1.2>	 1/17/89	CCH		Merged changes from 6.0.3.
;	   <1.1>	 1/16/89	CCH		Merged 6.0.3 final sources into 7.0.
;	   <1.0>	11/16/88	CCH		Added to EASE.
;___________________________________________________________________________________________________
; pre-EASE history (recent changes here went into EASE ROMproj, not SYSproj):
;				10/14/88	ldc		More changes for rom build compatibility
;				10/10/88	ldc		Replaced load with include for 'inc.sum.a', added conditional
;									assembly for ROM, removed code conditional on "forPatch"
;				 10/5/88	ldc		Replaced incorrect use of ScriptRecord.scriptFlags with
;									ScriptRecord.scriptBundle.itlbFlags
;
;----------------------------------	As of 2/02/89, the above changes are only in the forRom file;
;									some of these things should be done for System $700 as well.
;
;				 9/23/88	ldc		Patch UprString.
;				 6/17/88	ldc		added vector initialization for SmgrInternal routines
;				 6/15/88	ldc		Added smgrItlrID initialization
;				  6/7/88	ldc		Began romification
;
;---------------------------------- Changes above are for ROM or buildLevel 2
;
;				  6/6/88	med		Reformat for ptch version
;				  2/5/88	med		Get the version number from the header, so testers can alter it
;				  2/5/88	med		Reordered init code slightly/ for testing, expand expandmem if
;									too small
;				  2/4/88	med		Remove Launch offset, add InitResources and InitApplZone offsets
;				  2/4/88	med		If the Script Manager is already active, don’t install
;				12/17/87	med		Add lwrString
;				12/17/87	med		Allow os traps in patchloop
;				11/24/87	med		Added syserr if can't get pointer in system heap.
;				11/21/87	med		Exported CodeEntry
;				11/10/87	med		Removed OldMac support, Bail if not at least Mac+
;				 8/18/87	med		Initialized CharPortion
;				  7/8/87	med		Add InitWindow patch
;				  3/6/87	med		Check for substitute Chicago fond.
;									Added smScriptFlags initialization.
;				 2/28/87	med		Removed keyboard cache allocation and loading (to KeyNTrans).
;									Removed DSAT loading (to PTCH 0).
;				  2/2/87	med		Changed testing code to load keyboard on old macs
;				 1/29/87	med		Fixed old ROM test.
;									Factored in code for sysheap vs bufptr allocation.
;									Restored debugger break under compile flag
;				 1/29/87	med		Added and used smgrEMOffset (use equates, Joe!).
;									Made expandMem conditional, since Jerome will add it.
;				 1/19/87	jdt		Added low memory expansion block initialization. Replaced
;									resource type constants with literals.
;				 1/13/87	jdt		Removed NewBufPtr call from untweaked initialization.
;				12/22/86	jdt		Added checks on nil handles after GetResource calls. Changed
;									compatabilitiy flag names.
;				12/15/86	jdt		Added debugging code in initialization for Mark.
;				 12/9/86	jdt		Split utility routines from initialization code.
;				 12/5/86	jdt		Moved NewBufPtr into temporary code area for MED. This resource
;									should load into the application heap if aisTweaks is on and the
;									system heap if aisTweaks is off. Changed WimpyKybd and WimpyIcon
;									to SwapKybd and SwapIcon. Various comments added or modified.
;				 12/3/86	jdt		Added alternate initialization code for small system heap.
;									Script Manager and Roman Script globals now in system heap.
;				 12/2/86	jdt		Fixed bug in ResetKCHR with register-based ADB calls. Removed
;									special loading above BufPtr at intialialization time. Removed
;									loading of default KCHR resource (-1).
;				11/21/86	jdt		Removed Roman equates file. Removed KeyTrans entry in patch
;									table.
;				11/21/86	MED		Always check ResErr after calling GetResource. Use KCHR
;									resources in the ROM when possible. WimpyKybd now switches ADB
;									keyboards as well.
;				11/20/86	jdt		Replaced standard equates load.
;				 10/9/86	JDT		Added SMgrTrans entry to trap patch table, modified WimpyKybd to
;									use the script manager globals instead of changing the Key1Trans
;									hook variables. Reorganized the script manager initialization to
;									load the default KCHR last. The default KCHR is now loaded into
;									the keyboard cache.
;				 10/7/86	JDT		Played fast and loose with the deep shit alert tables.
;				 10/1/86	KWK		Modified to always load -1 KCHR and enable the keyboard during
;									the boot sequence.
;				 9/16/86	JDT		Fixed WimpyKybd stuff for switch-launch from our new system to
;									the wretched domestic system.
;				 9/13/86	JDT		Broke script manager initialization file into two peices:
;									SMgrInit for the initialization code and script manager core
;									routines and SMgrPatch for the trap patches and SMgrUtil. Added
;									check for option-d on boot to drop into the debugger.
;				 9/12/86	JDT		Roman script is enabled at initialization time so that its
;									bundle will be read in. Also, the configuration resource is
;									released during initialization time, event though it will be
;									read in again during the first launch.
;				 9/11/86	JDT		Slash and burn keyboard mission. Removed patch to SystemTask and
;									returned all keyboard swapping checks to GetOSEvent. We now
;									flush the event queue of all pending keyboard events when the
;									keyboard is swapped.
;				 9/10/86	JDT		Small fixes to Font2Script and FontScript. KeyHook now keeps its
;									own globals, so they are not initialize here. Now load KSWP
;									resource at launch time, and check for keyboard swapping in new
;									patch to SystemTask. GetOSEvent patch now uses the keyboard
;									swapping mechanism to simulate keyboard swapping with the mouse.
;									Configuration resource now includes the FontForce and IntlForce
;									flags, which are set at boot time.
;				 9/10/86	MED		A0 not set when setting ApFontID, changed to a3. Fixed bug in
;									Font2Script where a1 was used instead of a0.
;				  9/9/86	MED		Fixed IntlScript to not munge d0, and to check for script absent.
;				  9/9/86	JDT		Changed launch code to use Ken's script initialization plan.
;									Toggling modifier is shift instead of command, and toggling
;									rectangle is to the left of the switcher arrows.
;				  9/7/86	MED		Fixed Font2Script to take AppFont/SysFont/FontForce into
;									account.
;				  9/6/86	JDT		New smMunged verb added to environment verb table and supported
;									by GetOSEvent patch, KeyScript routine and SetEnvirons routine.
;									Count verb added and supported by the Launch patch.
;				  9/5/86	JDT		New two-step configuration process. We try to configure at at
;									the beginning of a switch-launch and check the system script at
;									the end of a switch-launch. Added Font2Script trap selector.
;				  9/4/86	JDT		System script initialization added to Launch code. Hooks for
;									FontScript and KeyScript removed from Script Manager core.
;									ScriptUtil trap selectors added for FontScript, IntlScript, and
;									KeyScript.
;				  9/3/86	JDT		Wet'n'wild reorganization. Region bundles eliminated.
;				 8/30/86	JDT		Moved ScriptUtil trap patch into this file. Added first-cut
;									versions of GetEnvirons and SetEnvirons.
;				 8/27/86	JDT		Moved DeadKey variables from KeyTrans to Script Manager globals.
;				 8/25/86	KWK		Modified trap patching to work with old ROMs.
;				 8/24/86	KWK		Minor bug fixes (MOVE.L Joe). Register usage cleanup.
;									smgrCore/risCore allocated above bufptr.
;				 8/21/86	JDT		Modified for Script Manager. Broke into script manager and roman
;									utilities files.
;				 8/21/86	KWK		Save/Restore registers on entry/exit.
;				 8/21/86	JDT		Moved RIS code from here to the SSSInit.
;				 8/20/86	KWK		No longer try to recover old DSAT storage.
;				 8/20/86	JDT		SyncRegion no longer scrolls. GetOSEvent now returns the
;									toggling events to the application.
;				 8/19/86	JDT		Reorganized Launch patch code for default setup of RIS, cleaner
;									handling of old system files during the wretched switch-launch.
;				 8/19/86	KWK		Added DSAT setup/SIS init at launch, modified for new trap
;									interface, moved RIS init code to trap code file.
;				  8/9/86	JDT		Added region icon drawing and toggling user interface.
;				  8/5/86	JDT		Reorganized the initialization procedure and package.
;				 7/29/86	JDT		Split the initialization into two phases. We now create the sis
;									core and ris entry at boot time and fill in the region bundle
;									table at launch time.
;				 7/20/86	JDT		Changed current region to ignore the sisKeyScript.
;				 7/17/86	JDT		Added the wonderful word-finding algorithm. Mark is responsible
;									for this thing. Not me, no way.
;				 7/14/86	JDT		Added current and toggle routines for regions.
;				 7/13/86	JDT		First draft.
;___________________________________________________________________________________________________
;	To Do:
;			Figure out how & when to initialize Gestalt for ROM (smgrROMVers >= 2)	pke 4/05/90
;
;___________________________________________________________________________________________________


		load	'StandardEqu.d'
		include	'ScriptPriv.a'

	IF NOT forRom THEN
		include	'PatchMacros.a'					; <2.6>
	ENDIF
		include	'HardwarePrivateEqu.a'			; <19>

tenPercent	equ	$0199							; 4.12 fixed point 10%

; -----------------------------------------------------------------------------
	IF NOT forRom THEN
CutBackPt	Proc		Export
		EntryTable	0							; <=== Last table entry
		EndProc
	ENDIF		
; -----------------------------------------------------------------------------
; routine:		SmgrInitialize
; warning:		This routine preserves all registers.
;
; This routine creates the script manager globals and the Roman script entry
; and initializes then.  It moves all of the Script Manager and Roman script
; code above BufPtr and patches several traps.
; -----------------------------------------------------------------------------

; Link the stack and save the registers.
;
; register usage:
;		a4.l 	Script manager globals pointer.
;		a3.l	Relocated code pointer.
;		a2.l	Patch tables and script entry pointers.
;		d7.b	Flag for old roms.
; -----------------------------------------------------------------------------

SmgrInitialize	proc	export

		import	PatchStart							; start of real routines
		import	SmgrTable,RomanTable,versionAddress

													; <6>
		import	utilTable,utilTableBase				; SMgr dispatch table	<04/26/89 pke>
		import	romanDispTable						; Roman dispatch table	<04/26/89 pke>

; -----------------------------------------------------------------------------
SmgrInitRegs:	reg	d0-d7/a0-a4				; <11/04/88 med>

		with	smgrRecord					;
		link	a6,#0						; link the stack.
		movem.l	SmgrInitRegs,-(sp)			; save all registers.
		
		move.l	ExpandMem,a4				; (need ExpandMem in a4 later)	<12/14/88 pke>
											; moved this up for doKeyboard code below <03/05/89 pke>
; -----------------------------------------------------------------------------
; if we are testing, test for opt-d, and drop into the debugger

	IF testScriptManager THEN				; for testing <1.28.87med>
		btst	#2,KeyMap+7					; option key?
		beq.s	@skipDebugger				; no, skip check.
		btst	#2,KeyMap					; 'd' for debugger?
		beq.s	@skipDebugger				; no, skip it.

; The user wants the debugger. If we are on 128k ROMs or less, we need to load
; the keyboard first. There used to be some code that supposedly did this, but
; it had gotten obsolete and was deleted. We should add something…				<9>

		_Debugger							; debugger break.
	
@skipDebugger
	ENDIF	; testScriptManager

; -----------------------------------------------------------------------------

; We used to set up ExpandMem here if it was not already active; now this is done
; in RomAllFix for the system and before initializing system resources (and calling
; SMgrInitialize) in the ROM. <03/02/89 cch>

	IF NOT forRom THEN							; do system initialization	<10/27/88 bbm>

		cmpi.l	#-1,intlSpec					; already initialized?		<12/14/88 pke><03/05/89 pke>
		bne		SMgrInitDone					; bail if so				<2/4/88med>

; Code that used to be here: If testScriptManager is true, make sure
; ExpandMem is big enough. No longer necessary.								<9>

	ENDIF	; NOT forRom


;<10/10/88ldc>	here we allocate script manager global space in RAM off of intlSpec
;Note: a4=ExpandMem pointer

		with	SmgrRecord
		move.l	#smgrSize,d0				; load size of block.
		bsr		NewBufPtr					; allocate and clear globals.

		move.w	#smgrVersPriv,smgrVersion(a0)	; stuff version number for ptch4

		move.l	a0,ExpandMemRec.emIntlGlobals(a4) ; store into globals block.	<1.28.87med><03/05/89 pke>
		move.l	a0,intlSpec					; store into low memory.
		move.l	a0,a4						; copy pointer for SMgr.
		endWith
 
;Note: now a4=SMgrRecord pointer

; -----------------------------------------------------------------------------
; Allocate and install the dispatch table (assumes >= 1 entry). New <04/26/89 pke>

smLowCall32 equ	smLowCall++$FFFF0000			; make longint; assumes smLowCall<0
		with	SmgrRecord						;
		move.l	#2*(smHighCall-smLowCall32+2),d0 ; size of dispatch table
		bsr		NewBufPtr						; allocate and clear table
		lea		-2*smLowCall32(a0),a1			; point to entry for selector=0
		move.l	a1,smgrDispTable(a4)			; save pointer in globals
		move.w	#smLowCall,smgrDispLow(a4)		; save low limit in globals
		move.w	#smHighCall,smgrDispHigh(a4)	; save high limit in globals
		lea		utilTableBase,a1				; start of offsets table
		lea		utilTable,a3					; get base addr for offsets
		move.w	#(smHighCall-smLowCall32)/2,d0	; number of entries - 1
@dispTabLoop
		move.w	(a1)+,d1						; get offset from utilTable
		lea		0(a3,d1.w),a2					; make it a real vector
		move.l	a2,(a0)+						; stuff it in table
		dbra	d0,@dispTabLoop					; if more, keep going
		endwith									;

; -----------------------------------------------------------------------------
; Install the routine vectors in the script manager core.

; Load pointer to start of the patch code <10/10/88ldc>
 		lea		PatchStart, a3			; return patch start as start of code, not copy
	
		LEA		SmgrTable, A2			; load table pointer.
SMgrLoop
		MOVE.L	(A2)+,D0				; get offsets.
		BEQ.S	SMgrDone				; last entry is zero.
		LEA		0(A3,D0.W),A0			; get routine address.
		SWAP	D0						; get second offset.
		MOVE.L	A0,0(A4,D0.W)			; stuff vector in globals.
		BRA.S	SMgrLoop				; do the next entry.
SMgrDone

; -----------------------------------------------------------------------------
; Install the ScriptUtil and LwrString trap so that these will be supported.
; Install Script Manager patches to other traps.
;
; In System 7, we check for A/UX before installing some patches.				<19>
; 

	IF	NOT forRom THEN					; Skip for ROM - trap addrs are			<12/14/88 pke>
										;    in disptable
		import  PatchTable, PatchTableNoAUX

		LEA		PatchTable,A2			; load address of patch table.

										;										<19>
		bsr.s	PatchLoop				; install patches we always want
		move.w	HwCfgFlags,d0			; check ‘em the compulsive way
		btst.l	#hwCbAUX,d0				; is it A/UX time?
		bne.s	PatchDone				; if so skip the mac-only patches
		lea		PatchTableNoAUX,A2		; load address of patch table.
		bsr.s	PatchLoop				; install patches we only want if not A/UX
	  	bra.s	PatchDone

PatchLoop
		move.w	(A2)+,D0				; load offset (and trap code).
		BEQ.S	@return					; last entry is zero.					<19>

		MOVE.W	D0, D1					; d1 not touched by trap.
		bclr	#15,d0					; tool trap?
		beq.s	@GetToolTrap			; yes => use new call.
		_GetTrapAddress NewOS			; get the address.
		bra.s	@DoneGetTrap			; skip new call.
@GetToolTrap
		_GetTrapAddress NewTool			; new tool trap call.
@DoneGetTrap

		move.w	(a2)+,d0				; offset in Smgr core					<6/7/88ldc>
		move.l	a0,0(a4,d0.w)			; store old trap address in smgr core	<4/27/88ldc>
		move.w	(a2)+,d0				; offset from PatchStart to new routine	<4/27/88ldc>
		lea		0(a3,d0.w),a0			; get address

		MOVE.W	D1,D0					; copy trap number.

; allow os traps <12/17/87med>

		bclr	#15,d0					; tool trap?
		beq.s	@SetToolTrap			; yes => use new call.
		_SetTrapAddress	NewOS			; set trap address.
		bra.s	@DoneSetTrap			; skip new call.
@SetToolTrap
		_SetTrapAddress NewTool			; new tool trap call.
@DoneSetTrap

		BRA.S	PatchLoop				; do the next trap patch.

@return									;										<19>
		rts								;										<19>

PatchDone

	ENDIF

; -----------------------------------------------------------------------------
; Load the configuration resource and set the flags based on the values
; in it.  Allocate the KCHR cache; this space is used to keep a copy of the
; current KCHR. Originally, this was allocated above BufPtr and was used
; because of limited space in the system heap.

BootConf
		with	itlcRecord				;
		sub.w	#4,sp					; make room for handle.
		move.l	#'itlc',-(sp)			; push conf type.
		move.w	#0,-(sp)				; push conf number.
		_GetResource					; load the resource.
		move.l	(sp),d0					; handle = nil?

		beq		BadError				; 										<05/30/89 pke><9>

		move.l	d0,a0						; load conf handle.
		move.l	(a0),a0						; load conf pointer.
		move.b	itlcFontForce(a0),d0		; load fontForce flag.
		move.b	d0,smgrFontForce(a4)		; store fontForce flag.
		move.b	itlcIntlForce(a0),d0		; load intlForce flag.
		move.b	d0,smgrIntlForce(a4)		; store intlForce flag.

		move.b	itlcFlags(a0),d0			; load itlc Flags byte					<12/14/88 pke>
		move.b	d0,smgrGenFlags(a4)			; put in 1st byte of smgrGenFlags long	<12/14/88 pke>

		move.l	itlcIconOffset(a0),d0		; load itlc icon loc info: offset,side	<03/28/89 pke>
		move.l	d0,smgrIconOffset(a4)		; save offset,side (1 word & 2 bytes)	<03/28/89 pke>

		move.w	itlcSystem(a0),d0				; load system code.
		move.w	d0,smgrSysScript(a4)			; set system script.
		move.w	#tenPercent,smgrCharPortion(a4)	; set default char portion

		_ReleaseResource						; release the conf resource.
		endWith	; itlcRecord					;

; assume expandMem is big enough, assume ROMs are later than 64K					<05/30/89 pke><9>
		with	ExpandMemRec
		move.l	expandMem,a2				;
		move.l	emKeyCache(a2),d0			; do we already have a key cache?
		bne.s	@doneKeyCacheAlloc			; if so, skip this
	
		clr.l	-(sp)						; make room for handle.
		move.l	#'KCHR',-(sp)				; push KCHR type.
		move.w	#0,-(sp)					; try for zero.
		move.w	#MapTrue,RomMapInsert		; look for KCHR in ROM
		_GetResource						; get the KCHR resource.
		move.l	(sp)+,a0					; load handle.
		move.l	a0,d4						; save handle & test if nil
		beq		BadError					; nil, error bail
	
		_GetHandleSize						; find resource size.
		cmp.l	#keyCacheMin,d0				; pick larger of itlc value or KCHR size
		bge.s	@2
		move.l	#keyCacheMin,d0
@2		addi.l	#keyCacheSlop,d0			; now add slop value
		move.l	d0,d3						; save size
	
		_NewPtr	sys,clear					; new pointer of proper size.
		bne		BadError
		move.l	a0,emKeyCache(a2)			; store in emKeyCache (expandMem).
; copy KCHR data into cache
		move.l	a0,a1						; set up destination.
		move.l	d4,a0						; load resource handle.
		move.l	(a0),a0						; load resource pointer.
		move.l	d3,d0						; load size.
		_BlockMove							; copy keyboard table.

@doneKeyCacheAlloc
		endWith	; ExpandMemRec
		
; -----------------------------------------------------------------------------
; Create the Roman Interface System entry and initialize it.  For now,
; set the system and application fonts to the standard Macintosh font
; numbers.
		with	scriptRecord					;
		move.l	#RomanCoreSize,d0				; size of Roman entry.
		bsr		NewBufPtr						; allocate Roman entry.
		move.l	a0,a2							; save entry pointer.
		move.l	a2,smgrEntry+(smRoman*4)(a4)	; store in SMgr globals.
	
		move.w	#romanVersPriv,scriptVersion(a2) ; set the version number. <3.1>
	
		move.l	#'ZSYS',scriptCreator(a2)		; install the creator.
		lea		SysResName,a0					; install the RIS file name
		move.l	a0,ScriptFile(a2)				; pointer.

		move.w	#RomanAppFond,scriptAppFond(a2)	; set the app font.

; Allocate and install the dispatch table (assumes >= 1 entry). New		<04/26/89 pke>
; Note a2 = ptr to ScriptRecord; no longer need a4; a3=code ptr (save)

		move.l	#2*(sisHighCall-smGetScript+2),d0 ; size of dispatch table
		bsr		NewBufPtr						; allocate and clear table
		move.l	a0,scriptDispTable(a2)			; save pointer in globals
		move.w	#smGetScript,scriptDispLow(a2)	; save low limit in globals
		move.w	#sisHighCall,scriptDispHigh(a2)	; save high limit in globals
		lea		romanDispTable,a1				; start of offsets table
		move.l	a1,a4							; copy it
		move.w	#(sisHighCall-smGetScript)/2,d0	; number of entries - 1
		move.l	a2,-(sp)						; save a2
@romanTabLoop
		movea.l	#0,a2							; assume 0 entry in dispatch table		<33>
		move.w	(a1)+,d1						; get offset from romanDispTable
		beq.s	@gotAddress						; if 0, leave entry as 0				<33>
		lea		0(a4,d1.w),a2					; make it a real vector
@gotAddress										;										<33>
		move.l	a2,(a0)+						; stuff it in table
		dbra	d0,@romanTabLoop				; if more, keep going
		move.l	(sp)+,a2						; restore a2

; see if the main System fond (3FFF for Chicago) is around <3/6/87med>

		move.w	#RomanSysFond,d4				; assume fond exists
		subq	#4,sp							; return room
		move.l	#'FOND',-(sp)					; see if we have real Chicago
		move.w	d4,-(sp)						; id
		MOVE.W	#MapTrue,RomMapInsert			; look in ROM first								<SM6> rb
		_GetResource
		tst.l	(sp)+							; was it there?
		bne.s	@SkipResetFond					; yes, skip
		clr.w	d4								; reset to 0
@SkipResetFond

		move.w	d4,scriptSysFond(a2)			; set the system font.

; end of check for substitute Chicago fond <3/6/87med>

		endWith									;


; -----------------------------------------------------------------------------
; Install the routine vectors in the Roman entry.  This includes the print
; action, keyboard hook, and text utility routines and the RIS name.
; A3 = code ptr, A2 = RIS core ptr, A1 = table ptr

		LEA		RomanTable,A1			; load table pointer.
RomanLoop	
		MOVE.L	(A1)+,D0				; get offset (and trap code).
		BEQ.S	RomanDone				; last entry is zero.
		LEA		0(A3,D0.W),A0			; find relocated routine.
		SWAP	D0						; get entry offset.
		MOVE.L	A0,0(A2,D0.W)			; stuff routine address in entry.,
		BRA.S	RomanLoop				; do the next routine.
	
BadError								;								<05/30/89 pke><9>
		move.w	#dsSysErr,d0			; load generic error.
		_SysError						; system error!
	

RomanDone
	
; -----------------------------------------------------------------------------
; Perform auto-initialization of script	systems based on info in their itlb	 <SM8> CSS

; Skip if Opt-E or Shift														
		btst	#0,KeyMap+7		; shift key down?								
		bne		DoneAutoInit	; if yes, skip script install					
		btst	#2,KeyMap+7		; option key down?								
		beq.s	@noSkipInstall	; no, skip check.					
		subq	#2,sp			; make room for Boolean result						
		move.w	#'e',-(sp)		; push 'e' as the char to test for					

		import	iTestLetter		;													
		bsr		iTestLetter		; returns TRUE if key with Roman 'e' being pressed	

		tst.b	(sp)+			; what was the result?								
		bne		DoneAutoInit	; if Opt-e, skip script install						
@noSkipInstall					;				

; no Opt-E, go ahead
		with	scriptRecord,itlbRecord,ItlbExtRecord
		GetSMgrCore	a4							; reset a4 to point to SMgrRecord
		move.w	#smgrCount-1,d3					; for all entries.
			
@SimpleLoopStart
		move.w	d3,d0							; copy index.
		lsl.w	#2,d0							; long word offset.
		move.l	smgrEntry(a4,d0.w),d0			; script installed?
		bne		@NextSimple						; yes -> try next entry.
		
		subq.l	#4,sp							; make room for handle.
		move.l	#'itlb',-(sp)					; push bundle type.
		move.w	d3,-(sp)						; push bundle number.
		_GetResource							; load the resource.
		move.l	(sp)+,d0						; handle = nil?
		beq		@NextSimple						; yes -> try next entry.

; we have a prospective itlb, so check if the simple bit is on
		move.l	d0,a3							; load bundle handle.
		move.l	(a3),a0							; load bundle pointer.
		btst.b	#smsfAutoInit,itlbFlags+1(a0)	; auto-init it? (+1 for mem test)
		beq		@ReleaseSimple					; no, try next one

; we have a simple script, so allocate the record, load the font numbers

		move.l	itlbLocalSize(a0),d0			; requested size for script locals
		cmp.l	#scriptSize,d0					; must be ≥ ScriptRecord size
		bcc.s	@doneFixLocalRecordSize			; if it already is, skip fix
		move.l	#scriptSize,d0					; if too small, fix it
@doneFixLocalRecordSize
		_NewPtr	sys,clear						; allocate script local data
		bne		BadError						; if error, bail
		move.l	a0,a2							; save entry pointer.
		move.w	d3,d0							; get script number
		asl.w	#2,d0							; *4 for long array
		move.l	a2,smgrEntry(a4,d0.w)			; store in SMgr globals.
	
; Use SimpleTable to initialize scriptVersion, scriptCreator, scriptFile instead		
; of explicitly initializing them here.

; Copy font information from itlb, and check it.
; For 7.0, this is moved to InitScripts.												

; copy relevant entries from Roman ScriptRecord to simple ScriptRecord
; a2=simple ScriptRecord

		move.l	smgrEntry+(smRoman*4)(a4),a0	; address of roman globals
		lea		SimpleTable,a1					; load table pointer.
@SimpleEntryLoop	
		move.w	(a1)+,d0						; get offset (and trap code).
		blt.s	@ReleaseSimple					; last entry is -1.						
		move.w	0(a0,d0.w),0(a2,d0.w)			; copy Roman word to simple scriptRecord
		bra.s	@SimpleEntryLoop				; do the next routine.

@ReleaseSimple
; Don't bother releasing anymore														
		
@NextSimple		
		subq	#1,d3							; don't do Roman
		bgt.s	@SimpleLoopStart				; keep going until 0 or less
		bra		DoneAutoInit					; clean exit							
		endWith									;

; -----------------------------------------------------------------------------
; Table of ScriptRecord fields to copy from Roman when auto-initializing
; a script.
;
; Moved initialization of scriptVersion, scriptCreator, scriptFile here instead
; of explicitly initializing them above.
;
; Changed terminator to be -1, cause one of the fields we want to initialize
; with this table has an offset of 0.
; -----------------------------------------------------------------------------

SimpleTable
			with	ScriptRecord
			dc.w	scriptVersion				;								
			dc.w	scriptCreator				;			
			dc.w	scriptCreator+2				; (long)						
			dc.w	scriptFile					;								
			dc.w	scriptFile+2				; (long)						
			dc.w	scriptDispTable
			dc.w	scriptDispTable+2			; (long)
			dc.w	scriptDispLow
			dc.w	scriptDispHigh
			dc.w	scriptPrint
			dc.w	scriptPrint+2				; (long)
			dc.w	scriptTrap
			dc.w	scriptTrap+2				; (long)
			dc.w	scriptName
			dc.w	scriptName+2				; (long)
			dc.w	$ffff						; now -1 is terminato
			endwith

DoneAutoInit

; -----------------------------------------------------------------------------
; Update from ScriptMgrExtTail.a <SM10> CSS
;
; Initialize emScriptAppGlobals field.
;
			move.l	ExpandMem,a0
			move.l	#-1,ExpandMemRec.emScriptAppGlobals(a0)

SMgrInitDone
;Roll in from ScripMgrExtTail.a
	IF forROM then
		bsr		InitDictionaryMgr		;   Init the dictionarymgr <PN>
	ENDIF
; Restore the registers, unlink the stack, and return to the caller.
SmgrExit
		movem.l	(sp)+,SmgrInitRegs		; restore all registers.
		unlk	a6						; unlink the stack.

	IF NOT forRom THEN
		Lea	CutBackPt,A0				; <=== Keep these two lines…
	ENDIF

		Rts								; <=== in any case

	endWith

;=======================================================================
;
;	InitDictionaryMgr
;		Called to load the 'dimg' file which contains the 
;		Dictionary Manager code.  We load the resources stick
;		them into expand mem, and call it a day.
;		JH, 10-9-91
;========================================================================

InitDictionaryMgr
			with	ExpandMemRec
			clr.l	-(sp)								;room for our handle
			move.l	#'dimg',-(sp)						;looking for a 'dimg' resource
			move.w	#-16385,-(sp)						;with an id of -16385
			move.w	#MapTrue,RomMapInsert				;check if resource is in ROM (it should be) <SM7> CSS
			_GetResource								;see if we can get it
			move.l	ExpandMem,a0						;ptr to expandmem rec into a0
			move.l	(sp)+,emDictionaryMgrPackHandle(a0)	;move the handle into our expandmem handle
	;		move.w	#0,emDictionaryMgrUseCount(a0)		;0 our count
			rts
			endwith	;ExpandMemRec
; -----------------------------------------------------------------------------
; Utility routine to allocate and clear global space
; (was above BufPtr in old systems)  <10/10/88ldc>

NewBufPtr
		_NewPtr	sys,clear				; <29Jan87med>
		beq.s	@1						; no -> skip this.				<11/24/87med>
		move.w	#dsSysErr,d0			; load generic error.			<11/24/87med>
		_SysError						; system error!					<11/24/87med>
@1	
		rts								; return to the caller.

; -----------------------------------------------------------------------------
; This table contains <smgrRecord offset><routine offset> entries used for
; initializing the smgrRecord routine vectors.

SmgrTable	proc
		with	smgrRecord
		import	PatchStart				; start of patch code

; template:
;		import	Xxx
;		dc.w	sVectXxx,Xxx-PatchStart

; PrintAction is in ScriptMgrExtensions.a which isn't linked for 'ptch' 4 but
; does exist for the ROM

	IF forRom THEN						;									<25>
		import	PrintAction				; printer action routine.
		dc.w	smgrPrint,PrintAction-PatchStart
	ENDIF								;									<25>
	
;--------------ScriptMgrUtilNum.a internal routines-------------------
; This table contains hooks for internal SMgr routines that have been
; vectorized for future modification.
; NOTE: These are filled in by both RAM and ROM versions of the Script
; Mgr, although they are only used by the ROM version. <06/30/89 pke>

; from ScriptMgrUtilNum.a <6/17/88ldc>
		import	AppendSymbol
		dc.w	sVectAppendSymbol,AppendSymbol-PatchStart
		import	ConvertToString
		dc.w	sVectConvertToString,ConvertToString-PatchStart
		import	ExpHandling
		dc.w	sVectExpHandling,ExpHandling-PatchStart
		import	ExpMatching
		dc.w	sVectExpMatching,ExpMatching-PatchStart
		import	CheckForDigits
		dc.w	sVectCheckForDigits,CheckForDigits-PatchStart
		import	MatchingSubstring
		dc.w	sVectMatchingSubstring,MatchingSubstring-PatchStart
		import	Cond
		dc.w	sVectCond,Cond-PatchStart
		import	CheckForm
		dc.w	sVectCheckForm,CheckForm-PatchStart
		import	TackOnExp
		dc.w	sVectTackOnExp,TackOnExp-PatchStart
		import	MakeExp
		dc.w	sVectMakeExp,MakeExp-PatchStart
		import	CheckPartsIntegrity
		dc.w	sVectCheckPartsIntegrity,CheckPartsIntegrity-PatchStart
		import	RetrieveChar
		dc.w	sVectRetrieveChar,RetrieveChar-PatchStart
		import	IsSubstring
		dc.w	sVectIsSubstring,IsSubstring-PatchStart
; add five more internal vectors from elsewhere 							<2.3>
		import	xSwapIcon
		dc.w	sVectSwapIcon,xSwapIcon-PatchStart
		import	xSwapKybd
		dc.w	sVectSwapKybd,xSwapKybd-PatchStart
		import	SMgrCalcRect
		dc.w	sVectSMgrCalcRect,SMgrCalcRect-PatchStart
		import	SMgrInitFonts
		dc.w	sVectSMgrInitFonts,SMgrInitFonts-PatchStart
		import	SMgrPostMunging
		dc.w	sVectSMgrPostMunging,SMgrPostMunging-PatchStart

; terminator - both fields zero.
		dc.w	0,0
		endWith
		endProc

; -----------------------------------------------------------------------------
; This table contains <scriptEntry offset><routine offset> entries used for
; initializing the RIS routine vectors.

RomanTable	proc
		import	PatchStart				; start of patch code
		import	RomanPrint				; Roman print action routine.
		import	RomanScript				; Roman ScriptUtil routine.
		import	RomanName				; Roman script name.

		with	scriptRecord
		dc.w	scriptPrint,RomanPrint-PatchStart
		dc.w	scriptTrap,RomanScript-PatchStart
		dc.w	scriptName,RomanName-PatchStart
		dc.w	0,0
		endWith
		EndProc

			proc
			export	utilTable, utilTableBase
			import	BitBucket,BitBucketReg

		IF forRom THEN													;	<11><21>
			import	FontScript, IntlScript, Font2Script					;	<x4>
			import	KeyScript											;	<x4>
			import	GetEnvirons, SetEnvirons, GetScript, SetScript		;	<x4>
			import	NFindScriptRun, ScriptToRange, xTestLetter
			import	SCLwrString, Font2RealScript, RealScript
			import	xNFindWord, TruncString, TruncText
			import	ReplaceText, InitScripts, AddScriptFonts
			import	IsCmdChar, InitScriptApp, CleanupScriptApp	
			import	ReInitScripts, FindCharInSet, InitKeybdMenu
			import	SetKbdMenuInfo, RebuildKeybdMenu
		ENDIF
			import	StyledLineBreak, FormatOrder, IntlTokenize
			import	InitDateCache, String2Date, String2Time
			import	LongSecs2Date, LongDate2Secs, ToggleDate, ValidDate
			import	xStr2Form, xForm2Str, xFormX2Str, xFormStr2X

; ----------------------------------------------------------------------------
; Moved from ScriptMgrUtil.a
; ----------------------------------------------------------------------------
; The selector table is indexed by a ScriptUtil selector and each cell
; is the offset of the proper routine from the beginning of the table.
; change also in ScriptEqu.a, and import above.
;
; For 7.0, we do something which seems strange. The extensions are in ptch 27,
; which must work with both ptch 4 (this code) and the new ROMs. So, the
; addresses of the new routines are installed into the RAM-based dispatch
; table as part of ptch 27's initialization. However, we still want to leave
; space in the RAM dispatch table created by ptch 4 for the vectors that will
; be installed by ptch 27 (so we don't have to reallocate and copy this table
; except for the new ROMs). Until ptch 27 actually installs the real routine
; addresses, these vectors will point to the BitBucket routine for handling
; unimplemented routines. Since ptch 4 actually creates the RAM dispatch table
; using the table below, we do all of this here.
;
; For 7.0, we move Get/SetEnvirons and Get/SetScript to ptch 27 and install
; them there, so just put in dummy vectors here.
;
; For the ROM build we include every vector since the dispatch table
; is set up only once, right here.
;
; *** We need a better way to handle the conditionals here. The table here needs
; *** to be sized depending on the min and max codes for a given set of
; *** conditionals, and the installation code in ScriptMgrExtTail.a needs to
; *** adapt similarly.

utilTableBase

		  IF NOT forRom THEN					;
			dc.w	BitBucket		- utilTable	; (-80)	for NFindScriptRun				<29>
			dc.w	BitBucket		- utilTable	; (-78)	for ScriptToRange				<28>
			dc.w	BitBucket		- utilTable	; (-76)	for TestLetter					<24>
			dc.w	BitBucket		- utilTable	; (-74)	for SCLwrString					<21>
			dc.w	BitBucket		- utilTable	; (-72)	for Font2RealScript				<21>
			dc.w	BitBucket		- utilTable	; (-70)	for RealScript					<21>
			dc.w	BitBucket		- utilTable	; (-68)	for HaveFontTranslationTable	<21>
			dc.w	BitBucket		- utilTable	; (-66)	for SetCachedTablesPurge		<21>
			dc.w	BitBucket		- utilTable	; (-64)	for SetCachedTablesNoPurge		<21>
			dc.w	BitBucket		- utilTable	; (-62)	for TranslateNoBreakFromUnicode	<21>
			dc.w	BitBucket		- utilTable	; (-60)	for TranslateToUnicode			<21>
			dc.w	BitBucket		- utilTable	; (-58)	for TranslateFromUnicode		<21>
			dc.w	BitBucket		- utilTable	; (-56)	for FindCharInSet		<20>
			dc.w	BitBucket		- utilTable	; (-54)	for ReInitScripts		<18>
			dc.w	BitBucket		- utilTable	; (-52)	for CleanupScriptApp	<17>
			dc.w	BitBucket		- utilTable	; (-50)	for InitScriptApp		<17>
			dc.w	BitBucket		- utilTable	; (-48)	for IsCmdChar			<14>
			dc.w	BitBucket		- utilTable	; (-46)	for RebuildKeybdMenu	<13>
			dc.w	BitBucket		- utilTable	; (-44)	for SetKbdMenuInfo		<12>
			dc.w	BitBucket		- utilTable	; (-42)	for AddScriptFonts
			dc.w	BitBucket		- utilTable	; (-40)	for InitKeybdMenu
			dc.w	BitBucket		- utilTable	; (-38)	for InitScripts
			dc.w	BitBucket		- utilTable	; (-36)	for ReplaceText
			dc.w	BitBucket		- utilTable	; (-34)	for TruncText
			dc.w	BitBucket		- utilTable	; (-32)	for TruncString
			dc.w	BitBucket		- utilTable	; (-30)	for NFindWord
		  ELSE									;
			dc.w	NFindScriptRun	- utilTable	; (-80)	for NFindScriptRun				<29>
			dc.w	ScriptToRange	- utilTable	; (-78)	for ScriptToRange				<28>
			dc.w	xTestLetter		- utilTable	; (-76)	for TestLetter					<24>
			dc.w	SCLwrString		- utilTable	; (-74)	for SCLwrString					<21>
			dc.w	Font2RealScript	- utilTable	; (-72)	for Font2RealScript				<21>
			dc.w	RealScript		- utilTable	; (-70)	for RealScript					<21>
			dc.w	BitBucket		- utilTable	; (-68)	for HaveFontTranslationTable	<21>
			dc.w	BitBucket		- utilTable	; (-66)	for SetCachedTablesPurge		<21>
			dc.w	BitBucket		- utilTable	; (-64)	for SetCachedTablesNoPurge		<21>
			dc.w	BitBucket		- utilTable	; (-62)	for TranslateNoBreakFromUnicode	<21>
			dc.w	BitBucket		- utilTable	; (-60)	for TranslateToUnicode			<21>
			dc.w	BitBucket		- utilTable	; (-58)	for TranslateFromUnicode		<21>
			dc.w	FindCharInSet	- utilTable	; (-56)	for FindCharInSet		<20>
			dc.w	ReInitScripts	- utilTable	; (-54)	for ReInitScripts		<18>
			dc.w	CleanupScriptApp- utilTable	; (-52)	for CleanupScriptApp	<17>
			dc.w	InitScriptApp	- utilTable	; (-50)	for InitScriptApp		<17>
			dc.w	IsCmdChar		- utilTable	; (-48)	for IsCmdChar			<14>
			dc.w	RebuildKeybdMenu- utilTable	; (-46)	for RebuildKeybdMenu	<13>
			dc.w	SetKbdMenuInfo	- utilTable	; (-44)	for SetKbdMenuInfo		<12>
			dc.w	AddScriptFonts	- utilTable	; (-42)	for AddScriptFonts
			dc.w	InitKeybdMenu	- utilTable	; (-40)	for InitKeybdMenu
			dc.w	InitScripts		- utilTable	; (-38)	for InitScripts
			dc.w	ReplaceText		- utilTable	; (-36)	for ReplaceText
			dc.w	TruncText		- utilTable	; (-34)	for TruncText
			dc.w	TruncString		- utilTable	; (-32)	for TruncString
			dc.w	xNFindWord		- utilTable	; (-30)	for NFindWord
		  ENDIF
			dc.w	ValidDate		- utilTable	; (-28)
			dc.w	xFormStr2X		- utilTable	; (-26)
			dc.w	xFormX2Str		- utilTable	; (-24)
			dc.w	xForm2Str		- utilTable	; (-22)
			dc.w	xStr2Form		- utilTable	; (-20)
			dc.w	ToggleDate		- utilTable	; (-18)
			dc.w	LongSecs2Date	- utilTable	; (-16)
			dc.w	LongDate2Secs	- utilTable	; (-14)
			dc.w	String2Time		- utilTable	; (-12)
			dc.w	String2Date		- utilTable	; (-10)
			dc.w	InitDateCache	- utilTable	; (-8)
			dc.w	IntlTokenize	- utilTable	; (-6)
			dc.w	FormatOrder		- utilTable	; (-4)
			
		IF forRom	THEN						;		<32>
			dc.w	StyledLineBreak	- utilTable	; (-2)	<32>
		ELSE									;		<32>
			dc.w	BitBucket		- utilTable	; (-2)	<32>
		ENDIF									;		<32>
		
utilTable
		IF forRom THEN							;								<21>
			; old versions for now												<21>
			dc.w	FontScript		- utilTable	; (00) FontScript
			dc.w	IntlScript		- utilTable	; (02) IntlScript
			dc.w	KeyScript		- utilTable	; (04) KeyScript
			dc.w	Font2Script		- utilTable	; (06) Font2Script
			dc.w	GetEnvirons		- utilTable	; (08) GetEnvirons
			dc.w	SetEnvirons		- utilTable	; (10) SetEnvirons
			dc.w	GetScript		- utilTable	; (12) GetScript
			dc.w	SetScript		- utilTable	; (14) SetScript
		ELSE									;								<21>
			; new 7.0 versions in (other) patches, fill in dummies here			<21>
			dc.w	BitBucket		- utilTable	; (00) FontScript
			dc.w	BitBucket		- utilTable	; (02) IntlScript
			dc.w	BitBucket		- utilTable	; (04) for KeyScript
			dc.w	BitBucket		- utilTable	; (06) Font2Script
			dc.w	BitBucket		- utilTable	; (08)	for GetEnvirons	<x2.6>
			dc.w	BitBucket		- utilTable	; (10)	for SetEnvirons	<x2.6>
			dc.w	BitBucket		- utilTable	; (12)	for GetScript	<x2.6>
			dc.w	BitBucket		- utilTable	; (14)	for SetScript	<x2.6>
		ENDIF									;								<21>
		
			endproc

; Move here, add proc and imports											;	<16>
; Markers of form <xNN> are from RomanUtil.a.

		proc
		export	romanDispTable
		import	BitBucket, BitBucketReg
		
		import	RomanGetScript, RomanSetScript, CharByte						; <SM8> CSS
		import	Translit, FindWord, HiliteText
		import	VisibleLength
	  IF forRom THEN								;							<21>
		import	CharType							;							<26>
		import	Pixel2Char, Char2Pixel
		import	DrawJust, MeasureJust
		import	PortionText
		import	ParseTable
		import	FindScriptRun
		import	NPixel2Char, NChar2Pixel
		import	NDrawJust, NMeasureJust
		import	NPortionText
	  ENDIF

; The Roman table is used to map routine selectors to routine offsets.
; For 7.0, PortionText and Pixel2Char are moved to ptch 27, so we just
; put in dummy vectors here. We also need dummy vectors for Kanji
; private routines and new 7.0 routines.	<x2>
; 
; For the ROM build we include every vector since the dispatch table
; is set up only once, right here.

romanDispTable										;							<04/26/89 pke>
	 IF (NOT forRom) THEN							;							<x2><x4><x10><21>
		dc.w	RomanGetScript	- romanDispTable	; GetScript		(12)		<x10> <SM8> CSS
		dc.w	RomanSetScript	- romanDispTable	; SetScript		(14)		<x10> <SM8> CSS
		dc.w	CharByte		- romanDispTable	; CharByte		(16)
		dc.w	BitBucket		- romanDispTable	; CharType		(18)		<26>
		dc.w	BitBucket		- romanDispTable	; Pixel2Char	(20)
		dc.w	BitBucket		- romanDispTable	; Char2Pixel	(22)
		dc.w	Translit		- romanDispTable	; Transliterate	(24)
		dc.w	FindWord		- romanDispTable	; FindWord		(26)
		dc.w	HiliteText		- romanDispTable	; HiliteText	(28)
		dc.w	BitBucket		- romanDispTable	; DrawJust		(30)
		dc.w	BitBucket		- romanDispTable	; MeasureJust	(32)
		dc.w	BitBucket		- romanDispTable	; ParseTable	(34)		<x11>
		dc.w	BitBucket		- romanDispTable	; PortionText	(36)		<x2><x10>
		dc.w	BitBucket		- romanDispTable	; FindScriptRun	(38)		<x8>
		dc.w	VisibleLength	- romanDispTable	; VisibleLength	(40)		<x10>
		dc.w	BitBucket		- romanDispTable	; IsSpecialFont	(42)
		dc.w	BitBucket		- romanDispTable	; RawPrinterValues	(44)
		dc.w	BitBucket		- romanDispTable	; NPixel2Char	(46)
		dc.w	BitBucket		- romanDispTable	; NChar2Pixel	(48)
		dc.w	BitBucket		- romanDispTable	; NDrawJust		(50)
		dc.w	BitBucket		- romanDispTable	; NMeasureJust	(52)
		dc.w	BitBucket		- romanDispTable	; NPortionText	(54)
	 ELSE
		dc.w	RomanGetScript	- romanDispTable	; GetScript		(12)		<x10> <SM8> CSS
		dc.w	RomanSetScript	- romanDispTable	; SetScript		(14)		<x10> <SM8> CSS
		dc.w	CharByte		- romanDispTable	; CharByte		(16)
		dc.w	CharType		- romanDispTable	; CharType		(18)		<26>
		dc.w	Pixel2Char		- romanDispTable	; Pixel2Char	(20)
		dc.w	Char2Pixel		- romanDispTable	; Char2Pixel	(22)
		dc.w	Translit		- romanDispTable	; Transliterate	(24)
		dc.w	FindWord		- romanDispTable	; FindWord		(26)
		dc.w	HiliteText		- romanDispTable	; HiliteText	(28)
		dc.w	DrawJust		- romanDispTable	; DrawJust		(30)
		dc.w	MeasureJust		- romanDispTable	; MeasureJust	(32)
		dc.w	ParseTable		- romanDispTable	; ParseTable	(34)
		dc.w	PortionText		- romanDispTable	; PortionText	(36)
		dc.w	FindScriptRun	- romanDispTable	; FindScriptRun	(38)
		dc.w	VisibleLength	- romanDispTable	; VisibleLength	(40)		<x10>
		dc.w	0									; IsSpecialFont	(42)		<33>
		dc.w	0									; RawPrinterValues	(44)	<33>
		dc.w	NPixel2Char		- romanDispTable	; NPixel2Char	(46)
		dc.w	NChar2Pixel		- romanDispTable	; NChar2Pixel	(48)
		dc.w	NDrawJust		- romanDispTable	; NDrawJust		(50)
		dc.w	NMeasureJust	- romanDispTable	; NMeasureJust	(52)
		dc.w	NPortionText	- romanDispTable	; NPortionText	(54)
	ENDIF
		endproc
		end

