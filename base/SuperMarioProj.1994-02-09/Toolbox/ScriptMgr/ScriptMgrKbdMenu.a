;
;	File:		ScriptMgrKbdMenu.a
;
;	Contains:	Initialization of the new Keyboard Menu in the System Menu bar.
;
;	Written by:	SMB	Sue Bartalo
;
;	Copyright:	© 1990-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;		<43>	  4/2/93	YK		Initialize D0 to zero before getting a length byte into the
;									lowest byte.
;		<42>	 3/27/93	YK		Use system script font for ‘About Keyboards…’ menu item.
;		<41>	 1/19/93	PKE		Update include file names: PackMacs.a->Packages.a. No effect on
;									objects.
;		<40>	 6/26/92	SMB		#1033660,<kst>: When we realized that Simplified Chinese
;									TSM-style IMs were not getting correctly installed as a result
;									of a flag value being defined incorrectly, we discovered some
;									other minor bugs: extra TSM-style IMs were getting installed
;									because the inputMethodCount also reflected the old-style IM
;									count. Will now use this only for the count of TSM-style IMs and
;									will use CJKcount to determine if any input methods are
;									installed as appropriate (in BuildKCHRTable, etc.)
;		<39>	 6/18/92	csd		#1030826 <SMB>: Fixed a bug in BuildIMTable where register d5
;									was being initialized too late. It would get used with garbage
;									in it if there were no input methods installed.
;		<38>	 6/17/92	SMB		#1030826,<ha>: Check if an old-style IM is "ready" before
;									installing it and if not, am updating the KCHR count and IM
;									count appropriately. Now using STR# (kKeyboardMenuItemsID)
;									instead of STR# (kKeyboardMenuID) Now using intfName instead of
;									intfFile for the IM name in the menu.
;		<37>	 5/31/92	FM		Removed obsolete conditional ScriptMgrKeyboardMenu.  I would
;									like to remove DoCmdKeyEquivalents too but I guess I'll wait on
;									that.
;		<36>	 5/12/92	SMB		#1026017,<pke>: Removed code that error exited if 'kcs4' is not
;									available. If 'kcs4' icon is not available will simply use
;									'kcs#' icon. Also, fixed stupid code in RebuildKeybdMenu that
;									causes rebuilding of menu d.s. to crash when a menu isn't
;									available. #1029051, 1029243, 1024274 also.
;		<35>	  4/8/92	SMB		#1026904,<ys>: #1026904,<ys>: Must set ResLoad to true around
;									call to localGetIndString for the ‘About Keyboards…’ string. The
;									resource was getting purged so was using an empty handle; also
;									changed the localGetIndString code to test the dereferenced
;									handle and to do a LoadResource if the handle was empty (for
;									correctness). This removes the dependency on ResLoad being true.
;		<34>	  4/6/92	SMB		#1024274,<pke>: General cleanup: remove hardcoding of "About
;									Keyboards…" added in <33> when the resource isn't available. Now
;									getting "About Keyboards…" using GetIndString; removed
;									unnecessary code. Since using "oldJIMCount" for a test rather
;									than for a count, now setting a bit "HaveOldJapanIMbit" in
;									CJKcount instead. No longer testing for existance of component
;									mgr (it exists). Fixed bug in AddMenuItem where old-style IM
;									itemRsrcID was getting written to script word instead of
;									language word of scriptLangRec. In AddMenuItem, need to call
;									SetScript with secret script flag 'kUsingOldInputMethodVerb'
;									when old-style IM becomes the default (after call to InformTSM).
;									In RebuildKeybdMenu, the equ for frame size was above the local
;									variable menuH, so the link instruction wasn't actually grabbing
;									enough stack space. Fixed now; been around since the routines
;									inception. (also, probably the writing to 0 bug: 1024274).
;		<33>	 2/22/92	KST		Fixed 2 bugs related to "menuItemStringHdl": 1. If we can't get
;									the resource, menuItemStringHdl was not cleared. 2. Need to make
;									menuItemStringHdl non-purgeable because the code set ResLoad to
;									false. Bad thing happened when the resource got purged.
;		<32>	 2/22/92	KST		Rewrite code to get IconSuite from Component. Changed TSM design
;									and removed "GetKeyboardIconSuite" call. Also add a field
;									"oldJIMCount" in the stack frame to keep the old Japanese input
;									method count.
;		<31>	 2/19/92	KST		Fixed a bug in "MakeIMIconSuite" which trashes A3.
;		<30>	 2/11/92	DCL		Changed the name of TSMEqu.[aph] to TextServices.[aph] for
;									better read-ability.
;		<29>	 2/10/92	KST		We now consolidate all default input methods info in one
;									resource managed by TSM. So keyboard menu should get this info
;									from TSM by calling GetDefaultInputMethod at boot time.
;		<28>	 1/30/92	JH		Right before the loop which starts at label @OldIMLoop the
;									intfArray handle is dereferenced and the first long is moved
;									into d4. There needs to be a check to see if that first long is
;									0. So adding a beq.s to NoMoreIMs.
;		<27>	 1/16/92	pvh		In OldIMLoop, clear D0 before using it to hold a long word value
;									for _BlockMove (D0 had residual trash in the upper word byte
;									causing _BlockMove to hose memory). D1 also held the bogus D0
;									value too.
;		<26>	 1/16/92	DTY		Double check the handle to Japanese system globals to make sure
;									there actually is a handle. If there is no handle, assume there
;									are no old Japanese input methods.
;		<25>	 1/15/92	SMB		Adding code to support old Input Methods… want old-style
;									(pre-7.0) Japanese input methods in the kbd menu. Cleanup stack
;									problem in MakeKCHRIconSuite & MakeIMIconSuite.
;		<24>	 1/13/92	SMB		Word-align menuFrame again: eliminate tempTwo field since meant
;									to replace it with CJKcount in last checkin.
;		<23>	 1/10/92	SMB		#1013637: be sure a script is enabled and not just installed.
;									Now adding KCHRs for double-byte scripts when no input methods
;									are available.
;		<22>	12/13/91	DTY		#1018116: BuildIMTable will trash the system heap when it tries
;									to add information about components to the end of the installed
;									items record but there were no components in the system.  Bad
;									form, Boss!  ;)
;		<21>	12/11/91	SMB		Rewrite to include Input Methods as well as KCHRs. Renamed
;									AuxKeyboardMenuInfo members and KCHRInstalledRec (is now
;									ItemInstalledRec) with new names. Bug #1013637 fixed - don't
;									show inputs in menu if their script is installed but not
;									enabled. Renamed scriptRecord's scriptKCHRCount member to
;									scriptInputCount.
;		<20>	 11/8/91	SMB		#1015613 (for CubeE & Bruges) - Fix bug that shows up when an
;									application has no menu bar. We really want to use the system
;									menu bar (SystemMenuList) and not the current menu bar which may
;									be an application's menu bar.
;		<19>	 2/11/91	PKE		smb,#PKE-Sys-020: RebuildKeybdMenu should perform some disposing
;									and rebuilding even without a Keyboard menu, so we update if
;									Mover has updated the keyboard layouts. Otherwise user can't
;									switch to layouts they moved in, or code will try to switch to
;									layouts that have been moved out. Note: this fix also requires
;									the previous bug fix in <18>.
;		<18>	 2/11/91	PKE		smb,#PKE-Sys-021: RebuildKeybdMenu (called by Mover) trashes a2
;									and d3 (because it doesn't do proper setup and cleanup for its
;									call to InitKeybdMenu).
;		<17>	 1/27/91	PKE		stb,#PKE-Sys-016: (Whiteboard bug in 800K install, with no keybd
;									icons) InitKeybdMenu error handling code was putting menuH
;									handle for DisposHandle on the stack instead of in a0, thus
;									messing up the stack and trashing regs across InitKeybdMenu.
;									Once menuH was being put in the right place, then another
;									problem had to be fixed: it was not valid if there was no menu.
;		<16>	 1/22/91	SMB		(csd) When no kcs resources are installed, needed to pop a3 off
;									the stack before an error exit (actually we just don't display a
;									keyboard menu. See branches to @ErrCleanup & @StkCleanup.
;		<15>	  1/7/91	SMB		(JDR) Need to modify to always have the Keyboard menu structures
;									so the KeyScript verb "NextKeybdInScript" is meaningful (and
;									functions!). Now testing smgrKbdMenuAvail in order to do the
;									right thing when a menu does/doesn't exist! In RebuildKeybdMenu
;									set script manager munged count to tell the Keybd CDEV to
;									rebuild it's list of KCHRs. Renamed Icons.a to IconUtilsPriv.a.
;		<14>	12/15/90	SMB		(gbm) Modified to use the 'kcs4' icon if the 'kcs8' is missing,
;									and to guarantee fetching resources from the system resource
;									file. Used 'extra' byte in local frame for a new flag,
;									usingGenericIcon. Modified use of ResLoad to be a byte op and
;									not a word op. Fixed bug in SortKCHRs by looping in the
;									outerloop through KCHRcount-1 KCHR in the buffers (instead of
;									the KCHRcount-2 KCHRs). This was causing a KCHR to not be
;									included in the menu but it would show in the Keybd CDEV since
;									it was in the system file.
;		<13>	10/30/90	SMB		NEEDED for 7.0b2: restore ResLoad before calling SortKCHRs since
;									_IUTextOrderSys depends on certain resources being in the system
;									heap.
;		<12>	  9/1/90	SMB		Rearranged initial conditions for displaying a menu. Bug fix: if
;									only 1 KCHR then don't need to sort in SortKCHRs.
;		<11>	 8/10/90	SMB		Removed the KeyScript call to re-enable the keyboards since
;									Mover is now making the call. Added ‘About Keyboards’ support
;									now.
;		<10>	  8/7/90	SMB		Adding guts to RebuildKeybdMenu. Added call to IUTextOrderSys to
;									sort the KCHRs alphabetically based on the 'itlm'. Changed
;									script's default KCHR indicator to be localizable in the STR#
;									resource for the kbd menu. Adding ‘About Keyboards…’ (but
;									conditionalized out until later.) Temporarily making a KeyScript
;									call to re-enable the keyboards if in RebuildKeybdMenu if they
;									were disabled.
;		 <9>	 7/16/90	PKE		Use new name for field in ExpandMemRec: emItlCache2Ptr is now
;									emItlSysCachePtr. Renamed Cache2Rec to NewItlCacheRec.
;		 <8>	 6/22/90	SMB		Conditionalizing out more code that expects the Next Keyboard
;									and Next Script menu items to exist. Using flag
;									DoCmdKeyEquivalents.
;		 <7>	 6/13/90	PKE		Put in framework for private RebuildKeybdMenu routine called by
;									Mover. This call lets us know that keyboards have been moved
;									into or out of the System file.
;		 <6>	 6/13/90	SMB		Removing the Next Keyboard and Next Script menu items until
;									their command key equivalents can be displayed in the menu.
;		 <5>	  6/5/90	SMB		Fixed odd address problem that occurred when initializing the
;									menuTitleString and DisabledDashSep by adding a dummy member to
;									the Strings record. Also cleaned up some inefficient code and
;									initialized a register! Disabled cmd key equivalents for Next
;									Keyboard and Next Script menu items.
;		 <4>	  6/1/90	SMB		Extended Keyboard Menu to display using sorted script list
;									(itl2Cache), and added Next Keyboard and Next Script menu items,
;									as well as disabled dividing lines between scripts. Also testing
;									itlc showIcon flag to determine whether or not to display the
;									keyboard menu.
;		 <3>	 5/31/90	SMB		Renaming IconUtils.a to Icons.a.
;		 <2>	 5/13/90	SMB		Adding InitKeyboardMenu guts!
;		 <1>	  5/5/90	PKE		Added a butchered version of Sue’s new file with a temporary
;									stub for InitKeybdMenu routine. Sue will fill this in later.
;___________________________________________________________________________________________________
;	To Do:
;	• Update use of d4 (was KCHRcount, is now total menu contents count) to be a long instead of a word
;	• If can't get a handle to use for the name of an IM (see @GetIMInfo) need to zero-out the itemInfo 
;		field and set update the count correctly.  May need to do better error-handling after
;		_GetComponentInfo too.
;	• clean up componentFlags and componentFlagsMask: should the componentFlags be #$00008F00 instead?
;	• search for <??>
;	• make RebuildKeybdMenu its own proc and move localGetIndString above it.
;	• Are the menuitems numbered correctly if no kbd menu is desired and the About menu 
;	item isn't there? Should check ScriptMgrKeyGetSet for all of this as well.
;	• what to do about err result from _DisposeIconSuite? already deleted menu items if a menu exists
;		and possibly already deleted icon suites so these leave the menu in a bad state.
;___________________________________________________________________________________________________

		load	'StandardEqu.d'					; Private.a, ScriptEqu.a, ...
		include 'ScriptPriv.a'
		include	'Packages.a'					;							<10><41>
		include 'IconUtilsPriv.a'				;							<15>
		include	'IntlUtilsPriv.a'				;							<10>
		include	'MenuMgrPriv.a'					;							<20>
		include 'TextServices.a'				;							<21> <29>
		include 'TSMPrivate.a'					;							<29>
		include	'Components.a'					;							<21>
		include 'GestaltEqu.a'					;							<21>

		string	pascal

		proc
		export	InitKeybdMenu
		export	RebuildKeybdMenu				;							<7>
		import	StdUnlink						; std unlink & exit			<1>

;-------------------------------------------------------------------------------
;	FUNCTION InitKeybdMenu: OSErr;
;-------------------------------------------------------------------------------

menuFrame			record	{a6link},decr
result				ds.w	1		; OSErr result code.					<1>
menuArgs			equ		*-8		; size of arguments.					<1>
selector			ds.l	1		; ScriptMgr selector on stack			<1>
return				ds.l	1		; return address.						<1>
a6link				ds.l	1		; old link pointer
rebuildFlag			ds.b	1		; indicates rebuilding so don't call _InsertMenu <10>
					ds.b	1		; unused								<21><34>
byteAvail			ds.b	1		; word-aligning the stack: use me		<25>
CJKcount			ds.b	1		; Using low 5 bits: which dbl-byte scripts have an IM: 0 => no IM, ow 1	<23>
									; xxxOCCJK
KCHRcount			ds.w	1		; number of KCHRs installed				<10><21>
TSMInputMthdCount	ds.l	1		; input method count (old & new)		<21> renamed <25> renamed again (added 'TSM') <40>
menuH				ds.l	1		; menuHandle
ScriptOrderPtr		ds.l	1		; ptr to ordering of scripts (in emItlSysCache)
ItemInstalledRecPtr	ds.l	1		; ptr to ItemInstalledRec
ItemOffsetsPtr		ds.l	1		; ptr to record of offsets of ItemInstalledRec for sorting
KeyboardMenuPtr		ds.l	1		; ptr to AuxKeyboardMenuInfo record
menuItem			ds.w	1		; menuItem number
defaultMark			ds.w	1		; marker for default KCHR in each script
scriptCount			ds.b	1		; number of scripts still to process	<10>
usingGenericIcon	ds.b	1		; T=> using a generic icon				<14>
scriptLangRec		ds.l	1		; contains the script (w) & language (w) <21>
compID				ds.l	1		; component identifier					<21>
NextItemString		ds.b	256
CompDesc			ds		ComponentDescription		;					<21>
menuLocals			equ		*		; size of locals
					endr

; definitions for creating an IconSuite of small color icons for scripts.
		string	asis
kcsTable			dc.l	'kcs#',Small1BitMask,'kcs4',Small4BitData,'kcs8',Small8BitData

		string	pascal

NumItemsAfterKCHRs	equ		2		; Next Keyboard and Next Script

KeyboardMenuRegs	reg		d2-d4/a2-a4	
		
;***********************************************************************************************

InitKeybdMenu	
		with	menuFrame,ItemInstalledRec
		link	a6,#menuLocals
		clr.w	result(a6)					; initialize to return noErr

;-----------------------------------------------------------------------------------			<10>
;	INITIALIZATIONS
;-----------------------------------------------------------------------------------			<10>
		movem.l	KeyboardMenuRegs,-(sp)

; get # of enabled scripts																		<4>
		with SmgrRecord
		GetSMgrCore	a2
		st		smgrKbdMenuAvail(a2)		; assume want menu to display						<15>
		cmp.b	#1,smgrEnabled(a2)			; > 1 script enabled?								<12>
		bhi.s	@HaveMenuStatus				; yep, display menu									<12>
		
; otherwise, check itlc flag (smfShowIcon) to determine whether or not to show the menu			<4>
		move.l	smgrGenFlags(a2),d0			;													<5>
		btst.l	#smfShowIcon,d0				; bit 31 ON => show icon even if only one script 	<5>
		bne.s	@HaveMenuStatus				;													<15>
		sf		smgrKbdMenuAvail(a2)		; don't want menu to display						<15>
		clr.l	menuH(a6)					; set menu handle to NIL							<17>
@HaveMenuStatus		
		move.b	smgrEnabled(a2),scriptCount(a6)	; save count									<12>
		endWith								;													<12>

; setup for resource fetch from the system file													<14>
		subq.w	#2,sp						; storage for current resource file					<14>
		_CurResFile							; 													<14>
		move.w	#0,-(sp)					; use system resource file							<14>
		_UseResFile							;													<14>

		move.b	ResLoad,-(sp)				;													<14>
		st		ResLoad						; set to true										<14>

; setup defaultMark for the menu
		move.w	#KeybdDefaultMrk,defaultMark(a6)	; initialize to empty, 0x00
		pea		NextItemString(a6)			; ptr to Str255										<34>
		move.w  #kKeyboardMenuItemsID,-(sp)	; strListID											<34><38>
		move.w	#DefMarkIndex,-(sp)			; string index										<34>
		import	localGetIndString			;													<34>
		bsr		localGetIndString			; making a pString (rather than a ptr to text)													<34>
		sf		ResLoad						; reset to F										<14>

		tst.b	NextItemString(a6)			; do we have a string?								<34>
		beq.s	@useDefMarker				; if empty, use default marker						<32>
; fetch the localized character
		move.b	NextItemString+1(a6),defaultMark+1(a6)	; write out the default marker byte	(skip length)	<34>
@useDefMarker

; Test if menu already exists so know if called from RebuildKeybdMenu					 		<10>
		sf		rebuildFlag(a6)				; assume first time									<10>
; Use the system menuBar and not the application menuBar in case appl doesn't have a menuBar (GetMHandle would fail).	<20>
		move.l	MenuList,-(sp)				; save the current menuList since it may be an apps menu <20>
		move.l	SystemMenuList,MenuList		;													<20>
		subq	#4,sp						; result											<10>
		move.w	#kKeyboardMenuID, -(sp)		; menuID											<10>
		_GetMHandle							;													<10>
		move.l	(sp)+,menuH(a6)				;													<10>
		move.l	(sp)+,MenuList				; restore the menuList								<20>
		tst.l	menuH(a6)					;													<10>		
		beq.s	@NewMenu
; If menu already exists then called from RebuildKeybdMenu					 					<10>
		st		rebuildFlag(a6)				; don't do _InsertMenu								<10>

;-----------------------------------------------------------------------------------
;	MENU setup
;-----------------------------------------------------------------------------------

@NewMenu
		bsr		CountMenuContents			; returns d4.l = to total # of installed inputs
		
; Allocate ItemInstalledRec table for # of installed KCHRs and Input Methods:
		move.l	d4,d0						; total number of KCHRs and Input Methods			<21>
		mulu	#ItemInstalledRecSz,d0
		_NewPtr ,SYS,CLEAR
		move.l	a0,ItemInstalledRecPtr(a6)
		move.l	a0,a4

		with smgrRecord,ScriptRecord,itlbRecord,ItemInstalledRec,AuxKeyboardMenuInfo
;-----------------------------------------------------------------------------------
		bsr		BuildIMTable				; Init the ItemInstalledRec table for input methods	<21>
		bsr		BuildKCHRTable				; Init the ItemInstalledRec table for KCHRs			<21>
;-----------------------------------------------------------------------------------
		st		ResLoad						; must be T for _IUTextOrderSys						<14>
		bsr		SortItems					; sort the Items 									<10>
		sf		ResLoad						; reset to F										<14>
;-------------------------------------------

; Allocate AuxKeyboardMenuInfo record for IconSuite handles for MF and other info for SystemMenu patch
		move.w	d4,d0						; total number of inputs
		add.b	scriptCount(a6),d0			; # of scripts = # of disabled (separating) lines

			IF DoCmdKeyEquivalents THEN				; 											<8>
			; Allocate space for empty entry (so can index by menu item #) and entries for items
			; beyond KCHRs (so that the iconSuiteH is 0). NumItemsAfterKCHRs=0 if no cmd key items
			; so would only +1. Added above in disabled line count								<8>
			add.w	#(1+NumItemsAfterKCHRs),d0		; 1=dummy entry
			ENDIF

		add.w	#2,d0						; for "About Keyboards…" & disabled line items		<11>
		mulu	#AuxMenuInfoSize,d0
		_NewPtr	,SYS,CLEAR
		move.l	a0,KeyboardMenuPtr(a6)
		GetSmgrCore a1						; get script manager core.
		move.l	a0,smgrKeyboardMenuPtr(a1)	; save in Smgr Record for MF
		move.l	a0,a2
; in order to index by menuItem # (not 0-based), must have a dummy entry at the beginning
		add.w	#AuxMenuInfoSize,a2			; point past empty entry to storage for 1st menuItem.

;-----------------------------------------------------------------------------------			<10>
;	Make a menu now…
;-----------------------------------------------------------------------------------			<10>

; Test if a menu is desired: if not, must still build menu d.s. so that the command-key 		<15>
; equivalent, cmd-opt-space bar (to switch between keybds. in a script) works.	 				<15>
		move.w	#1,menuItem(a6)				; initialize earlier for bra						<15>
		tst.b	smgrKbdMenuAvail(a1)		; do we want to display a menu?						<15>
		beq.s	@BuildMenuRec				;													<15>
; Do we already have a menu? (are we called from RebuildKeybdMenu?)
		tst.b	rebuildFlag(a6)				; do we already have a menu?						<21>
		bne.s	@GotMenuH					; bra if so											<21>

; Add a new menu for the Keyboard Menu
		subq	#4,sp						; result: menuHandle
		move.w	#kKeyboardMenuID, -(sp)		; menuID
		pea		#'Susan'					; pString											<21>
		_NewMenu
		move.l	(sp)+,menuH(a6)
@GotMenuH

; Add the About Keyboards… menuitem followed by a disabled line									<10>
		st		ResLoad						; set to true										<35>									<14>
		pea		NextItemString(a6)			; ptr to Str255										<34>
		move.w  #kKeyboardMenuItemsID,-(sp)	; strListID											<34><38>
		move.w	#AboutKybdsIndex,-(sp)		; string index										<34>
		import	localGetIndString			;													<34>
		bsr		localGetIndString			;													<34>
		sf		ResLoad						; reset to false									<35>
		tst.b	NextItemString(a6)			; do we have the string								<34>
		beq.s	@BuildMenuRec				; no, don't add AboutKeyboards…						<34>

; name the menu item
		move.l	menuH(a6),-(sp)
		pea		NextItemString(a6)			; name of this KCHR: pString
		move.w	menuItem(a6),-(sp)			; insert ‘after’ this menuItem
		_InsMenuItem
		move.l	menuH(a6),-(sp)
		move.w	#1,-(sp)					; the first item has a script code.		<42>
		move.w	#$1C,-(sp)
		_SetItemCmd
		move.l	menuH(a6),-(sp)
		move.w	#1,-(SP)
		move.w	#smSystemScript,-(sp)		; the script code is the sytem script	<42>
		_SetItmIcon
		add.w	#1,menuItem(a6)
		add.w	#AuxMenuInfoSize,a2			; point past 1st menuItem now
		bsr		AddDisabledLine				; separate scripts by a disabled line				<8>

;---------------------------------------------------------------------------
;	Add the menu guts…
;---------------------------------------------------------------------------
@BuildMenuRec								;													<15>
		move.l	ItemInstalledRecPtr(a6),a4	; reset to first KCHR’s info						<10>	
		move.l	ItemOffsetsPtr(a6),a3		; reset ptr
		move.w	(a3)+,d0					; get offset to KCHR info for this item				<10>
		add.w	d0,a4
;-------------------------------------------
; Currently:
; a2 = ptr to AuxKeyboardMenuInfo (storage for aux menu info for each input)
; a3 = ItemOffsetsPtr
; a4 = ptr to ItemInstalledRec
; d3 = current script #
; d4 = total number of inputs
; d5 = total num of input items thus far in this script
;--------------------------------------------
; Time to build each menu item and it's auxilliary menu information record
; For each enabled script, loop for the input items and add menu items for each one

;--------------------
;	Scripts loop…
;--------------------
@EnabledScriptLoop
		subq.b	#1,scriptCount(a6)			; decr enabled script count
		moveq	#0,d5						; initialize script's input item count to 0
		move.w	ItemScript(a4),d3			; script code
		
; be sure this script is enabled (bug #1013637)													<21>
		GetSMgrCore	a0
		move.w	d3,d0
		lsl.w	#2,d0						; long word offset
		move.l	smgrEntry(a0,d0.w),a0		; script record of installed script
		
; loop until cross a script boundary in the KCHR table
;-------------------------------
;	Items_within_a_script loop…
;-------------------------------
@ScriptItemsLoop	
		; if script not enabled, loop for next input. (a0 set above)
		tst.b	scriptEnabled(a0)			; script enabled?
		beq.s	@NextInput					; bra to fetch next input item if not a valid script

; find out the type of input to build the iconsuite
		move.b	itemInpuType(a4), itemType(a2)	; type of input								<25>
		beq.s	@KCHRinput						; bra if this is a KCHR						<25>
		cmp.b	#TSMIMitem, itemInpuType(a4)	; is this a new-style input method?			<25>
		bne.s	@OldIM							; no, is an old-style input method			<34>- replaced 2 branches

@NewIM
; this input type is a TSM-style IM
		move.l	itemInfo(a4), auxItemInfo(a2)	; store the component identifier here 		<21>
		bra.s	@IMIconSuite					;											<25>
@OldIM
		move.w	itemResID(a4),itemRsrcID(a2)	; save id in AuxKeyboardMenuInfo record
		move.l	#0, auxItemInfo(a2)				; NIL indicates it's not a new-style IM		<25>		
@IMIconSuite
		bsr		MakeIMIconSuite					; 											<21>
		bra.s	@Add2Menu
		
@KCHRinput
; this input type is a KCHR
		move.w	itemResID(a4),itemRsrcID(a2)	; save id in AuxKeyboardMenuInfo record
		movem.l	d2/d3,-(sp)						; save										<36>
		move.w	itemRsrcID(a2),d2				; store the desired KCHR icon ID			<36>
		move.w	#kKeyboardMenuID,d3				; store the default KCHR icon ID			<36>
		sf		usingGenericIcon(a6)			; initial assumption						<36>
		bsr		MakeIconSuite					;											<36>
		movem.l	(sp)+,d2/d3						; restore									<36>
		move.l	#0, auxItemInfo(a2)				; NIL indicates it's not a new-style Input Method		

@Add2Menu
; create a new menuItem and save the item order w/in the script in the AuxKeyboardMenuInfo record
		bsr		AddMenuItem					; preserves a0

;--------------------------------------------
@NextInput
; Get next input!
		sub.w	#1,d4						; are we out of inputs/menuItems to add?
	IF NOT DoCmdKeyEquivalents THEN			; bra if done									<8>
		beq.s	@SetTitle					;									 			<3>;temporary<6>
	ELSE
		beq		@SetCmdKeyEquiv				; add Next Keyboard and Next Script 			<3>;temporary<6>
	ENDIF
		add.w	#AuxMenuInfoSize,a2			; point to storage for next menuItem.

; Loop on next input in this script?
		move.l	ItemInstalledRecPtr(a6),a4	; reset to first KCHR’s info						<10>	
		move.w	(a3)+,d0					; get offset to KCHR info for this item
		add.w	d0,a4
		move.w	ItemScript(a4),d0
		cmp.w	d3,d0						; cmp to current script
		beq.s	@ScriptItemsLoop			; get next KCHR for this script

; Crossed a script boundary		
	IF NOT DoCmdKeyEquivalents THEN			; 												<8>
		tst.b	scriptCount(a6)				; more enabled scripts?							<8>
		beq.s	@SetTitle					; don’t add disabled line after last KCHR		<8>
		; if script not enabled, don't add a line. (a0 set above at @EnabledScriptLoop)		<23>
		tst.b	scriptEnabled(a0)			; script enabled?								<23>
		beq		@EnabledScriptLoop			; bra to fetch next input item if not a valid script <23>
		bsr		AddDisabledLine				; separate scripts by a disabled line			<8>
											; a2 incremented for next menuitem's info		<32>
		bra		@EnabledScriptLoop			;												<8>
	ELSE
			; Not really a routine- just a place I've moved the code to get it out of the
			; middle of here. Should be put back here if we want to use it.
			bsr		AddCmdKeyMenuItems	
	ENDIF									;												<6>

;------------------------------------------------------------------------------------------
;	FINALIZATION
;------------------------------------------------------------------------------------------

; change the title of the menu to the icon of the system script’s keybd by stuffing 
; the iconSuite handle into the string posn holder "Susan"
@SetTitle
		GetSmgrCore a3								; get script manager core.				<15>
		tst.b	smgrKbdMenuAvail(a3)				; do we want to display a menu?			<15>
		beq.s	@Cleanup							;										<15>
		move.l	menuH(a6),a0
		move.l	(a0),a0								; deref
; stuff the length (5 bytes) and special byte into the name: 01 indicates a handle is following
		move.w	#$0501, menuData(a0)				;										<21>
		
; stuff the system script's iconSuite handle into the name
 		move.l	KeyboardMenuPtr(a6),a1

; get item # of default script's KCHR														<10><15>
		move.w	smgrSysScript(a3),d0				;										<10>
		lsl.w	#2,d0								; long word offset						<10>
		move.l	smgrEntry(a3,d0.w),a3				; script record							<10>
		clr.w	d0									;										<10>
		move.b	ScriptKeysItemNum(a3),d0			;										<10>
		mulu.w	#AuxMenuInfoSize,d0					; offset into AuxMenuInfoRec			<10>
		add.w	d0,a1								;										<3><10>
		move.l	iconSuiteH(a1),menuData+2(a0)		; now at system script entry			<3>
		endwith		; with smgrRecord,ScriptRecord,itlbRecord,ItemInstalledRec,AuxKeyboardMenuInfo

		tst.b	rebuildFlag(a6)						; if rebuilding don’t insert menu		<10>
		bne.s	@CleanUp							;										<10>
		
; insert the menu now!		
		move.l	menuH(a6),-(sp)
		move.w	#0,-(sp)
		_InsertMenu

@Cleanup
		move.b	(sp)+,ResLoad						;										<14>
; restore previous (current) resource file													<14>
		_UseResFile									; current resource file ID on stack		<14>

		move.l	ItemInstalledRecPtr(a6),a0
		_DisposPtr
		tst.w	result(a6)
		bne.s	@done								; don't overwrite with potential DisposPtr error
		tst.w	d0
		beq.s	@done
		move.w	d0,result(a6)						; will override DisposHandle error if one existed
		move.l	ItemOffsetsPtr(a6),a0
		_DisposPtr
		tst.w	result(a6)
		bne.s	@done								; don't overwrite with potential DisposPtr error
		tst.w	d0
		beq.s	@done
		move.w	d0,result(a6)						; will override DisposHandle error if one existed

@done	
		movem.l	(sp)+,KeyboardMenuRegs
		move.w	#menuArgs, d0						; for StdUnlink: number of bytes to clean up
		bra		StdUnlink							; standard exit
		endwith										; menuFrame,ItemInstalledRec

;formFeed
;-----------------------------------------------------------------------------------
;	Utility CountMenuContents																	<21>
;
;	---- Input
;	a6 	stack frame, menuFrame
;
;	---- Output
;	d4	total # of _installed_ ‘KCHR’s, Input Methods, (menu items).
;-----------------------------------------------------------------------------------

CountMenuContents
		with	menuFrame,ItemInstalledRec,smgrRecord,scriptRecord,ScriptSystemGlobals,intfRecord
		moveq	#0,d4
		clr.b	CJKcount(a6)				; initialize to no input methods available	<34>
		move.l	d4, TSMInputMthdCount(a6)	; initialize								<25> <32>
; determine # of KCHR resources in the System file
		subq	#2,sp						; result
		move.l	#'KCHR',-(sp)				; resource type
		_Count1Resources					; get the number of KCHRs
		move.w	(sp)+,d4
		move.w	d4,KCHRcount(a6)			; save for KCHR search						<10>

;----------------------------------------------------------------------------------	
; count # of old Japanese input methods in the System									<25>
		GetSMgrCore	a0						; get Script Mgr core						<25>
		move.l	smgrEntry+(smJapanese*4)(a0),d0	; get handle to the Japanese system globals	<25> <26><34>
		bz.s	@GetNewIMs					; No handle, so assume no old input method.  Go find some new ones.  <26>
		move.l	d0,a0						;											<26>
		tst.b	scriptEnabled(a0)			; script enabled?							<25>
		beq.s	@GetNewIMs					; no Japanese script so get only new IMs now	<25>
; get handle to table of input methods
		move.l	intfArray(a0),a0			; load table handle							<25>
		move.l	(a0),a0						; load table pointer						<25>
		move.l	(a0),d0						; get table length => # of old input methods<25>
		beq.s	@GetNewIMs					; No old input methods.  Go find some new ones.  <34>
		add.l	d0,d4						; use reg instead of mem loc for setting d4	<32>
		bset.b	#HaveOldJapanIMbit,CJKcount(a6)	; use bit 5 to indicate a JIM exists	<34>
;----------------------------------------------------------------------------------	

@GetNewIMs
; set up component description record													<21>
		move.l	#kTextService, CompDesc.componentType(a6)	; text service interface type
		move.l	#kInputMethodService, CompDesc.componentSubType(a6)	; specific text service
		move.l	#0, CompDesc.componentManufacturer(a6)

; get the grand total of IMs for a comparison with the compiled total of IMs			<40>
		move.l	d3,-(sp)					; save										<40>
		move.l	#AllFlags, CompDesc.componentFlags(a6)		; all scripts, languages & takes active key events	<40>
		move.l	#ActiveEventMask, CompDesc.componentFlagsMask(a6)	; only care about the active event			<40>
		subq	#4,sp						; result									<40>
		pea		CompDesc.componentType(a6)	; count components of this desc 			<40>
		_CountComponents																<40>
		move.l	(sp)+,d3					; save result								<40>

		
;----------------------------------------------------------------------------------		<23>
; Determine # of input methods in the System but need to know which scripts have them. So,
; do a separate count for each double-byte script and set a bit in the CJKcount byte field of
; menuFrame that indicates whether or not an input method exists for the script.  Bits 0 - 4 are
; set thus: (CCJK): bit 4 = simpChinese, bit 3 = tradChinese, bit 2 = Japanese, bit1 = Korean	<23>
; Bit 5 is set above if an old-style Japanese IM is available.							<34>
;----------------------------------------------------------------------------------		<23>

		move.w	d2,-(sp)					; save around calls to CountDblByteIMs		<25>
		move.l	#ScriptActiveEventMask, CompDesc.componentFlagsMask(a6)	; now care about the script	& active event <23>

; count # of simplified Chinese Input Methods in the System								<23>
		move.l	#SimpChineseFlags, d0		; simpChinese script & takes active key events
		move.b	#HaveSimpChineseIMbit,d2
		bsr		CountDblByteIMs				;											<25>
		
; count # of traditional Chinese Input Methods in the System							<23>
		move.l	#TradChineseFlags, d0		; tradChinese script & takes active key events
		move.b	#HaveTradChineseIMbit,d2
		bsr		CountDblByteIMs				;											<25>

; count # of Japanese Input Methods in the System										<23>
		move.l	#JapaneseFlags, d0			; Japanese script & takes active key events
		move.b	#HaveJapaneseIMbit,d2
		bsr		CountDblByteIMs				;											<25>

; count # of Korean Input Methods in the System											<23>
		move.l	#KoreanFlags, d0			; Korean script & takes active key events
		move.b	#HaveKoreanIMbit,d2
		bsr		CountDblByteIMs				;											<25>

; compare grand total of IMs to compiled total to see if more exist beyond specifics above	<40>
		cmp.l	TSMInputMthdCount(a6),d3	; are the totals the same					<40>
		ble.s	@TSMCountOK					; if so, done								<40>
		sub.l	TSMInputMthdCount(a6),d4	; remove compiled totals from total count of KCHRs and IMs	<40>
		move.l	d3,TSMInputMthdCount(a6)	; use grand total of IMs instead of compiled<40>
		add.l	d3,d4						; add grand total instead					<40>
@TSMCountOK		
		
		move.w	(sp)+,d2					; restore									<25>
		move.l	(sp)+,d3					; restore									<25>
		rts
		endWith								; menuFrame,ItemInstalledRec,smgrRecord,scriptRecord,ScriptSystemGlobals,intfRecord
		
;formFeed
;-----------------------------------------------------------------------------------
;	BuildKCHRTable
;	Initialize the ItemInstalledRec table for the KCHRs
;	Adjusts input count for KCHRs in a double-byte script: will add KCHRs for 
;	double-byte scripts with no input methods.
;
;	---- Input
;	a4	ItemInstalledRecPtr(a6)
;	d4	total count of installed KCHRs & IMs
;
;	---- Register usage
;	d3	loop counter
;	d5	KCHRs in a double-byte script
;
;	---- Output
;	a4	ItemInstalledRecPtr(a6) is pointing to next available space
;-----------------------------------------------------------------------------------
BuildKCHRTable
		with menuFrame,ItemInstalledRec
; Build table for all KCHRs' res handles, ids, and scripts (whether belong to an enabled script or not)
		moveq	#0,d5						; assume no KCHRs in a double-byte script
		move.l	d4,-(sp)					; save total count
		move.w	KCHRcount(a6),d4			; only want KCHRs
		moveq	#1,d3						; start indexing with first ind resource
@GetKCHRLoop
		subq	#4,sp						; result
		move.l	#'KCHR',-(sp)				; resource type
		move.w	d3,-(sp)					; push the index value
		_Get1IxResource
		move.l	(sp),itemHandle(a4)
		
; get the KCHR ID corresponding to the KCHR handle		---------------------------------------	<10>
		pea		itemResID(a4)				; get the ID
		clr.l	-(sp)						; don’t need type
		pea		itemName(a4)				; push ptr to name string
		_GetResInfo							; get the name, etc.

; get the script # from the ‘KCHR’ ID: (KCHR id - #16384)/#512 + 1
		move.l	#smRoman,d1					; initialize to Roman script
		move.w	itemResID(a4),d0
		sub.w	#smFondStart,d0				; beginning of non-Roman resource IDs (zero base KCHR #) 
		bmi.s	@HaveScript
		moveq	#9,d1						; shift amt
		lsr.w	d1,d0						; get into script range (div by 2^9)
		addq.w	#1,d0						; get real script #
		move.w	d0,d1						; move script to d1 for test

;--------------------------------------------------					<23>		
; if the script is a double-byte script and no IM components are available, add the KCHRs
; if the appropriate bit is set in CCJKcount(a6) then have IMs for the script.
		tst.b	CJKcount(a6)				; are there any input methods?				<40>
		bz.s	@HaveScript					; no, so add these KCHRs.

; are we the simplified Chinese (19) script?
		cmp.w	#smSimpChinese,d0			
		bgt.s	@HaveScript					; bra if not a double-byte script
		bne.s	@TestKorean					; not simp. Chinese but maybe another dbl-byte script
;yep so check if any simplified Chinese IMs												<23>
		btst.b	#HaveSimpChineseIMbit, CJKcount(a6)		;								<25>
		beq.s	@HaveScript					; no IMs so add KCHRs for this script					
		bra.s	@dbKCHRCount

@TestKorean
; are we the Korean script?
		cmp.w	#smKorean,d0			
		bne.s	@TestTradChinese
;yep so check if any Korean IMs															<23>
		btst.b	#HaveKoreanIMbit, CJKcount(a6)		;									<25>
		beq.s	@HaveScript					; no IMs so add KCHRs for this script					
		bra.s	@dbKCHRCount

@TestTradChinese
; are we the traditional Chinese script?
		cmp.w	#smTradChinese,d0			
		bne.s	@TestJapanese
;yep so check if any traditional Chinese IMs											<23>
		btst.b	#HaveTradChineseIMbit, CJKcount(a6)		;								<25>
		beq.s	@HaveScript					; no IMs so add KCHRs for this script					
		bra.s	@dbKCHRCount

@TestJapanese
; are we the Japanese script?
		cmp.w	#smJapanese,d0			
		bne.s	@HaveScript					; not a double-byte script
;yep so check if any Japanese IMs														<23>
		btst.b	#HaveJapaneseIMbit, CJKcount(a6)		;								<25>
		bne.s	@dbKCHRCount				; TSM-style JIMs exist so don't add KCHRs
		btst.b	#HaveOldJapanIMbit, CJKcount(a6)	; any old-style JIMs?				<34>
		beq.s	@HaveScript					; no IMs so add KCHRs for this script		<34>
		; fall into @dbKCHRCount
;--------------------------------------------------						<23>
@dbKCHRCount
		add.w	#1,d5						; count of unincluded KCHRs in a double-byte script
		bra.s	@GetNextKCHR
		
@HaveScript
		move.w	d1,itemScript(a4)
; end of changes here									--------------------------------------- <10>
		move.l	#0,itemInfo(a4)				; NIL means not an Input Method (for now)	<21>
		move.b	#KCHRitem, itemInpuType(a4)	; this is a KCHR							<25>
		add.w	#ItemInstalledRecSz,a4
@GetNextKCHR
		addq	#1,d3						; bump the index
		cmp		d4,d3						; compare with the count
		ble		@GetKCHRLoop				; loop if more to do
		move.l	(sp)+,d4					; restore total
		sub.w	d5,d4						; adjust to not include KCHRs in a double-byte script
		sub.w	d5,KCHRcount(a6)			; adjust total KCHR count					<38>
		rts									
		endWith								; menuFrame,ItemInstalledRec
		
;formFeed
;-----------------------------------------------------------------------------------
;	BuildIMTable																					<21>
;	Initialize the ItemInstalledRec table for the Input Methods, both TSM-style and old-style
;
;	---- Input
;	a4	ItemInstalledRecPtr(a6) is pointing to next available space (beyond KCHRs)
;	d4	total count of installed input methods
;
;	---- Register usage
;	d3	loop counter
;	d5	6.x-style IMs not installed
;	a0,a1
;
;	---- Output
;	a4	ItemInstalledRecPtr(a6) is pointing beyond Input Methods
;-----------------------------------------------------------------------------------
BuildIMTable
		with	menuFrame,ItemInstalledRec, smgrRecord, scriptRecord, ScriptSystemGlobals, intfRecord
		move.l	d4,-(sp)					; save total count
		moveq	#0,d5						; assume no IMs that won't install			<38><39>
		move.l	TSMInputMthdCount(a6),d4	; only want TSM-style input methods
		bz		@DoOldIMs					; if no TSM-style input methods at all, check for old-style IMs		<40>
		moveq	#1,d3						; start indexing with first ind resource
;--------------------------------------------------------------------------------------------

; set up component description record to only fetch input methods for CJK scripts
		move.l	#kTextService, CompDesc.componentType(a6)		; text service interface type
		move.l	#kInputMethodService, CompDesc.componentSubType(a6)		; specific text service
		move.l	#0, CompDesc.componentManufacturer(a6)
		move.l	#$FFFFFFFF, CompDesc.componentFlags(a6) 
		move.l	#$00008000, CompDesc.componentFlagsMask(a6)	; we care about 2-byte scripts & taking active key events
															; smJapanese = 1, smTradCh = 2, smKorean = 3, smSimpCh = $19
; initial search: get TSM-style IM and then old-style IM…
		subq	#4,sp						; result: component identifier
		move.l	#0,-(sp)					; initial component of NIL => search all components
		pea		CompDesc(a6)				; find components of this desc 
		_FindNextComponent
		move.l	(sp), itemInfo(a4)			; component identifier: use as input on next call
		move.l	(sp)+, compID(a6)			; need for next FindNextComponent call
		cmp.l	#0, itemInfo(a4)			; 0 => no more matching components
		beq		@DoOldIMs					;											<25>
		bra.s	@GetIMInfo
		
@GetIMLoop
		subq	#4,sp						; result: component identifier
		move.l	compID(a6),-(sp)			; start search after this component
		move.l	#0, CompDesc.componentManufacturer(a6)
		move.l	#$FFFFFFFF, CompDesc.componentFlags(a6) 
		move.l	#$00008000, CompDesc.componentFlagsMask(a6)	; we care about 2-byte scripts & taking active key events

		pea		CompDesc(a6)				; find components of this desc
		_FindNextComponent
		move.l	(sp), itemInfo(a4)			; component identifier: use as input on next call	
		move.l	(sp)+, compID(a6)			; need for next FindNextComponent call
		cmp.l	#0, itemInfo(a4)			; 0 => no more matching components
		beq.s	@DoOldIMs					;											<25>

@GetIMInfo
; must create a handle for the name
		moveq	#0,d0						; 0 length
		_NewHandle
		bne.s	@DoOldIMs					; error in d0 (CCs set)						<25>
		move.l	a0,itemHandle(a4)
		; <??> should I branch to @NoMoreIMs?? not getting a handle may preclude other work being done…
		; <??> should 0-out the itemInfo field and update the count to reflect a nil handle!!

; get name
		subq	#2,sp						; OSErr result
		move.l	itemInfo(a4),-(sp)			; get more info on this component
		pea		CompDesc(a6)				; VAR: component description space
		move.l	itemHandle(a4),-(sp)		; name handle: receives component name
		move.l	#0,-(sp)					; NIL => don't care about component's info string
		move.l	#0,-(sp)					; NIL => for now don't care about the icon since really want an IconSuite
		_GetComponentInfo
		tst.w	(sp)+
		bne.s	@DoOldIMs					; bra if error (invalidComponentID)			<25>

; now save name 
		move.l	itemHandle(a4),a0			; double deref handle
		move.l	(a0),a0						; pointer to name
		lea		itemName(a4),a1				; ptr to name space on stack
		moveq	#0,D0						; clear high bytes for BlockMove
		move.b  (a0)+,d0					; get the length of this string
		move.b	d0,(a1)+					; store the length in the string (make a pString!)
		move.w  d0,d1						; save the length
		_BlockMove							; copy it into theString
		clr.b   0(a1,d1)					; set terminator byte

		move.l	itemHandle(a4),a0			; get rid of handle now
		_DisposeHandle
; inicate a new input method
		move.b	#TSMIMitem, itemInpuType(a4)	; this is a new IM						<25>

; get script		
		move.l	CompDesc.componentFlags(a6),d0
		and.l	#ScriptMask, d0				; only care about script code in low word
		lsr.w	#8,d0						; shift script to low nibble
		move.w	d0,itemScript(a4)

		add.w	#ItemInstalledRecSz,a4
		addq	#1,d3						; bump the index
		cmp		d4,d3						; compare with the count
		ble		@GetIMLoop

;--------------------------------------------------------------------------------------------
@DoOldIMs
; now get old input methods
		btst.b	#HaveOldJapanIMbit,CJKcount(a6)	; optimized: is there an old JIM		<34>
		beq.s	@NoMoreIMs					; no, so done								<32>
		GetSMgrCore	a1						; get Script Mgr core						<25>
		move.l	smgrEntry+(smJapanese*4)(a1),a1	; get handle to the Japanese system globals	<25> <26><34>

		move.l	a2,-(sp)					; save										<25>
		move.l	a1,a2		
; get handle to table of input methods
		move.l	intfArray(a2),a2			; load table handle							<25>
		move.l	(a2),a2						; load table pointer						<25>
		move.l	(a2)+,d4					; get # of old input methods				<25>
		beq.s	@RestoreA2					; if there aren't any restore a2 and get out!!!!	<28> 
		
@OldIMLoop
; pointer to next input method is in a2
		move.l	(a2)+,a0					; input method source
; check if this input method is "ready" before installing it							<38>
		btst.b	#intfFReady-8,intfFlags(a0)	; is the IM ready?							<38>
		bne.s	@InstallIM					; yes, install it							<38>
		add		#1,d5						; no, so be sure to decrement totals		<38>
		bra.s	@GetNextIM					; fetch the next one						<38>
			
@InstallIM
; get ID and save
		move.w	intfID(a0),itemResID(a4)	; store the ID here							<25>
; get and save name
		lea		intfName(a0),a0				; changed from intfFile to intfName			<38>
		lea		itemName(a4),a1				; ptr to name space on stack
		clr.l	d0							; clear this space!							<27>
		move.b  (a0)+,d0					; get the length of this string
		move.b	d0,(a1)+					; store the length in the string (make a pString!)
		move.w  d0,d1						; save the length
		_BlockMove							; copy it into theString
		clr.b   0(a1,d1)					; set terminator byte
; get script	
		move.w	#smJapanese,itemScript(a4)	; the only old-style input method supported <25>

; indicate an old input method
		move.l	#0, itemInfo(a4)
		move.b	#oldIMitem, itemInpuType(a4)	; this is an old IM						<25>

		add.w	#ItemInstalledRecSz,a4		; point to next storage place				<25>

@GetNextIM
		subq	#1,d4						; if non-zero, loop for the next IM			<25>
		bne.s	@OldIMLoop
;--------------------------------------------------------------------------------------------
@RestoreA2									; added new label for branch we take if there aren't any old IMs <28>
		move.l	(sp)+,a2					; restore									<25>
@NoMoreIMs
		move.l	(sp)+,d4					; restore total
		sub.w	d5,d4						; adjust total kbd & IM count				<38>
		rts									
		endWith								; menuFrame,ItemInstalledRec,smgrRecord,scriptRecord,ScriptSystemGlobals,intfRecord

;formFeed
;-----------------------------------------------------------------------------
;	MakeIconSuite
;
;	---- Input
; 	a2  ptr to AuxKeyboardMenuInfo (storage for each KCHR’s iconSuiteH)
;	d2	ID of kcs icon suite
;	d3	default input icon ID (either kKeyboardMenuID or kDefaultIMIconID)
;	a6	stack frame, menuFrame
;	usingGenericIcon(a6) flag set as desired on entry

;	---- Register usage
;	a3	kcsTable: array of icon resource types
;	d6	loop counter
;
;	---- Output
;	iconSuite created and handle stored in AuxKeyboardMenuInfo
;	result(a6) set appropriately
;-----------------------------------------------------------------------------

MakeIconSuite

iconSuiteRegs	reg		a0/a3/d6

		with menuFrame, AuxKeyboardMenuInfo
		movem.l	iconSuiteRegs,-(sp)			; save ptr to script record	and a3
; create an empty icon suite
		sub.w	#2,sp
		pea		iconSuiteH(a2)				; storage for this iconSuite
		_NewIconSuite
		move.w	(sp)+,d0
		move.w	d0,result(a6)				; save (shouldn't affect CCs)
		bne.s	@Done						; error exit really								<23>		

; get a handle to each script’s small icon resource (‘kcs#’,‘kcs4’,‘kcs8’) and stuff in the icon suite
		lea		kcsTable,a3
		move.l	#2,d6						; loop through for each small icon type (0 based)
@KcsLoop
		subq	#6,sp						; results for next 2 trap calls: resource handle & OSErr
		tst.b	usingGenericIcon(a6)		; do we want to or have we already used the generic icon?		<14>
		bne.s	@UseGeneric					; yes, so keep using it.						<14>
		move.l	(a3),-(sp)					; get small color icon resource type (‘kcs#’,‘kcs4’,‘kcs8’)
		move.w	d2,-(sp)					; the icon id
		_Get1Resource
		tst.l	(sp)
		bne.s	@GotResource

; if the 'kcs#' is missing for this icon then use generic icon								<14>
		cmp.l	#'kcs#',(a3)				; is this a 'kcs#' that's missing?				<14>
		bne.s	@GotResource				; if not, use 'kcs#' icon on color machine
		
; use the generic small icons since no icon exists for this KCHR
; result space already on the stack
		st		usingGenericIcon(a6)		; using generic icon for this KCHR				<14>
@UseGeneric									;												<14>
		move.l	(a3),-(sp)					; get small color icon resource type
		move.w	d3,-(sp)					; the generic icon id is different for KCHRs and IMs
		_Get1Resource
		; if 'kcs4' is missing use 'kcs#' icon by passing NIL as the resource ID
		; if 'kcs8' is missing use 'kcs4' icon by passing NIL as the resource ID
		bra.s	@AddIcon
		
@GotResource
		cmp.b	#TSMIMitem,itemType(a2)		; is this a TSM-style input method?
		bne.s	@AddIcon					; if not, skip detachment of resource
; if we load the icon from component's resfile, then detach the resource, make a handle
; and keep it around 
		move.l	(sp),-(sp)					; push the handle
		_DetachResource						;  this resource has to be detatched
		movea.l	(sp),a0						; a0 = handle
		_HNoPurge							;  this handle cannot be purgeable

@AddIcon
		add.l	#4,a3						; point past small color icon type
; result space and resource handle are on the stack already 
		move.l	iconSuiteH(a2),-(sp)
		move.l	(a3)+,-(sp)					; IconUtils expects specific types (Small1BitMask,Small4BitData,Small8BitData)
		_AddIconToSuite 
		move.w	(sp)+,d0					; set CCs
		move.w	d0,result(a6)				; save but doesn't affect CCs
		bne.s	@Done						; cleanup stack and error exit					<16>
		dbra	d6,@KcsLoop

@Done
		movem.l	(sp)+,iconSuiteRegs			; restore ptr to script record and a3				<23>
		rts
		endwith								; menuFrame
		
;formFeed
;-----------------------------------------------------------------------------
;	MakeIMIconSuite
;	Complete rewrite to use the new way of fetching iconSuite for Input Methods.			<32>
;	We're not using "GetKeyboardIconSuite" anymore. We get the icon resources directly from		<32>
;	Component resource file. By doing this, we don't need to open each Input Method.		<32>
;	If a TSM-styled Input Methods does not have icon resource, then we'll use				<32>
;	generic keyboard icon to make an iconSuite.												<32>
;	Got a facelift to use common routine MakeIconSuite										<36>
;	---- Input
; 	a2	ptr to AuxKeyboardMenuInfo (storage for each KCHR’s iconSuiteH)
;	a4	ptr to ItemInstalledRec
;	a6	stack frame, menuFrame
;
;	---- Register usage
;	d2
;	d3
;	d4	resFile open flag for TSM-style IMs (0 => component resfile is not open)
;		d4.w > 0 means component resfile is open
;	d5	d5.b = saved resload flag
;	d6	d6.w = 0 means resource chain has not altered, otherwise = current resfile
;
;	---- Output
;	iconSuite created and handle stored in AuxKeyboardMenuInfo
;-----------------------------------------------------------------------------
MakeIMIconSuite

IMiconSuiteRegs	reg		d2-d6/a0

		with menuFrame, AuxKeyboardMenuInfo, ItemInstalledRec
		movem.l	IMiconSuiteRegs,-(sp)		; save
		move.w	itemRsrcID(a2),d2			; store the desired old-style IM icon ID
		move.w	#kDefaultIMIconID,d3		; store the default IM icon ID
		st		usingGenericIcon(a6)		; initial assumption if old-style IM
		moveq	#0,d4						; component resfile not open flag
		move.w	d4,d6						; d6.w = 0 means resource chain has not altered
		move.b	ResLoad,d5					; d5.b = saved resload flag
		cmp.b	#oldIMitem,itemType(a2)		; is this an old-style input method?
		beq.s	@doIt						; yes, so use the default icon
		
; have a TSM-style input method: get the icon resource ID for the IM
		sf		usingGenericIcon(a6)		; initial assumption if TSM-style IM

		clr.w	result(a6)					; default = no error
; save current res file before opening the component res file
		subq.l	#2,sp						; room for result
		_CurResFile							; get current res file
		move.w	(sp)+,d6					; d6 = current resfile
	
		subq	#2,sp						; room for refnum
		move.l	auxItemInfo(a2),-(sp)		; component identifier
		_OpenComponentResFile				; open the resfile
		move.w	(sp)+,d4					; get the refnum
		ble.s	@UseGeneric					; can't open so use default IM icon
		
; crummy assumption about the resource icon ID being at the bottom of the script range but 
;	it has to be this way for TSM (per John and Kenny)… note the detachment of the resource
;	in MakeIconSuite for this mess…
		move.w	ItemScript(a4),d2			; use script code to ...
		subq	#1,d2						;	calculate the ...
		lsl.w	#8,d2						;	resource id
		add.w	d2,d2						; (code-1)*512
		add.w	#smFondStart,d2				; d2.w = resource id
		
		subq	#4,sp						; results for resource handle
		move.l	#'kcs#',-(sp)				; get small keyboard icon resource type
		move.w	d2,-(sp)					; icon resource id
		_Get1Resource
		move.l	(sp)+,d0					; do we get the icon?
		beq.s	@noResource					; no
		
; if we are loading from component's resfile, better set resload to true ...
		st		ResLoad						; set to true
		bra.s	@doIt						; yes, use common code
		
; if we can't load the resource, then close the resfile and use the generic small 
;	icons since no icon exists for this IM
@noResource
		sub.w	#2,sp						; room for result
		move.w	d4,-(sp)					; refnum
		_CloseComponentResFile
		tst.w	(sp)+						; pop result
		moveq	#0,d4						; d4 = 0 means component resfile is not open
		; fall into generic icon path
@UseGeneric
		st		usingGenericIcon(a6)		; initial assumption
@doIt
		bsr		MakeIconSuite

; done, so cleanup
		tst.w	d4							; is resfile open?
		ble.s	@ResChainAltered			; no
		sub.w	#2,sp						; room for result
		move.w	d4,-(sp)					; refnum
		_CloseComponentResFile
		tst.w	(sp)+						; pop result

@ResChainAltered
		tst.w	d6							; have we changed resource chain?
		beq.s	@RestoreResLoad				; no
		move.w	d6,-(sp)					; refnum on stack
		_UseResFile							; restore res file
		
@RestoreResLoad
		move.b	d5,ResLoad					; restore state
		movem.l	(sp)+,IMiconSuiteRegs
		rts
		endwith								; menuFrame

;formFeed
;-----------------------------------------------------------------------------
;		AddMenuItem
;
; 		Add this new menuItem (a KCHR) to the Keyboard Menu.
;		Called from InitKeyboardMenu.
; 		Using the a6 link from InitKeyboardMenu.
;
;		---- Input
;		d3 = script #
;		d5 = total num of inputs thus far in this script
; 		a2 = ptr to AuxKeyboardMenuInfo (storage for each KCHR’s iconSuiteH)
; 		a4 = ptr to ItemInstalledRec
;		a6 = stack frame, menuFrame
;
; 		Register usage:
; 		d3 = menuItem (total # of KCHRs)
; 		d4 = system keyscript
;		d5 = total num of KCHRs thus far in this script (incr here!)
; 		a2 = ptr to AuxKeyboardMenuInfo (storage for each KCHR’s iconSuiteH)
; 		a3 = ptr to script mgr record & then, script record
;
;		trashes a1				<#29>
;-----------------------------------------------------------------------------
AddMenuItem

		with menuFrame, ItemInstalledRec, AuxKeyboardMenuInfo
AddMenuRegs	reg	d3/d4/a0/a2-a4				; save a0, too											<23>

		movem.l	AddMenuRegs,-(sp)
		
; initializations
		with	smgrRecord
		GetSMgrCore	a3		
		move.w	smgrKeyScript(a3),d4		; get default keyscript
		lsl.w	#2,d3						; long word offset
		move.l	smgrEntry(a3,d3.w),a3		; script record
		move.w	menuItem(a6),d3				; item # (also, indicates the total # of inputs)

; if there's no menu then don't set item info														<15> 
		GetSMgrCore	a1						;														<15>
		tst.b	smgrKbdMenuAvail(a1)		;														<15>
		beq.s	@savePosn					;														<15>
		endWith

; name the menu item
		move.l	menuH(a6),-(sp)
		pea		itemName(a4)				; name of this KCHR: pString
		move.w	d3,-(sp)					; insert ‘after’ this menuItem
		_InsMenuItem
	
; set script in the item by setting the cmd to be $1C and the icon to the script #
		move.l	menuH(a6),-(sp)
		move.w	d3,-(sp)
		move.w	#scriptMenuCmd,-(sp)		; indicates scripted text	
		_SetItemCmd
		
		move.l	menuH(a6),-(sp)
		move.w	d3,-(sp)
		move.w	itemScript(a4),-(sp)
		_SetItmIcon

@savePosn
; set input count (also is the ordering within its script in the menu) in the AuxKeyboardMenuInfo record
		with	ScriptRecord, smgrRecord
		add.w	#1,d5
		move.w	d5,itemScriptPosn(a2)
		move.b	d5,scriptInputCount(a3)		; save the script's input (KCHR or Input Method) count

; if this is the script's default then save its item #: process by type of input: KCHR, old-style IM, new-style IM
		cmp.b	#TSMIMitem, itemType(a2)	; 														<25>
		blt		@KCHRinput					; KCHR item												<25>


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; < Begin new #29 > for CJK script .....
; At boot time, we need to mark default input method for each script, and check mark the item in the menu,
; get the default input method for this script from TSM to compare against this item.		-- <KST #29>

; need the default language for this script
		subq	#4,sp						; result
		move.w	itemScript(a4),-(sp)		; script
		move	#smScriptLang,-(sp)			; verb: I want the default lang from the 'itlb'
		_GetScript
		move.l	(sp)+,scriptLangRec(a6)		; default langCode (only want low word)
		move.w	itemScript(a4),scriptLangRec(a6)	; scriptCode in high word
		
; now get the default input method: the component identifier for TSM-style IMs or
; the FEF ID for old-style IMs
		subq	#2,sp						; OSErr result
		pea		compID(a6)					; returns default component identifier here
		pea		scriptLangRec(a6)			; wants a ptr to this record
		_GetDefaultInputMethod				; need to preserve a2/a3/d3/d4 ....
		move.w	(sp)+,d0					; result
		beq.w	@newDefIM					; noErr => use TSM-style IM as default

; Default isn't TSM-style so continue checking…  => is an old-style Japanese IM

; Now test if the default is the old-style IM (should be unless there is a problem since we've
; just tested for TSM-style default…)
		cmp.w	#tsmInputMethodIsOldErr,d0	; is this the special error?
		beq.s	@oldDefIM					; yes

; Here w/ a non-zero result (tsmInputMethodNotFoundErr) => no default IM found and no-TSM IM available
; So, if this is an old-style IM, use it as the default if another one hasn't already been set.
		cmp.b	#oldIMitem,itemType(a2)		; is this old?
		bne		@done						; No: nothing we can do. Sorry. (this shouldn't ever happen)
		
; Have we done this already?
		tst.b	ScriptKeysItemNum(a3)		; assume it was initially cleared	<34> - should be a byte op
		bne		@done						; yes, don't do it again
		
; OK, this old-style IM is going to be the default now. We better inform TSM about it…
;	 _InformTSM will set the default IM with this FEP ID (can't call _SetDefaultInputMethod
;	 since it's only valid for TSM-style IMs. However, note (as seen above) that 
;	 _GetDefaultInputMethod will return information about an old-style default IM. Strange but true;
;	 a kludge to allow old-style JIMs to still work w/ TSM.)

		move.w	itemRsrcID(a2),d0			; this is the FEP ID
		move.w	d0,scriptLangRec+2(a6)		; TSM needs script and id			<34> - store the ID in language word				
		subq	#2,sp						; OSErr result								
		move.w	#kMsgChangeToOldJIM,-(sp)	; message number							
		pea		scriptLangRec(a6)			; wants a ptr to this record as the message's parameter				
		_InformTSM							; hey, we are using the old-style IM now
		tst.w	(sp)+						; ignore error

; set secret script flag that says we are using old-style input method			<34>
		subq	#2,sp						; result							<34>
		move.w	#smJapanese,-(sp)			; script							<34>
		move	#kUsingOldInputMethodVerb,-(sp)		; verb: are we using an old IM?		<34>
		move.l	#UsingOldStyleIM,-(sp)		; TRUE								<34>
		_SetScript
		tst.w	(sp)+						; ignore OSErr						<34>
		bra.s	@SaveItemNum				; and save the item num

;------------------------------------------------------------------------------------------ 	
@oldDefIM									; default is old-style IM
		cmp.b	#oldIMitem, itemType(a2)	; is this old?
		bne		@done						; no
		
		move.w	compID+sidFEPID(a6),d0		; saved in low word of long
		cmp.w	itemRsrcID(a2),d0			; is this item the default component for this script?
		bne.s	@done						; no

; this is the default old-style IM so use it
		Import	GetKanjiUserIDIntf			; call local version of UserIDIntf		
		move.w	d0,-(sp)					; pass input method ID of new item
		jsr		GetKanjiUserIDIntf
		GetSMgrCore	a1								; get Script Mgr core
		move.l	smgrEntry+(smJapanese*4)(a1),a1		; load doubleTalkRecord for Japanese.
; if an error occured, didn't active old-style IM so don't make secret SetScript call.
		tst.w	ScriptSystemGlobals.FISError(a1)	; bad index?
		bne.s	@done								; yes -> bail.

	; we have a problem here. If the old default IM is not in the system ......
	;; what to do if we failed ???? <??> how could it get registered as the default if
	;; it's not in the system???
	
; set secret script flag that says we are using old-style input method
;	We make this call to tell TSM about this situation - it knows that an old-style IM
;	is the default but this flag hasn't been set yet. Without it set, patches won't get
;	loaded to support the old-style IMs. At boot time DoubleTalk clears this. Patches loaded 
;	after DoubleTalk depend on it. Set it. (details, details…)
		subq	#2,sp								; result
		move.w	#smJapanese,-(sp)					; script
		move	#kUsingOldInputMethodVerb,-(sp)		; verb: are we using an old IM?
		move.l	#UsingOldStyleIM,-(sp)				; TRUE	
		_SetScript
		tst.w	(sp)+								; result OSErr
		bne.s	@done
		bra.s	@SaveItemNum				;

;------------------------------------------------------------------------------------------ 	
@newDefIM									; default is TSM-style IM
		cmp.b	#TSMIMitem, itemType(a2)	; is this new?
		bne.s	@done						; no,
		move.l	auxItemInfo(a2),d0			; compare to the default
		cmp.l	compID(a6),d0				; is this item the default component for this script?
		bne.s	@done						; no 
		bra.s	@SaveItemNum				;

; < End new #29 >
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;------------------------------------------------------------------------------------------ 		<21>

@KCHRinput
		move.w	itemRsrcID(a2),d1			; get the first KCHR ID
		cmp.w	scriptBundle.itlbKeys(a3),d1
		bne.s	@done
;------------------------------------------------------------------------------------------ 		<21>

@SaveItemNum
		move.b	d3,ScriptKeysItemNum(a3)	; save item # of script's default KCHR
		GetSMgrCore	a1						;														<15>
		tst.b	smgrKbdMenuAvail(a1)		;														<15>
		beq.s	@done						;														<15>
		endwith

; default KCHR’s name gets a default mark that's localizable in the STR# resource for the kbd menu
		move.l	menuH(a6),-(sp)
		move.w	d3,-(sp)
		move.w	defaultMark(a6),-(sp)		; this is the script's default KCHR
		_SetItmMark

; Add ‘√’mark to the system KCHR
 		cmp.w	itemScript(a4),d4			; is this the system KCHR?
		bne.s	@done
; system KCHR gets ‘√’ mark and its icon gets put into menu name
		move.l	menuH(a6),-(sp)
		move.w	d3,-(sp)
		move.w	#checkMark,-(sp)
		_SetItmMark
		
@done
		add.w	#1,menuItem(a6)				; next item #
		movem.l	(sp)+,AddMenuRegs
		rts
		endWith


	
;------------------------------------------------------------------------------------------ <3>
;	Utility AddDisabledLine
;	Add disabled grey line
;
;	---- Input
; 	a2  ptr to AuxKeyboardMenuInfo (storage for each KCHR’s iconSuiteH)
;	a6	stack frame, menuFrame
;
;	---- Output
;	menuItem count incremented
;	a2 incremented for next menuitem's info
;------------------------------------------------------------------------------------------
AddDisabledLine
	
		with menuFrame, AuxKeyboardMenuInfo
		move.l	menuH(a6),-(sp)				; menu handle
		pea		#'(-'						; pString										<21>
		move.w	menuItem(a6),-(sp)			; insert ‘after’ this menuItem
		_InsMenuItem
		add.w	#1,menuItem(a6)				; next item #
; stuff a null handle in the menu item's position in the KeyboardMenu record.
		add.w	#AuxMenuInfoSize,a2			; point to storage for next menuItem.
		rts
		endwith


;formFeed
;------------------------------------------------------------------------------------------ <10>
;	Utility SortItems
;
;	Sort the installed items by script and name using the Script Manager routine IUTextOrderSys,
;	which sorts using the script ordering specified in ‘itlm’.
;	To save moving a lot of data around, we will sort the indices of the ItemInstalledRec array 
;	and fetch the data later.
;
; 	This is a straight selection algorithm (simple idea but....)
;	Search for the smallest KCHR # and exch it w/ the first KCHR # in the list.
;	Repeat w/ n-1, n-2, etc. items.
;	d0 & d1 are loop counters (indexes for each KCHR comparison)
;	d2 & d3 contain the results of the comparisons
;
;	---- Straight selection algorithm ---------------
;	for d0:= 0 to KCHRcount-1 do
;		d2:= d0
;		d3:= offset[d0]
;		for d1:= d0+1 to KCHRcount-1 do 
;			if name[d1] < name[d3] then
;				d2:= d1
;				d3:= offset[d2]
;			end
;		end
;		offset[d2]:= offset[d0]
;		offset[d0]:= d3
;	end
;
;	---- Input
;	d4 	KCHRcount
;	a6	stack frame, menuFrame
;
;	---- Register usage -----------------------------
;	d0-d2 are index counters
;	d3  storage of the least KCHR #
; 	d4	Input count	(inner loop terminator)
;	d5,d6	length of names, misc temp uses
;	d7	outer loop terminator
; 	a2	bPtr
;	a3	ItemOffsetsPtr
;	a4	aPtr
;------------------------------------------------------------------------------------
SortItems

		with menuFrame, ItemInstalledRec, AuxKeyboardMenuInfo
SortRegs	reg	d3-d7/a3
; initializations
		move.l	ItemInstalledRecPtr(a6),a4
		movem.l	SortRegs,-(sp)

; allocate record for offsets of ItemInstalledRec to be sorted
		moveq	#0,d0
		move.w	d4,d0						; total number of installed items
		add.w	d0,d0						; double for # of installed items
		_NewPtr ,SYS,CLEAR
		move.l	a0,ItemOffsetsPtr(a6)

; build record of offsets
		move.w	#0,d0						; index
		move.w	d4,d1						; loop terminator
		bra.s	@CheckZero
@FillArray
		move.w	d0,(a0)+					; save offset
		add.w	#ItemInstalledRecSz,d0		; incr to next offset
@CheckZero
		dbra.w	d1,@FillArray
;-------
		cmp.w	#1,d4						; do we have more than 1 KCHR?					<12>
		ble		@DoneSort					; nope: don’t sort								<12>
		move.l	ItemOffsetsPtr(a6),a3		; reset ptr
		move.l	a4,a2						; copy of ptr to KCHR info for sorting (a4=aPtr, a2=bPtr)
; initialize for outer loop
		move.w	#0,d0						; initialize outer loop controller to 0
		move.w	d4,d7						; terminator for outerloop
		sub.w	#1,d7						; KCHRcount-1 (instead of -2)					<14>
		
@OuterLoop
; for d0:= 0 to KCHRcount-1 do
;	d2:= d0
;	d3:= offset[d0]							; least index

		move.w	d0,d2						; d2:= d0
		move.w	d0,d3
		add.w	d3,d3						; pt to correct offset in KCHROffsets record

; initialize for inner loop
		move.w	d0,d1
		addq.w	#1,d1
		move.l	ItemInstalledRecPtr(a6),a2
		move.w	d1,d5
		add.w	d5,d5						; get to correct place in offset array
		move.w	0(a3,d5),d5					; get offset amount for this next element
		add.w	d5,a2
@InnerLoop
;	for d1:= d0+1 to KCHRcount-1 do
;		if name[d1] < name[d3] then
;			d2:= d1
;			d3:= offset[d2]					; new least index
;		end
;	end

;		if name[d1] < name[d3] then		(	now compare scripted names)
; a4 = KCHR a (aPtr, aLen, aScript)
; a2 = KCHR b (bPtr, bLen, bScript)
		movem.l	d0-d2,-(sp)
		moveq	#0,d5
		move.b	itemName(a4),d5				; aLen
		moveq	#0,d6
		move.b	itemName(a2),d6				; bLen
		sub.w	#2,sp						; result
		pea		itemName+1(a4)				; aPtr
		pea		itemName+1(a2)				; bPtr
		move.w	d5,-(sp)					; aLen
		move.w	d6,-(sp)					; bLen
		move.w	itemScript(a4),-(sp)		; aScript
		move.w	itemScript(a2),-(sp)		; bScript
		move.w	#iuScriptDefLang,-(sp)		; aLang => script's default lang
		move.w	#iuScriptDefLang,-(sp)		; bLang => script's default lang
		_IUTextOrderSys
		move.w	(sp)+,d0					; set CCs
		movem.l	(sp)+,d0-d2
		ble.s	@GetNextID					; aPtr is <= bPtr so don't exchange
		
		move.w	d1,d2
		move.w	d2,d3						; d3:= new least index
		add.w	d3,d3						; pt to correct offset in KCHROffsets record
		move.l	a2,a4						; update aPtr to be the least KCHR (which is bPtr in this case)

@GetNextID

		addq.w	#1,d1						; for d1:= d0+1 to KCHRcount do
; incr for fetch of next itemName (using current sort order)
		move.l	ItemInstalledRecPtr(a6),a2
		move.w	d1,d5
		add.w	d5,d5						; get to correct place in offset array
		move.w	0(a3,d5),d5					; get offset amount for this next element
		add.w	d5,a2
		cmp.w	d1,d4						; KCHRcount-1
		bhi.s	@InnerLoop
		
; swap this pass' least KCHR name with the KCHR name in the current position
;	offset[d2]:= offset[d0]
;	offset[d0]:= d3

		move.w	d0,d5						; this is the index of the higher KCHR name
		add.w	d5,d5
		move.w	d2,d6						; this is the index of the least KCHR name
		add.w	d6,d6
		move.w	0(a3,d3),d3
		move.w	0(a3,d5),0(a3,d6)			; this is the highest index for this pass
		move.w	d3,0(a3,d5)					; this is the least index for this pass
		
; loop again?	
		addq.w	#1,d0						; for d0:= 1 to KCHRcount-1 do
; set ptr to next ‘KCHR a’
		move.l	ItemInstalledRecPtr(a6),a4
		move.w	d0,d5
		add.w	d5,d5						; get to correct place in offset array
		move.w	0(a3,d5),d5					; get offset amount for this next element
		add.w	d5,a4
; set ptr to next ‘KCHR b’
		move.l	a4,a2						; just copy; incremented above
; are we done?
		cmp.w	d0,d7
		bhi		@OuterLoop
		
	IF DoCmdKeyEquivalents THEN				; 												<10>
			; finally, move the system script's default KCHR to the top of the menu.
				with SmgrRecord
				GetSMgrCore	a0
				move.w	smgrKeyScript(a0),d3		; get default keyscript
				move.l	ItemInstalledRecPtr(a6),a4	; 
				move.w	#0,d0						; offset of default KCHR in KCHROffsets array
			@InxLoop
				move.w	d0,d1
				add.w	d1,d1						; index into KCHROffsets array
				add.w	#1,d0
				move.w	0(a3,d1),d2					; get index into ItemInstalledRec
				cmp.w	itemResID(a4,d2),d3			; is this the default KCHR?
				bne.s	@InxLoop
			
			; have the default KCHR index now so shove the system script's KCHRs down a position
				sub.w	#1,d0						; incremented above
			
				move.w	d0,d4						; loop terminator (shift until this point)
				move.w	#0,d1
				move.w	(a3),d2						; holding cell for initial posn in array
				add.w	d1,d1
			@ShoveLoop
				add.w	d4,d4
				move.w	0(a3,d4),0(a3,d1)			; move em
			
				sub.w	#1,d0
				bls.s	@FinalMove					; move initial KCHR into its new home
				move.w	d4,d1
				move.w	d0,d4
				bra.s	@ShoveLoop		
			@FinalMove
				move.w	d2,0(a3,d4)					; finis! mission accompli!
				endwith
	ENDIF

@DoneSort	
		movem.l	(sp)+,SortRegs
		rts
; end
		endwith


;formFeed
;------------------------------------------------------------------------------------------ <25>
;	Utility CountDblByteIMs
;
;	Count the # of TSM style Input Methods in the System for a specific double-byte script 
;	and set a bit in the byte CJKcount(a6) that indicates whether or not an input method 
;	exists for the script.  Bits 0 - 4 are set thus: (CCJK): bit 4 = simpChinese, 
;	bit 3 = tradChinese, bit 2 = Japanese, bit1 = Korean.  Also updating the total # of 
;	input methods in d4 and TSMInputMthdCount(a6).
;
;	Input
;	a6	stack frame, menuFrame
;	d0	flags that indicate the script and the active key event bit
;	d2	bit to set in the byte CJKcount(a6)
;	d4	current count of inputs (KCHRs, input methods, etc.)
;
;	Uses
;	d0	result from _CountComponents
;
;	Output
;	d4						updated count of inputs (KCHRs, input methods (old-style and TSM-style), etc.)
;	TSMInputMthdCount(a6) 	updated count of TSM-style input methods
;------------------------------------------------------------------------------------------ <25>

CountDblByteIMs
		with	MenuFrame
		move.l	d0, CompDesc.componentFlags(a6)		; desired script & takes active key events
		subq	#4,sp						; result
		pea		CompDesc.componentType(a6)	; count components of this desc 
		_CountComponents
		move.l	(sp)+,d0
		bz.s	@noIMs
		bset.b	d2,CJKcount(a6)
		add.l	d0,d4						; can there really be a longInt worth of components???
		add.l	d0,TSMInputMthdCount(a6)
@noIMs
		rts
		endWith
		
;formFeed
;------------------------------------------------------------------------------------------	<7>
;	FUNCTION RebuildKeybdMenu: OSErr;
;------------------------------------------------------------------------------------------
;
; RebuildKeybdMenu is called by Mover to let us know that keyboards have
; been moved into or out of the System file, so we need to rebuild the
; keyboard menu.
;
;------------------------------------------------------------------------------------------
			
rkmFrame	record	{a6link},decr
result		ds.w	1						; OSErr result code.
rkmArgs		equ		*-8						; size of arguments.
selector	ds.l	1						; selector
return		ds.l	1						; return address.
a6link		ds.l	1						; old a6
; insert any local variables here
menuH		ds.l	1						;												<21>
rkmLocals	equ		*						; size of local variables
			endr

RebuildKeybdMenu
			with	rkmFrame,smgrRecord, AuxKeyboardMenuInfo	;
			link	a6,#rkmLocals			; link the stack.
			move.w	#noErr,result(a6)		; initialize noErr								<36>
			
; delete the old ptr to AuxKeyboardMenuInfo record so can store a new one					<10>
			movem.l	a2/d3,-(sp)
			GetSMgrCore	a0
; set munged count to tell the Keybd CDEV to rebuild it's list of KCHRs						<15>
			add.w	#1,smgrMunged(a0)		;												<15>
			move.l	smgrKeyboardMenuPtr(a0),a2
			tst.b	smgrKbdMenuAvail(a0)	;												<15>
			bne.s	@gotMenu				; got menu, so use info from it					<19>
; Get number of valid AuxKeyboardMenuInfo records into d3. If Keyboard menu is not			<19>
; up, we have a Roman-only system, so use KCHR count for Roman.								<19>
			with	ScriptRecord					;										<19>
			move.l	smgrEntry+(smRoman*4)(a0),a0	;										<19>
			moveq	#0,d3							; for wordizing							<19>
			move.b	scriptInputCount(a0),d3	; initialize item count to script's KCHR count	<19>
			bra.s	@DelIconSuiteLoop		;												<19><36>
			endwith							; ScriptRecord									<19>

@gotMenu									;												<19>
; Dispose of menu items & iconSuite handles for each menu item								<10>

; If an application doesn't have a menuBar then _GetMHandle will fail. What we 				<20>
; really want is to use the system menuBar and not the application menuBar.					<20>
			move.l	MenuList,-(sp)			; save the current menuList since it may be an apps menu <20>
			move.l	SystemMenuList,MenuList		;											<20>

			subq	#6,sp					; result for _GetMHandle & _CountMItems calls
			move.w	#kKeyboardMenuID, -(sp)	; menuID
			_GetMHandle
			tst.l	(sp)
			beq.s	@RestoreStack

			move.l	(sp),menuH(a6)			; want it for deletion of menuItems				<21>
			; leave menu handle on stack
; get # of menu items
			_CountMItems
			move.w	(sp)+,d3				; 												<36>
			move.l	(sp)+,MenuList			; restore the menuList							<20>
			move.w	d3,-(sp)				; save back on stack for next loop				<36>
			
; delete all the existing menu items (only if a menu exists!!!)								<36>
@DelMenuItemLoop
			move.l	menuH(a6),-(sp)			;												<21>
			move.w	d3,-(sp)				; item number									<21>
			_DelMenuItem					;												<21>
			dbra.w	d3,@DelMenuItemLoop
			move.w	(sp)+,d3				; initialize again for iconSuite loop			<36>

@DelIconSuiteLoop
; delete all the iconSuites
			tst.l	iconSuiteH(a2)
			beq.s	@NextItem
			sub.w	#2,sp
			move.l	iconSuiteH(a2),-(sp)	; storage for this iconSuite
			move.w	#$00,-(sp)				; dispose data flag = False
			_DisposeIconSuite
			tst.w	(sp)+					; pop result for now and don't bail				<36>
;;			move.w	(sp)+,d0				; sets CCs										<36>
;;			move.w	d0,result(a6)			; save											<36>
;;			bne		@done					;												<36>
@NextItem
			add.w	#AuxMenuInfoSize,a2		; next menu item
			dbra.w	d3,@DelIconSuiteLoop

			GetSMgrCore	a0
			move.l	smgrKeyboardMenuPtr(a0),a0	; auxiliary keyboard menu ptr		
			_DisposPtr
			move.w	d0,result(a6)

			subq	#2,sp					; space for OSErr result						<18>
			_InitKeybdMenu					;												<18>
			addq	#2,sp					; discard error result (we should really		<18>
			bra.s	@done
			
@RestoreStack
			addq	#6,sp					; results of _GetMHandle & _CountMItems
			move.l	(sp)+,MenuList			; restore the menuList							<20>
@done
			movem.l	(sp)+,a2/d3
			move.w	#rkmArgs,d0				; for StdUnlink
			bra		StdUnlink				; standard exit
			endwith

	IF DoCmdKeyEquivalents THEN				; 												<21>
			;------------------------------------------------------------------------------------------
			;		AddCmdKeyMenuItems
			;
			;		Not really a routine- just a place I've moved the code to get it out of the
			; 		middle of everything. Should be put back at 'bsr AddCmdKeyMenuItems' if we 
			;		want to use it.  CAN NO LONGER ASSUME "ABOUT KEYBOARDS… MENUITEM IS PRESENT!!! <34>
			;------------------------------------------------------------------------------------------
			AddCmdKeyMenuItems
						bsr		AddDisabledLine				; separate scripts by a disabled line
						tst.b	scriptCount(a6)				; more enabled scripts?
						bgt.s	@EnabledScriptLoop			; yup
				;------------------------------------------------------------------------------------------ <3>
				; add final items to menu
				@SetCmdKeyEquiv
						move.w	#NumItemsAfterKCHRs,d4		; num of cmd key equivalent items after KCHRs
						sub.w	#1,d4						; loop terminator: want 0 based
						move.w	#NextScriptIndex,d5			; first Cmd Key menu item is ‘Next Script’
				
				; (1st loop:) add ‘Next Script’ w/ a cmd key equivalent of ‘ ’ at the end
				; (2nd loop:) add ‘Next Keyboard’ w/ a cmd key equivalent of ‘ ’  at the end
				; my copy of the GetIndString library code: localGetIndString
					
						move.l  menuItemStringHdl(a6),a0
						tst.l	a0
						beq		@SetTitle					; if empty, just add title
				@CmdKeyLoop
						bsr		GetItemStr					;												<10>
						tst.l	NextItemString(a6)
						beq.s	@SetTitle					; error
				; since have a STR# resource, adding a disabled line (if it's not the last menu item)
						tst.w	d4							; is this the last item?
						beq.s	@SkipLine
						bsr		AddDisabledLine				; separate scripts by a disabled line
				@SkipLine		
				
				; name the menu item
						move.l	menuH(a6),-(sp)
						pea		NextItemString(a6)			; name of this KCHR: pString
						move.w	menuItem(a6),-(sp)			; insert ‘after’ this menuItem
						_InsMenuItem
				
				; Add cmd key equivalent (actually, due to current Menu Mgr limitations (no way to show 
				; CMD+space bar, no way to indicate CMD+SH and no way to show CMD+SH+space bar)
				; I will only put up the command key symbol (with a space).
				; Will need to add a table as this gets worked out, in order to add the correct chars
				; for each menu item's cmd key equivalent.
				
				; disable cmd key equivalents for now!														<5>
				;;		move.l	menuH(a6),-(sp)				;												<5>
				;;		move.w	menuItem(a6),-(sp)			; item #										<5>
				;;		move.w	d5,-(sp)					; temp: use string index (really want CMD+‘blank’)<5>
				;;		add.w	#$30,(sp)					; make it an ascii number						<5>
				;;		_SetItemCmd
						
				; if there is only one script enabled, disable the ‘Next Script’ menuItem
				; is this the ‘Next Script’ menuItem?
						cmp.w	#NextScriptIndex,d5
						bne.s	@NextKbd
						with	ExpandMemRec
						move.l	ExpandMem,a2
						move.l	emItlSysCachePtr(a2),a2		;													<9>
						endWith
						cmp.w	#1,(a2)						; is there only 1 script enabled?
						bhi.s	@NextItem					; nope
				; only 1 script's enabled so, disable item
						move.l	menuH(a6),-(sp)
						move.w	menuItem(a6),-(sp)
						_DisableItem
						bra.s	@NextItem
						
				@NextKbd
				; if there is only one KCHR for the default script, disable the ‘Next Keyboard in Script’ menuItem
				; last item is ‘Next Keyboard in Script’
						cmp.w	#NextKeybdIndex,d5
						bne.s	@NextItem
				; is there only 1 KCHR for this script?
						GetSMgrCore	a2						; the forgotten one!							<5>
						move.w	smgrKeyScript(a2),d2
						lsl.w	#2,d2
						move.l	smgrEntry(a2,d2.w),a3
						cmp.b	#1,scriptInputCount(a3)
						bhi.s	@NextItem
				; only 1 script's enabled so, disable item
						move.l	menuH(a6),-(sp)
						move.w	menuItem(a6),-(sp)
						_DisableItem
				@NextItem
						
						add.w	#1,menuItem(a6)
						add.w	#1,d5
						dbra.w	d4,@CmdKeyLoop
						endWith								;												<6>
	ENDIF
;___________________________________________________________________________________________________

		endproc									; this whole thing is one proc
;formFeed
;___________________________________________________________________________________________________
; GetIndString as taken from {Sources}Libs:InterfaceSrcs:ToolUtils.a
; (modified to return a pString)
;			getindstring(theString,strListID,index)
;			   char *theString <stringOut>;
;			   short strListID;
;			   short index;
;___________________________________________________________________________________________________

			BLANKS		ON
			STRING		ASIS

localGetIndString	proc	EXPORT

gsFrame		record	{a6link},decr
gsArgs		equ		*-8		; size of arguments.					<1>
theString	ds.l	1
strListID	ds.w	1
index		ds.w	1
return		ds.l	1		; return address
a6link		ds.l	1		; old link pointer
; insert any local variables here
gsLocals	equ		*		; size of local variables.			
			endr


			with	gsFrame
			link	a6,#gsLocals			; link
			move.l  d2,-(sp)				; save register d2
			subq	#4,sp					; GetResource result
			move.l  #'STR#',-(sp)			; theType
			move.w  strListID(a6),-(sp)		; strListID (was '14')
			_GetResource					; get resource
			move.l  theString(a6),a1		; theString (was '8'?)
			clr.b   (a1)					; assume empty
			move.l  (sp)+,d0				; handle to string list
			move.l  (sp)+,d2				; restore register d2
			tst.l   d0						; test result
			beq.s   gsret					; if empty, just quit

			move.l  d0,a0					; handle to string list
			move.l  (a0),a0					; pointer to string list
			cmp.l	#0,a0					; is the pointer NIL?					<35>
			bne.s	gsGet					; no, continue							<35>
			move.l	d0,-(sp)				; yes, so save handle 					<35>
			move.l	d2,-(sp)				; preserve register						<35>
			move.l	d0,-(sp)				; handle								<35>
			_LoadResource					;										<35>
			move.l	(sp)+,d2				; restore register						<35>
			move.l	(sp)+,a0				; get handle again						<35>
			move.l  (a0),a0					; deref again for ptr to string list	<35>
			move.l  theString(a6),a1		; restore theString						<35>
gsGet
			move.w  (a0)+,d0				; number of strings
			move.w  index(a6),d1			; index (was '18'?)
			ble.s   gsRet					; return if index <= 0

			cmp.w   d0,d1					; index > number of strings ?
			bgt.s   gsret					; return if index > number
			moveq   #0,d0					; clear for string lengths

gsLoop		subq.w  #1,d1					; decrement the index
			beq.s   gsCopy					; found the one we are looking for
			move.b  (a0)+,d0				; get length of this one
			add.l   d0,a0					; skip over this string
			bra.s   gsLoop					; and go on to next

gsCopy		move.b  (a0)+,d0				; get the length of this string
			move.b	d0,(a1)+				; store the length in the string (make a pString!)
			move.w  d0,d1					; save the length
			_BlockMove						; copy it into theString

gsRet		unlk	a6						; unlink
			move.l	(sp)+,a0				; pop return address.
			add.w	#gsArgs,sp				; pop arguments.
			jmp		(a0)					; return to the caller.
			endproc
;___________________________________________________________________________________________________
		
		end
;___________________________________________________________________________________________________
