;
;	File:		StandardWDEF.a
;
;	Contains:	This file contains the window definition procedure
; 				"DocumentProc", the standard Mac window type.
;  				It is a rectangular window with a title bar.
;
;	Written by:	Andy Hertzfeld  Aug 4, 1982; color interface by Chris Derossi
;
;	Copyright:	© 1982-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM5>	 5/27/93	SAM		Rereintroduced the change made in <34>.  Now after all these
;									years, Paul W. can finally sleep at night.
;	   <SM4>	12/16/92	HI		Removed the the instruction which sets ROMMapInsert to mapTrue before
;									GetResource() for 'wctb'. 'wctb' resource is modified by
;									programs such as Color CDEV and the StandardWDEF should read
;									the modified 'wctb' instead of the unmodifiable one from the
;									ROM. Previously, this prevented changing the window colors.
;									(Hoon Im)
;	   <SM3>	11/19/92	RB		Set ROMMapInsert to mapTrue before doing GetResource calls to
;									look in ROM first.
;		<SM1>	 10/22/92	CSS		Changed some short branches to regular branches as ROM direct
;									trap calling expanded code.
;		<37>	 10/6/91	DTY		#1005945: Put <34> back into the WDEF, conditionalized for
;									TheFuture.
;		<36>	 3/26/91	KSM		jdr+vl,#84033: To check for zoom flag, you MUST: (1) Decide that
;									this variant is a zooming variant, and (2) Insure that the spare
;									flag (showing handle allocated) is non-zero.
;		<35>	 3/19/91	VL		Rolled out <34> as GO5 said it's post-7.0. Now the file is the
;									same as <33>.
;		<34>	 3/18/91	VL		dty, Bug.Guide/#85080: The top line of the growicon was drawn
;									one pixel too low when the window is off the screen. Fixed the
;									problem by converting certain arithmetics operations from .l to
;									.w to avoid overflowing in the low word.
;		<33>	  3/4/91	dba		dty: get rid of SysVers conditionals and roll out the title bar
;									icon code that was accidentally left in
;		<32>	  3/1/91	VL		DFH, #83253 rollback: Rolled out changes in <30> as the fix only
;									obsures the crashing problem without solving it. The file should
;									be the same as <28>.
;		<31>	  3/1/91	VL		KSM, #KSM-004 rollback: Rolled out change <29> per Gang Of Five
;									but kept change <30>.
;		<30>	 2/28/91	DFH		VL,#83253: Made sure to use long word operations to calculate
;									addresses from offsets. Was using word-sized, which caused
;									intermittent crashes, since result was incorrect.
;		<29>	 2/27/91	KSM		vl,#KSM-004: BTST.B #0 the wZoom flag rather than TST.B to keep
;									from conflicting with people who call modal dialog on
;									non-dBoxProc variants (like Claris’ MacWrite IIv1.1 spell check)
;		<28>	 2/21/91	VL		dba, #82019: Fixed the problem of the racing stripes are drawn
;									over the window frame.
;		<27>	 2/19/91	VL		csd, #83215: Do not draw to WMgrCPort and use DeviceLoop when
;									drawing offscreen grow icon.
;		<26>	 1/14/91	VL		(dba) DrawGIcon should draw a black box when inactive due to
;									incompatibility with Finder and applications interface.
;		<25>	  1/2/91	VL		(ngk) Fixed the bug of not restoring clipRgn correctly in
;									DrawGIcon.
;		<24>	 11/9/90	VL		(dc) Titles should be drawn in black in non-color windows (undo
;									the changes in <21>).
;		<23>	10/30/90	VL		(dc) Fixed the off-by-one error in DrawGIcon by using SubPt
;									instead of sub.l for the global offset.
;		<22>	11/19/91	VL		(dc) Title should be drawn in TrueGray or Dithered Gray when
;									window is inactive. Also, System wctb should be used when an
;									old-style wctb is encountered in an app. Only when the system
;									wctb is not available should the default wctb in the code be
;									used.
;		<21>	 10/8/90	VL		(dc) Create a bogus color table for pmap when we do copybits. This is
;									necessary since QuickDraw expects it when we are copying to a
;									picture. Changed the offset to pixmap data since one more field
;									(or word) is added to store the number of bits per pixel (this
;									field is actually not used in this WDEF yet. But for the sake of
;									consistency with CDEF, the field is added).
;		<20>	 10/4/90	VL		Changed the color definition for WLTinge4.
;		<19>	 9/26/90	SAM		Commented out wZoom redefinition.
;		<18>	 9/20/90	VL		Lightened the title string gray because no one except Dean and
;									Tantek likes the dark gray. (Refer to <12> for history).
;		<17>	 9/15/90	VL		Switch to sysZone before FillRect so that the pixpat created
;									will be persistent.
;		<16>	 9/14/90	csd		Removed the local definition of _DeviceLoop.
;		<15>	 8/29/90	VL		Fixed "long title not truncated properly" bug by adjusting the
;									right indent into the title.
;		<14>	  8/7/90	DTY		Changed forecolor in PlotSymbol so the close and zoom boxes
;									highlight in gray, not color.
;		<13>	  8/7/90	DTY		Tweaked the dark tinge color to make windows look more like
;									Paulien’s drawings.
;		<12>	  8/6/90	DTY		Darkened the title string gray again because Tantek didn’t like
;									the light gray.
;		<11>	  8/4/90	DTY		Changed gray of inactive title string to match that generated by
;									DrawGrayishText.
;		<10>	  8/4/90	DTY		Fix some glitches in the drawing that I missed because I was
;									hallucinating or something. Changed some “'”’s to “’”’s for the
;									hell of it.
;		 <9>	  8/4/90	DTY		Mutilated drawing code to implement the new color scheme.  Added
;									code to dim windows to gray when deactive.
;		 <8>	 7/13/90	DVB		Turned on the color code.
;		 <7>	 5/24/90	csd		Turn the code back on to always allocate a data handle.
;									MultiFinder is overloading spareFlag, causing our tests to think
;									there’s a valid data handle.
;		 <6>	 5/17/90	csd		init pen to white background and black foreground; don’t
;									allocate data handle if there’s no zoom box.
;		 <5>	 4/13/90	csd		Disabled (temporarily) the color interface by requiring 33
;									bits/pixel in CheckAvailableColors.
;		 <4>	 4/12/90	HJR		Fix undefined sysvers for rom builds.
;		 <3>	 4/11/90	csd		Major rewrite to support shaded windows and _DeviceLoop. Also
;									includes movable-modal (variant 5) windows.
;		<1+>	  2/6/90	JRM		allow popup drawn to right of title, try out title icon in place
;									of close box
;
;	To Do:
;

;EASE$$$ READ ONLY COPY of file “StandardWDEF.a”
; 1.8	JSM 11/27/1989 Support icon in title bar for 7.0 only.
; 1.7	JSM 11/04/1989 and FJS. Added one pixel to the top and bottom of title
;		bars with small icons.
; 1.6	JJJ 08/29/1989 Fixed parameter setup before DisposHandle after label DisposeDoc.
; 1.5	SES 08/22/1989  Removed references to nFiles.  Updated equates accordingly.
; 1.4	JRM 08/07/1989 added support for optional icon in title bar
; 1.3	DAF 07/16/1989 Updated WDEF=0's version number.
; 1.2	DAF 07/14/1989 FOR AURORA BUILD - but affects all system builds also.
;		Reinstated true drop shadow on document windows on all machines.
; 1.1	CCH 11/11/1988 Fixed Header.
; 1.0	CCH 11/ 9/1988 Adding to EASE.
; OLD REVISIONS BELOW
;•1.1	CCH 9/23/1988 Got rid of inc.sum.d and empty nFiles
; 1.0	BBM 2/12/88 Adding file for the first time into EASE…
; END EASE MODIFICATION HISTORY
;
;  Modification History:
;
;	 21-Aug-82	AJH  Made DocumentProc support rectangular windows only
;	 30-Aug-82	AJH  Added growIcon hit detection, fixed hit to exclude perimeter drag
;	 07-Sep-82	AJH  Added handler for grow message
;	 12-Sep-82	AJH  Made it so proc doesn't have to calcRgns when not visible
;	 20-Sep-82	AJH  Added go-away button drawing and hit-testing
;	 25-Sep-82	AJH  Added cheap dialogBox window definition proc
;	 28-Sep-82	AJH  New GoAway button; restructured goAway drawing
;	 05-Oct-82	AJH  Removed Init message to save code
;	 06-Oct-82	AJH  Fixed dialogBox dragRgn bug
;	 10-Oct-82	AJH  Converted to QuickDraw trap interface
;	 16-Oct-82	AJH  Fixed GoAway hit-test origin bug
;	 17-OCt-82	AJH  Made both windowProcs preserve A1
;	 07-Nov-82	AJH  Changed DocumentProc hiliting to Lisa way
;	 14-Nov-82	AJH  Improved shape of Grow outline ala Lisa
;	 16-Nov-82	AJH  Made branch table offset-based to save space
;	 16-Nov-82	AJH  Special-cased hiliting of small windows
;	 20-Dec-82	AJH  Changed title bar to 20 pixels tall
;	 24-Dec-82	AJH  Made wProcAsm a separate assembly
;	 17-Mar-83	AJH  Added third variant -- shadowless dBoxProc
;	 27-Apr-83	AJH  only plot, hit-test goAway if window is active
;	 25-Jul-83	SC	 Fixed third variant -- frame was incorrect, see DrawDBox
;	 06-Aug-83	AJH  changed hiliting to use pattern
;	 09-Aug-83	AJH  added draw grow icon message receiver
;	 20-Aug-83	AJH  made it only hit-test or draws goAway if window is active
;	 29-Oct-83	AJH  new dBox border
;	 10-Nov-83	AJH  added variant 4 -- just like variant 0, but no inGrow
;	 24-Dec-83	AJH  fixed structRgn calc bug in variant 1
;	 24-Feb-84	AJH  fixed hit-testing of go-away -- was off by 2
;	 09-Jan-85	JTC  modified for MDS assembly: label DocumentProc changed
;					 to DocProc to avoid collision.
;	 15-Jan-85	EHB  fixed erase of 3 pixels of content rgn in DrawFrame;
;					 prevented erase of top line in DoTitleString.
;	 15-Jan-85	EHB  eliminated title flicker in CheckHilite; gnrl cleanup
;	 30-Jan-85	EHB  fixed boundary testing of GoAwayBox
;	 14-Feb-85	JTC  named rsrc.
;	 16-May-85	EHB  For GrowBox hitTesting, changed D4=16 to D4=14
;v3  16-May-85	EHB  Check left of window title when no grow box too
;	 29-Jul-85	EHB  converted back to porkshop
;v4   5-Aug-85	EHB  Allow variable size titles
;v5  29-Aug-85	EHB  Variant 8 knows how to zoom
;	 18-Sep-85	EHB  Added routine ChkPoint to allow slop on large zoom size
;	 09-Oct-85	EHB  Added designer zoom icon, restored old close mask
;	 18-Oct-85	EHB  New Zoom positioning (avoid lawsuits). Needs title fixes too
;					 Add tempRgn to frame to save clip, to calc window's region
;	 18-Oct-85	EHB  Only allow zooming on new ROMs (just in case)
;	 21-Oct-85	EHB  In HitDoc, use BuildTBarRect to hit-test title bar.  The old
;					 way didn't work with null content regions.
;	 03-Nov-85	EHB  Zoom was one pixel too far left (fix draw and hit)
;
;-Reno World------------------------------------------------------------------
;
;	 <C59/30Jun86> DAF  Added color support on nuMac. Dropped Krispee stuff
;	 <C117/25Sep86> DAF Updated defproc to use RGBForeColor/RGBBackColor
;	 <C203/06Oct86> DAF Updated SetUpColor to look up window part color rather
;						than assume part from position.  Changed textMode to
;						srcOr for titleString.  Made window rgn square
;						conditionally.
;	 <A285/28Oct86> DAF	Changed SquareWindows conditional to be true on nuMac only.
;	 <C407/16Nov86> DAF	Changed textMode to srcCopy, per Cary's recommendation
; 	 <C424/18Nov86> DAF	Added portToMap to correct problems in cWindows.
;	 <C491/08Dec86> DAF Locked titleString handle before drawing (OLD BUG!)
;	 <C666/22Jan87> DAF Universal defproc (version 10).  With the exception of
;						Square window flag, this defproc no longer has conditional
;						build sections (all system determination is dynamic)
;	 <C700/26Jan87> DAF Square windows now supported dynamically
;
;- Aurora and System 6.0.4 ---------------------------------------------------
;
;	  <1.2>			DAF	Removed square document windows due to popular demand.
;						Two changes (one in draw, one in calc).  Search for
;						';!!!'
;	  <1.3>			DAF	Upped version number by one.
;
;- 7.0 ---------------------------------------------------
;	  <1.4>			JRM	optional small icon drawn to left of window title
;						icon handle stored in bigger wDataHandle (now two zoom rects and icon handle)
;						re-rolled in S369 (rederef region to avoid heap scramble bug)

			STRING		ASIS

			PRINT		OFF
			LOAD		'StandardEqu.d'
			INCLUDE		'colorEqu.a'
			PRINT		ON

			hasTitleBarIcon: EQU 0

; ================================================
; REGISTERS
; ================================================
; registers being used and need to be preserved

rectReg		EQU		A4			; rectangle’s address is kept in reg
windowReg	EQU		A3			; window pointer address is kept in reg
titleHgtReg	EQU		D7			; window’s title bar height in reg
paramReg	EQU		D6			; parameter passed in function call
varCodeReg	EQU		D5			; varCode passed in funciton call

; ================================================
; CONSTANTS
; ================================================

HiliteFlagGlobal	EQU		$B20	; low memory with hiliting flag
HiliteFlagBit		EQU		0		; bit 0 in HiliteFlagGlobal byte

zoomBit 	EQU 	3			; bit 3 is zoom bit
growBit 	EQU 	2			; bit 2 is grow bit

IconSize	EQU		20			; width of small icon in title
minTitleH	EQU		19			; minimum title bar height without SICN
minTitleHIcon EQU	21			; minimum title bar height with SICN

dboxWithTitle	EQU		5		; proc ID of dBoxProc with title bar
dBoxBorderSize 	EQU		7		; dBoxProc border size
proc5TopAdjust	EQU		4		; title and border share some area
proc5HitZAdjust	EQU		6		; zoom box is more to the left
scrollBarSize	EQU		16		; size of scroll bar area

wHiliteLight		EQU		5
wHiliteDark			EQU		6
wTitleBarLight		EQU		7
wTitleBarDark		EQU		8
wDialogLight		EQU		9
wDialogDark			EQU		10
wTingeLight			EQU		11	; For color tinges in title bar & gadgets
wTingeDark			EQU		12

lowestShadeIndex	EQU		16
wHiliteShade0		EQU		16
wHiliteShade7		EQU		17
wHiliteShade8		EQU		18
wHiliteShadeA		EQU		19
wHiliteShadeD		EQU		20
wTitleBarShade0		EQU		21
wTitleBarShade1		EQU		22
wTitleBarShade4		EQU		23
wDialogShade0w		EQU		24
wDialogShade4w		EQU		25
wDialogShade6w		EQU		26
wDialogShadeBb		EQU		27
wDialogShadeF		EQU		28
wDialogShade0b		EQU		30
wDialogShade4b		EQU		31
wDialogShade6b		EQU		32
wDialogShadeBw		EQU		33
wLTinge0			EQU		34
wLTinge4			EQU		35
wDTingeF			EQU		36

wZoomGadget			EQU		0
wGoAwayGadget		EQU		1
wZoomHilitedGadget	EQU		2
wGoAwayHilitedGadget	EQU		3
wGrowGadget			EQU		4

kPixmapID			EQU		-14336
kHighlightPix		EQU		-14334

minWCTBDepth		EQU		4
minColorDepth		EQU		8


; <27> fakeDeviceFlags is used when we bypass DeviceLoop and draw the grow icon directly, and we’re
; on a machine that doesn’t have Color QuickDraw.

fakeDeviceFlags		equ		$A801


; ================================================
; TYPES
; ================================================
; There records are only types, they do not allocate space
; ------------- FontInfo record TYPE -------------
WInfoRec	RECORD	0				; FontInfo record type
WAscent		ds.w	1
WDescent	ds.w	1
WHeight		ds.w	1
WBoxDelta	ds.w	1
			ENDR

; ------------- RGBInfo record TYPE -------------
RGBInfoRec	RECORD	0				; RGBColor record type
red			ds.w	1
green		ds.w	1
blue		ds.w	1
			ENDR

WDefDrawFrame	RECORD	0				; stack frame for DeviceLoop draw proc
retAddress		ds.l	1				; return address
StartParams		EQU		*
userData		ds.l	1				; long we passed to DeviceLoop
devHandle		ds.l	1				; GDevice handle
deviceFlags		ds.w	1				; flags for current device
depth			ds.w	1				; bits/pixel for this call
ParamSize		EQU		*-StartParams
				ENDR


; ================================================
WDEF0		PROC		EXPORT
; ================================================

; FUNCTION MyWindow(varCode: INTEGER; window: WindowPtr;
;					message: INTEGER; param: LongInt): LongInt

; Create a stack frame recode that matches the above function.
; The parameters passed on the stack are between ParamBegin and ParamSize.
; ParamSize the number of bytes to be removed (poped) off the stack after
; the UNLINK instruction.  Any local variables to be created are listed
; between A6Link and LinkSize.  LinkSize is the size of the entire stack
; frame and it the number of bytes used in the LINK instruction.  To add
; more local variables, insert it between A6Link and LinkSize.

StackFrame	RECORD	{A6Link},DECR	; build a stack frame record
ProcResult	ds.l	1				; function’s result returned to caller
ParamBegin	EQU	*					; start parameters after this point
;			parameters on stack
varCode		ds.w	1				; variation code
window		ds.l	1				; the window pointer
message		ds.w	1				; operation to perform
param		ds.l	1				; addition information based on message
ParamSize	EQU		ParamBegin-*	; size of all the passed parameters
RetAddr 	ds.l	1				; place holder for return address
A6Link		ds.l	1				; place holder for A6 link
;			local variables being allocated
SavFgCol	ds		RGBInfoRec		; saved WMgrCPort ForeColor (color only)
SavBkCol	ds		RGBInfoRec		; saved WMgrCPort BackColor (color only)
WInfo		ds		WInfoRec		; record for font and other info
OldPort		ds.l	1				; current port to be restored
TempRgn		ds.l	1				; temporary region handle
AuxCTab		ds.l	1				; handle to auxCTable (color only)
AuxCPtr		ds.l	1				; pointer to auxCTable (color only)
IsColor		ds.b	1				; have colorQD in toolbox? [boolean]
IsTitleIcon	ds.b	1				; do we have an icon in the title bar?
IsProcFive	ds.b	1				; dBox with title bar? [boolean]
threeDWind	ds.b	1				; conditions right for System 7 windows?
curDepth	ds.l	1				; current drawing depth for SetupColor
startRGB	ds.w	3
endRGB		ds.w	3
tempRGB		ds.w	3
workPixMap	ds.l	1
gadgetHighlight	ds.w	1
tempPixels	ds.l	1
globalOffset	ds.l	1			; Amount to offset when drawing grow icon in WMgrPort
curZone		ds.l	1				; temporary storage for theZone <17>
bogusCtab	ds.l	1				; handle to bogus color table							<21>
hasZoom		ds.b	1				; TRUE if this window has a zoom box
			align
LinkSize	EQU 	*				; size of all the local variables
			ENDR


; ================================================
; MAIN entry point in the WDEF.
; ================================================
; Jump over the defined data and get to the code.

DocProc		bra.s	WDEFStart			; and a way we go


; Define in the code segment necessary data.  The standard header
; is first then additional data used in the WDEF.

			dc.w	0					; flags word
			dc.b	'WDEF'				; resource type
			dc.w	0					; resource ID
			dc.w	15					; version number


; ================================================
WDEFStart								; start of the WDEF code
; ================================================
			WITH	StackFrame			; cover our local stack frame
			LINK	A6,#LinkSize 		; set stack frame to address params
			moveM.l D3-D7/A1-A4,-(SP)	; save work registers
			clr.l	ProcResult(A6)		; initialize funtion’s result

; test if the message is in range

			cmp.w	#wGIconMsg,message(A6)	; compare to highest value			 DAF
			BGT 	WDEFEnd					; skip it, it’s too high			 DAF
			cmp.w	#wDrawMsg,message(A6)	;  compare to lowest value, too		 DAF
			BMI 	WDEFEnd					;

			move.l	(A5),A0 			; get pointer to QuickDraw globals
			move.l	(A0),OldPort(A6)	; save current port

; ------------- fetch the parameters -------------

			move.l	window(A6),windowReg ; get the window pointer
			lea 	TempRect,rectReg	; get TempRect address in a reg
			move.l	param(A6),paramReg	; get the param	in a reg
			move.w	varCode(A6),varCodeReg	; get the selector integer
IsThereZoom 
			BTST	#zoomBit,varCodeReg ; zooming variant				<36>
			BEQ.S 	IsNoZoom			; => no 						<36>
			TST.B	wZoom(A3)			; did we get the handle?		<36>
IsNoZoom	
			sne.b	hasZoom(a6)			; Set true only if both			<36>
			AND.w 	#3,varCodeReg		; ignore "inGrow" variant

; ------------- is the dBox with title? -------------
; determine if this is a dBoxProc using a title

			move.w	varCode(A6),D0		; get real selector
			AND.w	#7,D0				; AND off higher bits
			cmp.w	#dboxWithTitle,D0	; compare against new proc
			SEQ.b	IsProcFive(A6)		; set if dBox with title

; ------------- Determine type of system -------------
; We need to know if we have color QuickDraw and a color window manager port.

			cmp.w	#$3FFF,ROM85		; do we have color QD?
			SLS		IsColor(A6)			; set boolean depending on color or B&W system
			BLS.s	@ColorSys			; this system has color QD

			move.l	WMgrPort,-(SP)		; B&W, set to window manager port
			_SetPort					;
			bra		@CommonSys			; done for the B&W environment <SM1> CSS

; ------------- doin it with color -------------
; when using the WMgrCPort, it is the defproc’s responsibility to reconcile
; the WMgrPort and the WMgrCPort.  Also find the auxWinRec and lock it down
; This compares the pertinent fields of the WMgrPort and the WMgrCPort,
; updating the WMgrCPort as necessary to match the WMgrPort.

@ColorSys	move.l	WMgrCPort,-(SP)		; make the WMgrCPort the current port
			_SetPort					; set it
			move.l	WMgrPort,A0			; get the WMgrPort addr
			move.l	WMgrCPort,A1		; and the WMgrCPort too
			pea		bkPat(A0)			; push pointers to pattern for later
			pea		pnPat(A0)			;
										; copy all fields from pnLoc to end of grafPort,
										; excluding pnPixPat and fillPixPat
			lea		pnLoc(A0),A0				; point at source
			lea		pnLoc(A1),A1				; point at dest
			move.l	(A0)+,(A1)+					; copy pnLoc
			move.l	(A0)+,(A1)+					; copy pnSize
			move.w	(A0)+,(A1)+					; copy pnMode
			addq	#8,A0						; skip pnPat (aka, pnPixPat,fillPixPat)
			addq	#8,A1						;
			move.w	#((portRec-pnVis)/2)-1,D0	; set up a counter (long sized)
@1			move.w	(A0)+,(A1)+					; copy it
			Dbra	D0,@1						; loop
												; now set up the patterns in the WMgrCPort
			_PenPat								; (which is thePort) the parameters were
			_BackPat							; pushed before the copying loop above

			pea		SavFgCol(A6)		; push a pointer to save area
			_GetForeColor				; get the current color
			pea		SavBkCol(A6)		;
			_GetBackColor				;
			move.l	#blackColor, -(SP)	; set default colors
			_ForeColor
			move.l	#whiteColor, -(SP)
			_BackColor

; ------------- get auxWinRec -------------

			clr.l	-(SP)				; here’s a space for the var handle
			clr.w	-(SP)				; function return here
			move.l	windowReg,-(SP)		; push window ptr
			pea		6(SP)				; a pointer to the space above
			_GetAuxWin					; find the auxrec
			addq	#2,SP				; pitch the boolean (it doesn’t matter)
			move.l	(SP)+,A0			; get the auxRecHandle
			move.l	(A0),A0				; handle -> ptr
			move.l	awCTable(A0),A0		; get the colortable handle
			move.l	A0,AuxCTab(A6)		; save this handle
			_HLock						; lock the table down in memory
			move.l	(A0),AuxCPtr(A6)	; and get a pointer too!

; ------------- setup window info -------------
; Get the font info for this window.  Put the height of the title bar in
; titleHgtReg and wHeight(A6).  Put distance of the top of the goaway box
; from the top of the bar in WBoxDelta(A6).
;

@CommonSys	pea		WInfo(A6)			; push pointer to a FontInfoRec
			_GetFontInfo				; and get the font’s info
			move.w	WInfo.wAscent(A6),titleHgtReg ; get font ascent
			add.w	WInfo.wDescent(A6),titleHgtReg ; add descent
			addq.w	#4,titleHgtReg		; get the height
			BSET	#0,titleHgtReg		; make height odd for symmetry
			moveq	#minTitleH,D1		; get min title height for no icon

			cmp.w	D1,titleHgtReg		; force height to minimum
			bge.s	@3					; => not a tiny font
			move.w	D1,-(SP)			; save min title height on stack
			sub.w	titleHgtReg,D1		; how much less than minimum is it?
			LSR.w	#1,D1				; used for centering tiny fonts
			add.w	D1,WInfo.wAscent(A6) ; make the ascent "bigger"
			move.w	(SP)+,titleHgtReg	; pop min title height
@3			move.w	titleHgtReg,WInfo.wHeight(A6) ; WHeight=ascent+descent+2
			move.w	titleHgtReg,D0		; get height
			sub.w	#13,D0				; subtract height of box
			LSR.w	#1,D0				; divide by 2
			move.w	D0,WInfo.wBoxDelta(A6) ; save delta to goAway box

; ------------- create a temp region -------------

			clr.l	-(SP)				; create a temp region
			_NewRgn 					; get a new region
			move.l	(SP)+,TempRgn(A6)	; and save in our frame

; ------------- get a pixmap for drawing the gadgets ------------

			subq.l	#4, SP					; room for a PixMapHandle
			move.l	#'pmap', -(SP)			; the Pixmap resource type
			move.w	#kPixmapID, -(SP)		; ID of working pixmap
			move.w	#MapTrue,RomMapInsert	;												<SM3> rb
			_GetResource					; look in ROM first								<SM3> rb
			move.l	(SP)+, workPixmap(A6)	; save it for later
			move.l	#16,D0					; allocate a bogus ctab 						<21>
			_NewHandle	,SYS,CLEAR			;	in sys heap with 0 entries					<21>
			move.l	A0, bogusCtab(A6)		; store the ctab so that we can dispose of it	<21>
			move.l	workPixmap(A6),A0		; get the pixmap								<21>
			move.l	(A0),A0					; get ptr to pixmap								<21>
			move.l	bogusCtab(A6),pmTable(A0)	; put the bogus ctab in our pixmap			<21>
			clr.l	tempPixels(A6)			; init this to NIL

; ------------- go handle the message -------------

			move.w	message(A6),D0		; get message
			ADD 	D0,D0				; double for word index
			lea 	GoDocProc,A0		; get jump table address
			add.w	GoDocProc(D0),A0	; compute dispatch address
			jsr 	(A0)

; ------------- prepare to exit WDEF -------------
; Dispose of all data allocated and restore port

			move.l	bogusCtab(A6),A0	; Dispose the bogus Color table						<21>
			_DisposHandle				;
			move.l	TempRgn(A6),-(SP)	; dispose of temp region
			_DisposRgn					;
			tst.b	IsColor(A6)			; are we on a color system?
			beq.s	@NoColor2			; if on B&W, then skip

; ------------- color clean up -------------
; unlock the color table and restore the fore- and backColors									 DAF

			move.l	AuxCTab(A6),A0		; get the colortable handle
			_HUnlock					; release it
			pea		SavBkCol(A6)		; pointer to RGBColor
			_RGBBackColor				;
			pea		SavFgCol(A6)		; pointer to RGBColor
			_RGBForeColor				;
@NoColor2								; END OF A COLOR-ONLY SECTION

			move.l	OldPort(A6),-(SP)	; restore previous port
			_SetPort

; ------------- End of WDEF -------------
WDEFEnd									; ‘Out Of Range, of course’
			moveM.l (SP)+,D3-D7/A1-A4	; restore work registers
			UNLK	A6					; unlink stack frame
			move.l	(SP)+,A0			; get return address
			ADD 	#ParamSize,SP		; strip parameters
			jmp 	(A0)				; return to caller


; ------------- WDEF message jump table -------------
; dispatch table -- entries must be long branches!

GoDocProc	dc.w	DrawDoc-GoDocProc	; draw is message #0
			dc.w	HitDoc-GoDocProc	; hit test is message #1
			dc.w	CalcDoc-GoDocProc	; calc test is message #2
			dc.w	InitDoc-GoDocProc	; init is message #3
			dc.w	DisposeDoc-GoDocProc ; dispose is message #4
			dc.w	GrowDoc-GoDocProc	; grow message is #5
			dc.w	DrawGIcon-GoDocProc ; draw grow icon is #6

; ================================================
; wNew message
; ================================================
; InitDoc is used to initialize our zoom size and title icon handle
; Need to make sure the goAway is ignored if the application tried to
; set this flag.  Changing this here will change the window record.
; The application could set the goAway flag after creating the window,
; but that doesn’t seem likely to happen.

InitDoc
			tst.b	IsProcFive(A6)		; dBoxProc with title bar?
			beq.s	@KeepGoAway			; no, don’t touch goAway flag
			clr.w	wGoAway(windowReg)	; yes, then clear the flag out
@KeepGoAway
			moveq	#8+8,D0				; space for 2 rects

			_NewHandle ,clear			; allocate the space
			move.l	A0,wDataHandle(windowReg)	; save handle to data
			beq.s	InitDone					; => not able to get space

			move.w	varCode(A6),D0
			Btst	#zoomBit,D0			; does it want a zoom box?
			beq.s	InitDone			; no, then we’re done

; ------------- initialize userState and stdState -------------
; set default zoom data.  Consists of 2 rects: SmallSize, BigSize
; get the size of the zoomed out window in global coordinates.	To do this,
; pull the screen size from screenbits.bounds and indent a little.

			addq.b	#1,wZoom(windowReg)	; set zoom flag to TRUE
			move.l	(A0),A2 			; point to data
			addq.w	#8,A2				; point to bigSize
			move.l	GrafGlobals(A5),A1	; point to QuickDraw globals
			move.l	screenBits+bounds(A1),(A2)+ 	; get topLeft
			move.l	screenBits+bounds+4(A1),(A2)+	; get botRight
			moveq	#3,D0							; get indent

; Zooming the dBoxProc with a title.  Here I set the alternate size to be
; further inset of the screen.  This doesn’t take into account the
; normal zoomable windows have a shadow and this causes the proc=5 to be
; zoomed out one pixel short on the right edge.  Also, since proc=5 shares
; a portion of the title area with the fancy border of the content this
; makes the title bar zoom a few pixels lower than normal window.
; Applications using this window are suppose to manually set the alternate
; size anyway, so I’m not too concerned about this.

			tst.b	IsProcFive(A6)		; dBoxProc with title bar?
			beq.s	@1					; no, use normal sizing
			addq.w	#dBoxBorderSize,D0	; add fancy border to sizing

; ------------- inset stdState based on indentation -------------
@1
			sub.w	D0,-(A2)			; indent right
			sub.w	D0,-(A2)			; indent bottom
			add.w	D0,-(A2)			; indent left
			add.w	D0,-(A2)			; indent top
			move.w	MBarHeight,D0 		; get menu bar height
			add.w	D0,(A2)				; past menu bar height
			add.w	titleHgtReg,(A2) 	; and past window title

			move.l	(A0),rectReg 		; point at userState
			bsr		GetRect				; convert rect to global
InitDone	rts

; ================================================
; wDispose message
; ================================================
; DisposeDoc is called when the window is being closed.  All we need to do is
; give back the handle we borrowed.

DisposeDoc
			move.l	wDataHandle(windowReg),D0	; a data handle?
			beq.s	DisposeDone			; no, then we’re done

			move.l	D0, A0				; get data handle
			_DisposHandle				; release it, ignoring errors

DisposeDone	rts


; ================================================
; wDraw message
; ================================================
; DrawDoc -- draw the document window.   The windowPtr is in windowReg
; First test for a EORGoAway call and special case it
; Put shadowing about into D4.

DrawDoc		tst.b	wVisible(windowReg)		; is it visible?
			beq 	@exitDrawDoc 			; if not, don’t do anything

; ------------- set up shadow -------------

			_PenNormal					; we want the normal pen
			move.l	OneOne,D4			; get shadow factor, assume 1,1
			tst.w	varCodeReg			; documentProc?
			beq.s  	@1					; if so, we’re cool

			add.l	D4,D4				; double the shadow to 2,2
			cmp.w	#3,varCodeReg		; does it have shadow?
			beq.s  	@1					; if so, we’re cool
			moveq	#0,D4				; otherwise no shadow

@1
			move.l	structRgn(windowReg), -(SP)
			pea		WDefDrawWindow		; address of devloop drawing proc
			clr.l	-(SP)				; no unusual activities
			clr.l	-(SP)				; and no user data
			_DeviceLoop

			cmp.w 	#wInGoAway,paramReg ; was it an XOR call?
			blt 	@exitDrawDoc		; if not, don’t invert state bit
			eor.b	#1<<HiliteFlagBit, HiliteFlagGlobal

@exitDrawDoc
			rts


WDefDrawWindow

			with	WDefDrawFrame

			move.w	depth(SP), curDepth(A6)	; save this for SetupColor magic
			move.l	devHandle(SP), D1		; pass this drawing device
			bsr		CheckAvailableColors	; see if we have enough colors

			cmp.w 	#wInGoAway,paramReg ; is it a goAway call?
			bge 	EORStuff			; if so, go handle it

			bclr	#HiliteFlagBit, HiliteFlagGlobal	; otherwise, init hilite flag

; ------------- frame the window’s body -------------

			tst.b	wHilited(windowReg)	; Is window highlighted?
			bz.s	@inactiveFrame		; don’t draw shaded title bar
			moveq	#wFrameColor,D0		; get fore color
			bra.s	@frameShadeCorrect
@inactiveFrame
			moveq	#wHiliteShadeA,D0		; Get fore color
@frameShadeCorrect
			moveq	#wContentColor,D1	; get back color
			bsr		SetupColors			; set ’em up

			bsr		StructInTemp		; get StrucRgn.rgnBBox in rectReg
			sub.l	D4,botRight(rectReg) ; inset botRight to ignore shadow
			move.l	rectReg,-(SP)		; push rect address
			_FrameRect					; frame the body

			cmp.l	#0,D4				; any drop shadow?
			beq.s	NoDrop				; if not, skip

; ------------- draw the drop shadow -------------
; paint the drop shadow, shadow amount in D4

			moveq	#wFrameColor,D0		; Draw drop shadow with frame color always
			bsr		SetupForeColor

			move.l	D4,-(SP)			; push shadow factor
			_PenSize					; make penSize = shadow factor
			move.w	right(rectReg),-(SP) ; push right
			move.w	top(rectReg),-(SP)	; push top
			add.w	D4,(SP)				; add shadow factor
			_MoveTo 					; MoveTo(right,top+shadow)
			move.w	right(rectReg),-(SP) ; push right
			move.w	bottom(rectReg),-(SP) ; push bottom
			_LineTo 					; LineTo(right,bottom)
			move.w	left(rectReg),-(SP)	; push left
			add.w	D4,(SP)				; add shadow factor
			move.w	bottom(rectReg),-(SP) ; push bottom
			_LineTo 					; LineTo(left+shadow,bottom)
			_PenNormal					; restore normal pen

NoDrop		cmp.w 	#1,varCodeReg		; dBoxProc?
			bne		NotFancy			; if not, skip

; ------------- draw fancy border -------------
; draw fancy for dialog box ( only for variant 1).  The code is a little
; difficult to follow, but it saved some bytes this way.  New feature
; for a dBoxProc that’s deactive is that it get a gray frame.  Also, I
; removed the flicker that used to happen when a dBoxProc went deactive.

; In the case of the dBoxProc with title bar, the fancy border needs to
; consider the title area, and that the bottom of the title area is shared
; with the fancy border by a few pixels.

			tst.b	IsProcFive(A6)		; dBoxProc with title?
			beq.s	@1					; no, then don’t adjust framing

			add.w	titleHgtReg,top(rectReg) ; TempRect still in rectReg
 			subq.w	#proc5TopAdjust,top(rectReg) ; tweak it
@1
			move.l	rectReg,-(SP) 		; push the window’s structure rect
			move.l	OneOne,-(SP)		;
			_InsetRect					; inset TempRect

			lea		borderShades,a2		; Get shades for fancy border
			tst.b	wHilited(windowReg)	; Is window highlighted?
			bnz.s	@drawBorders		; Yes.  Go draw the borders
			add.w	#$10,a2				; Use gray shades for inactive windows
			tst.b	threeDWind(a6)		; Are we using System 7 windows?
			bnz.s	@drawBorders		; Yes, start drawing
			move.l	GrafGlobals(a5),a0	; No.  Use dithered gray
			pea		gray(a0)
			_PenPat
@drawBorders
			move.w	(a2)+, -(SP)		; lower right shade
			move.w	(a2)+, -(SP)		; upper left shade
			move.w	(a2)+, -(SP)		; shade for corners
			bsr		DrawShadedRect		; _FrameRect with shades

			move.l	rectReg,-(SP) 		; push the window’s structure rect
			move.l	OneOne,-(SP)		;
			_InsetRect					; inset TempRect
			move.w	(a2)+, D0	; shade for rect
			bsr		SetupForeColor
			move.l	rectReg,-(SP) 		; push the window’s structure rect
			_FrameRect

			move.l	rectReg,-(SP) 		; push the window’s structure rect
			move.l	OneOne,-(SP)		;
			_InsetRect					; inset TempRect
			move.w	(a2)+, -(SP)		; lower right shade
			move.w	(a2)+, -(SP)		; upper left shade
			move.w	(a2)+, -(SP)		; shade for corners
			bsr		DrawShadedRect		; _FrameRect with shades

			move.l	rectReg,-(SP) 		; push the window’s structure rect
			move.l	OneOne,-(SP)		;
			_InsetRect					; inset TempRect
			move.w	(a2)+, D0			; shade for rect
			bsr		SetupForeColor
			move.l	rectReg,-(SP) 		; push the window’s structure rect
			_FrameRect

			move.l	rectReg,-(SP) 		; push the window’s structure rect
			move.l	OneOne,-(SP)		;
			_InsetRect					; inset TempRect
			move.l	#$00030003,-(SP)	; erase to edge of content rgn
			_PenSize					; get a thick pen
			move.l	(A5), A2			; get graphic globals
			pea 	white(A2)			; white for erasing
			_PenPat						; set pen pattern
			move.l	rectReg,-(SP)		; push TempRect
			_FrameRect					; and frame TempRect
			_PenNormal					; back to normal pen

NotFancy	tst.b	IsProcFive(A6)		; dBox with a title bar?
			bne.s	DrawTitleBar		; yes, then draw it
			tst.w	varCodeReg			; test for dialog windows
			bne 	WDefDrawDone		; yes, dialogs have no title bar

; ------------- draw the title bar -------------
; Derive the titleBar rect from the structRgn and keep it in TempRect. Keep
; rectReg preserved since it now points at TempRect.

DrawTitleBar
			bsr 	BuildTBarRect		; title rect in TempRect and rectReg
			clr.b	-(SP)				; room for Boolean
			move.l	rectReg, -(SP)		; test the title bar rect for
			move.l	(A5), A0			; quickdraw globals
			move.l	thePort(A0), A0		; point at current (Wmgr) port
			move.l	visRgn(A0), -(SP) 	; intersection with the visRgn
			_RectInRgn
			tst.b	(SP)+				; test the result
			bz		WDefDrawDone		; if not, skip all this work
			tst.b	wHilited(windowReg)		; do we have a white background?
			bz.s	@inactiveTitle		; don’t draw shaded title bar
			moveq	#wFrameColor,D0		; get fore color
			moveq	#wTitleBarShade1, D1	; get back color
			bra.s	@titleShadeCorrect
@inactiveTitle
			moveq	#wHiliteShadeA,D0	; Get fore color
			moveq	#wContentColor, D1	; get back color
@titleShadeCorrect
			bsr		SetupColors			; set ’em up
			tst.b	isProcFive(A6)		; dBoxProc with title?
			bnz.s	@1					; don’t frame title if so
			move.l	rectReg, -(SP)		; rect of title bar
			_FrameRect
@1
			move.l	rectReg, -(SP)			; rect of title bar
			move.l	(SP), -(SP)				; also for _EraseRect
			move.l	OneOne, -(SP)			; inset factor of 1, 1
			_InsetRect						; exclude the actual frame
			_EraseRect						; erase the contents
			tst.b	wHilited(windowReg)		; do we have a white background?
			bz.s	@doTitle				; don’t draw 3-d title bar
			moveq	#wLTinge0, D0			; fore color
			bsr		SetupForeColor			; do the right thing
			move.w	left(rectReg), -(SP)	; left of tb interior
			move.w	bottom(rectReg), -(SP)	; bottom of tb interior
			sub.w	#1, (SP)				; pen falls to lower right
			_MoveTo
			clr.w	-(SP)					; no horiz delta
			move.w	bottom(rectReg), D0		; vertical delta is bottom-top
			sub.w	top(rectReg), D0
			subq.w	#1, D0
			neg.w	D0						; going -v, not +v
			move.w	D0, -(SP)
			_Line							; draw left hilite
			move.w	right(rectReg), D0		; horiz delta is right
			sub.w	left(rectReg), D0		; minus left
			subq.w	#1, D0
			move.w	D0, -(SP)
			clr.w	-(SP)					; no v delta
			_Line							; draw top hilite
			moveq	#wLTinge4, D0			; fore color
			bsr		SetupForeColor			; do the right thing
			clr.w	-(SP)					; no h delta
			move.w	bottom(rectReg), D0		; vertical delta is bottom-top
			sub.w	top(rectReg), D0
			subq.w	#1, D0
			move.w	D0, -(SP)
			_Line							; draw left hilite
			move.w	right(rectReg), D0		; horiz delta is right
			sub.w	left(rectReg), D0		; minus left
			subq.w	#1, D0
			neg.w	D0						; going -h, not +h
			move.w	D0, -(SP)
			clr.w	-(SP)					; no v delta
			_Line							; draw top hilite

@doTitle
; ------------- DoTitleString  -------------
; To prevent title flicker, DoTitleString leaves the left edge of the
; title in D3 and the right edge in D4.  If the title bar needs to be
; highlighted, the highlighting is done in 2 sections, one on each side
; of the title.  DoTitleString draws the title centered in tempRect.

; Warning -- it trashes D3 and D4.

; compute indent factor based on GoAwayButton state

			move.w	right(rectReg),D4	; get right into D4
			move.w	D4,D3				;
			sub.w	left(rectReg),D3	; compute width

			sub.w	wTitleWidth(windowReg),D3	; compute extra x
			asr.w	#1,D3				; divide by 2

; if the string is too long, position left edge

			moveq	#2,D0				; start title at x = 2
			tst.b	wGoAway(windowReg) 	; is there a go away button
			beq.s	@2					; skip if there’s not
			moveq	#32,D0				; start title at x = 32
@2			cmp.w	D0,D3				; to left of x?
			bge.s	@3					; => no, D3 is ok
			move.w	D0,D3
@3
			move.w	D3,D0				; save left indent in D0							<15>
			add.w	left(rectReg),D3	; compute x position
			move.w	D4,-(SP)			; save right across clip
			tst.b	hasZoom(a6)			; zoom flag set?									<36>
			beq.s	@4					; => no, edge ok
			sub.w	#32,D4				; get default right edge
			bra.s	@doneAdjustRight	;													<15>

@4										; set clip to d3..d4
			sub.w	D0,D4				; adjust right to have the same indent as left		<15>
@doneAdjustRight
			move.l	 TempRgn(A6),-(SP)	; get our temp region
			move.l	 (SP),-(SP) 		; copy for SectRgn
			_GetClip					; and save for restore

			move.w	D4,right(rectReg)	; set right for clipping
			move.l	rectReg,-(SP)		; push tempRect
			_ClipRect					; set clipping to it

			move.l	(A5),A0 			; get globals
			move.l	(A0),A0 			; get port
			move.l	clipRgn(A0),-(SP)	; and the rect region
			move.l	(SP),-(SP)			; and use clip as dest
			_SectRgn					; get the intersection

			move.w	(SP)+,right(rectReg); restore tempRect
			move.w	D3,-(SP)			; push left for MoveTo

; ------------- draw title string -------------

			move.w	top(rectReg),D0 	; get top
			add.w	WInfo.wAscent(A6),D0 ; move down to baseline
			addq.w	#1,D0				; leave 2 pixels white space
			move.w	D0,-(SP)			; push baseline
			_MoveTo

			tst.b	wHilited(windowReg)	; Is it highlighted?
			beq.s	@noHighlight		; No
			moveq	#wTextColor,D0		; get fore color for highlighted title
			bra.s	@drawTitle
@noHighlight
			moveq	#wHiliteShade7,D0	; Use a gray shade to dim title string if not highlighted. <18>
@drawTitle
			moveq	#wTitleBarShade1,D1	; get back color
			bsr		SetupColors			; set ’em up
			move.w	#srcOr,-(SP)		; set the mode to source OR
			_TextMode					;

			move.l	wTitleHandle(windowReg),A0	; get titleHandle
			_HLock								; lock the title down
			move.l	(A0),-(SP)					; push title pointer
			_DrawString 						; draw it
			move.l	wTitleHandle(windowReg),A0	; get the handle again
			_HUnlock							; release it

			move.l	TempRgn(A6),-(SP)	; push the old clip
			_SetClip					; and restore it

; ------------- calculate highlite rects  -------------
; Now calculate the size of the clear area needed for the title
; (only used if the window is highlighted).  The two registers D3 and
; D4 are used to supply the left and right edges of the gap in the title
; area for occupied by the string.  If no title is supplied, then there
; isn’t a gap.  If there is a title, then there is an extra indentation
; of a few pixels added.

			move.w	D3,D1				; left in D3, calc right in D1
			add.w	wTitleWidth(windowReg),D1	; add in the length

			cmp.w	D4,D1				; was title longer than space?
			bge.s	@5					; => yes, use D4
			move.w	D1,D4				;
@5
			tst.w	wTitleWidth(windowReg)	; is there a title?
			beq.s	@NoIndent			; no, then don’t include indent
			addq.w	#6,D4				; indent on right
			subq	#6,D3				; indent to the left
@NoIndent								; no indentation
				 						; Left in D3, right in D4

; ------------- draw title bar highliting -------------

			tst.b	wHilited(windowReg)	; is it hilited?
			bne.s	DoHilite			; yes, then draw it
			bra.w 	WDefDrawDone				; no, done with all drawing

DoHilite
			moveq	#wHiliteShade8, D0		; get fore color
			bsr		SetupForeColor			; set ’em up

			move.l	rectReg,-(SP)		; push the title rect
			move.w	#1,-(SP)			; push dh
			move.w	WInfo.wBoxDelta(A6),-(SP) ; push dv
			_InsetRect					; inset it some

; The dBoxProc with title has a two pixel fancy border around the entire
; window.  When drawing the highlited pattern, I need to allow for this.

			tst.b	IsProcFive(A6)		; dBoxProc with title?
			beq.s	@NoAdjust			; no, then skip adjustment
			addq.w	#1,left(rectReg)	; yes, adjust title bar left
			subq.w	#1,right(rectReg)	; and right
@NoAdjust

; This WDEF tries to put at least 32 pixels on the left of the title if there is a go-away box.
; However, if the title bar is less than 32 pixels wide, we will have a problem in which the
; "racing" stripes will be drawn outside the title bar.
; The following check is to make sure that the lines will be drawn within the title bar area.
			move.w	right(rectReg),d0	; get right															<28>
			cmp.w	d0,d3				; Does lines fit in the title bar?									<28>
			ble.s	@linesFitOnRight	; 	yes => continue													<28>
			move.w	d0,d3				;	no => use the right of rect instead of the calculated value		<28>
@linesFitOnRight						;																	<28>

			move.w	right(rectReg),-(SP) ; save right of TempRect
			move.w	D3,right(rectReg)	; new right = title left

			move.l	topLeft(rectReg),D0	; get topLeft
			and.l	#$00070007,D0		; only use mod 8
			move.l	(A5),A2 			; get globals, save in A2
			move.l	D0,patAlign(A2) 	; set up patAlign

			move.l	theZone,curZone(A6)	; save the current zone <17>
			move.l	sysZone,theZone		; going to create the pixpat in sysZone <17>
			move.l	rectReg,-(SP)		; fill this rect
			pea 	HilitePattern		; push the pattern address
			_FillRect					; fill left half with the pattern

			tst.b	hasZoom(a6)			; zoom flag set?									<36>
			beq.s	@1					; => no, use current d4
			move.w	(SP),D0 			; else get right edge of box
			sub.w	#26,D0				; how much room is there?
			cmp.w	D4,D0				; need at least 26 pixels
			bge.s	@1					; => got ’em, use current d4
			move.w	D0,D4				; else use right-26

@1			move.w	(SP)+,right(rectReg) ; restore right of title box

; This WDEF tries to put at least 26 pixels on the right if there is a zoom box or matches the indent
; from the left. This may cause a problem in which the "racing stripes" will be drawn outside the title
; bar area if the title bar is too small. The following check makes sure that the lines will be drawn
; within the title bar area.
			move.w	left(rectReg),d0	; get left of rect													<28>
			cmp.w	d0,d4				; Does lines fit in the title bar?									<28>
			bge.s	@linesFitOnLeft		;	yes => continue													<28>
			move.w	d0,d4				;	no => use left instead of the calculated value					<28>
@linesFitOnLeft							;																	<28>

			move.w	D4,left(rectReg)	; set new left of title box
			move.l	rectReg,-(SP)		; fill this rect
			pea 	HilitePattern		; push the pattern address
			_FillRect

			move.l	curZone(A6),theZone	; restore the zone <17>
			clr.l	patAlign(A2)

; ------------- DoGoAway  -------------

			tst.b	wGoAway(windowReg)	; is there a goaway button?
			beq.s	DoZoom				; => if not, try for zoom

			moveq	#wGoAwayGadget, D0
			bsr		SetupColorPict
			pea		TingeGoAway			; Address of tinge routine
			bsr	 	PlotGoAway

; ------------- DoZoom  -------------

DoZoom		
			tst.b	hasZoom(a6)			; zoom flag set?									<36>
			beq.s	WDefDrawDone		; no, then done drawing

			moveq	#wZoomGadget, D0
			bsr		SetupColorPict
			pea		TingeZoom			; Address of tinge routine
			bsr	 	PlotZoom			; and plot the symbol
			bra.s	WDefDrawDone		; done drawing

; ------------- goAway and zoom box highliting -------------
; decide which icon needs hiliting

EORStuff	
			beq.s	EORGoAway			; => it’s the goAway
			tst.b	hasZoom(a6)			; zoom flag set?									<36>
			beq.s	WDefDrawDone		; => no

			btst	#HiliteFlagBit, HiliteFlagGlobal
			bz.s	@drawHilitedZoom
			moveq	#wZoomGadget, D0
			pea		TingeZoom
			bra.s	@zoomCommon
@drawHilitedZoom
			moveq	#wZoomHilitedGadget, D0
			clr.l	-(sp)				; No tinge routine
@zoomCommon
			bsr		SetupColorPict
			bsr	 	PlotZoom			; and plot the symbol
			bra.s	WDefDrawDone

EORGoAway								; hilites/unhilites the goAway
			btst	#HiliteFlagBit, HiliteFlagGlobal
			bz.s	@drawHilitedGoAway
			moveq	#wGoAwayGadget, D0
			pea		TingeGoAway
			bra.s	@goAwayCommon
@drawHilitedGoAway
			moveq	#wGoAwayHilitedGadget, D0
			clr.l	-(sp)				; Highlighted state needs no tinging
@goAwayCommon
			bsr		SetupColorPict
			bsr		PlotGoAway

WDefDrawDone
			move.l	(SP)+, A0			; return address
			lea		WDefDrawFrame.ParamSize(SP), SP	; pop params
			jmp		(A0)


DrawShadedRect

ShadedRectFrame	RECORD	0
retAddr		ds.l	1
StartParams	EQU		*
cornerColor	ds.w	1
ulColor		ds.w	1
lrColor		ds.w	1
ParamSize	EQU		*-StartParams
			ENDR

			with	ShadedRectFrame

			move.w	cornerColor(SP), D0		; shade/color of corner
			bsr		SetupForeColor			; make it the pen color
			move.w	left(rectReg), -(SP)	; start at lower left
			move.w	bottom(rectReg), -(SP)
			subq.w	#1, (SP)
			_MoveTo
			move.l	#$FFFF0000, -(SP)		; h=0, v=-1
			_Line							; draw 1 pixel corner
			move.w	ulColor(SP), D0			; get shade for left and top
			bsr		SetupForeColor			; make it the pen color
			move.l	top(rectReg), -(SP)		; top AND left
			_LineTo							; draw line on left side
			move.w	right(rectReg), -(SP)
			subq.w	#1, (SP)
			move.w	top(rectReg), -(SP)
			_LineTo							; draw line across top

			move.w	cornerColor(SP), D0		; need corner color again
			bsr		SetupForeColor			; make it the pen color
			move.w	right(rectReg), -(SP)	; start in upper right
			subq.w	#1, (SP)
			move.w	top(rectReg), -(SP)
			_MoveTo
			move.l	#$00010000, -(SP)		; h = 0, v = 1
			_Line							; draw one pixel corner
			move.w	lrColor(SP), D0			; get shade for right and bottom
			bsr		SetupForeColor
			move.l	bottom(rectReg), -(SP)	; bottom AND right
			subq.w	#1, (SP)
			subq.w	#1, 2(SP)
			_LineTo							; draw line on right
			move.w	left(rectReg), -(SP)
			addq.w	#1, (SP)
			move.w	bottom(rectReg), -(SP)
			subq.w	#1, (SP)
			_LineTo							; draw line across bottom
			move.l	(SP)+, A0
			addq.l	#ShadedRectFrame.ParamSize, SP
			jmp		(A0)

			endwith

			endwith


; ================================================
; wHit message
; ================================================
; The hit test is to look for a click in the window’s content region.
; The problem with this is that the WDEF extends the window’s contect to
; include areas such as the fancy border, title bar, and drop shadow.  If
; the user clicks in the fancy border or shadow it is outside of the content
; but still within the window.  The reason for the inContent result in the
; first place was to let the application know the user clicked any where
; within the window excluding the drag area.  So, we check for a click
; within the structRgn’s rect but remove the title bar is it has one.
; This solved a few problems that hitherto were unknown, or at least not
; reported.  ModalDialog no longers reports an error when clicking in the
; dBoxProc’s fancy border.  Clicking in the drop shadow is a click in the
; window.  Since a dBoxProc with title bar allows switching in MultiFinder,
; clicking in the fancy border *must* be considered a click in the window.

; paramReg holds the mousePoint in global coordinates .
; windowReg holds the window pointer

HitDoc		clr.w	-(SP)				; make room for function result
			move.l	paramReg,-(SP)		; push the mouse point
			bsr		StructInTemp		; structRgn.rgnBBox in TempRect
			tst.w	varCodeReg			; dialog window?
			beq.s 	@1					; no, they have a title bar
			tst.b	IsProcFive(A6)		; dBoxProc with title?
			beq.s	@2					; no, then no title bar

@1			add.w	titleHgtReg,top(rectReg) ; remove title bar area
@2			move.l	rectReg,-(SP)		; point at TempRect
			_PtInRect					; pt in window area less title bar?
			tst.b	(SP)+				; well, is it?
			beq.s	NotInContent		; if not, go check out drag region
										; see if its in the grow icon area
			tst.w	varCodeReg			; is it a dialogBox?
			bne.s	JustContent 		; if so, its only in the content

; ------------- hit in grow?  -------------

			tst.b	wHilited(windowReg) ; is it active?						<JDR 20-FEB-90
			beq.s	JustContent 		; if not, it cant be in grow
			move.w	varCode(A6),D0
			Btst	#growBit,D0			; inGrow enabled?
			BGT.s	JustContent 		; if not, skip

			move.l	contRgn(windowReg),A0	; get region handle				<JDR 20-FEB-90
			move.l	(A0),A0 				; get region ptr
			move.l	rgnBBox+botRight(A0),D0 ; get bottom left of content
										; first consider the x coordinate
			moveq	#14,D4				; keep 14 in a register to save code
			sub 	D4,D0				; offset x by 14
			cmp 	D0,paramReg			; if <, just in content
			BLT.s	JustContent

			SWAP	D0					; its within range on x so try y
			sub 	D4,D0				; check out y dimension
			SWAP	paramReg
			cmp 	D0,paramReg			; compare y coordinates
			BLT.s	JustContent

			moveq	#wInGrow,D0 		; flag in grow Icon
			bra 	DoneHitDoc

; the point is in the content region so return a ‘1’

JustContent
			moveq	#wInContent,D0		; return in content
			bra 	DoneHitDoc			; go store function result and return

; ------------- hit not in content  -------------
; Not in the content.  see if its in the dragRgn (content extended by
; titleBar) dBoxProc may have tile higher above content than normal.

NotInContent
			bsr 	BuildTBarRect		; title bar rect into rectReg
			clr.w	-(SP)				; make room for function result
			move.l	paramReg,-(SP)		; push the mouse point
			move.l	rectReg,-(SP)		; and push the rect
			_PtInRect					; is the point in the title bar?

			tst.b	(SP)+				; examine result
			beq		DoneHitDoc2			; if not, return already = 0

			tst.b	wHilited(windowReg)	; is it hilited?
			beq.s	ItsInDrag			; if not, can’t be in GoAway

; ------------- hit in goAway or Zoom?  -------------
; test vertical first for goAway and Zoom since they’re the same

			move.l	paramReg,D0			; check vertical
			SWAP	D0					; which is high word of mousePoint
			move.l	windowReg,A0		; convert pointer if its a pixmap
			bsr		PortToMap			; convert						 DAF
			add.w	bounds+top(A0),D0	; convert to local
			sub.w	portRect+top(windowReg),D0 	; compensate for origin

; The vertical hit test assumes the zoom is offset from the portRect.
; The dBoxProc with title has the title area sharing a portion of the fancy
; border surrounding the content.  So, an adjustment is needed to locate
; the zoom box’s vertical position.

			tst.b	IsProcFive(A6)		; dBoxProc with title bar?
			beq.s	@OldVert			; no, use normal vertical test
			addq.w	#proc5TopAdjust,D0	; yes, then tweak it
@OldVert								; continue with normal testing

			add.w	WInfo.wBoxDelta(A6),D0 ; below box?
			bpl.s	ItsInDrag				; => yes
			add.w	#11,D0					; in box?
			BMI.s	ItsInDrag				; => no

			tst.b	wGoAway(windowReg)	; is there a goAway button?
			beq.s	HitZoom 			; => no, hit-test zoom

			move.l	paramReg,D0			; get mousePt
			ADD 	bounds+left(A0),D0	; convert to local (A0 still valid)  DAF
			sub 	portRect+left(windowReg),D0	; compensate for origin
			cmp 	#18,D0				; is it too far right?
			BGT.s	HitZoom 			; if so, its in drag
			subq.w	#8,D0				; it must be at least 7
			BMI.s	ItsInDrag

			moveq	#wInGoAway,D0		; its in the goAway button so signal it
			bra.s	DoneHitDoc

HitZoom		
			tst.b	hasZoom(a6)			; zoom flag set?									<36>
			beq.s	ItsInDrag			; => not in these here parts

			move.w	paramReg,D0				; get mousePt
			move.l	windowReg,A0			; convert pointer if its a pixmap
			bsr		PortToMap				; convert					 DAF
			add.w	bounds+left(A0),D0	; convert to local
			sub.w	portRect+right(windowReg),D0	; make right edge = 0

; The dBoxProc with title has moved the zoom box in towards the left due to
; the fancy border.  Need to adjust horizontal hit test for this case.

			tst.b	IsProcFive(A6)			; dBoxProc with title?
			beq.s	@OldZoomHit				; no, then normal position
			subq.w	#proc5HitZAdjust,D0		; tweak it
@OldZoomHit									; continue with testing

			cmp.w	#-19,D0 				; too far left?
			BLT.s	ItsInDrag				; => if so, it’s in drag
			cmp.w	#-9,D0					; too far right?
			BGT.s	ItsInDrag				; => if so, it’s in drag

			bsr 	IsItSmall				; is window big?
			beq.s	@1						; => oh boy, right again
			moveq	#wInZoomOut,D0			; say window small
			bra.s	DoneHitDoc				; und scram-muller

@1			moveq	#wInZoomIn,D0			; say window big
			bra.s	DoneHitDoc				; and muller out of here

ItsInDrag	moveq	#wInDrag,D0 		; flag in drag region

DoneHitDoc	move.l	D0,ProcResult(A6)		; update function result
DoneHitDoc2	rts


; ================================================
; wCalcRgns message
; ================================================
; CalcDoc  -- calculate the structure and content regions for the window pointed
; to by windowReg.  First update size for zooming if necessary

CalcDoc		
			tst.b	hasZoom(a6)			; zoom flag set?									<36>
			beq.s	@1					; => no
			bsr 	IsItSmall			; update window size

; ------------- calc ContRgn -------------
@1
			bsr		GetRect				; make a rectangular content region
			move.l	contRgn(windowReg),-(SP) ; content region gets result
			move.l	rectReg,-(SP)		; tempRect is the rectangle
			_RectRgn					; go make the region into content region

; ------------- calc structRgn -------------
; now do the structure region.	First correct the bounding rectangle (tempRect) for
; structure instead of content

			move.l	#$00020002,D4		; get the shadow factor for DBox
			move.l	structRgn(windowReg),-(SP) ; push the structRgn for later
			move.l	rectReg,-(SP)		; tempRect is the rect in rectReg
			move.l	rectReg,-(SP)		; make two copies
			move.l	MinusOne,-(SP)		; make 1 pixel bigger, all around
			_InsetRect					; make it bigger

			tst.w	varCodeReg			; is it dBox?
			bne.s	DoDBoxCalc			; skip if it is

			move.w	titleHgtReg,D0 		; move up to top of window
			subq.w	#1,D0				; tweak it
			sub.w	D0,top(rectReg) 	; and set top of struct region
			LSR.l	#1,D4				; adjust shadow factor
			bra.s	CalcCommon			; use common code for the rest

; ------------- calc structRgn for dialogs -------------
DoDBoxCalc
			cmp 	#1,varCodeReg		; is it variant 1?
			bne.s	CalcCommon

			move.l	rectReg,-(SP)		; tempRect is the rect in rectReg
			move.l	#$FFF9FFF9,-(SP)	; push (-7,-7)
			_InsetRect					; inset it

; The dBoxProc with title needs a larger structRgn. Also, a portion of this
; title area is shared with the fancy border that surrounds the	content.

			tst.b	IsProcFive(A6)		; dBoxProc with title?
			beq.s	CalcCommon			; skip if without title bar
			move.w	titleHgtReg,D0 		; move up to top of window
			subq.w	#proc5TopAdjust,D0	; tweak it
			sub.w	D0,top(rectReg) 	; and set top of struct region

CalcCommon								; create the structRgn for all windows.
			_RectRgn					; RectRgn(structRgn,tempRect)
			tst 	varCodeReg
			beq.s	@1					; if so, it has shadow
			cmp 	#3,varCodeReg		; is it variant 3?
			bne.s	CalcDone			; if not, no shadow
@1

; ------------- include drop shadow -------------
; now add in the 1 or 2 pixel drop shadow

			move.l	TempRgn(A6),-(SP)	; get temp region
			move.l	rectReg,-(SP)		; tempRect is the rect in rectReg
			move.l	(SP),-(SP)			; save another copy
			move.l	D4,-(SP)			; push shadow factor
			_OffsetRect 				; offset it
			_RectRgn

			move.l	structRgn(windowReg),-(SP)	;
			move.l	TempRgn(A6),-(SP)			; get temp region
			move.l	structRgn(windowReg),-(SP)	; structure gets the result
			_UnionRgn							; add it in

CalcDone	rts							; all done with CalcDocRgns


; ================================================
; wGrow message
; ================================================
; GrowDoc handles the grow message by drawing a grow outline based on
; the rectangle held in paramReg.  First make it one pixel bigger to
; jibe with the structure then frame the entire window.

GrowDoc		move.l	paramReg,-(SP)		; push the rect
			move.l	MinusOne,-(SP)		; push (-1,-1)
			_InsetRect
			move.l	paramReg,A3			; get rect ptr
			move.l	topLeft(A3),-(SP)	; save topleft for below
			move.w	titleHgtReg,D0 		; adjust for title
			subq.w	#1,D0				; and tweak it
			sub.w	D0,top(A3)			; and save it
			move.l	paramReg,-(SP)		; push the rectangle
			_FrameRect					; frame it

; ------------- draw the lower horizontal -------------
; line at the top of the horizontal scroll bar area

			move.w	left(A3),-(SP)		; push left
			move.w	bottom(A3),-(SP)	; push bottom
			sub 	#scrollBarSize,(SP)	; a few pixels above bottom
			move.l	(SP),-(SP)			; make a copy of this point
			_MoveTo 					; move to it
			move.w	right(A3),2(SP) 	; now go to the right edge
			_LineTo 					; draw the horizontal line

; ------------- draw the upper horizontal -------------
; line below the title bar area

			move.l	(SP),topLeft(A3)	; restore topLeft, leave on stack
			move.l	(SP),-(SP)			; make a copy of this point
			_MoveTo 					; move to it
			move.w	right(A3),2(SP) 	; now go to the right edge
			_LineTo 					; draw the horizontal line

; ------------- draw the vertical line -------------
; line along left edge of the vertical scroll bar

			move.w	right(A3),-(SP) 	; push right
			sub 	#scrollBarSize,(SP)	; few pixels to the left
			move.w	top(A3),-(SP)		; push top
			move.l	(SP),-(SP)			; make a copy of this point
			_MoveTo 					; and move to it
			move.w	bottom(A3),(SP) 	; now go to bottom edge
			_LineTo 					; draw the vertical line
										; restore the rect back to
										; how it was when we got it
			move.l	paramReg,-(SP)		; push the rect
			move.l	OneOne,-(SP)		; push (1,1)
			_InsetRect
GrowDone	rts


; ================================================
; wDrawGIcon message
; ================================================
;  Draw the grow icon.	First make this window the current grafPort

DrawGIcon
			move.l	GrafGlobals(A5),A0	; get the current port and save it  DAF
			move.l	thePort(A0),-(SP)	;								    DAF
			move.l	windowReg,-(SP)		; push the window’s port
			_SetPort					; make that the port
			clr.l	globalOffset(a6)	; No offset for BW systems.
			tst.b	IsColor(A6)			; is this a color system?
			beq		@NoColor8			; Nope.  Skip color stuff												<27>

; ------------- do color window -------------
; The region passed to _DeviceLoop has to be offset into global coordinates on
; color systems since we’re drawing into the window manager port.

			move.l	GrafGlobals(a5),a0	; get the port															<27>
			move.l	thePort(a0),a0		;																		<27>
			lea		portBits(a0),a0		; point to “bitmap” in the port											<27>
			tst.w	rowBytes(a0)		; is this a color port?													<27>
			bpl.s	@bitmap				;																		<27>
			move.l	baseAddr(a0),a0		; pixmap handle															<27>
			move.l	(a0),a0				; pixmap ptr															<27>
@bitmap									;																		<27>
			move.l	ScrnBase,d0			; get base address of screen											<27>
			cmp.l	baseAddr(a0),d0		; is it the same as thePort’s ?											<27>
			beq.s	@drawToScreen		; yes => we are drawing to screen										<27>
			move.w	#1, -(SP)			; no => assume old-port, depth equals 1									<27>
			tst.w	rowBytes(A0)		; is this an old-style port?											<27>
			bpl.s	@depthOk			; yes. depth of 1 on stack is okay										<27>
			move.w	pmPixelSize(A0),(SP)	; fix depth on stack												<27>
@depthOk								;																		<27>
			move.w	#fakeDeviceFlags, -(SP)	; assume non-CQD case												<27>
			clr.l	-(SP)				; NIL gDeviceHandle for non-CQD machines								<27>
			btst	#6,ROM85			; Color QuickDraw available?											<27>
			bnz		@deviceAndFlagsOk	; of not, fake versions on stack are correct							<27>
			move.l	theGDevice, A1		; current device GDHandle												<27>
			move.l	A1,(SP)				; fix gdHandle on stack													<27>
			move.l	(A1), A1			; point to the device													<27>
			move.w	gdFlags(A1),4(SP)	; fix gdFlags on stack													<27>
@deviceAndFlagsOk						;																		<27>
			clr.l	-(SP)				; flag clear (not drawing to screen)									<27>
			bsr		WDefDrawGIcon		; 																		<27>
			bra		@exitDrawGIcon		; 																		<27>
@drawToScreen							;																		<27>
			lea		globalOffset(a6),a2
			move.l	portRect(windowReg),d4
			move.l	d4,(a2)

			move.l	a2,-(sp)
			_LocalToGlobal				; Convert topLeft to global coordinates
			move.l	d4,-(SP)			; push src point					<23>
			move.l	a2,-(SP)			; push ptr to dest point			<23>
			_SubPt						; get local to global offset		<23>

; save the foreground and background of the WMgr port & set new colors

			subq	#6,SP				; make room for rgbColor on stack	 DAF
			move.l	SP,-(SP)			; push pointer to placeholder		 DAF
			_GetForeColor				; get the window port’s foreColor	 DAF
			subq	#6,SP				; make room for the backColor too	 DAF
			move.l	SP,-(SP)			; push pointer to placeholder		 DAF
			_GetBackColor				; get the window port’s backColor	 DAF

; Get the intersection of the clipRgn and visRgn of the window to use as the
; clipping region for drawing the grow icon.

			move.l	clipRgn(windowReg),-(sp)
			move.l	visRgn(windowReg),-(sp)
			move.l	tempRgn(a6),-(sp)
			_SectRgn 					; Get intersection of portRect & visRgn

			move.l	tempRgn(a6),-(sp)
			move.l	(a2),-(sp)
			_OfsetRgn					; Move the clipRgn into global coordinates

			move.l	WMgrCPort,-(sp)
			_SetPort					; Set port back to WMgrPort

			subq	#4,sp				;												<25>
			_NewRgn						; Allocate new region…							<25>
			move.l	(sp),-(sp)			;												<25>
			_GetClip					;  to save WMgrPort’s clipRgn in.				<25>

			move.l	tempRgn(A6),-(sp)
			move.l	(SP), -(SP)			; once more for DeviceLoop
			_SetClip					; Clip to the window’s clipRgn
			bra.s	@isColor			; Fill in the other _DeviceLoop parameters

@NoColor8								; END OF COLOR-ONLY SECTION
			move.l	tempRgn(A6), -(SP)	; rgn handle
			move.l	(SP), -(SP)			; once more for DeviceLoop
			pea		portRect(windowReg)	; local coord rect
			_RectRgn
@isColor
			pea		WDefDrawGIcon		; address of devloop drawing proc
			clr.l	-(SP)				; no unusual activities
			clr.l	-(SP)				; and no user data
			_DeviceLoop
			tst.b	IsColor(A6)			; is it a color system?
			beq.s	@exitDrawGIcon		; no, so skip this restore

			move.l	(sp),-(sp)
			_SetClip					; Restore WMgrPort clipRgn
			_DisposRgn					; Get rid of saved region

			move.l	SP,-(SP)			; push ptr to rgbColor previously saved on top of stack 	 DAF
			_RGBBackColor				; 								 DAF
			addq	#6,SP				; trash backcolor				 DAF
			move.l	SP,-(SP)			; 								 DAF
			_RGBForeColor				;								 DAF
			addq	#6,SP				;								 DAF
@exitDrawGIcon
			_SetPort					; restore the incoming port (saved above)  DAF
			rts

WDefDrawGIcon
			with	WDefDrawFrame

			move.w	depth(SP), curDepth(A6)	; save this for SetupColor magic
			move.l	devHandle(SP), D1		; pass this drawing device
			bsr		CheckAvailableColors

			moveq	#wFrameColor,D0		; get fore color
			moveq	#wContentColor,D1	; get back color
			bsr		SetupColors			; set ’em up

; ------------- plot grow icon -------------
; compute the grow icon rectangle in tempRect which is inside the lower
; left corner of the scroll bar area.

			move.l	globalOffset(a6),d4						; Get offset amount
			move.l	portRect+botRight(windowReg),(rectReg)	; botRight=topLeft
			move.l	(rectReg),botRight(rectReg)				; copy into botRight, too

			add.w	d4,left(rectReg)						; <SM5> 	reintroduced from <34>
			add.w	d4,right(rectReg)						; <SM5>
			swap	d4										; <SM5>
			add.w	d4,top(rectReg)							; <SM5>
			add.w	d4,bottom(rectReg)						; <SM5>

			sub.w	#scrollBarSize-2,top(rectReg)			; remove scroll area
			sub.w	#scrollBarSize-2,left(rectReg)

			tst.b	wHilited(windowReg)	; is it hilited?
			bne.s	@1					; yes, plot it
			move.l	rectReg,-(SP) 		; TempRect still in rectReg
			_EraseRect					;
			subi.l	#$00010001,(rectReg)	; Move topLeft back out
			bra.s	PlotBoundary		;
@1										;
			moveq	#wGrowGadget, D0
			bsr		SetupColorPict		; Get the grow gadget
			beq.s	@2					; Don’t to extra stuff for black and white gadget

; On color systems, the grow gadget is on a gray background;  do the gray.

			move.w	d2,-(sp)			; PlotSymbol will need D2, so save it in case _EraseRect trashes it
			moveq	#wTitleBarShade1, D0	; Use title bar gray for gray of grow icon
			bsr		SetupBackColor
			move.l	rectReg, -(SP)
			_EraseRect					; Gray shade
			move.w	(sp)+,d2

; The inside of the grow gadget it a darker gray.  Set the rectangle to the area
; to darken

			move.l	#$00030003,d3			; Save ourselves 6 bytes by using a register
			move.l	#$00040004,d4
			add.l	d4,(rectReg)
			sub.l	d3,botRight(rectReg)
@2
			subi.l	#$00010001,(rectReg)	; We subtracted one pixel less to avoid some flickering,
			pea		TingeGrow			; Tinging routine for grow gadget
			bsr		PlotSymbol			; so we have to put those pixels back before

; Set colors for plotting boundary

			moveq	#wFrameColor, D0	; get fore color
			moveq	#wContentColor,D1	; get back color
			bsr		SetupColors			; set it up

; ------------- plot the boundary lines -------------
; plot the left edge of the vertical scroll bar area and the top edge
; of the horizontal scroll bar area.

PlotBoundary
			move.w	portRect+left(windowReg),-(SP)	; push portRect.left
			move.l	globalOffset(a6),d4
			add.w	d4,(sp)							; Adjust for global case
			move.w	top(rectReg),-(SP)				; push tempRect.top
			_MoveTo
			move.w	portRect+right(windowReg),-(SP)	; push portRect.right
			add.w	d4,(sp)							; Adjust for global case
			move.w	top(rectReg),-(SP)				; push tempRect.top
			_LineTo									; draw the horizontal line

			swap	d4								; Get vertical offset into low word
			move.w	left(rectReg),-(SP)				; push tempRect.left
			move.w	(SP),-(SP)						; copy it again for later
			move.w	portRect+top(windowReg),-(SP)	; push portRect.top
			add.w	d4,(sp)							; Adjust for global case
			_MoveTo 								; move to it
			move.w	portRect+bottom(windowReg),-(SP) ; push portRect.bottom
			add.w	d4,(sp)							; Adjust for global case
			_LineTo 								; draw the vertical line

; ------------- done with grow drawing -------------
; don’t forget to take care of colors saved on stack

DrawGrowDone
			move.l	(SP)+, A0			; return address
			lea		WDefDrawFrame.ParamSize(SP), SP	; pop params
			jmp		(A0)

			endwith


; ================================================
; Plotters
; ================================================
; common code to draw little things like the goAway, zoom, and grow boxes

; A1 holds the symbol
; rectReg is the rectangle’s address
; D2 the plotting mode
; A2 points at bitmap or pixmap rect info

; ------------- Apply color tinge to the zoom box -------------

TingeZoom
			move.l	#$00040004,d3
			sub.l	d3,botRight(rectReg)
			move.l	rectReg,-(sp)
			_FrameRect					; Draw little box in zoom box first
			add.l	d3,botRight(rectReg)	; Restore full rectangle

; ------------- Apply color tinge to the goAway box -------------

TingeGoAway
			move.l	rectReg,-(sp)
			_FrameRect					; Draw upper part of shade

			move.l	OneOne,d3
			sub.l	d3,botRight(rectReg)
			move.l	rectReg,-(sp)
			_FrameRect					; Draw lower shade

			move.l	rectReg,-(sp)
			move.l	d3,-(sp)
			_OffsetRect					; Position rectangle for light shade

			moveq	#wLTinge0, D0
			bsr		SetupForeColor		; Do light tinge

			move.l	rectReg,-(sp)
			_FrameRect					; Draw light tinge
			sub.l	d3,(rectReg)		; Restore rectangle
			rts

; ------------- Apply color tinge to the grow box -------------

TingeGrow
			movem.l	d3/d4,-(sp)			; Save these registers
			move.l	#$00010001,d4
			add.l	d4,botRight(rectReg)
			bsr.s	DrawGrowBoxPart		; Draw a section of the grow icon

			moveq	#wDTingeF, D0		; Reset tinge for smaller box
			bsr		SetupForeColor

			move.l	rectReg,-(sp)
			move.l	#-1,-(sp)			; Move rectangle up and to the left
			_OffsetRect					; Set up position of smaller box
			sub.l	#$00030003,botRight(rectReg)
			bsr.s	DrawGrowBoxPart		; Draw smaller box

			move.l	rectReg,-(sp)
			move.l	d4,-(sp)
			_InsetRect
			add.l	d4,(rectReg)
			moveq	#wTitleBarShade4,d0
			bsr		SetupBackColor
			move.l	rectReg,-(sp)
			_EraseRect					; Refresh the dark gray inside small box

			sub.l	d4,(rectReg)
			asl.l	#2,d4
			add.l	d4,botRight(rectReg)	; Restore rectangle
			movem.l	(sp)+,d3/d4			; Restore registers

; The main body of the wDrawGIcon routine shifted the rectangle.  Shift it back
; to its original position here to save a check back in the mainstream.

			sub.l	d4,(rectReg)
			add.l	d3,botRight(rectReg)

			rts

; The grow box is made of two boxes that look like this:
;
;	@@@@@
;	@oooo	DrawGrowBoxPart will draw this part based on the rectangle
;	@o**@	in rectReg.  If we REALLY want to save some code, call TingeGoAway
;	@o**@	instead of DrawGrowBoxPart.  The resulting gadget looks a little
;	@o@@@	strange, but it’s passable in a pinch.
;

DrawGrowBoxPart
			move.l	rectReg,-(sp)
			_FrameRect					; Draw dark frame
			moveq	#wLTinge0,D0
			bsr		SetupForeColor

			move.l	(rectReg),d3		; Get topLeft
			add.l	OneOne,d3

			move.w	d3,-(sp)
			move.w	bottom(rectReg),-(sp)
			sub.w	#1,(sp)
			_MoveTo
			move.l	d3,-(sp)
			_LineTo						; Draw one light line
			move.w	right(rectReg),-(sp)
			sub.w	#1,(sp)
			swap	d3
			move.w	d3,-(sp)
			_LineTo
			rts

; ------------- plot the goAway box  -------------

PlotGoAway
			bsr		BuildTBarRect		; build a title bar rect in rectReg
			moveq	#9,D1				; add margin to left
			bra.s	PlotIt				; use common code to plot it

; ------------- plot the zoom box  -------------

PlotZoom
			bsr		BuildTBarRect		; build a title bar rect in rectReg
			move	right(rectReg),left(rectReg) ; left := right-22
			moveq	#-20,D1 			;

; The dBoxProc with title has a fancy border around it’s structure.
; This has to be taken into consideration when plotting the zoom box.

			tst.b	IsProcFive(A6)		; dBoxProc with title?
			beq.s	@1					; skip if standard title bar
			subq.w	#1,D1				; inset zoom to the left
@1										; don’t tweak it

; ------------- plot the little dude face  -------------
; make Temprect into a 16x16 square for our little bitmap
; dest rect top = rectReg.top + WInfo.wBoxDelta - 1
; dest rect bot = dest rect top + (A2).bottom - (A2).top
; dest rect left = rectReg.left + D1
; dest rect right = dest rect left + (A2).right - (A2).left

PlotIt
			move.w	d2,-(sp)
			add.w	D1,left(rectReg) 	; add offset to left
			move.w	WInfo.wBoxDelta(A6), D1
			add.w	D1, top(rectReg) 	; add offset to top
			addq.w	#1, top(rectReg) 	; align bitmap

			move.l	topLeft(rectReg),botRight(rectReg) ; topLeft = botRight

			move.w	2+bottom(A2), D0
			sub.w	2+top(A2), D0
			add.w	D0, bottom(rectReg);

			move.w	2+right(A2), D0
			sub.w	2+left(A2), D0
			add.w	D0, right(rectReg);

			move.l	rectReg, -(SP)
			move.l	#$FFFFFFFF, -(SP)
			_InsetRect
			moveq	#wTitleBarShade1, D0
			bsr		SetupBackColor
			move.l	rectReg, -(SP)
			_EraseRect
			move.l	rectReg, -(SP)
			move.l	OneOne, -(SP)
			_InsetRect
			move.w	(sp)+,d2

; ------------- plot the little dude’s face  -------------
; PlotSymbol -- A2 contains a PicHandle. rectReg holds the address of
; the destination rectangle.

; D2 is non-zero for pixmap, zero for bitmap
; A2 points to bounds/rect/bits
; rectReg holds destination rect

PlotSymbol
			move.w	D2,-(sp)			; Save color/BW flag
			tst.b	D2					; use picture or bits?
			bz.s	PlotBW				; if zero, use CopyBits
			tst.b	gadgetHighlight(a6)
			bz.s	@notHighlighted
			moveq	#wTitleBarDark, D0
			moveq	#wTingeLight, D1
			bra.s	plotSetupCommon
@notHighlighted
			moveq	#wTitleBarLight, D0
			moveq	#wTitleBarDark, D1
plotSetupCommon
			bsr		SetupColors
			move.l	workPixmap(A6), A0
			move.l	(A0), A0
			move.l	A0, -(SP)
			bra.s	copyBitsPixCommon

PlotBW
			lea 	IconBitmap,A0		; get pointer to source bitmap
			move.w	(A2)+, rowBytes(A0)
			move.l	(A2)+, bounds(A0)
			move.l	(A2)+, bounds+4(A0)
			move.l	A2, baseAddr(A0)

			pea 	IconBitmap			; push pointer source bitmap
copyBitsPixCommon
			move.l	(SP),A0 			; remember in A0, too
			move.l	GrafGlobals(A5),A1	; get lisaGraf global baseaddress
			move.l	thePort(A1),A1		; get thePort
			pea 	portBits(A1)		; that’s the destination bitmap
			pea 	bounds(A0)			; boundsRect of bitmap is source
			move.l	rectReg,-(SP)		; tempRect is the destination
			clr.w	-(SP)
			clr.l	-(SP)				; no mask region
										; the colors should be OK here
										; transfer the bitMap (stretching as necessary...)
			_CopyBits					; let Bill stretch those bits
			move.l	tempPixels(A6), A0	; get the locked pixels (if any)
			_HUnlock					; and unlock them

			move.w	(sp)+,D2
			bz.s	@noTingeRoutine		; Don’t tinge for black & white case

; All the tinge routines do the dark tinge first, so set it up for them

			moveq	#wDTingeF, D0
			bsr		SetupForeColor

			move.l	4(sp),d0			; Get address of tinging routine
			bz.s	@noTingeRoutine		; No; get out of here.
			move.l	(sp)+,(sp)			; Push down return address
			move.l	d0,a0
			jmp		(a0)				; Tinge the gadget
@noTingeRoutine
			move.l	(sp)+,a0			; Get return address
			addq	#4,sp				; Remove tinge routine from stack
			jmp		(a0)				; Return to caller

; ================================================
BuildTBarRect
; ================================================
; BuildTBarRect builds a rectangle enclosing the titleBar in TempRect
; leave rectReg pointing at TempRect, which is nice.

; WARNING -- Trashes D0,A0,A1,rectReg

			bsr.s	StructInTemp		; structRgn.rgnBBox in rectReg
										; make bottom := top + WHeight
			move	top(rectReg),D0		; get top
			add.w	titleHgtReg,D0 		; add precomputed height
			move	D0,bottom(rectReg)	; update bottom

; The dBoxProc with title has no shadow, don’t subtract off right edge.
			tst.b	IsProcFive(A6)		; dBoxProc with title?
			bne.s	@NoInset			; no, then standard title bar

			subq	#1,right(rectReg)	; inset right
@NoInset								; needed another entry point
			rts 						; return to caller


; ================================================
StructInTemp
; ================================================
; Get structRgn.rgnBBox into TempRect and keep TempRect address in rectReg

; WARNING - trashes A0

			move.l	structRgn(windowReg),A0	; get region handle
			move.l	(A0),A0 				; get region ptr
			addq	#rgnBBox,A0 			; point A0 at the bounding box
			move.l	(A0)+,(rectReg)			; copy rgnBox to TempRect
			move.l	(A0)+,botRight(rectReg)	;
			rts


; ================================================
IsItSmall
; ================================================
; IsItSmall returns NE if the window has been resized or moved (NE if window "small")
; It updates smallsize if it has.  (If tab, only move small window).

; WARNING -- Trashes A0,A2 and TempRect

			bsr.s	GetRect 			; rectReg = curSize
			move.l	wDataHandle(windowReg),A0	; get data handle
			move.l	(A0),A2 			; A2 = bigSize
			addq	#8,A2
										; the window is large if all corners
										; are within 7 of their default positions
			bsr.s	ChkPoint			; compare topleft
			bne.s	IsSmall 			; => not close enough
			bsr.s	ChkPoint			; compare botRight
			beq.s	NotSmall			; => it’s close enough

IsSmall 	move.l	wDataHandle(windowReg),A0	; get data handle
			move.l	(A0),rectReg 		; save window’s current size
			bsr.s	GetRect 			; get current size into rectReg
			moveq	#1,D0				; return NE!
NotSmall	lea 	TempRect,rectReg	; restore rectReg
			rts							; we’re done


; ================================================
ChkPoint
; ================================================
; This routine is called in sequence.  First time it checks topLeft,
; the next time is will check botRight.  It compares the rect in
; TempRect against the rect pointed at in A2.

; WARNING - increments rectReg

			move.l	(A2),-(SP)			; make point into a rect
			move.l	(A2)+,-(SP) 		; by pushing twice
			move.l	SP,-(SP)			; and insetting by 7
			move.l	#$FFF9FFF9,-(SP)	;
			_InsetRect					;
			clr.w	-(SP)				; is cursize within 7 of
			move.l	(rectReg)+,-(SP) 	; that point?
			pea 	6(SP)				;
			_PtInRect					;
			subq.b	#1,(SP) 			; reverse sign of result
			move.b	(SP)+,D0			;
			addq	#8,SP				; strip off the rect
			rts 						; exit w/EQ if "Big"


; ================================================
GetRect
; ================================================
; Returns the rect in rectReg converted to global coordinates

			move.l	portRect(windowReg),topLeft(rectReg)		   ; get locals
			move.l	portRect+botRight(windowReg),botRight(rectReg) ; get locals
			move.l	windowReg,A0		; copy portPtr for PortToMap
			bsr		PortToMap			; get the rect pointer
		 	move.l	rectReg,-(SP)		; push address of rect
			move.l	bounds(A0),-(SP)	; push offset locToGlob
			NEG.w	(SP)				; make offset positive
			NEG.w	2(SP)
			_OffsetRect 				; convert rect to global
GetRectDone	rts




;----------------------------------------------------------------------------
;
; These routines are the heart of the WDEF’s ability to draw the right thing
; on the right device based on the depth of the device. There are three kinds
; of window color types we can draw:
;
;	Black and White		Drawn on non-CQD Macs, and on devices that have less
;						than 8 bits per pixel. 8 bits per pixel is a high,
;						arbitrary limit that we may be able to relax if we
;						can integrate use of the Palette Manager into the
;						WDEF.
;	Custom wctbs		If there is a custom color table associated with
;						this window, then its colors are used. This may
;						change in the future if we find a way to customize
;						the colors of the System 7 three-d windows.
;	System 7.0 & later	Our new default for color environments.
;----------------------------------------------------------------------------

MakeRatioRGB
			movem.l	D7/A2, -(SP)
			lea		endRGB(A6), A0
			lea		startRGB(A6), A1
			lea		tempRGB(A6), A2

			mulu	#$1111, D2

			move.w	#2, D0
@nextChannel
			MOVEQ	#0, D1					; clear high word
			MOVE	(A0)+, D1				; background color component
			SUB		(A1), D1				; change from foreground
			SLO		D7						; remember if it was negated
			BHS.S	@orderedOK
			NEG		D1						; flip if subtraction would overflow
@orderedOK
			mulu	D2, D1					; multiply times scale factor
			SWAP	D1						; divide by 65K
			TST.B	D7
			BEQ.S	@notFlipped
			NEG.L	D1						; flip it
@notFlipped
			add.w	(A1)+, D1
			move.w	D1, (A2)+
			dbra	D0, @nextChannel
			movem.l	(SP)+, D7/A2
			rts


CheckAvailableColors
;----------------------------------------------------------------------------
; This routine is called just as we enter the _DeviceLoop drawing proc, after
; the current depth has been stored in curDepth(A6). If the depth is 8 bits
; per pixel or greater, and the wctb for this window is the default, then
; we’re going to draw the System 7 three-d windows instead (threeDWind gets
; set to TRUE). Otherwise, threeDWind gets set to FALSE.
;----------------------------------------------------------------------------
			movem.l	D3-D4/A2, -(SP)					; these should be saved
			move.w	curDepth(A6), D0				; how deep is the current device?
			cmp.w	#2, D0							; must be 2 bits/pixel or better

			sge		threeDWind(A6)					; set prelim answer
			blt.s	@exit							; get out if already no good

			move.l	TheGDevice, -(SP)				; save this
			move.l	D1, TheGDevice					; set our device for color mapping

			tst.b	varCodeReg						; what kind of window is this?
			bz.s	@doCheckHilite
			tst.b	IsProcFive(A6)					; is it moveable modal?
			bne.s	@doneCheckHilite
@doCheckHilite
			lea		HiliteShades, A2				; point at shades we need
			bsr.s	CheckShadesAvailable			; see if all these shades are here
			tst.b	threeDWind(A6)					; did we fail to get the shades?
			bz.s	@colorExit						; get out if so
			lea		TitleBarShades, A2				; point at shades we need
			bsr.s	CheckShadesAvailable			; see if all these shades are here
			tst.b	threeDWind(A6)					; did we fail to get the shades?
			bz.s	@colorExit						; get out if so
			lea		TingeShades, A2					; point at shades we need
			bsr.s	CheckShadesAvailable			; see if all these shades are here
			tst.b	threeDWind(A6)					; did we fail to get the shades?
			bz.s	@colorExit						; get out if so
@doneCheckHilite
			cmp.b	#dBoxProc, varCodeReg			; do we need the thick dialog border?
			bne.s	@colorExit						; if not, we’re done checking
			lea		DialogShades, A2				; point at shades we need
			bsr.s	CheckShadesAvailable			; see if all these shades are here
@colorExit
			move.l	(SP)+, TheGDevice				; restore device
@exit
			movem.l	(SP)+, D3-D4/A2
			rts

CheckShadesAvailable
			move.w	(A2), D3						; get next ‘light’ color
			move.l	#'csd ', D4						; an unlikely pixel value
@rampLoop
			cmp		(A2), D3						; get the next shade’s light color
			bne.s	@exit							; if new, reinit for new ramp
			move.l	A2, A0							; point to shade entry
			bsr		SetupRatioColor					; get shade in tempRGB
			subq.l	#4, SP							; room for pixel index
			pea		tempRGB(A6)						; the shade RGB we want
			_Color2Index							; what does it map to?
			move.l	(SP)+, D0						; get the pixel index
			cmp.l	D0, D4							; is it the same as last time?
			beq.s	@failure						; if so, not enough colors
			move.l	D0, D4							; update ‘last’ shade index
			addq.l	#6, A2							; point to next shade
			bra.s	@rampLoop						; and test it
@failure
			sf		threeDWind(A6)					; use the old kind
@exit
			rts

DefaultWCTB
;----------------------------------------------------------
; This table of bytes represents the colors in the default
; wctb. It uses bytes because we know that the default
; table only has black and white.
;----------------------------------------------------------
			dc.b	$FF, $00, $00, $00, $FF, $00, $00, $FF
			dc.b	$FF, $00, $00, $00, $00, $00, $00, $00
			dc.b	$00, $00, $00, $00, $00, $FF, $FF, $FF
			dc.b	$FF, $FF, $FF, $00, $00, $00, $00, $00
			dc.b	$00, $FF, $FF, $FF, $FF
			align

SetupRatioColor
			move.w	4(A0), -(SP)						; push shade percent
			move.w	2(A0), -(SP)						; push dark (to/fore) end of shade
			move.w	(A0), D0							; get light shade color number
			bsr.s	SetUpColor							; get the color of the light (from/back) end
			move.l	(SP)+, A0							; get pointer to light color
			move.l	(A0)+, startRGB(A6)					; copy red and green
			move.w	(A0), startRGB+4(A6)				; copy blue
			move.w	(SP)+, D0							; get dark color number
			bsr.s	SetUpColor							; get the color of the light end
			move.l	(SP)+, A0							; get pointer to light color
			move.l	(A0)+, endRGB(A6)					; copy red and green
			move.w	(A0), endRGB+4(A6)					; copy blue
			move.w	(SP)+, D2							; get shade percentage
			bsr.s	MakeRatioRGB						; create a shade between the two
			rts

; ================================================
SetupColors
; ================================================
; Added this routine to help setup fore- and back color and save code.
; SetUpColor takes a fore color in D0, and a back color in D1.
; It then calls SetUpColor with both of them (which likes its
; parameter in D0), and calls RGBForeColor and RGBBackColor
; where appropriate.

			move.w	D1,-(SP)			; save part identifier of back color
			bsr.s	SetupForeColor
			move.w	(SP)+,D0			; get saved part
			bsr.s	SetupBackColor
			rts							; all done

; ================================================
SetupForeColor
; ================================================

			bsr.s	SetUpColor			; D0 has forecolor part identifier
			bz.s	@setClassicFore		; if non-CQD answer, branch
			_RGBForeColor
			bra.s	@exit
@setClassicFore
			_ForeColor
@exit
			rts											; all done

; ================================================
SetupBackColor
; ================================================

			bsr.s	SetUpColor			; D0 has forecolor part identifier
			bz.s	@setClassicBack		; if non-CQD answer, branch
			_RGBBackColor
			bra.s	@exit
@setClassicBack
			_BackColor
@exit
			rts											; all done

; ================================================
SetUpColor
; ================================================
; SetUpColor takes a window part identifier in D0, finds the corresponding
;	part in the AuxWinTable (the part code is in the .value field) and returns
;	a pointer to its RGB on the stack.  If the requested part is not found,
;	the old black and white color for that part is used.

			tst.b	threeDWind(A6)						; can we use System 7 windows?
			bz.s	@useBlackAndWhite					; nope? Try other cases
			cmp.w	#lowestShadeIndex, D0				; is this a shade color?
			blt.s	@notShade							; not a shade color
			sub.w	#lowestShadeIndex, D0				; normalize to shade colors
			mulu	#6, D0								; x6 for table index
			lea		ShadeTable, A0						; point at table of shade colors
			add.w	D0, A0								; point to correct entry
			bsr.s	SetupRatioColor						; get color in tempRGB
			move.l	(SP)+, A0							; pop the return address
			pea		tempRGB(A6)							; point to rgb color
			moveq	#1, D0								; indicate color answer
			jmp		(A0)								; get outa here

@notShade
			move.l	AuxCPtr(A6), A0						; get the color table pointer
			bsr		GoodColorTable						; does ctb contain the index (in D0)?	<22>
			beq.s	@foundIt							; yes => go return corresponding color	<22>
			move.w	D0,-(SP)							; save the index to color table on stack<22>
			subq.l	#4,SP								; leave space for results				<22>
			move.l	#'wctb',-(SP)						; try to get the system wctb			<22>
			clr.w	-(SP)								;										<22>
			_GetResource								; look in ROM first						<22><SM3> rb
			move.l	(SP)+,A0							; get the wctb resource					<22>
			move.w	(SP)+,D0							; retrieve the index					<22>
			cmp.l	#0,A0								; did we really get the wctb resource	<22>
			beq.s	@useDefaultCTab						; no =>	go use the default ctab			<22>
			move.l	(A0),A0								; yes => deference to get ptr to wctb	<22>
			bsr		GoodColorTable						; does wctb contain the index (in D0)?	<22>
			beq.s	@foundIt							; yes => go return corresponding color	<22>
@useDefaultCTab											; no => use the default ctab			<22>
			mulu	#6,D0								; (x6) index into rgb specs
			lea		ThreeDColors, A0					; point at standard colors
@getCorrectColor										;										<22>
			move.l	(SP)+,D1							; get return address					<22>
			pea		(A0, D0.w)							; point at correct color
			move.l	D1, A0								; get return address
			bra.s	@exitColor
@foundIt
			lea		ctTable+rgb(A0, D1), A0 			; get the address of the color to use
			move.l	A0, D0								; we’ll need A0 in a second
			move.l	(SP)+, A0							; get the return address
			move.l	D0, -(SP)							; push the rgb addr on the stack
@exitColor
			moveq	#1, D0								; indicate color answer
			jmp		(A0)								; return to caller

@useBlackAndWhite
			lea		DefaultWCTB, A0						; point to cheesy color table
			move.b	(A0, D0.w), D0						; get white or black (as a byte)
			bnz.s	@simpleWhite						; branch if we want white
			moveq	#blackColor, D0						; get the old-style color
			bra.s	@classicExit						; get outa here
@simpleWhite
			moveq	#whiteColor, D0						; get old-style white
@classicExit
			move.l	(SP)+, A0							; return address
			move.l	D0, -(SP)							; classic color
			moveq	#0, D0								; indicate classic answer
			jmp		(A0)


SetupColorPict
			add.w	d0, D0								; (x2) index into words
			tst.b	threeDWind(A6)						; are we using pictures?
			bz.s	@blackAndWhiteBits					; if not, use bits instead
			lea		PixelRsrcIDs, A2					; point to pixel IDs
			subq.l	#4, SP								; room for the PicHandle
			move.l	#'pixs', -(SP)
			move.w	(A2, D0.w), -(SP)					; push the resource ID
			cmpi.w	#kHighlightPix,(sp)
			seq		gadgetHighlight(a6)					; Set if we’re highlighting
			move.w	#MapTrue,RomMapInsert				;										<SM3> rb
			_GetResource								; look in ROM first						<SM3> rb
			move.l	(SP)+, A0							; pixels handle
			_HLock										; don’t want it to move
			move.l	A0, tempPixels(A6)					; save for dispose
			move.l	(A0), A2							; point to pixels info
			move.l	workPixmap(A6), A1					; get pixmap handle
			move.l	(A1), A1							; point to pixmap
			move.w	(A2), pmRowBytes(A1)				; copy rowbytes for this image
			move.l	2(A2), pmBounds(A1)					; copy top/left
			move.l	6(A2), pmBounds+4(A1)				; copy bottom/right
			lea		12(A2), A0							;										<21>
			move.l	A0, pmBaseAddr(A1)
			moveq	#1, D2								; indicate color solution
			bra.s	@exit
@blackAndWhiteBits
			lea		BitmapOffsets, A2					; point to offset table
			adda.w	(A2, D0.w), A2						; add offset to correct bitmap
			moveq	#0, D2								; indicate b&w bits
@exit
			rts

GoodColorTable
			move.w	ctSize(A0), D1						; get the color table size
			asl.w	#3, D1								; (x8) convert to color table index
@legalIndex
			cmp.w	ctTable+value(A0,D1), D0			; is this the one?
			beq.s	@done								; if equal, then done
			subq.w	#8, D1								; try the previous one
			bge.s	@legalIndex							; loop while index positive
@done
			rts

; ================================================
PortToMap										;  DAF
; ================================================
; Given a window pointer in A0, return the bitmap/pixmap pointer in A0

			addq	#portBits,A0				;POINT TO BITMAP/PIXMAP HANDLE
			tst		rowBytes(A0)				;BITMAP OR PIXMAP HANDLE?
			bpl.s	GotBitMap					;=>JUST A BITMAP
			move.l	baseAddr(A0),A0				;ELSE GET PORT’S PIXMAP HANDLE
			move.l	(A0),A0						;GET PIXMAP POINTER
GotBitMap	rts


; ================================================
; CONSTANTS
; ================================================
; some data used in the WDEF

; ------------- HilitePattern used in the title bar -------------
HilitePattern
			dc.w	$FF00,$FF00,$FF00,$FF00

PixelRsrcIDs
;----------------------------------------------------------
; This is a table of resource IDs for the PICTs which are
; used to draw the small pieces of the System 7 windows.
;----------------------------------------------------------
			dc.w	-14335							; wZoomGadget
			dc.w	-14335							; wGoAwayGadget
			dc.w	-14334							; wZoomGadgetHighlight
			dc.w	-14334							; wGoAwayGadgetHighlight
			dc.w	-14335							; wGrowGadget

ThreeDColors
;-----------------------------------------------------------
; These are the RGB colors which are used to draw the shaded
; windows.
;-----------------------------------------------------------
			dc.w	$FFFF, $FFFF, $FFFF				; wContentColor
			dc.w	$0000, $0000, $0000				; wFrameColor
			dc.w	$0000, $0000, $0000				; wTextColor
			dc.w	$0000, $0000, $0000				; wHiliteColor (not used)
			dc.w	$FFFF, $FFFF, $FFFF				; wTitleBarColor (not used)
			dc.w	$FFFF, $FFFF, $FFFF				; wHiliteLight
			dc.w	$0000, $0000, $0000				; wHiliteDark
			dc.w	$FFFF, $FFFF, $FFFF				; wTitleBarLight
			dc.w	$0000, $0000, $0000				; wTitleBarDark
			dc.w	$CCCC, $CCCC, $FFFF				; wDialogLight
			dc.w	$0000, $0000, $0000				; wDialogDark
			dc.w	$CCCC, $CCCC, $FFFF				; wTingeLight
			dc.w	$3333, $3333, $6666				; wTingeDark

ShadeTable
HiliteShades
			dc.w	wHiliteLight, wHiliteDark, $0		; wHiliteShade0
			dc.w	wHiliteLight, wHiliteDark, $7		; wHiliteShade7
			dc.w	wHiliteLight, wHiliteDark, $8		; wHiliteShade8
			dc.w	wHiliteLight, wHiliteDark, $A		; wHiliteShadeA
			dc.w	wHiliteLight, wHiliteDark, $D		; wHiliteShadeD
TitleBarShades
			dc.w	wTitleBarLight, wTitleBarDark, $0	; wTitleBarShade0
			dc.w	wTitleBarLight, wTitleBarDark, $1	; wTitleBarShade1
			dc.w	wTitleBarLight, wTitleBarDark, $4	; wTitleBarShade4
DialogShades
			dc.w	wDialogLight, wDialogDark, $0		; wDialogShade0w
			dc.w	wDialogLight, wDialogDark, $4		; wDialogShade4w
			dc.w	wDialogLight, wDialogDark, $6		; wDialogShade6w
			dc.w	wDialogLight, wDialogDark, $B		; wDialogShadeBb
			dc.w	wDialogLight, wDialogDark, $F		; wDialogShadeF
			dc.w	0, 0, 0								; stop checking shades
			dc.w	wDialogLight, wDialogDark, $0		; wDialogShade0b
			dc.w	wDialogLight, wDialogDark, $4		; wDialogShade4b
			dc.w	wDialogLight, wDialogDark, $6		; wDialogShade6b
			dc.w	wDialogLight, wDialogDark, $B		; wDialogShadeBw
TingeShades
			dc.w	wTingeLight, wTitleBarDark, $0		; wLTinge0
			dc.w	wTingeLight, wTingeDark, $4			; wLTinge4					<20>
			dc.w	wTitleBarLight, wTingeDark, $F		; wDTingeF
EndOfShades
			dc.w	0

BorderShades
			dc.w	wDialogShade6w, wDialogShade0w		; Border colors for active windows
			dc.w	wDialogShade6w, wTitleBarShade4
			dc.w	wDialogShade0b, wDialogShade6b
			dc.w	wDialogShade6b, wDialogShadeF

			dc.w	wTitleBarShade0, wTitleBarShade0		; Border colors for inactive windows
			dc.w	wTitleBarShade0, wTitleBarShade0
			dc.w	wHiliteShade8, wHiliteShade8
			dc.w	wHiliteShade8, wHiliteShade8

BitmapOffsets
;----------------------------------------------------------
; This is a table of words which represent the offsets
; from WDEFBitmaps to the beginning of each bitmap
;----------------------------------------------------------
			dc.w	ZoomData-BitmapOffsets
			dc.w	GoAwayData-BitmapOffsets
			dc.w	ZoomHiliteData-BitmapOffsets
			dc.w	GoAwayHiliteData-BitmapOffsets
			dc.w	GrowBits-BitmapOffsets

WDEFBitmaps
;----------------------------------------------------------
; These bitmaps are used when drawing on classic QD
; machines, or when the bit depth is too low to draw in
; color.
;----------------------------------------------------------


; ------------- ZoomData used in the zoom box -------------
ZoomData

			dc.w	$0002						; rowBytes
			dc.w	$0000, $0000, $000B, $000B	; bounds
			dc.w	$FFE0						; •••••••••••.....
			dc.w	$8220						; •.....•...•.....
			dc.w	$8220						; •.....•...•.....
			dc.w	$8220						; •.....•...•.....
			dc.w	$8220						; •.....•...•.....
			dc.w	$8220						; •.....•...•.....
			dc.w	$FE20						; •••••••...•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$FFE0						; •••••••••••.....

ZoomHiliteData
GoAwayHiliteData
			dc.w	$0002						; rowBytes
			dc.w	$0000, $0000, $000B, $000B	; bounds

			dc.w	$FFE0						; •••••••••••.....
			dc.w	$8420						; •....•....•.....
			dc.w	$A4A0						; •.•..•..•.•.....
			dc.w	$9520						; •..•.•.•..•.....
			dc.w	$8020						; •.........•.....
			dc.w	$F1E0						; ••••...••••.....
			dc.w	$8020						; •.........•.....
			dc.w	$9520						; •..•.•.•..•.....
			dc.w	$A4A0						; •.•..•..•.•.....
			dc.w	$8420						; •....•....•.....
			dc.w	$FFE0						; •••••••••••.....

; ------------- BitMap for default GoAway button -------------
GoAwayData

			dc.w	$0002						; rowBytes
			dc.w	$0000, $0000, $000B, $000B	; bounds
			dc.w	$FFE0						; •••••••••••.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$8020						; •.........•.....
			dc.w	$FFE0						; •••••••••••.....

; ------------- BitMap for GrowIcon -------------
GrowBits
			dc.w	$0002						; rowBytes
			dc.w	$0000, $0000, $000F, $000F	; bounds
			dc.w	$0000						; ................
			dc.w	$0000						; ................
			dc.w	$0000						; ................
			dc.w	$1FC0						; ...•••••••......
			dc.w	$1040						; ...•.....•......
			dc.w	$107C						; ...•.....•••••..
			dc.w	$1044						; ...•.....•...•..
			dc.w	$1044						; ...•.....•...•..
			dc.w	$1044						; ...•.....•...•..
			dc.w	$1FC4						; ...•••••••...•..
			dc.w	$0404						; .....•.......•..
			dc.w	$0404						; .....•.......•..
			dc.w	$0404						; .....•.......•..
			dc.w	$07FC						; .....•••••••••..
			dc.w	$0000						; ................

			END
