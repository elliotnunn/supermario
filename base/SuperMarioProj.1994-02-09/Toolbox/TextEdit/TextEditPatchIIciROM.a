;
;	File:		TextEditPatchIIciROM.a (formerly TextEdit67cFix.a)
;
;	Contains:	TextEdit patches for inclusion in PatchIIciROM.a
;
;	Written by:	SMB	Sue Bartalo
;				YS	Yishai Steinhart
;
;	Copyright:	© Apple Computer, Inc. 1990-1992 all rights reserved.
;
; This file contains the patches for TextEdit on ROM version $7C of Machine type $06 (the IIci).
; This file is included in PatchIIciROM.a.
;
;	Change History (most recent first):
;
;		<51>	 8/11/92	SMB		#1036481 <gbm>: Removed font/keyboard synchronization for
;									Roman-only systems.  It's unnecessary and slows things down!
;		<50>	 7/15/92	SMB		## <ys>: Renamed DoText selectors: teMark is now teHighlight and
;									teLoc is teCaret.
;		<49>	  7/8/92	PKE		Fix up previous comment (I was too quick with the Return key).
;		<48>	  7/8/92	PKE		#1035214 <csd>: We would like to fix DoSearch so that it always
;									exits by calling FreeFmtOrderArray at exit, which will dispose
;									of any fmtOrdering handle and clear ExpandMemRec.emFmtOrderHFlag
;									which says that the handle is valid. This will prevent
;									subsequent calls from thinking they have a valid handle before
;									they actually allocate one. However, this fix is too risky; so
;									instead we modify DoText to always clear the flag so that no
;									routine thinks it has a valid handle when it doesn't. The more
;									correct fix is in TextEdit.a.
;		<47>	  7/7/92	PKE		#1030684 <yds>: TEGetPoint failed in unstyled multiline text if
;									a R->L script was present because in this case DoMeasure
;									measured from the beginning of the buffer, not the beginning of
;									the current line. Fixed.
;		<46>	 6/23/92	SMB		#1029263,<pke>: Now checking the script's 'itlb' flags to
;									determine if the keyboard and font should be synchronized.
;		<45>	 4/27/92	DTY		Get rid of hasSplineFonts conditionals.
;		<44>	  4/3/92	YS		#1025998, in TextBox, when trying to find the right line highet
;									in systems that use associated font (see <43>), saving and
;									restoring of the font saves a LONG (instead of a word) creating
;									the problem of loosing the port font. Another connected problem
;									was the way Script Manager handeld those privete verb calls in
;									the roman. This was fixed in the Script Manager. <44-YDS-4/2/92>
;		<43>	  2/6/92	YS		#1014691, Cube-E, In the old days, the Hebrew/Arabic extention
;									used to calculate the highet of a script font as Max(script font
;									size, associated font size). The problem with that is that if
;									you use style runs, like styled TE & WP's, you can't get the
;									real size of of a script font, and you allways have the
;									associated font size in it. The universal one byte init no
;									longer handles it. TE will calculate it itself if it is: 1)
;									unstyled text. 2) script font. 3) Has associated font (other
;									then 0). In this file we do a 'come from' patch to GetFontInfo,
;									one patch is from TextBox and the other is from GetSize
;									<43-YDS-2/6/92>
;		<42>	  2/4/92	YS		#1015382, Cube-E, don't redraw the whole line for a left 2 right
;									system when justification is teForceLeft. <42-YDS-2/5/92>
;		<41>	 1/30/92	YS		#1018683, Cube-E: TextBox should handle #teForceLeft correctly
;									and not set it to #teJustLeft allways. Had to add a ptchTextBox
;									for that. <41-YDS-1/30/92>.
;		<40>	 1/13/92	PKE		#1019673, Bruges: Unstyled TE should not sync the keyboard at
;									all for smEastEurRoman script.
;		<39>	12/17/91	PKE		#1017647: Fix keyboard synchronization in unstyled one-byte
;									non-Roman text. For bidi scripts: don't synchronize control
;									chars and L-R numbers, set keyboard to Roman for other L-R
;									chars, and sync keyboard to font for R-L chars. For other
;									scripts: sync keyboard to font for script letters, set keyboard
;									to Roman for Roman letters, and don't sync anything else.
;		<38>	12/12/91	DCL		#1009157: Changed a Tst to Tst.b so as not to test the potential
;									garbage in the other byte. Changed procedure noClickProc in
;									TextEdit.a, StyledTextEdit.a, and TextEditPatchIIciROM.a
;		<37>	11/12/91	SMB		#1014705 - for CubeE and Bruges - Keyboard and font synch'ing
;									isn't correct for punctuation and numbers: TE allows a Roman
;									keyboard & a non-Roman font combination for ascii characters and
;									european characters (or high ascii chars.) and it should also
;									allow this for numbers and punctuation marks. This was reported
;									against the Eastern European systems. Actually, this code will
;									be optimized to only allow this unsynchronized state for 2-byte
;									text. See ClickKeyboard2Font. Also fixed the synchronization of
;									unstyled text cases in TEClick and TEKey.
;		<36>	 9/30/91	YS		Used to syncronize the keyboard wrong for L->R scripts
;									(unstyled) when was backspacing a selection (and not a single
;									delete), d6 wasn't set up corectly. use teSelStart(a3) instead.
;									(bug #1013159) <36-YDS-10/1/91>
;		<35>	 9/23/91	PKE		For Cube-E (and Bruges): If non-Roman scripts are installed,
;									TEInit should no longer set TESysJust to its idea of system
;									default, since users can now set the default. Also: Define
;									forLocalizability here if it is not defined in BBSStartup.
;		<34>	 9/13/91	YS		Moved in 6.1 fixes for a Localizable 7.0.1 (forLocalizability)
;							<34p>   Fix the wrong placment of the caret for one blinking cycle
;									when changing a language and typing a char. (bug #1006971)
;									<34p-YDS-9/2/91> <34o> Fix the problem of the arrow keys not
;									functioning in a L->R system, with line direction R->L (bug
;									#1007934) <34o-YDS-9/2/91>. <34m> when backspacing, synch the
;									keyboard to the right language even for unstyled (single byte
;									only). (bug #1006972) <34m-YDS-9/2/91> <34l> Fix the Big cursor
;									bug, this is NOT the old big applelink cursor bug (fix YSD
;									<3.1>). In the case where the cursor is on a line start, we used
;									to fall into the single caret code
; 									(but we didn't have any split caret !!!), so while switching
;									the cursor rect's  for a single caret, we used to garbage the 
;									selRect. so, we now test ExpandMemRec.emTwoCursorsFlag in this 
;									case to avoid it. (bug #1007065) <34l-YDS-9/2/91>
;		 					<34k>	Fix TEGetPoint for styled TE for R->L scripts, used to asume
;									that if we are on a begining of a style run, the width is 0, and
;									if we are on the end, we should TextWidth all of it, which is
;									not true for R->L scripts. (bug #1007067) <34k-YDS-9/2/91>
;							<34j>	Added support for a single caret while handling an Arrow (left
;									or right) key, for styled L->R text. have to change the Keyboard
;									in a different way to support the corect display of a single 
;									caret. <34j-YDS-9/2/91>
;							<34i>	Fix DoMeasure for Right to left text in unstyled TE, in order to 
;									support fix <Y8> for unstyled, use _Pixel2Char instead of 
;									MeasureIt. <34i-YDS-9/2/91> 
;							<34h>	Fix TEGetPoint Bug for Right to left text, use DoMeasure 
;									instead of MeasureIt. <34h-YDS-9/2/91> 
;							<34g>	Synch Keyboard to click even with an unstyled TE record, 
;									this is not only a nice thing to do, but very importent when
;									handling a single cursor on a bi-direction script, if we 
;									would like your single-split carret to be displayed 
;									correctly. <34g-YDS-9/2/91>
;							<34f>	when click on script boundry, take care of the next cursor
;									update, has to do with the split carret stuff. This was fixed
;									in SetKeyboard2Font and ClickKeyboard2Font.<34f-YDS-9/2/91>
;							<34e>	find where the click was (to define the right script).<34e-YDS-9/2/91>
;							<34d>	Support for a single carret, this supports the styled 
;									TE part.<34d-YDS-9/2/91>
;							<34c>	Added support for a single carret, it will expand & shrink 
;									the the right part of a cursor to show only "one" cursor, 
;									depending on the language, so we will gwt a moving cursor 
;									(when switching scripts). this supports the unstyled TE part.<34c-YDS-9/2/91>
;							<34b>	using the byte after the TwoByteCharBuffer in teDispatchH for
;									fixes <3.3> and <3.4> (lastScript), so change the place it clears 
;									so only a word will cleared there.<34b-YDS-9/2/91>
;							<34a>	Fixing Hebrew/Arabic AppleLink bug that causes a big cursor: 
;									the  right way! this fix is in alot of places. <34a-YDS-9/2/91>
;
;
;
;		<33>	  4/3/91	SMB		jdr,#86089: (also, pke) Fixing appl-crashing bug in
;									NewRomanFindLine - should be clearing the high word of d0 before
;									doing a long operation. Shows up when applications use
;									TEHitTestHook and have multiple styles on a line.
;		<32>	 2/14/91	SMB		pke,#70628: Unfortunately, forced to remove support for Forward
;									Delete that was added in <19>. Conditionalizing it out so it can
;									be added again later. See <32>.
;		<31>	 2/14/91	SMB		pke,#82817: After Dark and Chooser string clipping bug -
;									NewRomanFindLine's dependency on _NPixel2Char takes into account
;									the caret width when determining linebreaks. This 1 pixel
;									difference caused strings that were 1 pixel too long to no
;									longer completely display since the linebreak occured in a
;									different place. The problem was that the measurement occured on
;									the character boundary (after the final character of the string)
;									and the leading edge value returned was F. TextEdit deals with
;									these results by backing up one character to guarantee that all
;									characters completely display when drawn. In the case of calling
;									_NPixel2Char this is not necessary since it will still return
;									the correct results and TextEdit will behave correctly based on
;									these results. So, to fix this problem we no longer subtract one
;									for the caret width before calling _(N)Pixel2Char.
;		<30>	 2/14/91	SMB		pke,#68221: Completing the fix in TextBox to turn off
;									PreseveGlyph before drawing in order to draw squished characters
;									when their ascent or descent is larger than the font's metrics.
;									This problem in TextBox can be demonstrated when an accented
;									character appears in a dialog. The previous fix in <22> had the
;									comefrom patch on _DrawText instead of _MoveTo although the rest
;									of the patch was based on the MoveTo call. So, the patch was
;									never executed since the address never corresponded to a
;									DrawText call! Brain damaged!
;		<29>	 2/14/91	SMB		pke,#DTS FT: Quit trashing a4 across Hook calls!
;		<28>	 2/11/91	SMB		pke,#SMB-2/9/91-1: TextEdit didn't always erase characters when
;									deleting them. Another symptom of this same bug is that TextEdit
;									didn't line break at a CR. The problem was that when TE looked
;									ahead for blanks at the end of a line in NewRomanFindLine, it
;									skipped over blanks, CRs and any other character whose value was
;									<=$20. Now it checks each breaking character for a CR and once
;									found, forces a line break there.
;		<27>	 2/11/91	SMB		jdt,#TEBug.ReCaLines: KanjiTalk bug fix in ReCalLines - need to
;									back up 2 bytes for correct redrawing of double-byte text.
;		<26>	 2/11/91	SMB		pke,#OYDBB002: Fixed the MathCad (application) bug in
;									NewRomanFindLines by ckecking for a dummy style run at the end
;									of the StyleRun array whose startChar = endChar.
;		<25>	 2/11/91	SMB		pke,#SMB-2/10/91-1: TextEdit should be using the low memory
;									TEDoText hook rather than jumping directly to the DoText patch!
;		<24>	  2/2/91	PKE		KIP: Fix 606 build by renaming leftSide references in P2CFrame
;									to leadingEdge in code that is only used if SysVers < $700.
;		<23>	  2/1/91	SMB		pke,#HIG-JS-048,#81519,#82169: In NewRomanFindLine: testing for
;									a blank at a line break before calling TE's FindWord routine.
;									Fixed problem with styles in balloons: was comparing a final
;									result to the linestart in d6, but it was modified for styles,
;									so needed to compare to actual value saved in lineStart(a6).
;									Fixed performance problem: change in algorithm caused unstyled
;									TE to call TextWidth on the entire document (pinned to each
;									lineStart) when determining line breaks. Major slowdown! Are now
;									calling _NPixel2Char instead of _TextWidth & _Pixel2Char in TE's
;									Pixel2Char routine (TEHitTestHook). Should make TE FAST(er)!
;									Renamed leftSide to leadingEdge in P2CFrame and added
;									WidthRemaining member (see TextEditPriv.a).
;		<22>	 1/22/91	SMB		(pke) Re-fixing bug #68221. The previous fix required calling
;									OutlineMetrics for the whole font in order to get an ascent &
;									height in TextEdit. This wasn't acceptable due to reformatting
;									problems. So, the code to support OutlineMetrics has been
;									removed and we are now turning off PreserveGlyph before drawing
;									in order to draw squished characters when their ascent or
;									descent is larger than the font's metrics. GetFontInfo will
;									still be used to get ascent & height, as in the past, and we
;									will be backwards compatible although not pretty.
;		<21>	 1/20/91	SMB		(csd) Fix incorrect calling of FindWord and FindLine when
;									patching in ReCalLines and NewRomanFindLine. Must use the
;									low-memory vectors to access the patches. Added a line in
;									ptchRecalLines that was accidentally dropped (thereby causing
;									some linebreaking problems…)
;		<20>	 1/18/91	SMB		(pke) Fixed bug # 62963 - No longer preserving a3/a4 across
;									DumpBuffer routine. Saving a3 caused a dangling ptr and it's not
;									necessary to save a4. Also, added a call to DumpBuffer in
;									TEDispose in case an app never calls TEIdle (which empties the
;									buffer). Changed _NewHandle call in GetHandle to allocate the
;									handle in the System heap in order to prevent orphaning the
;									handle when an application quit without emptying the text
;									buffer. • Also fixed a linebreaking bug in Pixel2Char - wasn't
;									calling DoubleByte with the correct offset (was using the offset
;									for the line not the offset w/in the whole text buffer thus
;									far.)
;		<19>	 1/14/91	SMB		(jdt) • Added ptchReCalLines for a KT bug: Only draw line in
;									ReCalLines when wordRedraw is <1. • Fixed bug # 35646 (fixed for
;									SS-6.0.4 and 6.0.5 in ptch0) - up-arrow key doesn't get to
;									beginning of text. Had to add patches to PtToLine, DoFind,
;									PinDisplay, PinA0Rect and the routines that called them:
;									Refresh, Scroll, TEScroll, TEPinScroll. TEClick, TEKey,
;									TEGetOffset, DefClikProc, DoDraw and DoHilite had to be updated
;									to call these patched routines rather than the ROM routines. •
;									Fixed bug #66732 & #57858: if the scrap handle parameter
;									(newStyles) in SetStylScrap was NIL should do nothing and exit.
;									(see ptchTEDispatch) • Fixed bug #58512: Must lock null scrap
;									handle in InsRsrved before calling PstStylGuts since PstStylGuts
;									expects to use the handle again after moving memory. Since
;									InsGuts calls InsRsrved, patched InsGuts and the two routines
;									that call it, TEInsert & TEStylInsert. • Fixed bug #77962: TE
;									was determining line breaks by measuring words rather than style
;									runs for a Roman-only system. This was causing drawing to be
;									significantly different than the measuring when FractEnable was
;									on or a scaled font was used. Rewrote code (now called
;									NewRomanFindLine) to do the right thing! • fjs fixed bug #70628:
;									adding forwardDeleteChar support in TEKey so that this function
;									key on the extended keyboard works. • Fixed bug #67699:
;									StdTxMeas did not detect overflow when measuring long lines, so
;									the widths returned to TE in this case were small, causing TE to
;									write all the text on one line. StdTxMeas was modified to keep
;									the last count and width before the overflow. This info is used
;									to call _Pixel2Char to get the correct character offset for line
;									breaking. • Fixed bug #66900: TextBox did not clip text
;									correctly for long words due to the incorrect use of _P2C's
;									LeadingEdge flag. See changes in TE's Pixel2Char and
;									ptchDoSearch. • Fixed bug #68221: did not calculate the ascent &
;									descent of an outline font correctly if preserveGlyph is true.
;									Now calling OutlineMetrics for this. See routine
;									GetOutlineMetrics; the routines needing it (TextBox & GetSize)
;									require a comeFrom tail patch on GetFontInfo. • Fixed Finder
;									bugs #80728 & 75607: in StdEntry, for unstyled text, save the
;									grafport's font info before setting the TERec's style info into
;									the grafport.
;		<18>	12/15/90	SMB		(gbm) Added support for another gestalt selector, gestaltTE5,
;									for the new TextWidthHook.
;		<17>	10/30/90	SMB		(PKE) • Fix text buffering bug: must preserve register a1
;									(ExpandMem ptr) around a call to SetFont2Keyboard. Also, moved
;									code that dumps the buffer in SetFont2Keyboard after determining
;									that synchronizing was necessary. Then, must test for an empty
;									buffer in TEBufferText after the SetFont2Keyboard call and after
;									a full buffer has been dumped. Using hasBufferingFix conditional
;									for these changes. • Added TextWidthHook to dispatch table and
;									the internal interface which uses the hook, TETextWidthHook to
;									hook out the TextWidth calls to keep our developers happi(er)!.
;									Renamed nTEWidthHook to ScriptChar2Pixel. Using hasTextWidthHook
;									conditional for these changes.
;		<16>	 9/16/90	SMB		Put GestaltTEciVersion proc and installation code back in.
;		<15>	 9/11/90	SMB		Fix teCROnly bug that crashes the system: pre-incrementing
;									caused us to compare one too many in the text and then the +1 to
;									point beyond the CR caused the line breaks to be one off. Moved
;									InlineInput test into TESetSelect instead of ClickKeyboard,
;									since never want to call KeyScript while doing inline. If in
;									Inline, then not hilighting to the EOLs anymore, only to edge of
;									text (see InvrtRectangle). Modified highlighting code to
;									highlight the middle rectangle line by line in order to call
;									highHook for Inline. Fixed Hebrew/Arabic scrolling down bug -
;									caused selRect's top & bottom values to be negative which caused
;									a BIG caret to be drawn. Fixed in CaretInsideRun (revisited:
;									must also bra if equal).
;		<14>	 8/14/90	DTY		Changed into a linked patch.
;		<13>	 6/22/90	SMB		NEEDED for SS-6.0.5, SIXPACK & 7.0: fixed Arabic line end bug
;									for unstyled text, where the system slowed down because was
;									reading off the end of the line starts.
;		<12>	 6/11/90	SMB		NEEDED FOR SIXPACK & 7.0: Added Inline Input bit to
;									TEFeatureFlag and support for it in ClickKeyboard2Font.
;		<11>	 5/29/90	DDG		NEEDED FOR SIXPACK: Changed all the sixpack conditionals from
;									six-point-oh-seven to six-point-oh-six.
;		 <9>	 4/27/90	SMB		NEEDED for SIXPACK - Fixed old bug for old FindWord: when using an
;									application's teWordBreak routine must save d1!
;		 <8>	 4/10/90	SMB		NEEDED for 6.0.x, 7.0 and SS-6.0.5: Adding Scrolling Down bug
;									fix that I erroneously omitted on 1/16/90! (see comment <3>
;									below)
;		 <7>	 3/20/90	SMB		NEEDED for 6.0.5 and SS-6.0.4 - Added call to SetKeyboard2Font
;									in TEKey (rather than DelGuts, see 1/23/90) for Script Systems:
;									whenever backspacing over a script boundary the keyscript wasn't
;									updated. Bug #59422. - Fixed TEFindWord for line breaking on a
;									Roman-only system to branch for 'bge' to #teFromFind instead of
;									'bgt'. (Should have been in 1/23/90??) - In TEBufferText, must
;									set d0 to the current position before calling SetFont2Keyboard
;									(in case of a kbd change while buffering)
;		 <6>	 2/18/90	SMB		NEEDED for 6.0.5 - DoSearch didn't work correctly when the
;									TEHitTestHook had been replaced. We needed to check a
;									terminating condition when hooked out: the high word of d0 was
;									set T if found a char offset.
;		 <5>	 2/13/90	SMB		NEEDED for 6.0.5 - Moved conditional test in ptchDelGuts.	-
;									Patched TEWidthHook in GetLRPosition, PixelWidths, and GetWidth.
;									Also added nTEWidthHook and OldChar2Pixel.
;				 					- Patched TEWidthHook in GetLRPosition, PixelWidths, and GetWidth. Also
;									added nTEWidthHook and OldChar2Pixel.
;		 <4>	 1/30/90	SMB		NEEDED FOR SS-6.0.4 and 6.0.5 -
;				 1/30/90	smb		- Fix in TEKey so that when the current position is at a line end and
;									the height of the current line is > the height of the next line, the 
;									down arrow will put the caret on the next line.  Bug #53697.
;				 1/30/90	smb		-Decided NOT to fix bug 35646 for the IIci - up-arrow key doesn't get 
;									to beginning of text - since it wasn't very important and it would
;									take a lot of patches in many routines to fix it.
;				 1/29/90	smb		- No longer call SetFont2Keyboard for ptchDumpBuffer.
;									- Added patch to DoCaret to pin the caret in view when 
;									blanks exceed the edge of the view rect.
;				 1/26/90	smb		- Before synchronizing the font to the keybd, dump the text buffer: user
;									could change the keyboard in the middle of buffering. (see TEBufferText and
;									SetFont2Keyboard)
;				 1/25/90	smb		- Call HideCaret for up & down arrows to erase the old caret before
;									setting teLftCaret in TEKey. Fixes bug #52887!
;									- Fixed up arrow bug, #51967, that caused the caret to move up multiple 
;									lines according to the size of the largest font on the current line.
;									- If zero width in DoSearch, want to branch ow this one pixel difference
;									causes the caret to display on the wrong line ending. Roman fix.
;									Bugs #58921,59247.
;				 1/24/90	smb		- Found bug in DoSearch where needed to setup a2 as current line again.
;				 1/23/90			- Removed all equates and records since moved them into TextEditPriv.a.
;							emt		- Added humane scrolling (slower) to DefClikProc (also see TEClick).
;				 1/23/90			- Changed FindWord branch for linebreaking to 'bge' instead of 'bgt'.
;									- Added call to SetKeyboard2Font in DelGuts for Script Systems: 
;									whenever backspacing over a script boundary the keyscript wasn't
;									updated. Bug #59422.
;									- Reorg beginning of FindWord in order to be compatible with applications
;									using incorrect char breaking algorithms for Script Systems.
;		 <3>	 1/16/90	SMB		NEEDED FOR 6.0.5 - Fixed bug in TEGetPoint, added double-byte
;									buffer at end of dispatch record, fixed bug in r-to-l processing
;									of caret that showed up when scrolling down.
;		 		 1/8/90		SMB		NEEDED FOR 6.0.4SS & 6.0.5: bug 58823, TEGetPoint returned 
;									incorrect values when there's no text in the TERec. • Using 
;									private space in TEDispatchRec for buffering of a double-byte
;									char rather than using ExpandMem as a global buffer which can
;									affect any active TE record.  This fixes a bug seen in KanjiTalk
;									(AppleShare)when an application uses two TE records. Buffering
;									in one record can be dumped into the other record due to the 
;									global storage space not knowing which record it applies to.
;		 <2>	  1/4/90	PKE		NEEDED FOR 6.0.5 (smb's changes from SS-6.0.4b23 to SS-6.0.4f1):
;									• Set the offset parameter to non-zero for StyledLineBreak for
;									unstyled text. • In ptchTESetStyle and ptchTEGetPoint must pop
;									TEDispatch's return address. • Added ptchHiliteMiddle and
;									patched out more of OnSameLine and MeasureWidth to use this
;									patched HiliteMiddle. Have to save d2! ALSO: Changed
;									conditionals from (Scripts604 | SysVers >= $700) to (Scripts604
;									| SysVers >= $605). Updated header to BBS format.
;		<1>		12/18/89	CCH		Adding for the first time into BBS.
; BBS versions from here up:
;___________________________________________________________________________________________________
; EASE versions below:
;	   <1.3>	12/14/89	smb		Added ROMEndDoSearch jmp address since I left it off and broke
;									the 6.0.5 build!
;	   <1.2>	12/11/89	smb		More Arabic fixes: horizontal cursor movement now works at line
;									ends.
;								•	In CursorMovement and GetStyleEnd had to pin the style run to
;									the line end for correct position.
;								•	Need to use the high caret rectangle in TEKey rather than always
;									using the teSelRect!
;								•	Added a new keyboard/font synchronization routine to be used
;									when doing a hit-down which allows a Roman keyboard with a
;									non-Roman font, specifically because KanjiTalk wants to enter
;									Roman text from a Japanese font.
;								•	Fixed potential bug in TESetStyle: must test the doFont bit in
;									the mode since it's possible for the mode to be an additive 
;									combination of styles.
;								•	Use application font for SetFont2Keyboard rather than system
;									font.
;								•	Have to use emBufferPtr for a flag to indicate when I
;									unsynchronize the font & keyboard in ClickKeyboard2Font. These
;									will be used to keep SetFont2Keyboard from synchronizing the
;									font & keyboard when trying to paste a character in this
;									unsynchronized situation.
;								•	Also had to add a call to ClickKeyboard2Font from TESetSelect
;									in order for horizontal cursor movement to work correctly in
;									this new unsynchronized situation.
;								•	Fixed LR highlighting bug at line ends; in InvrtRectangle.
;								•	Unconditionalized code in VisibleLength to fix a LR line w/
;									R justification display bug. Mark was right!
;								•	Set flags in caret display code to indicate when in the middle
;									of a style run but on a line end (see CaretInsideRun).
;								•	Fixed bug in {hit-down on,cursor movement to} a script boundary
;									to set the keyboard to the preceeding style run rather than the
;									succeeding one. (see calls to ClickKeyboard2Font).
;								•	In BufferChar & DumpBuffer backed up one offset posn to get
;									previous style run for SetFont2Keybaord call.
;								•	Fixed problem with setting the boundaries in ChkBounds. Also set
;									boundary in DoDraw based on WordRedraw rather than teSysJust.
;								•	Corrected test of teForceLeft in iTEGetPoint.
;								•	Fixed bug of a large cursor (#52888) due to RomanFindLine (really
;									StylMeasure & P2C) incorrectly increasing the char count due to
;									an invalid leftSide flag set in TE's P2C. This caused ReCalLines
;									to read beyond the end of the line heights record. Fixed by
;									setting a flag which said to ignore the leftSide flag if TextWidth
;									did the measuring in P2C.
;	   <1.1>	11/21/89	smb		Bug fix in FindWord for Chinese Script System: clear
;									fwLeadingEdge flag!
;								•	Added updating of outlined region in TEUpdate.
;								•	Fixed TETrimMeasure to call VisibleLength at the appropriate times
;									for unstyled text: LineRect uses the line direction and
;									justification to determine when to call it.
;								•	Adding call to GetStylesInOrder in order to call VisibleLength
;									for a line's style runs. We need to traverse the style runs in
;									display order but backwards!
;								•	Fixed buffering bug in BufferChar & TEKey; must set emBufferLen
;									non-zero when buffer the 1st byte of a 2-byte character.
;								•	Moved secondStyleRun and firstStyleRun from SharedFrame to
;									FmtOrderFrame since TextFrame needs this info for XTrimMeasure
;									changes.
;								•	Bug fix for buffering 2 byte text on Kanji! see DumpBuffer and
;									TEBufferText.
;								•	Removed testing of LRTextFlag since it's based on WordRedraw.
;									Will tst WordRedraw instead!
;								•	Not removing setting of LRTextFlag in GetFormatOrdering or
;									teGetFormatOrder since it won't hurt.
;								•	Had to clear (a2) in iTEFeatureFlag so that the return result was
;									set right for an initial state of clear (vs. set). 
;								•	Fixed ptchTrimMeasure for unstyled TE. Also added test for 
;									unstyled TE in ptchGetNextDisplayStyle. Moved firstStyleRun and
;									secondStyleRun to "top" of FmtOrderFrame.
;								•	In ptchTEGetPoint changed longs back to words as they were
;									originally!
;								•	Bug in DumpBuffer for unstyled textEdit: screwed up stack since was
;									popping the stack w/o doing the push! Now doing the push as well!
;								•	SecondStyleRun and firstStyleRun need to be above directionParam in
;									the FmtOrderFrame!
;								•	Added @getStyleNew code for right-to-left directional scripts in
;									ptchDoSearch.
;								•	Added a test in ptchGetRLPosition because when processing a CR
;									entered at the EOD, the current line (a2) is the next line. This
;									causes TE to look beyond the end of the lineStarts array.
;	   <1.0>	10/12/89	smb		New file containing the TextEdit patches from PatchIIciROM.a. Is
;									included therein.
;____________________________________________________________________________
; To aid the historians, here is the recent history of TextEdit from PatchIIciROM.a:
;
;	   <7.7>	10/12/89	smb		Moved TextEdit patches to TextEditPatchIIciROM.a. Fixed bug in
;									old highlighting code that I introduced accidently (changed
;									move.w -> move.l).
;	   <7.2>	 10/5/89	smb		Added old highlighting code for TextEdit for HyperCard
;									outlining.
;	   <7.0>	 10/4/89	smb		Fixed 6.0.4 build by moving around some of my conditionals due
;									to dependencies! Fixed TEInit to set TEDoText like it used to.
;									Cleaned up TEOutlineHilite. Fixed caret display for outline
;									highlighting.
;	   <6.8>	 9/29/89	smb		Added patches for TextEdit for TEFeatureFlag, SetFont2Keyboard,
;									and fixed CursorMovement for double-byte characters.
;	   <5.5>	 8/30/89	smb		NEEDED FOR Scripts604 and Big Bang! Bug fix in ptchTEFindWord
;									(fixed word dragging bug and now uses old FindWord code when
;									RecalLines calls. Also added ptchMeasureWidth to fix a
;									hilighting bug at line ends when the line direction is RL on a
;									system that is normally LR (ie - Roman, Kanji, etc.)
;	   <4.2>	 8/18/89	smb		NEEDED FOR 6.0.4: Another unlocked handle problem!
;									AAAARRRRRGGGGHHHHHH! (See ptchOnSameLine below)
;	   <3.8>	 8/15/89	smb		NEEDED FOR 6.0.4: Fixed some problems in my patch code for the
;									bad pointer bug.
;	   <3.4>	 8/11/89	smb		smb Finally rolled in patches for a bad pointer bug (#51602) and
;									an up & down arrow keys bug (#51961). See comments below.
;	   <3.1>	  8/8/89	smb		NEEDED FOR 6.0.4: Reverted TEFindWord patch since the previous
;									patch introduces an uglier bug that won't be fixed now. Also
;									added gestalt function for TE.
;	   <2.8>	  8/8/89	smb		NEEDED FOR 604: Added more TE patches for Aurora!
;	   <1.8>	 7/25/89	smb		NEEDED FOR 6.0.4: Added TextEdit patches for Aurora.
;____________________________________________________________________________
;	To Do:
;	Check insGuts: may be able to use a0 instead of a1 for _HLock.
;	TEKEy: set d6 to 1,-1 and move into d3 for doublebyte call.
;	Remove extraneous code from NewRomanFindLine. Marked with (XX).
;	See WBOverid - could simply jump into rom again since removed ForceOldFW patch.
;____________________________________________________________________________

			LOAD	'StandardEqu.d'
			INCLUDE	'GestaltEqu.a'
			INCLUDE	'SysPrivateEqu.a'
			INCLUDE	'LinkedPatchMacros.a'

  			IF  		(&TYPE('Scripts604') = 'UNDEFINED') THEN 
Scripts604 	EQU 		0
  			ENDIF
  		IF  &TYPE('forLocalizability') = 'UNDEFINED' THEN	;					<35>
forLocalizability 	EQU 1									;					<35>
  		ENDIF												;					<35>
			
	IF Scripts604 | SysVers>= $605 THEN			; added Scripts604 <20July89smb>
			INCLUDE		'ScriptPriv.a'			; <8July89smb>
	ENDIF
			INCLUDE		'TextEditPriv.a'		; <1/9/90smb>
			INCLUDE		'fontPrivate.a'			; <19>

ROMXDoText			ROMBind		(IIci,$22A70)				; called by TEInit
ROMXReCalLines		ROMBind		(IIci,$243B8)				; called by TEInit
ROMDefWordBrk		ROMBind		(IIci,$240B4)				; called by TEInit
EndTEInit			ROMBind		(IIci,$2200C)				; called by TEInit
ROMForceOldFW		ROMBind		(IIci,$24062)				; called by ptchTEFindWord
ROMWBOverid			ROMBind		(IIci,$24066)				; called by ptchTEFindWord
ROMTESMgrFWord		ROMBind		(IIci,$23F5C)				; called by ptchTEFindWord
ROM@GetSelWrap		ROMBind		(IIci,$23F82)				; called by ptchTEFindWord
EndDelGuts			ROMBind		(IIci,$23D0A)				; called by DelGuts (TEDelete)
ROMStdEntry			ROMBind		(IIci,$23B1A)				; called by DelGuts (TEDelete)
ROMHideCaret		ROMBind		(IIci,$246B4)				; called by DelGuts (TEDelete)
ROMSelSort			ROMBind		(IIci,$23C08)				; called by DelGuts (TEDelete)
ROMGetCurStyle		ROMBind		(IIci,$2534A)				; called by DelGuts (TEDelete), ptchSetFont2Keyboard
ROMClearRsrved		ROMBind		(IIci,$223D0)				; called by DelGuts (TEDelete)
ROMGetStyle			ROMBind		(IIci,$253BE)				; called by DelGuts (TEDelete)
ROMAltSetRsrved		ROMBind		(IIci,$253F4)				; called by DelGuts (TEDelete)
ROMDeleteStyle		ROMBind		(IIci,$23D8A)				; called by DelGuts (TEDelete)
ROMMungeSetup		ROMBind		(IIci,$24A94)				; called by DelGuts (TEDelete)
ROMConcatStyles		ROMBind		(IIci,$257F2)				; called by DelGuts (TEDelete)
ROMConcatRuns		ROMBind		(IIci,$2584C)				; called by DelGuts (TEDelete)
ROMSetStyle			ROMBind		(IIci,$257AE)				; called by ptchSetFont2Keyboard
ROMAnyNullStyle		ROMBind		(IIci,$25710)				; called by ptchSetFont2Keyboard
ROMSetRsrved		ROMBind		(IIci,$253E8)				; called by ptchSetFont2Keyboard
ROM@Use4HitTest		ROMBind		(IIci,$238F2)				; label in ptchTEChar2Pixel
ROM@UseC2P			ROMBind		(IIci,$23928)				; label in ptchTEChar2Pixel
ROMGetDirection		ROMBind		(IIci,$22F50)				; called by ptchTEChar2Pixel
ROM@fixStack		ROMBind		(IIci,$23922)				; label in ptchTEChar2Pixel
ROM@RomanTrim		ROMBind		(IIci,$237B6)				; label in ptchTrimMeasure
ROMMeasureIt		ROMBind		(IIci,$237D6)				; called by ptchTrimMeasure
EndCursorMovement	ROMBind		(IIci,$24D2E)				; called by ptchCursorMovement
ROMSetUpP2C			ROMBind		(IIci,$2413C)				; called by ptchPixel2Char
ROMTEPixel2Char		ROMBind		(IIci,$22696)				; called by ptchPixel2Char
ROMDoHilite			ROMBind		(IIci,$23114)				; called by ptchTEDoText
ROMDoCaret			ROMBind		(IIci,$22A86)				; called by ptchTEDoText
ROMPreamble			ROMBind		(IIci,$22A2C)				; called by ptchTEDoText
ROMLineRect			ROMBind		(IIci,$236D2)				; called by ptchTEDoText
ROM@BailToLeft		ROMBind		(IIci,$227F6)				; label in ptchDoSearch
ROM@DoMeasure		ROMBind		(IIci,$227B0)				; label in ptchDoSearch
ROM@getStyleOld		ROMBind		(IIci,$2277A)				; label in ptchDoSearch
ROM@NoMoreStyles	ROMBind		(IIci,$227E4)				; label in ptchDoSearch
ROMEndDoSearch		ROMBind		(IIci,$2275A)				; called by ptchTEDoText
ROMEndTEFmtOrder	ROMBind		(IIci,$22FF6)				; called by ptchTEGetFormatOrder
ROMDoDraw			ROMBind		(IIci,$2288E)				; called by ptchDoDraw
ROMPinDisplay		ROMBind		(IIci,$23A5A)				; called by ptchDoDraw
ROMPrepLine			ROMBind		(IIci,$22A18)				; called by ptchDoDraw
ROMChkBounds		ROMBind		(IIci,$23638)				; called by ptchDoDraw,ptchGetStylesInOrder
ROMDoErase			ROMBind		(IIci,$229AC)				; called by ptchDoDraw
ROMTEDrawHook		ROMBind		(IIci,$22878)				; called by ptchDoDraw
ROMPtrToLine		ROMBind		(IIci,$236C6)				; called by ptchDoDraw
ROMNextLineRect		ROMBind		(IIci,$236A8)				; called by ptchDoDraw
ROMFreeFmtOrderArray	ROMBind		(IIci,$230FE)			; called by ptchDoDraw
ROMGetFormatOrdering	ROMBind		(IIci,$22F82)			; called by ptchCaretDisplay
ROMFixFormatEnd		ROMBind		(IIci,$24F52)				; called by ptchCaretDisplay
ROMGetLRPosition	ROMBind		(IIci,$22C1A)				; called by ptchCaretDisplay
ROMGetRLPosition	ROMBind		(IIci,$22C6A)				; called by ptchCaretDisplay
ROMMeasureWholeRun	ROMBind		(IIci,$23404)				; called by ptchCaretDisplay
ROM@SetEnds			ROMBind		(IIci,$22BCA)				; label in ptchCaretDisplay
ROM@finis			ROMBind		(IIci,$22BF6)				; label in ptchCaretDisplay
ROM@done			ROMBind		(IIci,$22C12)				; label in ptchCaretDisplay
ROMteGetFormatOrder	ROMBind		(IIci,$22FE2)				; called by ptchGetStylesInOrder
EndGetStylesInOrder	ROMBind		(IIci,$22FDA)				; called by ptchGetStylesInOrder
ROMOldStyle			ROMBind		(IIci,$232B2)				; called by ptchOnSameLine
ROMMeasureWidth		ROMBind		(IIci,$2333A)				; called by ptchOnSameLine
ROMHiliteMore		ROMBind		(IIci,$232C8)				; called by ptchOnSameLine
ROM@OneStyleTest	ROMBind		(IIci,$23654)				; label in ptchChkBounds
ROM@OneStyle		ROMBind		(IIci,$23674)				; label in ptchChkBounds
BackToChkBounds		ROMBind		(IIci,$23662)				; called by ptchChkBounds
BackToDoMeasure		ROMBind		(IIci,$239C8)				; called by ptchDoMeasure
ROM@MeasureDone		ROMBind		(IIci,$23A4E)				; label in ptchDoMeasure
ROMGetWidth			ROMBind		(IIci,$2382C)				; called by ptchDoMeasure
ROM@PlainMeasure	ROMBind		(IIci,$23A40)				; label in ptchDoMeasure
BackToTestRunDirection	ROMBind	(IIci,$24F2A)				; called by ptchTestRunDirection
ROMGetLine			ROMBind		(IIci,$22A5A)				; called by ptchCursorMovement
ROM@CursorMoveDone	ROMBind		(IIci,$24EDE)				; label in ptchCursorMovement
ROMTestLineEnds		ROMBind		(IIci,$24EE6)				; called by ptchCursorMovement
ROMSetRun			ROMBind		(IIci,$24F04)				; called by ptchCursorMovement
ROM@OneCharacterTest	ROMBind	(IIci,$24E9C)				; label in ptchCursorMovement
ROM@CSubDelta		ROMBind		(IIci,$24ED8)				; label in ptchCursorMovement
ROM@InMiddle		ROMBind		(IIci,$24E3E)				; label in ptchCursorMovement
ROM@TakeRightBranch	ROMBind		(IIci,$24E78)				; label in ptchCursorMovement
ROMGetStyleEnd		ROMBind		(IIci,$24F40)				; called by ptchCursorMovement
ROM@NewFmtIndex		ROMBind		(IIci,$24E36)				; label in ptchCursorMovement
ROMGetNumStyles		ROMBind		(IIci,$25398)				; called by ptchDoMeasure
ROM@RightArrow		ROMBind		(IIci,$24BB0)				; label in ptchTEKey
ROM@LeftArrow		ROMBind		(IIci,$24BB8)				; label in ptchTEKey
ROM@NormalChar		ROMBind		(IIci,$24B6C)				; label in ptchTEKey
ROMbackspace		ROMBind		(IIci,$24C12)				; called by ptchTEKey
ROMFindLineHite		ROMBind		(IIci,$250E0)				; called by ptchTEKey
ROMDoFind			ROMBind		(IIci,$22668)				; called by ptchTEKey
ROMleftRight		ROMBind		(IIci,$24BD6)				; called by ptchTEKey
ROM@hiliteIt		ROMBind		(IIci,$2338A)				; label in ptchMeasureWidth
ROM@dontQuit		ROMBind		(IIci,$2338E)				; label in ptchMeasureWidth
ROM@inBetween		ROMBind		(IIci,$2339A)				; label in ptchMeasureWidth
ROM@justMeasure		ROMBind		(IIci,$233F2)				; label in ptchMeasureWidth
ROMHiLite			ROMBind		(IIci,$22552)				; called by ptchTEActivate
ROMinTEDispatch		ROMBind		(IIci,$23C06)				; called by ptchTEDispatch
ROMinTEGetText		ROMBind		(IIci,$2203C)				; called by ptchTEGetText
ROMinTESetText		ROMBind		(IIci,$22186)				; called by ptchTESetText
ROMinTECalText		ROMBind		(IIci,$2229E)				; called by ptchTECalText
ROMinTESetSelect	ROMBind		(IIci,$22302)				; called by ptchTESetSelect
ROMinTEClick		ROMBind		(IIci,$22568)				; called by ptchTEClick
ROMinTECopy			ROMBind		(IIci,$23C1C)				; called by ptchTECopy
ROMinTECut			ROMBind		(IIci,$23CF4)				; called by ptchTECut
ROMinTEIdle			ROMBind		(IIci,$24770)				; called by ptchTEIdle
ROMinTEPaste		ROMBind		(IIci,$2479A)				; called by ptchTEPaste
ROMinTEInsert		ROMBind		(IIci,$24B18)				; called by ptchTEInsert
ROMinTESetJust		ROMBind		(IIci,$250FC)				; called by ptchTESetJust
ROMinTEScroll		ROMBind		(IIci,$25124)				; called by ptchTEScroll
ROMinTEPinScroll	ROMBind		(IIci,$2517A)				; called by ptchTEPinScroll
ROMinTESelView		ROMBind		(IIci,$25202)				; called by ptchTESelView
ROMinTEAutoView		ROMBind		(IIci,$2528C)				; called by ptchTEAutoView
ROMinTEGetOffset	ROMBind		(IIci,$25952)				; called by ptchTEGetOffset
ROMDrawCaret		ROMBind		(IIci,$246A8)				; called by ptchTEKey
ROMinPasteChar		ROMBind		(IIci,$24C02)				; called by ptchTEKey
ROMStdExit			ROMBind		(IIci,$222A2)				; called by ptchTEKey
ROMGetHandle		ROMBind		(IIci,$24C7E)				; called by ptchTEBufferText
ROM@MoreRoom		ROMBind		(IIci,$24C72)				; label in ptchTEBufferText
ROMPasteGuts		ROMBind		(IIci,$24838)				; called by ptchDumpBuffer
ROMDoubleByte		ROMBind		(IIci,$24FD2)				; called by ptchCursorMovement
ROMStdExit2			ROMBind		(IIci,$222A8)				; called by ptchTEFeatureFlag
ROMEpilog4			ROMBind		(IIci,$222A0)				; called by ptchTEActivate/ptchTEDeactivate
ROMTEFeatureFlag	ROMBind		(IIci,$252AC)				; called by ptchStdEntry (to patch TEDispatch)
ROMAddrTable		ROMBind		(IIci,$21EE0)				; called by ptchStdEntry
ROMGetLineHites		ROMBind		(IIci,$23736)				; called by ptchDoHilite
ROMInvertHook		ROMBind		(IIci,$23AF6)				; called by ptchDoHilite
ROMDrawIt			ROMBind		(IIci,$246C8)				; called by ptchTEActivate
ROMRefresh			ROMBind		(IIci,$25104)				; called by ptchTEUpdate
ROMEpilog8			ROMBind		(IIci,$2512C)				; called by ptchTEUpdate
ROM@FullStyleRun	ROMBind		(IIci,$2386E)				; label in ptchGetWidth
ROM@UseChar2Pixel	ROMBind		(IIci,$2387C)				; label in ptchGetWidth
ROMinTEGetPoint		ROMBind		(IIci,$259E6)				; called by ptchTEGetPoint
ROMTEGetPoint		ROMBind		(IIci,$25990)				; called by ptchStdEntry
ROM@HitIt			ROMBind		(IIci,$2280E)				; label in ptchDoSearch
ROMTEHitTestHook	ROMBind		(IIci,$2286C)				; called by ptchDoSearch
ROMinGetRLPosn		ROMBind		(IIci,$22CBA)				; called by ptchGetRLPosition
ROM@LineEnd			ROMBind		(IIci,$22D26)				; label in ptchGetRLPosition
ROM@InRLMiddle		ROMBind		(IIci,$22D2A)				; label in ptchGetRLPosition
ROM@GotCursorStyle	ROMBind		(IIci,$22CC0)				; label in ptchGetRLPosition
ROMinSetKeyboard2Font	ROMBind		(IIci,$250CA)			; called by ptchSetKeyboard2Font
ROM@DoneInKeybd2Font	ROMBind		(IIci,$250DC)			; label in ptchSetKeyboard2Font
ROM@KeybdOK			ROMBind		(IIci,$25504)				; label in ptchiTESetStyle
ROM@DoEndOfLine		ROMBind		(IIci,$259FC)				; label in ptchiTEGetPoint
ROM@DoTheJustThing	ROMBind		(IIci,$25A04)				; label in ptchiTEGetPoint
ROMCleanUpSel		ROMBind		(IIci,$23BCE)				; called by ptchTESetSelect
ROM@NoSynchInSetSelect	ROMBind		(IIci,$22334)			; label in ptchTESetSelect
ROM@NoSynchInTEClick	ROMBind		(IIci,$225AC)			; label in ptchTEClick
ROM@LROrientation	ROMBind		(IIci,$228B2)				; label in ptchDoDraw
ROM@UseStyleStart	ROMBind		(IIci,$22E7E)				; label in ptchCaretInsideRun
ROMbeyond@UseStyleStart	ROMBind	(IIci,$22E84)				; label in ptchCaretInsideRun
ROMHiliteLineEnds	ROMBind		(IIci,$23498)				; called by ptchInvrtRectangle
ROMPixelWidths		ROMBind		(IIci,$235BE)				; called by ptchInvrtRectangle
ROMafter@HitIt		ROMBind		(IIci,$2281A)				; label in ptchDoSearch
ROMfindDone			ROMBind		(IIci,$2283A)				; called by ptchDoSearch
ROMTESetStyle		ROMBind		(IIci,$254EE)				; called by ptchTEDispatch
ROMTEEOLHook		ROMBind		(IIci,$22850)				; called by ptchTEFindLine
ROMinFindLine		ROMBind		(IIci,$241D0)				; called by ptchTEFindLine
ROM@SetUp			ROMBind		(IIci,$2428C)				; label in ptchTEFindLine
ROM@FindLineFinis	ROMBind		(IIci,$2430E)				; label in ptchTEFindLine
ROMRomanFindLine	ROMBind		(IIci,$24316)				; called by ptchTEFindLine
ROM@testEnds		ROMBind		(IIci,$232D6)				; label in ptchOnSameLine
ROM@exit			ROMBind		(IIci,$233FE)				; label in ptchMeasureWidth
ROM@HiliteOffsetRun	ROMBind		(IIci,$233E6)				; label in ptchMeasureWidth
ROM@hiliteRun		ROMBind		(IIci,$233BA)				; label in ptchMeasureWidth
ROMteHiliteText		ROMBind		(IIci,$234D8)				; called by ptchOnSameLine
ROMGetHite			ROMBind		(IIci,$23776)				; called by ptchTEGetPoint
ROMinTENew			ROMBind		(IIci,$223BC)				; label in ptchTENew
ROMXEOLHook			ROMBind		(IIci,$2285A)				; called by ptchInstallIntDispatch
ROMXDRAWHook		ROMBind		(IIci,$22884)				; called by ptchInstallIntDispatch
ROMChar2Pixel		ROMBind		(IIci,$23896)				; called by ptchInstallIntDispatch
ROMPixel2Char		ROMBind		(IIci,$22690)				; called by ptchInstallIntDispatch
ROMGetSize			ROMBind		(IIci,$2226A)				; called by ptchTENew
ROMSetDirection		ROMBind		(IIci,$22F16)				; called by ptchTENew
ROMDefClikProc		ROMBind		(IIci,$252D6)				; called by ptchTENew
ROMinTEStylNew		ROMBind		(IIci,$224D4)				; label in ptchTEStylNew
ROMMyNewHandle		ROMBind		(IIci,$22510)				; called by ptchTEStylNew
ROMGetDefStyle		ROMBind		(IIci,$22206)				; called by ptchTEStylNew
ROMPtToLine			ROMBind		(IIci,$23AA8)				; called by ptchDefClikProc
ROMSetKeyboard2Font	ROMBind		(IIci,$250B2)				; called by ptchDelGuts
	IF hasTextWidthHook	THEN								;									<17>
ROM@ZeroWidth		ROMBind		(IIci,$22A04)				; called by ptchDoErase				<17>
ROM@GoErase			ROMBind		(IIci,$22A08)				; called by ptchDoErase				<17>
	ENDIF													;									<17>
	IF SysVers>= $700	THEN								;									<19>
ROMstage2y			ROMBind		(IIci,$2442E)				; called by ptchReCalLines			<19>
ROMstage2A			ROMBind		(IIci,$2443C)				; called by ptchReCalLines			<19>
ROMClrLineSts		ROMBind		(IIci,$24442)				; called by ptchReCalLines			<19>
ROMinPtToLine		ROMBind		(IIci,$23AB6)				; called by PtToLine				<19>
ROMinDoHilite		ROMBind		(IIci,$23118)				; called by ptchDoHilite			<19>
ROMinDoFind			ROMBind		(IIci,$22670)				; called by ptch{TEClick,TEKey,TEGetOffset}	<19>
ROMinPinDisplay		ROMBind		(IIci,$23A84)				; called by ptchPinDisplay			<19>			
ROMinRefresh		ROMBind		(IIci,$2510C)				; called by ptchRefresh				<19>			
ROMSetStylScrap		ROMBind		(IIci,$25A60)				; called by ptchTEDispatch			<19>
ROMTEStylInsert		ROMBind		(IIci,$25B20)				; called by ptchTEStylInsert		<19>
ROMPstStylGuts		ROMBind		(IIci,$248EE)				; called by ptchTEStylInsert		<19>
ROMRecalDraw		ROMBind		(IIci,$23E18)				; called by ptchTEStylInsert		<19>
ROMShowCaret		ROMBind		(IIci,$24690)				; called by ptchTEStylInsert		<19>
ROMAfterInsert		ROMBind		(IIci,$24B28)				; called by ptchTEInsert			<19>
ROMInsRsrved		ROMBind		(IIci,$24AAA)				; called by ptchInsGuts				<19>
ROMClickExpand		ROMBind		(IIci,$22544)				; called by ptchTEClick				<19>
AfterMoveToInTextBox	ROMBind		(IIci,$22116)			; used for patch to TextBox			<22>
ROMGo14Exit			ROMBind		(IIci,$2217C)				; used for patch to TextBox			<22>
ROMinTEDispose		ROMBind		(IIci,$22052)				; used for patch to TEDispose		<20>
ROMinGetHandle		ROMBind		(IIci,$24C80)				; called by ptchGetHandle			<20>
ROMFindWord			ROMBind		(IIci,$23F34)				; called by ptchReCalLines & ptchNewRomanFindLine	<21>
ROMFindLine			ROMBind		(IIci,$24144)				; called by ptchReCalLines			<21>
ROMDoText			ROMBind		(IIci,$22A6A)				; called by ptchTEKey and ptchTEClick	<25>
AfterHiliteText		ROMBind		(IIci,$23536)				; used for patch to teHiliteText	<29>
	ENDIF													;									<19>
	IF forLocalizability THEN								; <34-YDS-9/2/91>
ROMInMeasureIt		ROMBind		(IIci,$237DA)				; called by DoMeasure
ROMSelView			ROMBind		(IIci,$25208)				; called by ptchTEKey
ROM@goHome			ROMBind		(IIci,$24792)				; called by ptchTEIdle
ROMOneCursor		ROMBind		(IIci,$22EEA)				; called by ptchGetRLPosition
ROM@RLDone			ROMBind		(IIci,$22D2E)				; label in GetRLPosition
ROMinSetUp2Rectangles	ROMBind	(IIci,$22D46)				; called by ptchSetUp2Rectangles
RONInTextBox		ROMBind		(IIci,$220C2)				; called by ptchTextBox  <41-YDS-1/30/92>
ROMAfterGetFInfoInTextBox	ROMBind	(IIci,$22104)			; Come from patch after GetFontInfo in TextBox <43-YDS-2/6/92>
ROMAfterGetFInfoInGetSize	ROMBind	(IIci,$22272)			; Come from patch after GetFontInfo in GetSize <43-YDS-2/6/92>
	ENDIF													;									<19>

;----------------------------------------------------------------------
			ROMs	IIci
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEFindWord
;			<19July89smb> Fixed Roman FindWord hyphenation bug. Problem
;			was occuring because RecalLines used the SMgr-compatible FindWord
;			for determining a word boundary but when it called FindLine for
;			the line break, FindLine used the oldFindLine code (RomanFindLine)
;			which used the old FindWord code. The correct fix for this is
;			to use the old FindWord code when the caller is RecalLines. This 
;			introduces an uglier bug that can't be fixed for 6.0.4 so we opted
;			for the easiest fix which is to always use the old FindWord for all
;			of Roman word breaking needs.
;			<28Aug89smb> We now use the old FindWord code for RecalLines for 
;			6.0.4 Script Systems and Big Bang since the uglier bug is now fixed.
;			The bug was that the leadingEdge flag was not set correctly for word drag. 
;			<26Oct89smb> Bug fix for Chinese Script System: clear fwLeadingEdge flag!
; 			<1/17/90smb> Redone to be compatible with applications using incorrect char
;			breaking algorithms for Script Systems.
;			<2/28/90smb> Changed 'bgt' to 'bge' for linebreaking. 
;			<4/17/90smb> Fixed old bug for old FindWord: when using an 
;			application's teWordBreak routine must save d1!
;----------------------------------------------------------------------

ptchTEFindWord	PatchProc	TEFindWord

fwRegs		REG			d3-d5/a0-a2

	IF Scripts604 | SysVers>= $605 THEN
; Redone to be compatible with applications using incorrect char breaking algorithms for Script Systems
; <1/17/90smb>
; If a non-Roman system then use new FindWord code
			move.l		ExpandMem,a0
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)	; number of installed scripts
			bne.s		UseSMgrFW				; use new FindWord

; Roman-only system
; test if line breaking calling; if so, use old FindWord.
			cmpi.w		#teFromFind,d2			; called by Roman FindLine or teRecal?
			bge			WBOverid				; changed to 'bge' instead of 'bgt' <2/28/90smb>
			
; Otherwise, look for an overriding FindWord routine.
			move.l		d0,-(sp)				; preserve
			move.l		teWordBreak(a3),d0
			_StripAddress						; does return in d0
			move.l		ExpandMem,a0
			cmp.l		ExpandMemRec.emCleanWordBrk(a0),d0	; same?
			beq.s		@NoOverride				; Branch around wordBreak cleanup stuff
			move.l		(sp)+,d0				; restore (and not earlier since StripAddress returns here!)
			bra			WBOverid				; Handle via old logic if an override exists

; If we get here, there's no wordBreak override
@NoOverride
			move.l		(sp)+,d0				; restore (and not earlier since StripAddress returns here!)
UseSMgrFW
			with		FindWordFrame
			link		a6,#fwLink				; This version uses the Script Manager
			movem.l		fwRegs,-(sp)

; The value of fwLeadingEdge is determined by which routine called FindWord.
; If RecalLines called (teFromRecal (16)), we want to look back to determine the word so
; leadingEdge is False, implying we hit on the trailing edge of a character.
; If ClickExpand called (teWordSelect (4) or teWordDrag (8)), leadingEdge can be taken from
; teLftClick in the teRecord.

			clr.w		fwLeadingEdge(a6)		; initialize (for bra to @GetSelWrap) <26Oct89smb>
			cmpi.w		#teFromRecal,d2			; is it RecalLines calling? <28Aug89smb>
			beq.s		@GetSelWrap				; yep.
; if ClickExpand calling, get leadingEdge from teLftClick in teRecord. Use teLftClick rather than
; teLftCaret since DoSearch sets teLftClick. <28Aug89smb>
			move.b		teLftClick(a3),d1		

; if calling for WordDrag then simulate Kanji code. <25Aug89smb>
			cmpi.w		#teWordDrag,d2			; <25Aug89smb>
			bne.s		@StuffIt				; <25Aug89smb>
; at this point a2 is still equal to the Left Anchor for teClick so compare the offset to it <25Aug89smb>
			cmp.w		d0,a2					; compare L. anchor to char offset <25Aug89smb>
			scc			d1						; set leadingEdge flag accordingly <25Aug89smb>
@StuffIt
			ext.w		d1
			move.w		d1,fwLeadingEdge(a6)
@GetSelWrap
			jmpROM		ROM@GetSelWrap
;;no longer used <1/17/90smb> ForceOldFW	jmpROM		ROMForceOldFW

	ELSE
; come here for 6.0.4 only! <1/17/90smb>
; Look for an overriding FindWord routine.

			move.l		d0,-(sp)				; preserve
			move.l		teWordBreak(a3),d0
			_StripAddress
			move.l		ExpandMem,a0
			cmp.l		ExpandMemRec.emCleanWordBrk(a0),d0	; same?
			beq.s		@NoOverride				; Branch around wordBreak cleanup stuff
			move.l		(sp)+,d0				; restore
			bra.s		WBOverid				; Handle via old logic if an override exists (bra to WBOverid)

; If we get here, there's no wordBreak override
@NoOverride
			move.l		(sp)+,d0				; restore
				
; If a Roman system then use old FindWord code <8Aug89smb>
			move.l		ExpandMem,a0							; <8Aug89smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)	; number of installed scripts <8Aug89smb>
			beq			WBOverid								; use old FindWord <8Aug89smb>
			jmpROM		ROMTESMgrFWord
	ENDIF
	
	IF SysVers < $606 THEN
WBOverid	jmpROM		ROMWBOverid				; bra to WBOverid
	ELSE
; new <4/17/90smb>
; forced here from RomanFindLine; mask off flag in low bit of d2 <8June89smb>
			
WBOverid										; here's our FindWord				<EHB 01Oct85>
			swap		d2						; get constant into high word		<EHB 01Oct85>
			move.w		d0,d2					; save position in low word 		<EHB 01Oct85>

			move.w		d0,d1
			beq.s		RightScan

			bsr.s		LeftScan				; do left scan 1st

; Right scan, given a char code in D1, this returns the next word break >= D1

RightScan
			bclr		#17,d2					; clear bit 17 (right)				<EHB 01Oct85>
RS1
			cmp 		teLength(a3),d1 		; see if @ right edge
			bhs.s		@0						; assume found if at right edge
			move		d1,a1					; pass index
			bsr.s		CallBreak
			bne.s		@0
			addq		#1,d1					; try next char
			bra.s		RS1 					;									<EHB 01Oct85>
@0
			rts

; Given a char location in D0, this routine returns a new word break to left of D0

LeftScan
			bSet		#17,d2					; set bit 1 (left)					<EHB 01Oct85>
LS1
			subq		#1,d0					; pre decrement
			move		d0,a1					; pass index
			bsr.s		CallBreak				; was it a break?
			bne.s		@0						; if so, skip town

			tst 		d0						; are we done?
			beq.s		@1						; if so, skip town
			bra.s		LS1 					; keep looking
@0
			addq		#1,d0					; try next char
@1
			rts

			export	CallBreak					;												<23>
CallBreak
			movem.l 	d0-d1/a0-a1,-(sp)		; save regs - also save d1! <4/17/90smb>
			move		a1,d0					; pass index in D0
			move.l		teTextH(a3),a0			; get handle
			move.l		(a0),a0
			move.l		teWordBreak(a3),a1		; get routine
			jsr 		(a1)					; call routine which sets CC's
			movem.l 	(sp)+,d0-d1/a0-a1		; restore regs - also restore d1! <4/17/90smb>
			rts
	ENDIF
			ENDPROC

;----------------------------------------------------------------------
;			PROCEDURE ptchTEFindLine
;			For a 7.0 (or greater) system with only the Roman script system
;			installed, the ptchNewRomanFindLine routine must be used. For an
;			earlier system with only the Roman script system installed, will 
;			use the ROM's RomanFindLine code.
;			If multiple scripts are installed for an SS-604 system or a 6.0.5
;			(or greater) system, then fall into the ptchScriptFindLine code
;			below.																			<21>
;----------------------------------------------------------------------
	IF Scripts604 | SysVers>= $605 THEN
ptchTEFindLine	PatchProc	TEFindLine

FindLineRegs	reg		d1-d7/a0-a2
			move.l	ExpandMem,a0				;											<19>
			cmpi.b	#1,ExpandMemRec.emScriptsInstalled(a0)	; total number of installed scripts	<19>
	IF SysVers>= $700 THEN						;											<21>
			beq		ptchNewRomanFindLine		; use new Roman FindLine					<19>
	ELSE
			beqROM	ROMRomanFindLine			; use ROM code								<21>
	ENDIF
			; otherwise fall into ptchScriptFindLine
	
;----------------------------------------------------------------------
;			PROCEDURE ptchScriptFindLine
;			<16Dec89smb>
;			Set the offset parameter to non-zero for StyledLineBreak for
;			unstyled text. NOTE! This fix is only for UNSTYLED text.
;			<9/6/90smb>  Fix teCROnly bug that crashes the system: pre-
;			incrementing caused us to compare one too many in the text and then
;			the +1 to point beyond the CR caused the line breaks to be one off.
;----------------------------------------------------------------------
ptchScriptFindLine								; labeled for clarification although not used		<21>

; left this test here rather than move to RecalLines since it would be duplicated 4x in RecalLines <12july89smb>
; If a Roman system then use old FindLine code: performance improvement <5May89smb>
			Movem.l	FindLineRegs,-(sp)			; preserve whether use new or old FindLine
			with	LineBreakFrame
			link	a6,#localFrame
; initializations
			moveq	#0,d7						; flag multiple styles: init to single style
			move.w	d6,lineStart(a6)
			move.w	d6,EOLCharPosn(a6)			; start for new EOL position calculation
			clr.w	textPtrOffset(a6)

; set up textWidth: pixel width for displaying the text
			moveq	#0,d0
			move.w	teDestRect+right(a3),d0		; right edge
			sub.w	teDestRect+left(a3),d0
	IF SysVers < $700 THEN						;														<31>
			subq	#1,d0						; reduce for caret indent								<31>
	ENDIF										;														<31>
			swap	d0							; width is FIXED
			move.l	d0,width(a6)				; textWidth

; textLength: is necessary for CR test and unstyled text
			moveq	#0,d1						; longize
			move.w	teLength(a3),d1				; doc length
			sub.w	d6,d1						; adjusted to lineStart position
			move.l	d1,length(a6)

; textPtr: pointer to current lineStart position.
			movea.l	teTextH(a3),a2				; handle to start of text
			movea.l	(a2),a2						; dereference
			add.w	d6,a2						; begin search for CR here <17Nov88smb>
			
; if we are in CR only mode, just search for a CR
	IF SysVers < $606 THEN						;														<16>
			addq.w	#1,d1						; incr for initial decr below in dbeq test <17Nov88smb>
	ENDIF
			tst.b	teCROnly(a3)
			bge.s	@StyleCheck					; changed from beq to bge <2May89smb>
			; notice: CCs are set to not equal AT THIS POINT based on test of CROnly.
			bra.s	@CheckLength				; zero check
@CRLoop
			move.b	(a2)+,d0					; is it a CR? changed to byte <28Jan89smb>
			jsrROM	ROMTEEOLHook
@CheckLength
			dbeq	d1,@CRLoop
			beq.s	@GotCR
			move.w	teLength(a3),d0				; return end of text if CR not found
			jmpROM	ROM@FindLineFinis			; <17Mar89smb>
@GotCR
			move.w	teLength(a3),d0				; doc length <15Mar89smb>
			sub.l	d1,d0						; - characters left
	IF SysVers < $606 THEN						;														<16>
			addq	#1,d0						; go one beyond the CR <15Mar89smb>
	ENDIF
			jmpROM	ROM@FindLineFinis			; <17Mar89smb>
; End of CR check

@StyleCheck
	IF SysVers < $606 THEN						;														<16>
			subq.w	#1,d1						; decr from CR test above <17Nov88smb>
	ENDIF
			move.l	a2,textPtr(a6)
			move.l	a2,initlTextPtr(a6)
			
; test for new style edit record
			tst.w	teSize(a3)					; check style flag
			bpl		@noStyle					; don't set style: old-style edit record
			jmpROM	ROMinFindLine				; jump back into styled processing

@noStyle
			move.w	#0,currStyle(a6)			; needed for a termination test
; set up textStart and textEnd for non-styled text
			move.l	#0,start(a6)				; absolute posn from beginning of text		
			move.l	length(a6),end(a6)
; Set the offset parameter to non-zero since this is the 1st script run on the line (AND THE ONLY ONE!) <15Dec89smb>.
			move.l	#1,offset(a6)				; necc for corrections to SMgr routine <15Dec89smb>
			jmpROM	ROM@SetUp					; patched now, jump back in!

	IF SysVers>= $700 THEN						;													<21>
;----------------------------------------------------------------------
;			PROCEDURE ptchNewRomanFindLine
;			<1/9/91smb>	Must be patched to now call NewRomanFindLine 
;			for a Roman-only system. Rewrote to break on style runs
;			rather than word boundaries.															<19>
;----------------------------------------------------------------------
ptchNewRomanFindLine

			Movem.l	FindLineRegs,-(sp)			; preserve whether use new or old FindLine
			with	LineBreakFrame
			link	a6,#localFrame

; textLength: is necessary for CR test and unstyled text
			moveq	#0,d1						; longize
			move.w	teLength(a3),d1				; doc length
			sub.w	d6,d1						; adjusted to lineStart position
			move.l	d1,length(a6)

; textPtr: pointer to current lineStart position.
			movea.l	teTextH(a3),a2				; handle to start of text
			movea.l	(a2),a2						; dereference
			add.w	d6,a2						; begin search for CR here
			
			tst.b	teCROnly(a3)				; do we only want to break on CRs?
			bne		@CROnlyMode					; yup.

; more initializations
			move.l	a2,textPtr(a6)
			moveq	#0,d7						; flag multiple styles: init to single style
			move.w	d6,lineStart(a6)
			move.w	d6,EOLCharPosn(a6)			; start for new EOL position calculation

; set up textWidth: pixel width for displaying the text
			moveq	#0,d4
			move.w	teDestRect+right(a3),d4		; right edge
			sub.w	teDestRect+left(a3),d4
;;			subq	#1,d4						; reduce for caret indent							<31>
			move.l	d4,width(a6)				; textWidth
			
; test for new style edit record
			tst.w	teSize(a3)					; check style flag
			bpl		@CallP2C					; old-style edit record
			
; test for single or multiple format runs in the text
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			cmpi.w	#1,nRuns(a1)
			beq.s	@OneStyle					; bra if one style
			
			moveq	#1,d7						; flag multiple styles to process
@OneStyle
			moveq	#0,d0
			move.w	d6,d0
			jsrROM	ROMGetCurStyle				; a0: ptr to current style, d0: style index
			addq.w	#1,d0						; index returned is 0 based but nRuns isn't
			move.w	d0,styleIndex(a6)
; test for last style run
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			cmp.w	nRuns(a1),d0				; is styleIndex < nRuns?
			bcs.s	@StyleLoop					; yes
			moveq	#0,d7						; on last style run
			
; only one run so set up real length of run. The last entry in the styleRun table has
; a startChar posn equal to teLength+1. Must subtract the extra 1 to get the real length
; of the run.

@StyleLoop
			move.l	a0,currStyle(a6)
			lea		stStartSize(a0),a1
			move.l	a1,nextStyle(a6)
			jsrROM	ROMSetStyle					; set grafport style from current style in a0
			
; set up textStart (beginning of style run) and pin to lineStart
			moveq	#0,d1						; longize
			move.l	currStyle(a6),a0
			move.w	startChar(a0),d1			; get start of this format run
			cmp.w	lineStart(a6),d1			; must pin to this LineStart!
			bhs.s	@GetLength					; bra if should use start of style run
			move.w	d6,d1						; use beginning of line
			
@GetLength
; get the length
			moveq	#0,d0						; longize
			move.w	stStartSize(a0),d0			; end of style run
			sub.w	d1,d0						; minus the style start
			move.l	d0,length(a6)
; test for one or last style to adjust length
			tst.w	d7							
			bne.s	@CallP2C					; multiple styles so can use next style run for length
			sub.l	#1,length(a6)
;-----------------------------------------------
@CallP2C
; call Pixel2Char
			move.l	textPtr(a6),a0				; textPtr
			move.w	length+2(a6),d0				; textLength (style run length)
			move.w	width+2(a6),d1				; width
			clr.l	d2							; no slop
			jsrROM	ROMTEHitTestHook			; call Pixel2Char
			; returns:
			;	d0	(low word)	pixel width to character offset in block
			;		(high word)	boolean = TRUE (0001) if offset corresponding to
			;		 the given pixel width was found
			;	d1.w character offset
			;	d2.w flagged (0001) if hit on leading edge of char

			move.w	d1,d3						; save char offset until after CR test
			sub.w	d0,d4						; update pixel width
			bls		@CRTest						; got a hit (width <= 0)

; if at the last style, and pixel width > 0, and the TEHitTestHook is replaced, then
; must check the high word of d0 to see if we REALLY got a hit! <2/16/90smb>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	HitTestHook(a0),a0
			peaROM	ROMPixel2Char
			cmpa.l	(sp)+,a0
			beq.s	@NotAHit
; we've been hooked out so test per the old interface specs for a hit.
			swap	d0
			tst.b	d0
			bne.s	@CRTest
;----------------------------------------------------------------------
@NotAHit
; test for CR
			move.l	textPtr(a6),a2
			move.w	length+2(a6),d1
			bsr		TestForCR
			tst.b	d0							; did we find a CR?
			beq.s	@NoCR						; no, just measure
; found a CR
			move.w	length+2(a6),d0				; style run length
			sub.l	d1,d0						; - characters left		(should make this .w)	<29>x
			add.w	EOLCharPosn(a6),d0			; new break posn
			bra		@finis
@NoCR
			move.l	d4,width(a6)				;  and save as long.
			add.w	d3,EOLCharPosn(a6)			; update char offset
			tst.w	d7							
			beq		@setResult					; only one style or last style to process

; test if we just processed the second to last format run
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			move.w	styleIndex(a6),d0
			addq.w	#1,d0						; for next style run
			move.w	d0,styleIndex(a6)			
			cmp.w	nRuns(a1),d0				; at last style run?
			bne.s	@DoNextRun
			
; last format run: last entry of style run table is a dummy entry = teLength + 1
			moveq	#0,d7						; flag no more runs after this one
; special test for case of dummy RUN of 1 char, which is 1 longer than the teLength, as found
; in KanjiTalk. Test here to save some other processing.			
			move.l	nextStyle(a6),a0
			move.w	stStartSize(a0),d6
			sub.w	startChar(a0),d6
			subq.w	#1,d6
; MathCad creates a 0 length style run at the end of the StyleRun array of teLength->teLength,	<26>
; instead of teLength->teLength+1, so we're testing for their bug here!							<26>
			ble		@setResult					; problem of 0 length style run in MathCad		<26>
;;			beq		@setResult					;				change branching condition		<26>

@DoNextRun			
; use the next format to continue searching for a line break position.
; accumulate style offsets on line for line end

			move.l	nextStyle(a6),a0
			move.w	startChar(a0),d6
			moveq	#0,d0						; clear high word before add					<33>
			move.w	length+2(a6),d0
			add.l	d0,textPtr(a6)				; update textPtr to the next style run
			bra		@StyleLoop

;----------------------------------------------------------------------
; on the way out now…
;----------------------------------------------------------------------
@CRTest
; test for CR
			move.l	textPtr(a6),a2
			move.w	d3,d1						; offset of char hit is length to use when searching for CR
			bsr		TestForCR
			tst.b	d0							; did we find a CR?
			bne.s	@GotCR						; yes, done earlier than hit!

; no CR found, so use char offset but back up to word boundary
			add.w	d3,EOLCharPosn(a6)			; update char offset
			move.w	EOLCharPosn(a6),d0
			
; Must test if at a blank since FindWord will backup before testing if not @ posn. 0.			<23>
; the problem this introduces is that we will not use an appications hook to teWordBreak if
; there is a blank or non-graphic character in this position.
			tst.b	d0							; 												<23>
			beq.s	@CallFW						; 												<23>
@WrdBrkLoop
			move.w	d0,a1						; CallBreak wants offset here					<23>
			import	CallBreak					;												<23>
			bsr		CallBreak					; calls Roman wordbreak hooked routine			<23>
			beq.s	@CallFW						; CCs set if char<=$20 & d0 = wordstart			<23>
; point past the break character and look for another break character until at EOD				<23>
			cmp.w	teLength(a3),d0				; is this break character at the EOD			<23>
			beq		@HaveWordSt					; yes, so done									<23>
; check if the break character is a CR! don't look ahead if so!									<28>
			movea.l	teTextH(a3),a2				; handle to start of text						<28>
			movea.l	(a2),a2						; dereference									<28>
			move.w	d0,-(sp)					; save wordStart								<28>
			addq.w	#1,(sp)						; incr beyond this break character				<28>
			move.b	0(a2,d0.w),d0				; fetch the char to test						<28>
			jsrROM	ROMTEEOLHook				;												<28>
			movem.w	(sp)+,d0					; don't change CCs								<28>
			; now bra based on result of TEEOLHook 												<28>
			beq.s	@finis						; found a CR so done							<28>
; is a break char but not a CR so, try again													<28>
;;			addq	#1,d0						; no, so look ahead for next break character	<23><28>
			bra.s	@WrdBrkLoop					;												<23>

@CallFW
			MoveQ	#teFromFind,D2				; say findLine is calling
			jsrROM	ROMFindWord					; EOL posn in d0			vectored so jsr to ROM addr	<21>

@HaveWordSt
; must pin word start to lineStart for the case that it breaks across a word
			cmp.w	lineStart(a6),d0			; d6 changes for styled so use actual lineStart	<23>
			bls		@setResult
; test for case of 0 returned if line has no blanks
; these two lines seem to be redundant!!! (XX)
			tst.w	d0							; non-zero word start is ok
			bne.s	@finis
			move.w	EOLCharPosn(a6),d0			; assume P2C result is less than word end found
			cmp.w	d1,d0						; use smaller of two
			bls		@finis						; use P2C result
; we should never come here!  (XX)			
			move.w	d1,d0						; use word end found
			bra		@finis

@GotCR
			move.w	d3,d0						; style run length
			sub.l	d1,d0						; - characters left		(should make this .w)	<29>x
			add.w	EOLCharPosn(a6),d0			; new break posn
			bra		@finis

;-----------------------------------------------
@CROnlyMode			
; since we are in CR only mode, just search for a CR
			bsr		TestForCR
			tst.b	d0							; did we find a CR?
			bne.s	@FoundCR					; yes
			move.w	teLength(a3),d0				; no, return end of text
			bra		@finis
@FoundCR
			move.w	teLength(a3),d0				; doc length <15Mar89smb>
			sub.l	d1,d0						; - characters left
			bra		@finis
; End of CR check
;-----------------------------------------------
@setResult	move.w	EOLCharPosn(a6),d0		; want result in d0
@finis
			unlk	a6
			movem.l	(sp)+,FindLineRegs			; restore
			rts
			endWith

;----------------------------------------------------------------------
;			PROCEDURE TestForCR
;			Called by NewRomanFindLine to search for a carriage return.
;		Entry
;			d1.w = length to search
;			a2.l = text pointer
;		Exit
;			d0.b = TRUE (FF) if CR found
;			d1.w = characters left
;		Uses d0,d1
;----------------------------------------------------------------------
TestForCR
			tst.w	d1							; is the initial length 0?
			beq.s	NoCR
			; notice: CCs are set to NOT EQUAL at this point.
			bra.s	@TestLength
@CRLoop
			move.b	(a2)+,d0					; is it a CR? changed to byte
			jsrROM	ROMTEEOLHook
@TestLength
			dbeq	d1,@CRLoop
			beq.s	GotCR
			bra		NoCR						; no CR in this run, just measure
NoCR
			sf		d0							; return F
			rts
GotCR
			st		d0							; return T
			rts
	ENDIF										; IF SysVers>= $700 (ptchNewRomanFindLine)
			ENDPROC								; ptchTEFindLine
	ENDIF										; IF Scripts604 | SysVers>= $605 (ptchTEFindLine)
	

;----------------------------------------------------------------------
;			ptchSetFont2Keyboard 
;			<18July89smb> Replaced call to AltSetRsrved to SetRsrved.
; 			<20July89smb> Before using an existing NullStyle in SetFont2Keyboard
;			must make sure the font's script is the same as the keyScript.
;			Otherwise, use script's default font.
;			<28Sept89smb> Complete rewrite for 6.0.4 Script Systems and 7.0!
;			<7Dec89smb>	If unsynched and keyScript <> Roman, then synch up.
;			Use application font as default now.
;----------------------------------------------------------------------
ptchSetFont2Keyboard	PROC	EXPORT

	IF Scripts604 | SysVers>= $605 THEN
			IMPORT	ptchDumpBuffer
			
			jsrROM	ROMGetCurStyle
; if only 1 script installed none of this is necessary
			move.l	ExpandMem,a1			; <1Feb89smb>
			cmpi.b	#1,ExpandMemRec.emScriptsInstalled(a1)
			beq		@Done					; only one script => keyboard set just fine!

			movem.l	d4/a2,-(sp)				; save
; get the keyboard script						
			move.l	a0,a2					; save style ptr
			clr.l	-(sp)
			move.w	#smKeyScript,-(sp)		; verb
			_GetEnvirons
			move.l	(sp)+,d4				; actually only a word

;---------------------------------------------------------------------------------
; If have an unsynchronized font & keyboard, and the KeyScript is not Roman, then synchronize
; the font and keyboard. <3Dec89smb>
			move.l	ExpandMem,a0
			tst.b	ExpandMemRec.emUnsynchedFlag(a0)
			beq.s	@TstNullStyle			; bra if synched up
; we are unsynchronized but are the keyScripts different?
			sf		ExpandMemRec.emUnsynchedFlag(a0)	; assume will synch up
			cmp.w	#smRoman,d4				; if unsynchronized, the keyScript was Roman
			bne.s	@TstNullStyle			; bra if want to synch up ?

			st		ExpandMemRec.emUnsynchedFlag(a0)	; don't synch up
			move.w	styleIndex(a2),d0		; get index to styleRec
			jsrROM	ROMGetStyle				; get the styleRec in a0
			move.l	a0,-(sp)				; temp save
			move.l	a2,a0					; restore current style ptr
			jsrROM	ROMSetStyle				; set the grafport; preserves a0
			move.l	(sp)+,a0				; restore styleRec
			move.w	stFont(a0),d0			; want current font here when branch!
			bra		@SetFont				; bra if equ: want to stay unsynched
			
; the new keyScript is non-Roman and we're currently unsynchronized so synch up
@TstNullStyle			
;---------------------------------------------------------------------------------
	IF NOT hasBufferingFix THEN				; 														<17>
; before synchronizing dump the text buffer: could change the keyboard in the middle of buffering <1/26/90smb>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFTextBuffering,d0
			beq.s	@noBuffer
			bsr		ptchDumpBuffer			; dump text from buffer
@noBuffer	
	ENDIF									;														<17>

; if a null style exists and it's font corresponds to the keyScript, use it!
			jsrROM	ROMAnyNullStyle			; returns a0 pointing to the null scrap record; cc's set
			beq.s	@styleLoop				; nope
			lea		scrpStyleTab(a0),a0		; point to start of table
			
; must test if font is of the same script before using it
			move.l	a0,-(sp)				; save scrpStyleTab
			sub.w	#2,sp					; allocate return, 1 int
			move.w	scrpFont(a0),-(sp)		; scrpFont 
			_Font2Script					; get script from font
			move.w	(sp)+,d1				; fontScript
			move.l	(sp)+,a0				; restore scrpStyleTab
			move.w	scrpFont(a0),d0			; want current font here when branch!
			
			cmp.w	d1,d4					; is the scrpFont's script = the keyscript?
			beq.s	@SetFont				; already rsrved but must write to grafport

	IF hasBufferingFix THEN					; 														<17>
; before synchronizing dump the text buffer: could change the keyboard in the middle of buffering <1/26/90smb>
; Dump here rather than inside the styleLoop below and after we are sure that things aren't synched.<17>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFTextBuffering,d0
			beq.s	@noBuffer
			bsr		ptchDumpBuffer			; dump text from buffer
@noBuffer	
	ENDIF									;														<17>

; no null style exists or bad font
; d4.b = the keyScript
; a2.l = the current style ptr.

; Test if the current font is the correct script If not, use the keyScript to determine
; a font to use. Will find the font by looking back in the styleRun array until we find
; a font whose script corresponds to the keyScript.  If none exist, we'll use the script
; system's default font.

@styleLoop
			move.w	styleIndex(a2),d0		; get index to styleRec
			jsrROM	ROMGetStyle				; get the styleRec in a0
			move.l	a0,-(sp)				; temp save
			
; set the grafport now since in the case of a selection SetRsrved does nothing (must set for BufferChar). 
			move.l	a2,a0					; restore a0
			jsrROM	ROMSetStyle				; preserves a0
			sub.w	#2,sp					; allocate return, 1 int
			_FontScript						; get script from font in grafport
			move.w	(sp)+,d1				; fontScript
			move.l	(sp)+,a0				; restore styleRec
			move.w	stFont(a0),d0			; want current font here when branch!
			
; test if the keyboard script is the same as the fontScript
			cmp.w	d1,d4					; is the font's script = the keyscript?
			beq.s	@SetFont				; yep, use it.

			cmpi.w	#0,startChar(a2)		; are we at the start of the styleRun array yet?
			beq.s	@UseKbdScript			; yes.
			subq	#stStartSize,a2			; no, next!
			bra.s	@styleLoop
			
@UseKbdScript
; no more styles to check, use script system's application font
			clr.l	-(sp)					; allocate return
			move.w	d4,-(sp)				; script
;;			move.w	#smScriptSysFond,-(sp)	; verb
			move.w	#smScriptAppFond,-(sp)	; verb: use application font <3Dec89smb>
			_GetScript
			move.l	(sp)+,d0				; font is only a word

@SetFont
; are we replacing a selection? <6Sept89smb>
			move.w	teSelStart(a3),d1		; get selection start
			cmp.w	teSelEnd(a3),d1			; same as selEnd?
			beq.s	@notSelection
; is a selection so delete selection and then set
			move.l	d0,d4					; save the font
			move.l	a4,-(sp)				; pass the handle
			_TEDelete
			move.l	d4,d0					; restore the font and set it!
@notSelection
; load new font as in textStyle.tsFont
; d0 = font to use
			move.l	ExpandMem,a0			; textStylePtr: actually only font attribute
			move.w	d0,ExpandMemRec.emNewFont(a0)
			move.l	a0,a2
			lea		ExpandMemRec.emNewStyle(a2),a2
			lea		ExpandMemRec.emNewFont(a0),a0
; redraw flag and mode already set at init time above
			move.l	a0,2(a2)				; only stuffed the font: need address of emNewFont
			jsrROM	ROMSetRsrved			; call this routine, which TESetStyle calls <18July89smb>
			movem.l	(sp)+,d4/a2				; restore
@Done
			Rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	ELSE
			jsrROM	ROMGetCurStyle			; <25June89smb> moved into here from calling routines
; if only 1 script installed none of this is necessary
			move.l	ExpandMem,a1			; <1Feb89smb>
			cmpi.b	#1,ExpandMemRec.emScriptsInstalled(a1)
			beq		@Done					; only one script => keyboard set just fine!

; get the keyboard script
			move.l	a0,-(sp)				; save style ptr
			clr.l	-(sp)
			move.w	#smKeyScript,-(sp)		; verb
			_GetEnvirons
			move.l	(sp)+,d0				; actually only a byte

; set the font in the grafport
			move.l	(sp)+,a0				; restore a0
			move.w	d0,-(sp)				; save keyScript
			jsrROM	ROMSetStyle				; preserves a0

			sub.w	#2,sp					; allocate return, 1 int
			_FontScript						; get script from font in grafport
			move.w	(sp)+,d1				; fontScript

; test if the keyboard script is the same as the fontScript
			move.w	(sp)+,d0				; get keyScript
			cmp.w	d0,d1
			beq.s	@Done					; font is ok

; synch the font to the keyboard
			movem.w	d3/d4,-(sp)				; need these babies for storage <20July89smb>
			move.w	d0,d3					; save keyScript to compare w/ font in nullStyle <20July89smb>
			clr.l	-(sp)					; allocate return
			move.w	d0,-(sp)				; script
			move.w	#smScriptSysFond,-(sp)	; verb
			_GetScript
			move.l	(sp)+,d0				; font is only a word

; simulate a TESetStyle call to set the new font (just call SetRsrved)
; first test if a null style exists and if so, use this instead of the script system's font <12Mar89smb>
			jsrROM	ROMAnyNullStyle			; returns a0 pointing to the null scrap record
			beq.s	@UseScriptFont			; nope, use script's font
			move.w	d0,d4					; save script's font <20July89smb>
			Lea		scrpStyleTab(a0),a0		; point to start of table

; must test if font is of the same script before using it <20July89smb>
			move.l	a0,-(sp)				; save scrpStyleTab <20July89smb>
			sub.w	#2,sp					; allocate return, 1 int <20July89smb>
			move.w	scrpFont(a0),-(sp)		; scrpFont <20July89smb>
			_Font2Script					; get script from font <20July89smb>
			move.w	(sp)+,d1				; fontScript <20July89smb>
			move.l	(sp)+,a0				; restore scrpStyleTab <20July89smb>

			cmp.w	d3,d1					; is the scrpFont the same script as the keyscript? <20July89smb>
			beq.s	@UseNullStyle
			move.w	d4,d0					; diff script so use script's def font <20July89smb>
			bra.s	@UseScriptFont
@UseNullStyle
			move.w	scrpFont(a0),d0			; want to use the style in the null scrap record
@UseScriptFont
; at this point d0 contains the new font to use.  The rest of the style information (size, face, etc)
; will be taken from the scrpStyle if one exists otherwise it comes from teSelStart's style. <20July89smb>
			movem.w	(sp)+,d3/d4				; restore <20July89smb>
; load new font as in textStyle.tsFont
			move.l	ExpandMem,a0			; <1Feb89smb> textStylePtr: actually only font attribute
			move.w	d0,ExpandMemRec.emNewFont(a0)
			move.l	a0,a2					; <3Feb89smb>
			lea		ExpandMemRec.emNewStyle(a2),a2	; changed to lea <12July89smb>
			lea		ExpandMemRec.emNewFont(a0),a0	; changed to lea <12July89smb>
; redraw flag and mode already set at init time above
			move.l	a0,2(a2)				; only stuffed the font: need address of emNewFont <10Mar89smb>
			jsrROM	ROMSetRsrved			; call this routine, which TESetStyle calls <18July89smb>
@Done
			Rts
	ENDIF
			ENDPROC

	IF Scripts604 | SysVers>= $605 THEN		; new <7Dec89smb>
;----------------------------------------------------------------------
;			ptchSetKeyboard2Font
;			<7Dec89smb> Added flag to clear up unsynchronized font & keybd.
;----------------------------------------------------------------------
ptchSetKeyboard2Font	PROC
	
; if only 1 script installed none of this is necessary
			move.l		a0,-(sp)				; save style ptr
			move.l		ExpandMem,a1			; <1Feb89smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a1)
			beq.s		@done					; only one script => keyboard set just fine!

; turn off the flag set when TE creates an unsynchronized font & keyboard situation <3Dec89smb>
			sf			ExpandMemRec.emUnsynchedFlag(a1)	; <3Dec89smb>
	IF forLocalizability THEN					; <34f-YDS-9/2/91>
			sub.w		#2,sp					; allocate return, 1 int
			_FontScript							; get script from font in grafport
												; change the keyboard to match the current selection's script.
			Move.w	(sp), d0					; script param on the stack from FontScript call !!!
			move.l	teDispatchH(a3),a0			; get teDispatchH addres 
			move.l	(a0),a0						;
			move.b	d0, lastScript(a0)			; push script numberused to highligt (d0) to lastScript
			_KeyScript							; script param on the stack from FontScript call
	ELSE
			jmpROM		ROMinSetKeyboard2Font
	ENDIF
@done		jmpROM		ROM@DoneInKeybd2Font
			ENDPROC
;----------------------------------------------------------------------
;			ClickKeyboard2Font
;			<3Dec89smb>
;
;			When click in Roman text (whether as an insertion point or selection),
;			in a non-Roman font, set the keyboard to Roman.  This is the only
;			time we will allow an unsynchronized font and keyboard. Used by TEClick
;			and TESetSelect since for hit-down or cursor movement.
;
;			ENTRY
;				The font must have been set in the grafport upon entry
;				d0 = the current char offset or teSelStart
;			USES
;				a1,d0-d2
;				preserves a0/d3/d4
;----------------------------------------------------------------------
ClickKeyboard2Font		PROC	EXPORT
			
; if only 1 script installed none of this is necessary
			movem.l		a0/a2/d3/d4,-(sp)				; save style ptr
			move.l		ExpandMem,a1			; <1Feb89smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a1)
			beq			@done					; only one script => keyboard set just fine!

			move.w		d0,d3					; char offset to use for synching <3Dec89smb>

; get the script (the font must have been set in the grafport already)			
			sub.w		#2,sp					; allocate return, 1 int
			_FontScript							; get script from font in grafport
;---------------------------------------------------------------------
; Will now allow a Roman keyboard and a non-Roman font for hit-down; KanjiTalk wants
; to be able to input Roman text from a Kanji font <3Dec89smb>

; if we're in single-byte Roman text, and the font is non-Roman then 
; want keyboard to be Roman <3Dec89smb>
			move.l		ExpandMem,a0			; initialize to false <3Dec89smb>
			sf			ExpandMemRec.emUnsynchedFlag(a0)	; <3Dec89smb>			

; if the font script = Roman then synch keyboard to the font
			move.w		(sp)+,d4				; font script
			beq.s		@UseFont

; Always synchronize the keyboard & font unless a double-byte script. 							<37>
			subq		#4,sp					;												<37>
			move.w		d4,-(sp)				;												<37>
			move.w		#smScriptRedraw,-(sp)	;												<37>
			_GetScript							;												<37>
			move.l		(sp)+,d0				;												<37>
			tst.b		d0						; result is a byte								<37>
			ble			@UseFont				; 0 = single byte LR script, -1 = RL script, 1 = double-byte script	<37>
			
; If we're not in single-byte Roman text then synch keyboard to the font
; now test with charbyte to see if we're in Roman text
			clr.w		-(sp)					; room for return
			move.l		teTextH(a3),a2			; get handle
			move.l		(a2),a2					; save text ptr to re-use						<37>
			move.l		a2,-(sp)				; pointer to start of text						<37>
			move.w		d3,-(sp)				; offset in text
			_CharByte
			tst.w		(sp)+					; high byte of character?
			bne.s		@UseFont				; if not single byte text, synch to font script

; Is a single byte character…
; Is this Roman text?
			clr.w		-(sp)					; room for return
			move.l		a2,-(sp)				; pointer to start of text
			move.w		d3,-(sp)				; offset in text			
			_CharType
			move.w		(sp)+,d0				; now let's see what "type" of char we have!
			
; Mask off what I'm interested in: the Type ($000F) and the Direction ($2000)
; I want a char whose Direction is LR (smCharLeft, $0000) and whose Type is Roman
; which can be smCharAscii (1) or smCharEuro (7).
			and.w		#smcTypeMask+smcRightMask,d0
;;			beq.s		@Set2Roman				; smCharPunct = 0
			cmp.w		#smCharAscii,d0
			beq.s		@Set2Roman
			cmp.w		#smCharEuro,d0			; not really necc f. 2-byte scripts…			<37>
			bne.s		@UseFont				; otherwise, must use the font script
@Set2Roman
; want the keyboard to be Roman rather than synchronized to the font script <3Dec89smb>
			move.w		#smRoman,d4
			move.l		ExpandMem,a0			; indicate that we have an anamoly now! <3Dec89smb>
			st			ExpandMemRec.emUnsynchedFlag(a0)	; <3Dec89smb>
@UseFont
			move.w		d4,-(sp)
;---------------------------------------------------------------------
; change the keyboard to match the current selection's script.

	IF forLocalizability THEN					; <34f-YDS-9/2/91>
			Move.w	(sp), d0					; script param on the stack from FontScript call !!!
			move.l	teDispatchH(a3),a0			; get teDispatchH addres 
			move.l	(a0),a0						;
			move.b	d0, lastScript(a0)			; push script numberused to highligt (d0) to lastScript
	ENDIF

			_KeyScript							; script param on the stack from FontScript call
@done
			movem.l		(sp)+,a0/a2/d3/d4				; restore style ptr
			Rts
			ENDPROC
	ENDIF

;----------------------------------------------------------------------
;			PROCEDURE ptchTEChar2Pixel
;			<7Aug89smb>	 test if called for R-to-L highlighting rather
;			than hit-testing.
;			<9/20/90>	Patch out more of C2P in order to use TextWidthHook
;----------------------------------------------------------------------
ptchTEChar2Pixel	PatchProc	JChar2Pixel

; see initial comments in TextEdit.a
			move.l	d3,-(sp)
			tst.b	TESysJust
			beq		@UseC2P
; RL line direction
			movem.l	d0/d2/a0/a1,-(sp)
			move.w	d1,-(sp)
			tst.b	teSize(a3)
			bpl.s	@noStyle
			move.L	teTextH(a3),a1				; source = text
			move.L	(a1),a1 					; dereference
			suba.l	a1,a0						; offset to beginning of text to be measured
			move.w	a0,d0						; length to beginning of style run
			add.w	(sp),d0						; add in length to offset
			move.w	d0,d3						; save
			jsrROM	ROMGetCurStyle
			jsrROM	ROMGetDirection				; <6June89smb>
			bra.s	@TestDir					; <6June89smb>
@noStyle
;; d3 must be an absolute position for comparing to line ends. <20June89smb>
			move.w	d1,d3						; offset w/in line <20June89smb>
			add.w	(a2),d3						; absolute position <20June89smb>
; get the script direction from the font in the grafport for unstyled text <6June89smb>
			jsrROM	ROMGetDirection				; input is a3 - handle to teRec						<11><17>
;;			sub.w	#6,sp						; allocate return, 1 long, 1 int					<11><17>
;;			_FontScript							; returns script; leave on stack as param			<11><17>
;;			move.w	#smScriptRight,-(sp)		; pass verb											<11><17>
;;			_GetScript																				<11><17>
;;			move.l	(sp)+,d1					; get byte = line direction							<11><17>
@TestDir
			cmp.b	TESysJust,d1
			beq.s	@fixStack					; not equal=> LR script

; RL line and LR script
; compare current position to line ends
			move.w	(sp)+,d1
			movem.l	(sp)+,d0/d2/a0/a1
; test if called for R-to-L highlighting rather than hit-testing <31July89smb>
			move.l	d2,-(sp)					; save  <1Aug89smb>
			swap	d2							; direction in high word <31July89smb>
			cmp.w	#smHilite,d2				; bug fix for Arabic highlighting <31July89smb>
			movem.l	(sp)+,d2					; restore (w/o affecting CCs) <1Aug89smb>

	IF NOT hasTextWidthHook THEN				;													<17>
			bne.s	@Use4HitTest				; <31July89smb>
			bra.s	@UseC2P						; using for hilighting! <31July89smb>
@Use4HitTest
			jmpROM	ROM@Use4HitTest
	ELSE										;													<17>
			beq.s	@UseC2P						; using for hilighting! <31July89smb>				<17>
; use for hit testing																				<17>
			cmp.w	(a2),d3						; same as lineStart?
			beq.s	@OnAnEnd
			cmp.w	2(a2),d3					; same as lineEnd?
			bne.s	@UseC2P
			
@OnAnEnd
; RL line and LR script and on a lineEnd so process w/o calling C2P.
			swap	d2							; direction in high word
			cmp.w	#smLeftCaret,d2
			bne.s	@RightCaret
			cmp.w	(a2),d3						; same as lineStart?
			beq.s	@TextWidth					; yep, start
			bra.s	@ZeroWidth					; nope, end
@RightCaret
			cmp.w	(a2),d3						; same as lineStart?
			beq.s	@ZeroWidth					; yep, start
			
@TextWidth
			moveq	#0,d1						; wants offset here									<17>
			import	TETextWidthHook				;													<17>
			bsr		TETextWidthHook				; hook out TextWidth								<17>
			bra.s	@done
@ZeroWidth
			moveq	#0,d1
@done		move.l	(sp)+,d3					; restore <4May89smb>
			Rts
	ENDIF										;													<17>
@fixStack
			jmpROM	ROM@fixStack
@UseC2P
			jmpROM	ROM@UseC2P

			ENDPROC

;----------------------------------------------------------------------
;			PROCEDURE ptchPixel2Char
;			<7Aug89smb>	 I need to patch a bug in the routine SetUp, a
;			subroutine of StylMeasure, and only called by RomanFindLine.
;			It is a caller of P2C that has no vector or trap.
;			Patching out the vector jPixel2Char and not the hook, TEHitTestHook.
;			This will allow developers to patch out the same vector w/o
;			repercussions but if they chain in a fix before using jPixel2Char
;			in the hook, then there may be a problem.
;			<7Dec89smb>	 Added flag to indicate that the leftSide flag shouldn't
;			be set if TextWidth was used to measure. Also added more patches
;			to ptchSetUp to handle this new flag: don't bother looking at leftSide
;			flag if TextWidth did the measuring instead of SMgr's P2C. Also added
;			three other lines that weren't necessary before but cleaner to have the
;			complete end of the routine here now.
;			<9/20/90smb>	Calling TETextWidthHook now.
;----------------------------------------------------------------------
ptchPixel2Char	PatchProc	JPixel2Char
	IF Scripts604 | SysVers>= $605 THEN
			with	P2CFrame
			link	a6,#locals
			move.l	a0,textPtr(a6)				; save for result
			move.w	d1,pixelWidth(a6)			; save for SMgr P2C (and width used for 7.0)

	IF SysVers>= $700 THEN
; use NPixel2Char now for a faster and more powerful hit-test routine!							<23>
			subq	#2,sp
			move.l	a0,-(sp)					; pass text ptr to buffer
			and.l	#$0000FFFF,d0				; want length as a longint
 			move.l	d0,-(sp)
			swap	d2							; here's the slop
			clr.w	d2							;  as a FIXED
			move.l	d2,-(sp)
			move.w	d1,txtWidth(a6)				; save for result
			swap	d1							; pass de pixel width
			clr.w	d1							;  as a FIXED
			move.l	d1,-(sp)
			pea		leadingEdge(a6)				; leadingEdge is a var
			pea		widthRemaining(a6)			; width remaining is a var & FIXED			
			move.w	#smOnlyStyleRun,-(sp)		; default style run position
			move.l	#$00010001,d0				; default 1/1 scaling
			move.l	d0,-(sp)					; push numer
			move.l	d0,-(sp)					; push denom
			_NPixel2Char
			move.w	(sp)+,d1					; returns the char offset
			move.w	txtWidth(a6),d0				; return initial width for a hit
			moveq	#0,d2						; must clear since DoSearch tests it
			tst.w	widthRemaining(a6)			; is there a hit? (FIXED result)
			bmi.s	@SetLEFlag					; yep
			sub.w	widthRemaining(a6),d0		; return actual measured width

@SetLEFlag
; indicate to DoSearch that SMgr's P2C used hence leadingEdge flag is valid
			bset	#16,d2						; flag that P2C used						
			move.b	leadingEdge(a6),d2			; renamed from leftSide							<23>
			bne.s	@finis						; bra if leadingEdge is T since whole character fits	<20>
; decrement if LeadingEdge is F to be sure whole character will display							<23>
; backup correctly for either single or double byte text
			movem.l	d0/d2/d3/d6,-(sp)			;												<23>
			move.l	textPtr(a6),a0				; pointer to text measured						<23>
			move.l	teTextH(a3),a1				;												<23>
			move.l	(a1),a1						;												<23>
			suba.l	a1,a0						; offset of this text							<23>
			move.w	a0,-(sp)					; save for decrement							<23>
			move.w	d1,d6						; DoubleByte wants offset here					<23>
			add.w	a0,d6						; current position								<23>
			move.w	#-1,d3						; incremental direction to move					<23>
			jsrROM	ROMDoubleByte				;												<23>
			move.w	d6,d1						; new position									<23>
			sub.w	(sp)+,d1					; restore as an offset w/in this text			<23>
			movem.l	(sp)+,d0/d2/d3/d6			;												<23>
@finis
			unlk	a6
			rts
	ELSE										; NOT (SysVers>= $700)							<23>

			move.w	d0,textLen(a6)				; save for return test
			move.w	d2,slop(a6)					; save for SMgr P2C
						
	  IF hasTextWidthHook THEN					; 												<17>
			moveq	#0,d1						; wants offset here								<17>
			import	TETextWidthHook				;												<17>
			bsr		TETextWidthHook				; hook out TextWidth							<17>
	  ELSE										;												<17>
			subq.l	#2,sp						; room for result
			move.l	a0,-(sp)					; ptr on stack
			move.w	#0,-(sp)					; offset to first char
			move.w	d0,-(sp)					; length of block
			_TextWidth							; how wide is it?
			clr.l	d0
			move.w	(sp)+,d0					; this wide
	  ENDIF										;												<17>
			moveq	#0,d2						; must clear since DoSearch tests it <26June89smb>
			move.w	textLen(a6),d1				; char offset := length (end posn of style run)

; catch corrected result of overflow bug in StdTxMeas											<19>
			with	splineKeyRec
			move.l	expandMem,a0							; get low memory expand pointer.	<19>
			move.l	ExpandMemRec.emSplineKey(a0),a0			; get handle to splineKey globals.	<19>
			move.l	(a0), a0								; get pointer to splineKey globals.	<19>
			cmp.b	#-1, splineKeyRec.safeCount(a0)			; check to see if count changed		<19>
			beq.s	@noOverFlow								;									<19>
			move.w	splineKeyRec.safeCount(a0),d1			; new char offset					<19>
			endWith
			move.w	d1,textLen(a6)				; try this out: use the new count for P2C		<19>
@noOverFlow
			cmp.w	pixelWidth(a6),d0			; measured width <= pixelWidth input?
			bls.s	@finis						; yes, get next style until run out of pixels <26June89smb>

; measured text > inputted pixelWidth therefore must measure with P2C to get char offset <23Sept88smb>
			move.w	d0,txtWidth(a6)
			clr.w	-(sp)						; room for Pixel2Char return
			move.l	textPtr(a6),-(sp)			; pass text ptr to buffer
			move.w	textLen(a6),-(sp)			; pass text len
			move.w	slop(a6),-(sp)				; here's the slop
			move.w	pixelWidth(a6),-(sp)		; pass de pixel width
			pea		leadingEdge(a6)				; leftSide is a var (renamed from leftSide)		<24>
						
			_Pixel2Char
			move.w	(sp)+,d1					; returns the char offset
			move.w	txtWidth(a6),d0				; restore measured pixelWidth

			bset	#16,d0						; an offset corresponds to PixelWidth						
; indicate SMgr's P2C used hence leadingEdge flag is valid <7Dec89smb>
			moveq	#0,d2						; clear again after P2C call <7Dec89smb>
			bset	#16,d2						; flag that P2C used <7Dec89smb>						
			move.b	leadingEdge(a6),d2			; renamed from leftSide							<24>
	  IF SysVers>= $700 THEN
			bne.s	@finis						; whole character fits							<19>
; decrement if LeadingEdge is F to be sure whole character will display							<19>
; backup correctly for either single or double byte text (pinHead!)								<19>
			movem.l	d0/d2/d3/d6,-(sp)			;												<19>
			move.l	textPtr(a6),a0				;												<20>
			move.l	teTextH(a3),a1				;												<20>
			move.l	(a1),a1						; pointer to text measured						<20>
			suba.l	a1,a0						; offset of this text							<20>
			move.w	a0,-(sp)					; save for decrement							<20>
			move.w	d1,d6						; DoubleByte wants offset here					<20>
			add.w	a0,d6						; current position								<20>
			move.w	#-1,d3						; incremental direction	to move					<19>
			jsrROM	ROMDoubleByte				;												<19>
			move.w	d6,d1						; new position									<19>
			sub.w	(sp)+,d1					; restore as an offset w/in this text			<20>
			movem.l	(sp)+,d0/d2/d3/d6			;												<19>
@finis
			unlk	a6
			rts
	  ELSE
			beq.s	@finis						; PixelWidth R. of char or L.of entire string
; increment to compensate for decrement if leadingEdge is true AND we are within the line boundaries
			add.w	#1,d1						; caller assumes R. side; incr for L.side 
@finis
			unlk	a6
			cmpROM	ROMSetUpP2C,(sp)			; if StylMeasure called bra to ptchSetUp <7Dec89smb>
			beq.s	ptchSetUp					; <7Dec89smb>
			rts
;-----------------------------------------------
ptchSetUp
			sub.w	d0,d4						; update width
			swap	d0							; get flag in low byte

			addq.l	#4,sp						; pop return address <7Dec89smb>
; if SMgr's P2C measured the text then the leadingEdge flag is valid <7Dec89smb>
			tst.l	d2							; flag in high word; whole reg 0 if TextWidth used <7Dec89smb>
			beq.s	@CharOffsetOK				; TextWidth used, not SMgr's P2C <7Dec89smb>
			bclr	#16,d2						; clean up! <7Dec89smb>
	  ENDIF
	ENDIF										;												<23>
			endWith
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
	ELSE										; NOT (Scripts604 | SysVers>= $605)
			cmpROM	ROMSetUpP2C,(sp)
			beq.s	@DeBuggyCaller
; other caller
			jmpROM	ROMTEPixel2Char

@DeBuggyCaller
; P2C was called by SetUp in StylMeasure, which is only called by RomanFindLine
			jsrROM	ROMTEPixel2Char
			sub.w	d0,d4						; update width
			swap	d0							; get flag in low byte
	ENDIF
;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
; RomanFindLine expects the char offset to come back as a leftSide hit. Since using SMgr P2C must
; check the leftSide flag and if it's F. incr the char count for the decr in RomanFindline. This
; forces the result to be a leftSide hit at the next character. <4Aug89smb>
			tst.b		d2						; rightSide of char? <4Aug89smb>
			bne.s		@CharOffsetOK			; nope, left <4Aug89smb>
			addq.w		#1,d1					; force a leftSide hit <4Aug89smb>
@CharOffsetOK
			move.w		(sp)+,d2				; restore count, another forgotten line! <7Dec89smb>
			Rts
			ENDPROC

;----------------------------------------------------------------------
;			PROCEDURE GestaltTEciVersion
;			<8Aug89smb>
;			The following Gestalt Function is an interface using the Gestalt
;			mechanism to determine the current version of TextEdit.
;
;			 FUNCTION	GestaltTEVersion (	gestaltSelector: 	OSType;
;											VAR gestaltResult:	Longint;): OSErr;
;
;			The versions for the gestaltTextEditVersion selector are:
;				gestaltUndefSelectorErr = old styled TextEdit (pre-MacIIci TE)
;			All the following versions of TE are based on the SMgr-compatible version:
;				gestaltTE1 (1) = MacIIci ROM/PTCH 67c
;				gestaltTE2 (2) = 604 Script Systems PTCH 67c (Script bug fixes for MacIIci)
;				gestaltTE3 (3) = 604 Script Systems ptch0/parallels Big Bang (for MacII, MacSE, Mac+)
;				gestaltTE4 (4) = Big Bang ptch0/PTCH 67c
;				gestaltTE5 (5) = TextWidthHook available in System 7
;
;			THE OBVIOUS: since this is here for the MacIIci ROM patch, we have
;			hardcoded the ONLY value that is appropriate to be returned! sigh.
;_________________________________________________________________________________

GestaltTEciVersion PROC EXPORT

			move.l		(sp)+, a0			; return address
			move.l		(sp)+, a1			; address of result
; return correct version of this code <29Aug89smb>
; rearranged the order of these conditionals in case we set Scripts604 true for SysVers >= $605	<2>

		IF SysVers >= $700 THEN
			move.l		#gestaltTE5, (a1)	; TextWidthHook available in System 7				<18>
		ELSEIF SysVers >= $605 THEN			; changed IF to ELSEIF								<18>
			move.l		#gestaltTE4, (a1)	; 6.0.5 & Big Bang
		ELSEIF Scripts604 THEN
			move.l		#gestaltTE2, (a1)	; 604 Scripts
		ELSE
			move.l		#gestaltTE1, (a1)	; MacIIci ROM
		ENDIF
			adda.w		#4, sp				; pop the selector type
			move.w		#noErr, (sp)		; it always works
			jmp			(a0)
			ENDPROC


;----------------------------------------------------------------------
; Created one procedure for all the routines needing changes due to the GetNextDisplayStyle
; bug!  What a mess! <9Aug89smb>
;----------------------------------------------------------------------

			PROC
			EXPORT	ptchTestRunDirection
			EXPORT	ptchTEDoText
			EXPORT	ptchDoDraw
			EXPORT	ptchCursorMovement
			EXPORT	ptchFindStyleRun
			EXPORT	ptchTEGetFormatOrder
			EXPORT	ptchCaretDisplay
			EXPORT	ptchGetStylesInOrder
			EXPORT	ptchChkBounds
			EXPORT	ptchDoMeasure
			EXPORT	ptchOnSameLine
			EXPORT	ptchTEKey
			EXPORT	ptchTEInit					; <2Oct89smb> moved into this proc
			EXPORT	ptchTEDelete
			EXPORT	ptchTrimMeasure				; <16Nov89smb>
	IF Scripts604 | SysVers>= $605 THEN
			EXPORT	ptchDumpBuffer				; <28Sept89smb>
			EXPORT	ptchBufferChar				; <28Sept89smb>
			EXPORT	ptchTEBufferText			; <28Sept89smb>
			EXPORT	ptchGetStyleEnd				; <26Nov89smb>
;----------------------------------------------------------------------
; Added all the traps that call StdEntry since there are dependencies here.<28Sept89smb>
;----------------------------------------------------------------------
			EXPORT	ptchTEActivate
			EXPORT	ptchTEDeactivate
			EXPORT	ptchTEDispatch
			EXPORT	ptchTEGetText
			EXPORT	ptchTESetText
			EXPORT	ptchTECalText
			EXPORT	ptchTESetSelect
			EXPORT	ptchTEUpdate
			EXPORT	ptchTEClick
			EXPORT	ptchTECopy
			EXPORT	ptchTECut
			EXPORT	ptchTEIdle
			EXPORT	ptchTEPaste
			EXPORT	ptchTEInsert
			EXPORT	ptchTESetJust
			EXPORT	ptchTEScroll
			EXPORT	ptchTEPinScroll
			EXPORT	ptchTESelView
			EXPORT	ptchTEAutoView
			EXPORT	ptchTEGetOffset
;----------------------------------------------------------------------
			EXPORT	ptchGetWidth				; <16Nov89smb> ptchDoMeasure dependent
			EXPORT	ptchGetRLPosition			; <20Nov89smb> ptchCaretDisplay dependent
			EXPORT	ptchCaretInsideRun			; <7Dec89smb>
			EXPORT	ptchDoCaret					; <1/29/90smb> calls CaretDisplay
			EXPORT	ptchGetLRPosition			; <2/8/90smb> called by CaretDisplay
	ENDIF
	IF hasTextWidthHook THEN					;													<17>
			EXPORT	ptchDoErase					;													<17>
	ENDIF										;													<17>
	IF forLocalizability THEN
			EXPORT	ptchOnLineEnd				; <34a-YDS-9/2/91>
			EXPORT	ptchWholeDoMeasure			; <34-YDS-9/2/91>
	ENDIF
;----------------------------------------------------------------------
;			PROCEDURE ptchGetNextDisplayStyle
;			<8Aug89smb>	 Made a2StyleRun(a6) an offset rather than a
;			pointer. The pointer's handle wasn't locked so it moves! UGH!!
;			<16Nov89smb> Added code to test for unstyled teRecords since
;			this looks like it should break without it! (see calls to here!)
;----------------------------------------------------------------------
ptchGetNextDisplayStyle
			with	SharedFrame,TEFormatOrder
			movea.l	a2StyleRun(a6),a0
; For styled, is an offset to desired posn in style run array, otherwise is a ptr <5Aug89smb>
; Made a2StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!)
; Get to posn in styleRun array via the style handle and saved offset <5Aug89smb>
			tst.w	teSize(a3)					; <16Nov89smb>
			bpl.s	@Unstyled					; saved as a ptr for unstyled text! <16Nov89smb>
; styled teRec
			move.l	teStylesH(a3),a1			; <5Aug89smb>
			move.l	(a1),a1						; deref <5Aug89smb>
			add.l	a1,a0						; add to offset to get desired posn in the array <5Aug89smb>
@Unstyled
			move.w	fmtOrderingIndex(a6),d0		; index (0-d2) into array for next style run
			lsl.w	#1,d0						; index into fmtOrdering array
			move.l	fmtOrderingPtr(a6),a1
			move.w	0(a1,d0.w),d0				; index of style run to process
			move.w	d0,styleRunIndex(a6)
			lsl.w	#lnStStartSize,d0			; offset in styleRun array
			lea.l	0(a0,d0.w),a0				; pointer to next style run
			rts
			endWith

;----------------------------------------------------------------------
;			PROCEDURE ptchTEInit
;			<18July89smb>	 replaced d1 w/ d3 for WordRedraw determination,
;			and fixed loop incremental.
;			<2Oct89smb>		moved ptchTEInit here due to its dependency on
;			ptchTEDoText, which was in a different proc.			
;----------------------------------------------------------------------
ptchTEInit

			MoveQ		#0,D0
			Move		D0,TEScrpLength 		; save in global space
			_NewHandle
			Move.L		A0,TEScrpHandle 		; Save in global space

			Lea			ptchTEDoText,a0			; set up doText hook (added back in) <2Oct89smb>
			move.l		a0,TEDoText				; TEDoText is a low memory global
	IF SysVers >= $700 THEN						; 										<19>
			import		ptchReCalLines			;										<19>
			Lea			ptchReCalLines,a0		; set up recal hook w/ patched version	<19>
	ELSE
			LeaROM		ROMXReCalLines,a0		; set up recal hook
	ENDIF
			Move.L		a0,TERecal
			LeaROM 		ROMDefWordBrk,a0		; get default word break
			Move.L		a0,TEWdBreak

; Defensive reset in case an application changed teSysJust contrary to system default.
;
; Now, we just reset it for Roman-only systems (because TE in such a system cannot currently	<35>
; handle R-L direction; we will fix this eventually). For other scripts, the Text Control		<35>
; Panel lets users choose the default line direction, so we don't want to override it.			<35>
			WITH	smgrRecord,scriptRecord
			GetSMgrCore a0						; load SMgr globals pointer.
	IF 1 THEN									;												<35>
			move.b	smgrEnabled(a0),d0			; how many scripts enabled?						<35>
			ble.s	@bail						; if 0 (or neg!), can't initialize				<35>
			subq.b	#1,d0						; Roman-only?									<35>
			bne.s	@doneSetSysJust				; if not, don't reset 							<35>
			clr.w	TESysJust					; Roman-only, force to L-R (else TE screws up)	<35>
@doneSetSysJust									;												<35>
	ELSE										; (keep old code for reference for a while)		<35>
			tst.b	smgrEnabled(a0)				; script manager disabled?
			beq.s	@bail						; yes -> bail out.
			move.w	smgrSysScript(a0),d0		; get system script code.
			lsl.w	#2,d0						; script code is long offset.
			move.l	smgrEntry(a0,d0.w),a0		; load system script entry.
			move.b	scriptJust(a0),d0			; load script just.
			ext.w	d0							; sign extend just.
			move.w	d0,TESysJust				; set global just.
	ENDIF										;												<35>
			endWith								;

;<2Feb89smb>
; initialize NewStyle params for SetRsrved call in SetFont2Keyboard (flag.b, textStylePtr.l, mode.w)
			move.l		ExpandMem,a0
			lea			ExpandMemRec.emNewStyle(a0),a0		; changed from add to lea <12July89smb>
			move.b		#$FF,(a0)				; flag.b
			move.w		#1,6(a0)				; mode.w

;  Find correct WordDraw value.  Used for redrawing for line calculation
;	after character input. A WordDraw value of:
;			0 = redraw the char in front of the inputted char,
;			1 = redraw the word in front of the inputted char,
;			FF = redraw the whole line.
; To set the correct value walk through the scripts (32 of them!),
; 	<OR> in 1 for each double-byte script and <OR> in FF for each right-left script.
			move.b		#0,WordRedraw			; default case
			move.l		d3,-(sp)				; save <18July89smb>
			moveq		#0,d3					; init d3; for d3 := 0 to 32 do
@WordRedrawLoop
			clr.l		-(sp)					; allocate return
			move.w		d3,-(sp)				; script number
			move.w		#smScriptRedraw,-(sp)	; verb
			_GetScript							; if disabled, will return zero.
			move.l		(sp)+,d0				; values are 0, 1, FF
			or.b		d0,WordRedraw			; add it in: 1 ++ x, FF ++ x
; if all FFs, then dont need to go further-so check for negative
			bmi.s		@WRLoopXit
			addq.w		#1,d3					; next script to check <18July89smb>
			cmpi.w		#32,d3					; beyond last script? <18July89smb>
			bls.s		@WordRedrawLoop			; keep going until done w/ scripts
@WRLoopXit
			move.l		(sp)+,d3				; restore <18July89smb>
			jmpROM		EndTEInit
@bail
			Rts

;----------------------------------------------------------------------
;			PROCEDURE ptchTEDoText
;			<8Aug89smb>	 I need to patch bugs in DoSearch and DoDraw,
;			which are hooks via TeDoText.
;			<1/29/90smb>  Added patch to DoCaret to pin the caret in view
;			when blanks exceed the edge of the view rect.
;----------------------------------------------------------------------
ptchTEDoText
			with		TextFrame,TEFormatOrder
			Link		A6,#TextFrameSz 		; link frame for DoText procs
			move.l		a0,-(sp)				; save just in case								<48>
			move.l		ExpandMem,a0			;												<48>
			sf			ExpandMemRec.emFmtOrderHFlag(a0)	; ensure that we don't think		<48>
															; we have a handle to a formatarray	<48>
			move.l		(sp)+,a0				;												<48>
			Tst 		D7						; check dispatch code
			Beq.s		ptchDoSearch
			Bgt			@DoHilite
			Cmp 		#teDraw,D7
			Beq 		ptchDoDraw
	IF Scripts604 | SysVers>= $605 THEN
			bra			ptchDoCaret				; <1/29/90smb>
@DoHilite	bra			ptchDoHilite			; <4Oct89smb>
	ELSE
			jmpROM		ROMDoCaret				; falls into DoCaret <9Aug89smb>
@DoHilite	jmpROM		ROMDoHilite
	ENDIF

;----------------------------------------------------------------------
;			PROCEDURE ptchDoSearch
;			<8Aug89smb>
;			<19Nov89smb>	Fix for RL directional text.
;			<7Dec89smb>		More fixes due to new P2C flag so must patch
;			LR system also.
;			<1/24/90smb>	Need to set up a2 again w/ lineStart when 
;			found a character break.
;			<1/25/90smb>	Need to bra to @BailToLeft for zero width.
;			<2/16/90smb>	If at the last style, and pixel width > 0, and the
;			TEHitTestHook is replaced, then must check the high word of d0
;			to see if we REALLY got a hit!
;----------------------------------------------------------------------
ptchDoSearch
			with		TextFrame,TEFormatOrder
			jsrROM		ROMPreamble				; get A2 from D3

			Move		(A2),D3 				; set left anchor			<14Jan86>
			Move		D3,D4 					; init char counter

			jsrROM 		ROMLineRect				; set rLine to A2 line

			Move		(A2),D7 				; set left anchor
			sf			teLftClick(A3)			; assume false for later!	<4May89smb>

			Move.W		teSelPoint+h(A3),D5		; get h coord
			Sub.W		teSelRect+left(A3),D5	; subtract justification

; set d0 and teLftClick(a3) if at left of selRect <4May89smb>
			ble			@BailToLeft				; special case on left of whole line
;;<1/25/90smb> if zero width, want to branch ow this one pixel difference causes the 
;;<1/25/90smb> caret to display on the wrong line ending. (Roman fix)
;;<1/25/90smb> 			blt			@BailToLeft				; special case on left of whole line <16Aug89smb>

			Move		teSelRect+left(A3),teSelRect+right(A3); init right side to left
			Move.W		#UnboundLeft,teSelRect+left(A3); bogus left

			Move.W		2(A2),D6				; end of line

			Tst.W		teSize(A3)				; check style flag
			Bmi.S		@StyledRecord

			st			useOldMethod(a6)
			MoveQ		#1,D2					; just 1 style
			Move.W		D3,D1					; start of line
			Move.W		D6,D0					; whole line
	IF NOT (Scripts604 | SysVers>= $605) THEN	; <7Dec89smb>
			jmpROM		ROM@DoMeasure	
	ELSE
			Bra			@DoMeasure				; <7Dec89smb>
	ENDIF
@StyledRecord
			sf			useOldMethod(a6)		; flag for getting style runs <28Sept88smb>
; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge			@getStyleOld			; nope, only L->R directional text

			Move.W		D3,D0					; start offset
			Move.W		D6,D1					; end of selection
			bsr			ptchGetStylesInOrder	; <9Aug89smb>
; tests whether any styles to process <15Nov88smb>
			bge.s		@GetStyleHandle			; <15Nov88smb>
			jmpROM		ROM@NoMoreStyles		; done <15Nov88smb>

;----------------------------------------------------------------------
; added more code at @getStyleNew for right-to-left directional scripts <19Nov89smb>
@getStyleNew
; get next style using the results from getFormatOrder <28Sept88smb>
;; <5Aug89smb>			movea.l		a2StyleRun(a6),a0
; Made a2StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!)
; Get to posn in styleRun array via the Style Handle and saved offset <5Aug89smb>
			move.l		teStylesH(a3),a0		; <5Aug89smb>
			move.l		(a0),a0					; deref <5Aug89smb>
			add.l		a2StyleRun(a6),a0		; add in offset to desired posn in the array <5Aug89smb>

	IF NOT (Scripts604 | SysVers>= $605) THEN	; needed <7Dec89smb>
			jmpROM		ROMEndDoSearch
;;;;;;; Removed the code for a LR script system here.  Not necc since using ROM code for this case.			
;;@getStyleOld
;;			st			useOldMethod(a6)
;;			Move.W		D3,D0					; get selection start!!!
;;			Move.W		D6,D1					; end of line
;;			Bsr			GetCurStyle				; get its style	<7Oct88smb>
;;			Bsr			GetNumStyles			; # of styles between offsets <7Oct88smb>
;;			Move.W		D0,D2					; preserve # of styles
;;;;;;; Removed the code for a LR script system here.  Not necc since using ROM code for this case.			

	ELSE
			move.w		fmtOrderingIndex(a6),d0	; index (0-d2) into array for next style run
			lsl.w		#1,d0					; index into fmtOrdering array <28June89smb>
			lea.l		fmtOrderingPtr(a6),a1	; get ptr to array of format runs ordering <15Nov88smb>
			move.l		(a1),a1					; dereference for ordering <15Nov88smb>
			move.w		0(a1,d0.w),d0			; index of next style run
			lsl.w		#lnStStartSize,d0		; offset in styleRun array from d3 style run <28June89smb>
			lea.l		0(a0,d0.w),a0			; next style run		
			addq		#1,fmtOrderingIndex(a6)	; incr the style run counter			
			subq		#1,D2					; dec the style counter
			bge.s		@GetStyleHandle
			jmpROM		ROM@NoMoreStyles		; done 
			
@getStyleOld
			st			useOldMethod(a6)
			Move.W		D3,D0					; get selection start!!!
			Move.W		D6,D1					; end of line
			jsrROM		ROMGetCurStyle				; get its style	<7Oct88smb>
			jsrROM		ROMGetNumStyles			; # of styles between offsets <7Oct88smb>
			Move.W		D0,D2					; preserve # of styles
	ENDIF

@GetStyleHandle
			Move.L		A0,A2					; preserve ptr to current style
			Move.L		teStylesH(A3),A0		; handle to style info
			_HLock								; lock it up
			Move.L		A2,A0					; restore style ptr

@StyleLoop
			Move.L		A0,A2					; save ptr to style start
			jsrROM		ROMSetStyle				; set the style
			Move.W		startChar(A0),D1		; get start of style
			
			AddQ.L		#stStartSize,A0			; pt to next style run in StyleRun array 
			Move.W		startChar(A0),D0		; want end of this style run
			
			Cmp.W		D3,D1					; compare styleStart to beginning of line
			Bhs.S		@OnSameLine				; made this unsigned
			Move.W		D3,D1					; set beginning of style to beginning of line

@OnSameLine
			Move.W		D1,D7
			Cmp.W		D0,D6					; compare styleEnd to end of line
			Bhs.S		@DoMeasure				; made this unsigned
			Move.W		D6,D0					; set end of style to end of line

@DoMeasure
			Move.W		D2,-(SP)				; style count
			Sub.W		D1,D0					; length
			Move.L		teTextH(A3),A0			; handle to text
			Move.L		(A0),A0					; dereference
			AddA.W		D1,A0					; add offset to start of line
			Move.W		D5,D1					; get pixel offset
			MoveQ		#0,D2					; slop
			jsrROM		ROMTEHitTestHook		; call our hook instead
			
			Add.W		D0,teSelRect+right(A3)	; update selRect
			Add.W		D1,D7					; update char offset
			Sub.W		D0,D5					; update pixel offset

; find out if the pixel position was within the style run. <9Nov88smb>
	
			ble.s		@HitIt					; got a hit! (D5 <= 0)

;----------------------------------------------------------------------
; if at the last style, and pixel width > 0, and the TEHitTestHook is replaced, then
; must check the high word of d0 to see if we REALLY got a hit! <2/16/90smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		HITTESTHook(a0),a0
			peaROM		ROMPixel2Char
			cmpa.l		(sp)+,a0
			beq.s		@NotAHit
; we've been hooked out so test per the old interface specs for a hit.
			swap		d0
			tst.b		d0
			bne.s		@HitIt
@NotAHit
;----------------------------------------------------------------------
			Move.L		a2,a0					; ptr to current style
			moveq		#0,d2					; clear P2C flag from high word <7Dec89smb>
			Move.W		(sp)+,d2				; restore style count
; if no more style runs (at right of selRect), set exit info <4May89smb>
			bne.s		@getNextStyle			; last style on line?
			jmpROM		ROM@NoMoreStyles			

@getNextStyle
	IF NOT (Scripts604 | SysVers>= $605) THEN	; needed <7Dec89smb>
;;;;;;; Removed the code for a LR script system here.  Not necc since using ROM code for this case.			
;;			tst.b		useOldMethod(a6)		; <28Sept88smb>
;;			beq			@getStyleNew			; use formatOrder array

;; either unstyled or styled, LR record.
;;			Addq.l		#stStartSize,a0			; get next style <7Oct88smb>
;;			SubQ		#1,D2					; dec # of styles
;;			Bne.S		@StyleLoop				; keep looping if more			<C971/RWW102887>NO
;;;;;;; Removed the code for a LR script system here.  Not necc since using ROM code for this case.			
			bra.s		@getStyleNew
	ELSE
			tst.b		useOldMethod(a6)		; <28Sept88smb>
			beq			@getStyleNew			; use formatOrder array

; either unstyled or styled, LR record.
			Addq.l		#stStartSize,a0			; get next style <7Oct88smb>
			SubQ		#1,D2					; dec # of styles
			Bne.S		@StyleLoop				; keep looping if more			<C971/RWW102887>NO			
			jmpROM		ROM@NoMoreStyles			
	ENDIF
;----------------------------------------------------------------------
@BailToLeft
			jmpROM		ROM@BailToLeft
	IF NOT (Scripts604 | SysVers>= $605) THEN	; needed <7Dec89smb>
@getStyleOld
			jmpROM		ROM@getStyleOld
@HitIt
			jmpROM		ROM@HitIt
	ELSE
@HitIt
			addq.l		#2,sp					; remove style count from stack
; if SMgr's P2C measured the text then the leftSide flag is valid <7Dec89smb>
			tst.l		d2						; flag in high word; whole reg 0 if TextWidth used <7Dec89smb>
			beq.s		findDone				; TextWidth used, not SMgr's P2C <7Dec89smb>
			bclr		#16,d2					; clean up! <7Dec89smb>						

			tst.b		d2						; left or right side of char? (set in P2C) ; <7Dec89smb> flag in byte
	IF SysVers>= $700 THEN						; change this to correspond to P2C change		<19>
			st			teLftClick(A3)			; mark it to left
			bne.s		findDone				;												<19>
			movem.l		d0/d2/d3/d6,-(sp)		;												<19>
			move.w		d7,d6					; current position								<19>
			move.w		#1,d3					; incremental direction	to move					<19>
			jsrROM		ROMDoubleByte			;												<19>
			move.w		d6,d7					; new position									<19>
			movem.l		(sp)+,d0/d2/d3/d6		;												<19>
			sf			teLftClick(A3)			; mark it to right
	ELSE
			beq.s		findDone
; bug fix <1/24/90smb>
			subq		#1,d7					; adjust result to left half
			st			teLftClick(A3)			; mark it to left
	ENDIF
; Only want to test for a CR if the charOffset = 2(a2) and the leftSide = T.
; CR is a neutral character therefore, if it follows a style run whose direction is
; different from the line direction, it will always occur at the EOL posn, in the
; line direction. <5May89smb>
; <1/24/90smb> need to set up a2 again w/ lineStart
			move.w		d3,d0					; <1/24/90smb>
			lea 		teLines(a3),a2			; <1/24/90smb>
			jsrROM		ROMGetLine				; <1/24/90smb>
; end of fix <1/24/90smb>
			jmpROM		ROMafter@HitIt
findDone	jmpROM		ROMfindDone
	ENDIF
			endWith

;----------------------------------------------------------------------
;			PROCEDURE ptchDoDraw
;			<1/21/90smb>	We are now patching out all of DoDraw for 7.0
;			in order to set PreserveGlyph FALSE before drawing, and then 
;			restoring it afterwards.
;			<9/20/90smb>	Calling ptchDoErase now for TETextWidthHook.
;			<7Dec89smb>  Must call patch to ChkBounds.
;			Test WordRedraw to extend bounds of rectangle after calling
;			ChkBounds.
;			<8Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from DoDraw.  
;			GetNextDisplayStyle is only called for R-L directional
;			scripts, w/ styled text.  However, since DoDraw loops
;			for each line, I have to patch out the whole routine
;			for this situation.  DoDraw is a hook via TeDoText.
;----------------------------------------------------------------------
ptchDoDraw
;-----------------------------------------------
	IF SysVers>= $700 THEN
			with		TextFrame,TEFormatOrder
			import		ptchPinDisplay			;												<19>
			jsr			ptchPinDisplay			; you guessed it: it's patched now!				<19>
			jsrROM		ROMPreamble				; set rLine to A2 line

; ** <C105/14aug86/MBK> Only call LineRect at start to avoid height search **
			jsrROM		ROMLineRect

;-----------------------------------------------												<22>
; Turn PreserveGlyph off before drawing, but save its previous setting							<22>
			clr.w		-(sp)					; boolean result								<22>
			_GetPreserveGlyph					;												<22>
			; leave result on stack
			tst.w		(sp)					; preserve or squash? (byte result but cleared word)
			beq.s		@IsFalse				;												<22>
			move.b		#0,-(sp)				; set PreserveGlyph FALSE						<22>
			_SetPreserveGlyph					;												<22>
@IsFalse
;-----------------------------------------------												<22>

@lineLoop
			jsrROM		ROMPrepLine				; pin D4 at line end
			bls			@Test4Handle			; done...

			bsr			ptchChkBounds			; extend bounds if necessary
			tst.b		WordRedraw				; if R-L script (-1), then erase whole line  <7Dec89smb>
			bge.s		@LROrientation			; no, left->right flow  <7Dec89smb>
			Move.W		#UnboundRight,teSelRect+right(A3) 	; else, set unbound right <7Dec89smb>
			Move.W		#UnboundLeft,teSelRect+left(A3) ; else, set unbound left

@LROrientation
			move.W		d4,d6					; selEnd
			bsr			ptchDoErase				; calling TETextWidthHook now

			move.w		saveLeft(a6),-(sp)		; saved true left value	** <C105/18aug86/MBK> Got rid of rTrue **
			move.w		teSelRect+top(a3),-(sp) ; position pen
			move		teAscent(a3),d0

			tst.w		teSize(a3)				; check style flag
			bmi.s		@styledRecord

; record has no style, so draw all at once	(the old way)
			add 		d0,(sp) 				; drop pen to baseline
			_MoveTo

			move.l		teTextH(a3),a0			; get text handle
			move.l		(a0),a0 				; dereference
			add.l		d3,a0					; offset pointer

			clr.w		d0						; D0-D1 aren't a concern, since…	<C971/RWW110387>
			move.w		d4,d1					; …one would expect _DrawText…		<C971/RWW110387>
			sub.w		d3,d1					; …to blow them away anyways		<C971/RWW110387>
			jsrROM		ROMTEDrawHook			; go draw it

			bra			@nxtLine				;									<C971/RWW102887>NO

; record has style, so draw one style at a time
@styledRecord
			tst.w		d0						; check default ascent
			bpl.s		@ascentSet				; use it if set

			jsrROM		ROMPtrToLine				; convert A2 ptr to line #
			ext.l		d0						; make it long just in case	** <C381/6nov86/MBK> **
			lsl.l		#2,d0					; mult by 4					** <C381/6nov86/MBK> **

			move.l		teStylesH(a3),a0		; handle to style info
			move.l		(a0),a0					; deref
			move.l		lhTab(a0),a0			; array of max hite indeces
			move.l		(a0),a0					; deref
			move.w		2(a0,d0.L),d0			; max ascent

@ascentSet
			add 		d0,(sp) 				; drop pen to baseline
			_MoveTo
			
			sf			useOldMethod(a6)		; init flag for getting style runs <28Sept88smb>
; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge.s		@getStyleOld			; nope, only L->R directional text

			move.w		d3,d0					; start offset
			move.w		d4,d1					; end of selection
			bsr			ptchGetStylesInOrder	; <9Aug89smb>
; tests whether any styles to process <15Nov88smb>
			bge.s		@styleLoop				; <15Nov88smb>
			bra			@nxtLine				; <15Nov88smb>
			
@getStyleNew
; get next style using the results from getFormatOrder <28Sept88smb>
			bsr			ptchGetNextDisplayStyle		; <8Aug89smb>
			addq		#1,fmtOrderingIndex(a6)	; incr the style run counter			
			subq		#1,d2					; dec the style counter
			bge.s		@styleLoop
			bra			@nxtLine

@getStyleOld
			st			useOldMethod(a6)
			move.w		d3,d0					; start offset
			move.w		d4,d1					; end of selection
			jsrROM		ROMGetCurStyle			; get its style	<7Oct88smb> replaces GetFirstStyle call
			jsrROM		ROMGetNumStyles			; # of styles between offsets <7Oct88smb>
			move.w		d0,d2					; save style count

@styleLoop
			move.l		a0,-(sp)				; ptr to style: preserve a4	<21Dec88smb>
			jsrROM		ROMSetStyle				; set style
			move.w		startChar(a0),d0		; get start of style
			addq		#stStartSize,a0			; ptr to next style
			move.w		d6,d4					; init to end of line
			cmp.w		startChar(a0),d6		; compare to end of line
			blo.s		@4
			move.w		startChar(a0),d4		; set to end of style

@4			move.w		d2,-(sp)				; save the count
			move.l		teTextH(A3),a0			; get text handle
			move.l		(a0),a0 				; dereference

			cmp.w		d3,d0
			bhs.s		@5						; made this unsigned	** <C381/6nov86/MBK> **
			move.w		d3,d0					; reset if needed

@5			adda.w		d0,a0					; offset pointer

			move.l		teStylesH(a3),a1		; get style handle
			move.l		(a1),a1
			move.l		a1,d1					; <21Dec88smb>
			sub.l		d1,2(a7)				; save as an offset <21Dec88smb>

			move.w		d4,d1					; amount := range - i				<C971/RWW110387>
			sub.w		d0,d1					;									<C971/RWW110387>
			clr.w		d0						; no offset							<C971/RWW110387>
			jsrROM		ROMTEDrawHook			; go draw it

; Unlock the style handle when through with pointer.
			move.l		teStylesH(a3),a1		; get style handle
			move.l		(a1),a1
			move.l		a1,d1					; <21Dec88smb>
			add.l		d1,2(a7)				; restore as pointer <21Dec88smb>

			move.w		(sp)+,d2				; restore the count
			move.l		(sp)+,a0				; ptr to style <21Dec88smb>

			tst.b		useOldMethod(a6)		; <28Sept88smb>
			beq.s		@getStyleNew			; use formatOrder array

			addq.l		#stStartSize,a0			; get next style <7Oct88smb> replaces GetNextStyle call
			subq		#1,d2					; dec the style counter
			bne.s		@styleLoop				; must be more than 1 line

; ** <C105/14aug86/MBK> NextLineRect will not search for height from start **

@nxtLine

			jsrROM		ROMPtrToLine			; convert A2 to line #
			addq		#1,d0					; next line
			jsrROM		ROMNextLineRect			; set next line's rect
			move		(a2),d3 				; get start
			bra 		@lineLoop				; keep going

@Test4Handle

;-----------------------------------------------												<22>
; Restore PreserveGlyph							
			; previous PreserveGlyph value still on stack
			_SetPreserveGlyph					;												<22>						
;-----------------------------------------------												<22>

			jsrROM		ROMFreeFmtOrderArray	; <18Jan89smb>
doBye
			movem.l 	(sp)+,d2-d7/a2-a4		; restore regs
			unlk		a6						; unlink DoText frame
			move.l		GrafGlobals(a5),a0		; get the port in A0 for
			move.l		thePort(a0),a0			; compatibility
			rts
			endWith
;-----------------------------------------------
	ELSE										; NOT (SysVers>= $700)
	
	IF NOT (Scripts604 | SysVers>= $605) THEN
			tst.b		WordRedraw				; RL script system installed?
			bge			@UseROM					; if not, use ROM code <28Sept89smb> unsigned
			tst.w		teSize(a3)				; styled or unstyled?
			bpl			@UseROM					; if unstyled, use ROM code <14Aug89smb>
	ENDIF
	
; we are here for styled, RL directional scripts
			with		TextFrame,TEFormatOrder
			jsrROM 		ROMPinDisplay
			jsrROM		ROMPreamble				; set rLine to A2 line
			jsrROM		ROMLineRect

@lineLoop
			jsrROM		ROMPrepLine				; pin D4 at line end
			Bls			@Test4Handle			; done...

	IF Scripts604 | SysVers>= $605 THEN			; <7Dec89smb>
			bsr			ptchChkBounds			; <7Dec89smb>
			tst.b		WordRedraw				; if R-L script (-1), then erase whole line  <7Dec89smb>
			bge.s		@LROrientation			; no, left->right flow  <7Dec89smb>
			Move.W		#UnboundRight,teSelRect+right(A3) 	; else, set unbound right <7Dec89smb>
	ELSE
			jsrROM		ROMChkBounds			; extend bounds if necessary
			Tst.W		TESysJust				; reverse order?
			Beq.S		@LROrientation			; no, left->right flow
	ENDIF

			Move.W		#UnboundLeft,teSelRect+left(A3) 	; else, set unbound left

@LROrientation
	IF Scripts604 | SysVers>= $605 THEN			; <7Dec89smb>
; moved these optimizations here due to patch above <7Dec89smb>
			tst.b		WordRedraw				; RL script system installed?
			bge			@UseROM					; if not, use ROM code <28Sept89smb> unsigned
			tst.w		teSize(a3)				; styled or unstyled?
			bpl			@UseROM					; if unstyled, use ROM code <14Aug89smb>
	ENDIF										; <7Dec89smb>

			Move.W		D4,D6					; selEnd
	IF hasTextWidthHook THEN					;												<17>
			bsr			ptchDoErase				; calling TETextWidthHook now					<17>
	ELSE										;												<17>
			jsrROM		ROMDoErase				; to fix italics problem** <C182/2oct86/MBK> **
	ENDIF										;												<17>

			Move.W		saveLeft(A6),-(SP)		; saved true left value	** <C105/18aug86/MBK> Got rid of rTrue **
			Move.W		teSelRect+top(A3),-(SP) ; position pen
			Move		teAscent(A3),D0
;;;;;;; Removed the code that tests for an unstyled record here.  Not necc since using ROM code for this case.

			Tst.W		D0						; check default ascent
			Bpl.S		@ascentSet				; use it if set

			jsrROM		ROMPtrToLine			; convert A2 ptr to line #
			Ext.L		D0						; make it long just in case	** <C381/6nov86/MBK> **
			LsL.L		#2,D0					; mult by 4					** <C381/6nov86/MBK> **

			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; deref
			Move.L		lhTab(A0),A0			; array of max hite indeces
			Move.L		(A0),A0					; deref
			Move.W		2(A0,D0.L),D0			; max ascent

@ascentSet
			Add 		D0,(SP) 				; drop pen to baseline
			_MoveTo
			
;;<14Aug89smb>			sf			useOldMethod(a6)		; init flag for getting style runs <28Sept88smb>
; determine if display order is different from backin-store order <28Sept88smb>
;;;;;;; Removed the code for a LR script system here.  Not necc since using ROM code for this case.			

			Move.W		D3,D0					; start offset
			Move.W		D4,D1					; end of selection
			bsr			ptchGetStylesInOrder	; <9Aug89smb>		
; tests whether any styles to process <15Nov88smb>
			bge.s		@styleLoop				; <15Nov88smb>
			bra.s		@nxtLine				; <15Nov88smb>

@getStyleNew
; get next style using the results from getFormatOrder <28Sept88smb>
			bsr			ptchGetNextDisplayStyle	; <8Aug89smb>
			addq		#1,fmtOrderingIndex(a6)	; incr the style run counter			
			subq		#1,D2					; dec the style counter
			bcs.s		@nxtLine				; fixed branching <14Aug89smb>
;; <14Aug89smb>			bge.s		@styleLoop
;; <14Aug89smb>			bra.s		@nxtLine

;;;;;;; Removed the code for a LR script system here.  Not necc since using ROM code for this case.			

@styleLoop
			Move.L		A0,-(sp)				; ptr to style: preserve a4	<21Dec88smb>
			jsrROM		ROMSetStyle				; set style
			Move.W		startChar(A0),D0		; get start of style
			AddQ		#stStartSize,A0			; ptr to next style
			Move.W		D6,D4					; init to end of line
			Cmp.W		startChar(A0),D6		; compare to end of line
			Blo.S		@4
			Move.W		startChar(A0),D4		; set to end of style

@4			Move.W		D2,-(SP)				; save the count
			Move.L		teTextH(A3),A0			; get text handle
			Move.L		(A0),A0 				; dereference

			Cmp.W		D3,D0
			Bhs.S		@5						; made this unsigned	** <C381/6nov86/MBK> **
			Move.W		D3,D0					; reset if needed

@5			AddA.W		D0,A0					; offset pointer

			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1
			move.l		a1,d1					; <21Dec88smb>
			Sub.L		d1,2(A7)				; save as an offset <21Dec88smb>

			Move.W		D4,D1					; amount := range - i
			Sub.W		D0,D1
			Clr.W		D0						; no offset
			jsrROM		ROMTEDrawHook			; go draw it

; Unlock the style handle when through with pointer.
			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1
			move.l		a1,d1					; <21Dec88smb>
			Add.L		d1,2(A7)				; restore as pointer

			Move.W		(SP)+,D2				; restore the count
			Move.L		(sp)+,A0				; ptr to style

			bra.s		@getStyleNew			; <8Aug89smb>
;;;;;;; Removed the code that tests for an LR script system here.  Not necc since using ROM code for this case.
;;			tst.b		useOldMethod(a6)		; <28Sept88smb>
;;			beq.s		@getStyleNew			; use formatOrder array
;;;;;;; Removed the code for an unstyled record here.  Not necc since using ROM code for this case.

@nxtLine
			jsrROM		ROMPtrToLine			; convert A2 to line #
			AddQ		#1,D0					; next line
			jsrROM		ROMNextLineRect			; set next line's rect
			Move		(A2),D3 				; get start
			Bra 		@lineLoop				; keep going

	IF NOT (Scripts604 | SysVers>= $605) THEN
@UseROM		jmpROM		ROMDoDraw				; otherwise, use ROM code!
	ELSE
@UseROM		jmpROM		ROM@LROrientation		; otherwise, use ROM code now!
	ENDIF
@Test4Handle
			jsrROM		ROMFreeFmtOrderArray	; <18Jan89smb>
doBye
			MoveM.L 	(SP)+,D2-D7/A2-A4		; restore regs
			Unlk		A6						; unlink DoText frame
			Move.L		GrafGlobals(A5),A0		; get the port in A0 for
			Move.L		thePort(A0),A0			; compatibility
			Rts
			endWith
	ENDIF										; NOT (SysVers>= $700)

	IF Scripts604 | SysVers>= $605 THEN
;----------------------------------------------------------------------
;			PROCEDURE ptchDoCaret
;			<1/29/90smb>  Added patch to DoCaret to pin the caret in view
;			when blanks exceed the edge of the view rect. See end of routine.
;----------------------------------------------------------------------
ptchDoCaret
			jsrROM		ROMPreamble				; set rLine to A2 line

			tst 		d3						; special case @ 1st character		<03Nov85> SC
			beq.s		@GetSelRect				; if so skip all these checks		<03Nov85> SC

			cmp 		(a2),d3 				; at line start?
			bne.s		@GetSelRect				; skip if not next-line start

			move		teLength(a3),d0 		; are we past last char?
			beq.s		@GetSelRect				; (and is there a last char?)
			cmp 		d0,d3					; are we past last char?
			blo.s		@LeftCaret				; if not, skip special case

			move.l		teTextH(a3),a0			; get text handle
			move.l		(a0),a0 				; dereference

			move.b		-1(a0,d3),d0			; THESE TWO LINES REPLACE PREVIOUS	<C971/RWW110387>
			jsrROM		ROMTEEOLHook				;									<C971/RWW110387>
			beq.s		@GetSelRect				; skip the line
			bra.s		@PrevLine
@LeftCaret
			tst.b		teLftCaret(a3)			; to left?
			bne.s		@GetSelRect				; skip line pull back if so
@PrevLine
			subq		#2,a2					; skip to previous line
@GetSelRect
; determines the boundaries of the selection rectangle that contains the cursor, setting left = right
			jsrROM		ROMLineRect				; removed from Prep		** <C105/14aug86/MBK> **

			tst.w		teSize(a3)				; <27Oct88smb>
			bmi.s		@GetCursors				; bra if styled text
			tst.b		WordRedraw				; old style record, test for Roman/double-byte system
			bmi.s		@GetCursors				; bra if RL unstyled text <22June89smb>
			tst.b		teSysJust				; <22June89smb>
			beq.s		@OldStyleRecord			; bra if LR text on a LR line <22June89smb>
@GetCursors
; styled text OR unstyled RL text OR unstyled LR text on a RL line
			bsr			ptchCaretDisplay			; possibly split cursors <27Oct88smb>
			move.w		teSelRect+left(a3),d0
			move.w		d0,saveLeft(a6)
			bra.s		@Fix4Cursor
			
; Old style edit record for Roman; process as before <27Oct88smb>
@OldStyleRecord
			jsrROM		ROMPrepLine				; get selRect from D3..D4		<C971/RWW102887>NO
			move		saveLeft(a6),d0			; get caret loc
			move		d0,teSelRect+right(a3)	; and set in teSelRect
@Fix4Cursor
			subq		#1,d0
			move		d0,teSelRect+left(a3)
;-----------------------------------------------------------------------------------------			
; pin caret to edge of view rect if it's displaying out of view <1/29/90smb>
; make sure it's a caret position (selStart = selEnd)
			move.w		teSelStart(a3),d0
			cmp.w		teSelEnd(a3),d0
			bne			@Done
			
			tst.b		teSysJust
			bne.s		@RLDirection
; for a left-to-right line:
; if the viewRect.right >= the destRect.right and
; if the selRect.left >= the viewRect.right
; 	then selRect.right = viewRect.right
; 		 selRect.left = viewRect.right-1.
; is the viewRect.right >= the destRect.right?
			move.w		teViewRect+right(a3),d0
			cmp.w		teDestRect+right(a3),d0
			blt.s		@Done
; is the selRect.left >= the viewRect.right?
			move.w		teViewRect+right(a3),d0
			cmp.w		teSelRect+left(a3),d0
			bgt.s		@Done
; pin caret to edge of view rect
			move.w		d0,teSelRect+right(a3)
			subq.w		#1,d0
			move.w		d0,teSelRect+left(a3)
; test for split carets
			move.l		ExpandMem,a0
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)
			beq.s		@Done
; test if 2nd (split) caret is out of view also:is the Left edge greater than the view rect's Right edge
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; top, left, bottom, right of 2nd caret
			addq.w		#1,d0								; view rect still here: get back to right edge.
			cmp.w		left(a0),d0
			bgt.s		@Done
; pin split caret to edge of view rect also.
			move.w		d0,right(a0)
			subq.w		#1,d0
			move.w		d0,left(a0)
			bra.s		@Done
@RLDirection
; for a right-to-left line:
; if the viewRect.left <= the destRect.left and
; if the selRect.right <= the viewRect.left
; 	then selRect.left = viewRect.left
; 		 selRect.right = viewRect.left+1.
; is the viewRect.left <= the destRect.left?
			move.w		teViewRect+left(a3),d0
			cmp.w		teDestRect+left(a3),d0
			bgt.s		@Done
; is the selRect.right <= the viewRect.left?
			move.w		teViewRect+left(a3),d0
			cmp.w		teSelRect+right(a3),d0
			blt.s		@Done
; pin caret to edge of view rect
			move.w		d0,teSelRect+left(a3)
			addq.w		#1,d0
			move.w		d0,teSelRect+right(a3)
; test for split carets
			move.l		ExpandMem,a0
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)
			beq.s		@Done
; test if 2nd (split) caret is out of view also:is the Right edge less than the view rect's Left edge
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; top, left, bottom, right of 2nd caret
			subq.w		#1,d0								; view rect still here: get back to left edge.
			cmp.w		right(a0),d0
			blt.s		@Done
; pin split caret to edge of view rect also.
			move.w		d0,left(a0)
			addq.w		#1,d0
			move.w		d0,right(a0)
@Done
; end of changes <1/29/90smb>
;-----------------------------------------------------------------------------------------			
			bra 		doBye

;----------------------------------------------------------------------
;			PROCEDURE ptchDoHilite
;			<4Oct89smb>	 HyperCard expects to outline highlight one window
;			rather than the three the new highlighting code gives, so
;			I'm putting back the old code for Roman systems.  At this writing,
;			we will still have a problem for non-Roman script systems.
;			<9/6/90smb>  Now patching DoHilite if Inline Input is active to 
;			hilite each line of the middle rectangle in order to call
;			highHook.
;----------------------------------------------------------------------
ptchDoHilite
; If a Roman system then use old DoHilite code: HyperCard expects to hilite a whole region not three! <3Oct89smb>
			move.l		ExpandMem,a0
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)	; total number of installed scripts
			beq			RomanDoHilite			; use old DoHilite
;----------------------------------------------------------------------								<16>
	IF hasInlineInput THEN						; 													<16>
; If SysVers >= 606 then test if Inline is active.  If not, then use ROM code.
	  IF SysVers < $700 THEN				; if < $700 then test for inline; otherwise, use this for >=$700	<29>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFInlineInput,d0		; is Inline Input active?
			beq		@UseRomHilite			; no, so use the ROM hiliting code
	  ENDIF									; If SysVers < $700 THEN								<29>	

; Inline is active so, patch DoHilite so that each line of the middle rectangle is highlighted 
; independently OR SysVers >= $700 so we need to use the patched version of ptchOnSameLine.			<29>			

; use this code for mixed directional text
			
		IF SysVers>= $700 THEN				;														<19>
			import	ptchPinDisplay			;														<19>
			jsr		ptchPinDisplay			; you guessed it: it's patched now!						<19>
		ELSE
			jsrROM 	ROMPinDisplay
		ENDIF								;														<19>
			jsrROM	ROMPreamble				; set rLine to A2 line, d5 = d4
											; sets A2 to point to line containing d3
			jsrROM	ROMLineRect				; get top, bottom and just (from A2)

			move.l	a4,-(sp)				; need for OnSameLine vector <26June89smb>

			with	HiliteFrame
			link	a6,#HiLiteSz			; LineRect needs to access doText stack frame			

			movea.l	a2,a1					; save d3 lineStart
			cmp.w	d3,d4					; wrong order?
			beq		@unLinkFrame
			bhi.s	@Get2ndLine				; no, correct
			exg		d3,d4					; fix
			
; find out the first offset's line for Right to Left directional text
			move.w	d3,d0
			lea 	teLines(A3),a2			; point to line starts
			jsrROM	ROMGetLine				; returns ptr to line in a2
			bra.s	@CompareLines
@Get2ndLine
; test if 2nd offset is at the end of the 1st offset's line <2Dec88smb>
			cmp.w	2(a2),d4				; <2Dec88smb>
			beq.s	@CompareLines			; <2Dec88smb>
			
; get the second offset's line. Already have lineStart for d3 in a1
			move.w	d4,d0
			jsrROM	ROMGetLine 				; returns ptr to line in a2

@CompareLines
			exg		a1,a2
			cmpa.l	a1,a2
			bne.s	@MultipleLines			; over multiple lines
			bsr		ptchOnSameLine
			bra		@unLinkFrame

@MultipleLines
; [d3,d4] over multiple line
; set up for line containing d3
			move.l	a1,d4Line(a6)			; save lineStart for d4 for later
			move.l	a2,d3Line(a6)
			move.w	d4,savD4(a6)
			move.w	2(a2),d4				; end of d3 line
			bsr		ptchOnSameLine			; hilite regions on 1st line

; set up for line containing d4			

			move.w	savD4(a6),d4
			move.l	d4Line(a6),a2			; LineRect wants the current line in a2
			move.w	(a2),d3					; beginning of d3 line
			
; ********* Be sure to notice the unusual use of link/unlk here	*******
; *********	due to multiple line highlighting! 					*******
			move.l	d3Line(a6),a1			; temp for unlink 
			unlk	a6						; unlink HiliteFrame for LineRect *********
			move.w	teSelRect+bottom(a3),-(sp)	; save for middle rectangle's top edge
			move.l	a1,-(sp)				; save d3's line
			jsrROM	ROMLineRect				; get top, bottom and just (from A2)
			bsr		ptchOnSameLine			; hilite regions on last line
			
			move.l	(sp)+,a1				; d3's line
; now hilite the middle rectangle, between the lines containing the offsets.
; a1 = ptr to line containing d3
; a2 = ptr to line containing d4			
	
; tests for lines inbetween 1st and last
			move.w	2(a1),d2				; end of 1st line				
			cmp.w	(a2),d2					; end of 1st rectangle = beginning of last rectangle
			beq.s	@noMidRect				; done: no middle rectangle

;-------------------------------------------													<29>
	IF hasInlineInput THEN					; 													<29>
; if inlineInput then don't want to hilite to edge of selRect, only to text boundaries			<29>
			move.l	teDispatchH(a3),a0		; 													<29>
			move.l	(a0),a0					; 													<29>
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops				<29>
			btst	#teFInlineInput,d0		; is this Inline Input feature desired?				<29>
			beq.s	@HiliteMiddle			; no, so hilite middle rect as one!					<29>
; inline input so measure the middle rectangle of text											<29>
; a1 = ptr to line containing d3
; a2 = ptr to line containing d4
@AnotherLine								;													<29>
			move.w	d2,d3					; d2 contains the new d3
			add.w	#2,a1					; increment to pt to line containing new d3
			move.w	2(a1),d4
			movem.l	a1/a2,-(sp)				; save d3 & d4's line
			move.l	a1,a2					; LineRect wants the current line in a2
			jsrROM	ROMLineRect				; get top, bottom & just (from a2)
			bsr		ptchOnSameLine			; hilite regions on this line
			movem.l	(sp)+,a1/a2
			move.w	2(a1),d2				; end of d3's line
			cmp.w	(a2),d2					; end of d3's line = beginning of last line?
			bne.s	@AnotherLine			; bra if another line to measure & hilite			<29>
			bra.s	@noMidRect				; otherwise done									<29>
	ENDIF									;													<29>
;-------------------------------------------													<29>

; set up selRect(a3)																			<29>
@HiliteMiddle								;													<29>
			move.w	teSelRect+top(a3),teSelRect+bottom(a3)	; top of last rect = bottom of middle rect
			move.w	(sp)+,teSelRect+top(a3)		; bottom of 1st rect = top of middle rect		<29>
			move.w	#UnboundLeft,teSelRect+left(a3) 	; far left								<29>
			move.w	#UnboundRight,teSelRect+right(a3) 	; far right								<29>

			move.l	teHiHook(a3),D0 		; do the inversion via hook if exists				<29>
			jsrROM 	ROMInvertHook			; hilite it											<29>
			bra.s	@finis					;													<29>

@noMidRect
			addq	#2,a7					; don't need saved pixelWidth for top edge
			bra.s	@finis
@unLinkFrame
; ********* Be sure to notice the unusual use of link/unlk here	*******
; *********	due to multiple line highlighting! 					*******
			unlk	a6						; unlink HiliteFrame
@finis
			move.l	(sp)+,a4				; restore handle <26June89smb>
			bra		doBye
			endWith
	ENDIF									; IF hasInlineInput THEN
;----------------------------------------------------------------------								<16>
@UseRomHilite								;														<16>
		IF SysVers>= $700 THEN				;													<19>
			import		ptchPinDisplay		;													<19>
			jsr			ptchPinDisplay		; you guessed it: it's patched now!					<19>
			jmpROM		ROMinDoHilite		;
		ELSE
			jmpROM		ROMDoHilite
		ENDIF								;													<19>

;----------------------------------------------------------------------								<16>
RomanDoHilite
		IF SysVers>= $700 THEN					;													<19>
			import		ptchPinDisplay			;													<19>
			jsr			ptchPinDisplay			; you guessed it: it's patched now!					<19>
		ELSE
			jsrROM 		ROMPinDisplay
		ENDIF									;													<19>
			jsrROM		ROMPreamble				; set rLine to A2 line

			jsrROM		ROMLineRect				; get top, bottom and just
			jsrROM		ROMPrepLine				; pin D4 at line end
			bls.s		@done					; done...						<C971/RWW102887>NO

;;<7Dec89smb>			jsrROM		ROMChkBounds			; check far left and right
			bsr			ptchChkBounds			; extend bounds if necessary <7Dec89smb>

			move.l		teHiHook(A3),d0 		; do the inversion via hook if
			jsrROM 		ROMInvertHook			; there

			cmp.w		2(a2),d5				; only 1 line?
			bls.s		@done					; made this unsigned	** <C381/6nov86/MBK> **

			jsrROM		ROMPtrToLine			; get current line #
			move.w		d0,d1					; save it
			move.w		d5,d0					; offset to look for
			jsrROM		ROMGetLine				; get D5 line ptr
			jsrROM		ROMPtrToLine			; convert A2 ptr to line #
			addq		#1,d1
			cmp.w		d0,d1					; get the difference
			beq.s		@LastLine				; no lines inbetween

			move.w		d0,-(SP)				; save line #
			exg			d0,d1
			move.w		teSelRect+bottom(a3),teSelRect+top(a3)
			jsrROM		ROMGetLineHites			; hites from 2nd to last lines
			add.w		d0,teSelRect+bottom(a3)	; hite to last line
			move.w		#UnboundLeft,teSelRect+left(a3) ; far left
			move.w		#UnboundRight,teSelRect+right(a3) ; far right

			move.l		teHiHook(A3),d0
			jsrROM		ROMInvertHook			; hilite it
			move.w		(SP)+,d0				; restore line #

; hilite last line
@LastLine
			jsrROM		ROMNextLineRect			; get rectangle for last line	<C971/RWW102887>NO
			move.w		(A2),D3					; for chkBounds
			jsrROM		ROMPrepLine				; get left and right
			bls.s		@done					; done...

;;<7Dec89smb>			jsrROM		ROMChkBounds			; check far left and right
			bsr			ptchChkBounds			; extend bounds if necessary <7Dec89smb>

			move.l		teHiHook(A3),D0 		; do the inversion via hook if
			jsrROM 		ROMInvertHook			; there
@done
			bra 		doBye
		ENDIF

;----------------------------------------------------------------------
;			PROCEDURE ptchCursorMovement
;			<7Aug89smb>	 Compare a byte, not a word, for the arrow key type.
;			<9Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from FindStyleRun, which
;			is not vectored.  So, have to fix in CursorMovement and then
;			jump back into FindStyleRun.
;			<28Sept89smb> Fixed double-byte bugs.
;			<22Nov89smb> Had to pin the style run to the line end for 
;			correct position.
;----------------------------------------------------------------------
ptchCursorMovement

CursorMoveRegs		reg		d2-d5/d7/a2
			with	CursorFrame,TEFormatOrder
			link	a6,#CursorFrameSz
			movem.l	CursorMoveRegs,-(sp)

; Initializations
			sf		FormatEndFlag(a6)			; <17Jan89smb>
; ***** cd = left? *****
			cmpi.b	#leftArrowChar,d1			; left arrow? <7Aug89smb> cmp byte not word
			beq.s	@SetLeftCD
; right arrow
			move.b	#$FF,d0						; cursor direction = right
			move.w	#1,d7						; fmt run index delta (in cursor direction [R])
			move.b	#1,d2						; q: m[q] = m[1] = n = rightmost fmt index boundary
			moveq	#0,d1						; p: m[p] = m[0] = 0 = leftmost fmt index boundary

			bra.s	@GetLineDir
@SetLeftCD
			moveq	#0,d0						; cursor direction = left
			move.w	#-1,d7						; fmt run index delta (in cursor direction [L])
			moveq	#0,d2						; q: m[q] = m[0] = 0 = leftmost fmt index boundary
			move.b	#1,d1						; p: m[p] = m[1] = n = rightmost fmt index boundary

; ***** cd = ld? *****
@GetLineDir
; get line direction
			cmp.b	TESysJust,d0
			beq.s	@CDequalsLD
; CD <> LD: cursor direction <> line direction (left arrow, RL line dir; right arrow, LR line dir)
			move.w	#-1,d5						; character delta
			move.b	#1,d3						; start
			moveq	#0,d4						; end
			bra.s	@NeedLine
@CDequalsLD
; CD = LD: cursor direction = line direction (left arrow, LR line dir; right arrow, RL line dir)
			move.w	#$1,d5						; character delta
			moveq	#0,d3						; start
			move.b	#1,d4						; end
@NeedLine
; need to test line ends so get current line containing character offset
			move.w	d6,d0
			lea		teLines(a3),a2
			movea.l	a2,a0
			jsrROM	ROMGetLine

; special case! if at end of document (test if on last line) and cd <> ld don't
; want to add charDelta<17Jan89smb>
			move.w	teNLines(a3),d0				; number of lines
			lsl.w	#1,d0
			add.w	d0,a0						; want end of last line
			cmpa.l	a0,a2						; on last line?
			bne.s	@OtherLineStuff
			tst.b	d5
			blt		@done						; at EOD, done.

@OtherLineStuff
; yet another special case!  If at the lineStart, and cd = ld, then want to be on
; previous line. <16Jan89smb>
			cmp.w	(a2),d6
			bne.s	@OnCorrectLine				; not at lineStart
			cmpi.w	#0,d6
			beq.s	@OnCorrectLine				; not beginning of text
			tst.b	d5
			blt.s	@OnCorrectLine				; cd <> ld
			subq	#2,a2						; previous line
@OnCorrectLine
			movem.w	d1/d2,-(sp)
			jsrROM	ROMGetFormatOrdering
			movem.w	(sp)+,d1/d2					; restore

; ***** if c = l[s] then c = c *****
; if s = 0, then l[s] = lineStart
; if s = 1, then l[s] = lineEnd
			move.b	d3,d0						; start
			jsrROM	ROMTestLineEnds
			bne		@done						; c = c. done

; ***** if c = l[e] then r1 = m[p] *****
; if e = 0, then l[e] = lineStart
; if e = 1, then l[e] = lineEnd
			move.b	d4,d0						; end
			jsrROM	ROMTestLineEnds
			beq.s	@FindRun
; ***** r1 = m[p] *****
; d1 = p as input
			jsrROM	ROMSetRun					; returns d1.w = r1: leftmost or rightmost format
; ***** d(r1) = ld? *****
			bsr		ptchTestRunDirection		; d1 = r1 (format index) <9Aug89smb>
			bne		@CSubDelta					; True: equal
			bra		@OneCharacterTest
@FindRun
; find r s.t. f[r,0]<c<f[r,1] OR
;	((f[r,0]=c or f[r,1]=c) AND IF on a cluster boundary then d(r)=ld
; 							   Else find r s.t. c = f[r,e])
			bsr		ptchFindStyleRun			; returns a0 pointing to style run of d6, d1 = r <9Aug89smb>
			cmp.w	startChar(a0),d6
			beq.s	@OnBoundary
			jsrROM	ROMFixFormatEnd				; <17Jan89smb> if last format run, must decrement
			cmp.w	d0,d6						; <17Jan89smb>
			bcs		@InMiddle					; <17Jan89smb>		<26June89smb> made unsigned
			st		FormatEndFlag(a6)			; <17Jan89smb> on end of style run
@OnBoundary
; on boundary: test for cluster boundary <17Jan89smb>
; get this style run's script direction
			movem.l	d1/d2,-(sp)					; save r (d1) and style
			jsrROM	ROMGetDirection
			move.b	d1,d0
			movem.l	(sp)+,d1/d2					; <20Jan89smb>
			cmp.b	TESysJust,d0				; <20Jan89smb>
			beq		@TakeRightBranch			; <20Jan89smb>
			move.b	d0,RunDirection(a6)			; <20Jan89smb>

; get other boundary style run
			tst.b	FormatEndFlag(a6)			; test if at start or end of style run
			bne.s	@GetNextRun					; at end of this style run
; at start of this style run so get previous style run in backing-store order
			subq.l	#stStartSize,a0
			bra.s	@GetScriptDir
@GetNextRun
; get next style run in backing-store since at end of this style run
			addq.l	#stStartSize,a0
@GetScriptDir
; get the other style run's script direction
			movem.l	d1/d2,-(sp)					; save r (d1) and style
			jsrROM	ROMGetDirection
			move.b	d1,d0
			movem.l	(sp)+,d1/d2
; compare script directions to see if on a cluster boundary
			cmp.b	RunDirection(a6),d0
			bne.s	@ClusterBoundary

; On a style run boundary with both runs of the same script <17Jan89smb>
; ***** d(r) = ld? *****
; d(r) <> ld so find r s.t. c = f[r,e]
; get original boundary style again <25June89smb>
			tst.b	FormatEndFlag(a6)			; test if at start or end of style run
			bne.s	@GetPrevRun					; at end of this style run
; at start of this style run so get previous style run in backing-store order
			add.l	#stStartSize,a0
			bra.s	@TestStylEnd
@GetPrevRun
; get next style run in backing-store since at end of this style run
			subq.l	#stStartSize,a0
@TestStylEnd
			move.w	d1,-(sp)					; save original r
			move.b	d4,d1						; end
			move.w	d6,d0						; save d6
	IF Scripts604 | SysVers>= $605 THEN
			bsr		ptchGetStyleEnd				; <26Nov89smb>
	ELSE
			jsrROM	ROMGetStyleEnd				; returns style start or end in d6
	ENDIF
			move.w	(sp)+,d1					; restore r
			exg		d6,d0						; want original char offset in d6
			cmp.w	d0,d6						; does c = f[r,e]?
			beq.s	@GetNewIndex				; yep
			bsr		ptchFindStyleRun			; d1 =  r s.t. c = f[r,e] <9Aug89smb>

@GetNewIndex
; ***** r1 = r + fmtDelta *****
			add.w	d7,d1						; format delta
			bra.s	@NewFmtIndex				; <20Jan89smb> must check for 1 char in style run

@ClusterBoundary
; find r s.t. (f[r,0]=c or f[r,1]=c) AND d(r)=ld <17Jan89smb>
; Since the character is on a cluster boundary, we want the style run with it's
; direction = the line direction (LD).
; ***** d(r) = ld? *****
			bsr		ptchFindStyleRun			; find other boundary run with d(r) = ld; d1 = r <9Aug89smb>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	IF Scripts604 | SysVers>= $605 THEN
; continue conditionally!
			bra.s	@TakeRightBranch			; True: d(r) = ld
	
@InMiddle
; firmly in the middle.  Test the line direction to determine the branch to take <17Jan89smb>
; ***** d(r) = ld? *****
			bsr		ptchTestRunDirection		; does the direction of the run = line direction?
			bne.s	@TakeRightBranch			; True: d(r) = ld
; d(r) <> ld
; ***** c <> f[r,e] - charDelta? ***** are we one away from a style boundary?
			move.w	d1,-(sp)
			move.b	d4,d1						; end
			move.w	d6,d0						; save d6
;;			jsrROM	ROMGetStyleEnd				; returns style start or end in d6
			bsr		ptchGetStyleEnd				; <26Nov89smb>
			move.w	(sp)+,d1
			
; must adjust for double-byte characters <2Sept89smb>
			movem.l	a0/d0-d3,-(sp)				; save <2Sept89smb>
			move.w	d5,d3						; <2Sept89smb>
			neg.w	d3							; <2Sept89smb>
; f[r,e] - charDelta (where the delta may be -2/2 rather than -1/1)
			jsrROM	ROMDoubleByte				; <2Sept89smb>
			movem.l	(sp)+,a0/d0-d3				; <2Sept89smb>
			exg		d6,d0						; want original char offset in d6
			cmp.w	d0,d6
;------------------------------------------------------------------------------------
; must pin to line end to get correct offset, so to truly be done: <22Nov89smb>
; c <> l[e] - charDelta
			beq.s	@TstFmtIndeces				; <22Nov89smb>
; if e = 0, then l[e] = lineStart
; if e = 1, then l[e] = lineEnd
			move.w	2(a2),d0					; assume e=1 so use lineEnd ; <22Nov89smb>
			cmpi.b	#0,d4						; end ; <22Nov89smb>
			beq.s	@IsLineStart				; <22Nov89smb>
			bra.s	@SubDelta					; <22Nov89smb>
@IsLineStart
			move.w	(a2),d0						; <22Nov89smb>
@SubDelta
			sub.w	d5,d0						; - charDelta <22Nov89smb>
			cmp.w	d6,d0						; <22Nov89smb>
			bne		@CAddDelta					; done
;-----------------------------------------------------------------------------------

@TstFmtIndeces
; ***** r = m[q]? *****
; in the leftmost or rightmost format? test format indeces
			move.w	d1,d0						; save r(n)
			move.b	d2,d1						; q
			jsrROM	ROMSetRun					; returns m[q] in d1.w (0/n)
			cmp.w	d0,d1
			beq.s	@CUseLineSt					; yep, r = m[q]: c = l[s]
			
; ***** r1 = r + fmtDelta *****
			add.w	d7,d0						; format delta
			move.w	d0,d1						; want r1 in d1
; ***** d(r1) = ld? ***** 
@NewFmtIndex
			bsr		ptchTestRunDirection		; does the direction of the run = line direction?
			beq		@CAddDelta					; False: d(r1) <> ld ; c = c + CharDelta												; True: d(r1) = ld
; ***** c = f[r1,e] *****
			move.b	d4,d1						; end
;;			jsrROM	ROMGetStyleEnd				; returns new char offset in d6
			bsr		ptchGetStyleEnd				; <26Nov89smb>
			bra		@done

@TakeRightBranch
; (either on a boundary or firmly in the middle) AND d(r) = ld
; ***** c <> f[r,s]? *****
			tst.b	d3							; start
			bne.s	@EndOffset					; s = 1
; c <> f[r,0]? => start offset for format run r
			cmp.w	startChar(a0),d6
			bne.s	@CSubDelta
			bra.s	@TestFmtArrayEnds
@EndOffset
; c <> f[r,1]? => end offset for format run r
			jsrROM	ROMFixFormatEnd				; <17Jan89smb> if last format run, must decrement
			cmp.w	d0,d6
			bne.s	@CSubDelta
		
@TestFmtArrayEnds
; ***** r = m[q]? *****
; in the leftmost or rightmost format? test format indeces
			move.w	d1,d0						; save r(n)
			move.b	d2,d1						; q
			jsrROM	ROMSetRun					; returns m[q] in d1.w (0/n)
			cmp.w	d0,d1
			beq.s	@done						; yep, r = m[q]: c = c
; ***** r1 = r + fmtDelta *****
			add.w	d7,d0						; format delta
			move.w	d0,d1						; want r1 in d1
; ***** d(r1) = ld? ***** 
			bsr		ptchTestRunDirection		; does the direction of the run = line direction?
			bne.s	@CSubDelta					; True: equal
			
@OneCharacterTest
; no, style run direction <> line direction
; ***** f[r1,1] - f[r1,0] <> 1? *****
; test if there is only one character in the run.
			jsrROM	ROMFixFormatEnd				; <17Jan89smb> if last format run, must decrement
			sub.w	startChar(a0),d0
			cmpi.w	#1,d0
			bhi.s	@CUseStartDelta				; c = f[r1,s] + charDelta	<26June89smb> made unsigned

; ***** r1 = m[q]? *****
; in the leftmost or rightmost format? test format indeces
			move.w	d1,d0						; save r(n)
			move.b	d2,d1						; q
			jsrROM	ROMSetRun					; returns m[q] in d1.w (0/n)
			cmp.w	d0,d1
			beq.s	@CUseStart					; terminator is direction test
; ***** r2 = r1 + fmtDelta *****
			add.w	d7,d0						; format delta
			move.w	d0,d1						; want r1 in d1
; ***** d(r2) = ld? ***** 
			bsr		ptchTestRunDirection		; does the direction of the run = line direction?
			beq.s	@CUseStartDelta				; d(r2) <> ld: c = f[r1,s] + charDelta
@CUseStart
; ***** c = f[r1,s] ******
			move.b	d3,d1						; start
;;			jsrROM	ROMGetStyleEnd				; returns new char offset in d6
			bsr		ptchGetStyleEnd				; <26Nov89smb>
			bra.s	@done
			
@CUseStartDelta
;***** c = f[r1,s] + charDelta *****
			move.b	d3,d1						; start
;;			jsrROM	ROMGetStyleEnd				; returns new char offset in d6
			bsr		ptchGetStyleEnd				; <26Nov89smb>
			bra.s	@CAddDelta

@CUseLineSt
; ***** c = l[s] *****
			move.b	d3,d1						; start
			tst.b	d1
			bne.s	@UseLineEnd
; c = l[0] = lineStart
			move.w	(a2),d6
			bra.s	@done			
@UseLineEnd
; c = l[1] = lineEnd
			move.w	2(a2),d6
			bra.s	@done
; if double-byte character fix the offset posn.<2Sept89smb>
@CSubDelta
			neg.w	d5							; <2Sept89smb>
@CAddDelta
			move.w	d5,d3						; DoubleByte wants charDelta here <2Sept89smb>
			jsrROM	ROMDoubleByte				; <2Sept89smb>

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	ELSE
; continue here for 6.0.4 Roman System patches
@TakeRightBranch
			jmpROM	ROM@TakeRightBranch
@OneCharacterTest
			jmpROM	ROM@OneCharacterTest
@CSubDelta	jmpROM	ROM@CSubDelta
@InMiddle	jmpROM	ROM@InMiddle
@NewFmtIndex
			jmpROM	ROM@NewFmtIndex

	ENDIF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; rejoin again
@done
			movem.l	(sp)+,CursorMoveRegs
			unlk	a6
			rts
			endWith

;----------------------------------------------------------------------
;			PROCEDURE ptchFindStyleRun
;			<9Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from FindStyleRun, which
;			is not vectored.
;----------------------------------------------------------------------
ptchFindStyleRun
			with	CursorFrame,TEFormatOrder
@RunLoop
			bsr		ptchGetNextDisplayStyle		; <9Aug89smb>
			move.w	fmtOrderingIndex(a6),d1
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter
			cmp.w	startChar(a0),d6
			bhi.s	@CheckUpperBound			; in middle?	<26June89smb> made unsigned
			beq.s	@done
			bra.s	@RunLoop
@CheckUpperBound
	IF forLocalizability THEN					; <34o-YDS-9/2/91>
			jsrRom	ROMFixFormatEnd				;
	ELSE
			jmpRom	ROMFixFormatEnd				; <17Jan89smb> if last format run, must decrement
	ENDIF
			cmp.w	d0,d6						; <17Jan89smb>
			bhi.s	@RunLoop					; <26June89smb> made unsigned
@done
			rts
			endwith

	IF Scripts604 | SysVers>= $605 THEN
;----------------------------------------------------------------------
;			PROCEDURE ptchGetStyleEnd
;			<26Nov89smb>
;			Must pin the style run to the appropriate line ending.
;----------------------------------------------------------------------
ptchGetStyleEnd
			move.w	d0,-(sp)					; <17Jan89smb>
			tst.b	d1
			bne.s	@UseEnd
; f[r1,0] = start offset for format run at format index r1.
			move.w	startChar(a0),d6

; must pin style run to lineStart! <26Nov89smb>
			cmp.w	(a2),d6
			bhs.s	@done						; style start on this line <26Nov89smb>
			move.w	(a2),d6						; use lineStart <26Nov89smb>
			bra.s	@done		

@UseEnd
; f[r1,1] = end offset for format run at format index r1.
			jsrROM	ROMFixFormatEnd				; <17Jan89smb> if last format run, must decrement
			move.w	d0,d6						; <17Jan89smb>

; must pin style run to line end if it breaks across the line! <26Nov89smb>
			cmp.w	2(a2),d6					; <26Nov89smb>
			bls.s	@done						; <26Nov89smb>
			move.w	2(a2),d6					; <26Nov89smb>
@done
			move.w	(sp)+,d0					; restore <17Jan89smb>
			rts
	ENDIF
;----------------------------------------------------------------------
;			PROCEDURE ptchTEGetFormatOrder
;			<6Aug89smb>	 I need to patch a bug in the routine SetUp, a
;			subroutine of StyleMeasure, and only called by RomanFindLine.
;			It is a caller of P2C that has no vector or trap.
;----------------------------------------------------------------------
ptchTEGetFormatOrder
FormatOrderRegs		reg		d2-d4

			with	SharedFrame,TEFormatOrder
			moveq.l	#0,d2

			jsrROM	ROMGetCurStyle
; Made a2StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!) Oh-Dopey-Me!
			move.l	teStylesH(a3),a1			; <5Aug89smb>
			move.l	(a1),a1						; deref <5Aug89smb>
			sub.l	a1,a0						; save posn as an offset <5Aug89smb>
			move.l	a0,a2StyleRun(a6)			; save offset to style run of lineStart
			add.l	a1,a0						; restore for succeeding GetNumStyles call
			jmpROM	ROMEndTEFmtOrder
			endWith
			
;----------------------------------------------------------------------
;			PROCEDURE ptchCaretDisplay
;			<8Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from CaretDisplay. Must
;			replace this much code since the bug occurs in looping code.
;			<9/20/90smb>	Patched to call ptchMeasureWholeRun for
;			TextWidth hook.
;----------------------------------------------------------------------
ptchCaretDisplay

			with	SharedFrame,TEFormatOrder
			link	a6,#SharedFrameSz
			move.l	ExpandMem,a0				; <1Feb89smb> initialize for only 1 cursor
			sf		ExpandMemRec.emTwoCursorsFlag(a0)
			sf		ExpandMemRec.emFmtOrderHFlag(a0) ; no handle allocated for styles
			clr.w	gotOneRun(a6)				; set gotOneRun and onBoundaryFlag to F.
			sf		scriptDirection(a6)			; initialize to LR
			clr.w	d5

			jsrROM	ROMGetFormatOrdering			; <8Mar89smb>

; accumulate widths of style runs until hit one containing a cursor.
@MeasureLoop
			bsr		ptchGetNextDisplayStyle		; <8Aug89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr for the next measurement

; does this style contain a cursor?
@Check4Cursor
			cmp.w	startChar(a0),d3			; cursor at beginning of run?
;;			bhi.s	@CheckUpperBound			; <26June89smb> made unsigned					<13>
			beq.s	@CursorRun					; cursor on start boundary of it's run
;;			bra		@GetWidth					; cursor outside of run							<13>
			blo		@GetWidth					; 												<13>
			

@CheckUpperBound
			jsrROM	ROMFixFormatEnd				; if last format run, must decrement <17Jan89smb>
			cmp.w	d0,d3						; cursor at end of run? <17Jan89smb>
			bhi.s	@GetWidth					; cursor outside of run <26June89smb> made unsigned
			blt.s	@FoundCursor				; cursor in middle of run

; in style previous to cursor's run
			tst.b	gotOneRun(a6)				; set up second rectangle now?
			bne		@SetEnds					; yup, already have top and bottom
			st		prevStyleFlag(a6)			; cursor at end of this run (previous style)
			bra.s	@OnBoundary
@CursorRun
; in cursor's run
			tst.b	gotOneRun(a6)				; set up second rectangle now?
			bne		@SetEnds					; yup, already have top and bottom
			sf		prevStyleFlag(a6)			; cursor at beginnning of it's run
@OnBoundary
			st		onBoundaryFlag(a6)			; cursor on boundary of run

; cursor either in middle of the style run or on a boundary
@FoundCursor
			tst.w	teSize(a3)					; <1Dec88smb>
			bpl.s	@DontSet
			jsrROM	ROMSetStyle
@DontSet
			tst.b	WordRedraw					; <4Oct89smb>
			blt.s	@ContainsRLText				; <4Oct89smb>
			tst.b	teSysJust
			bne.s	@ContainsRLText
; in LR text only on a LR directional line: done stepping thru style
			clr.l	d2							; #smLeftCaret set in low word of d2
			jsrROM	ROMGetLRPosition
			add.w	d1,d5						; add C2P width to totalWidth of line thus far (d5)

			add.w	d5,teSelRect+left(a3)		; add width to left and right edges of selRect
			add.w	d5,teSelRect+right(a3)
			bra		@done

@ContainsRLText
			move.w	d2,-(sp)					; save style counter
	IF Scripts604 | SysVers>= $605 THEN
			bsr		ptchGetRLPosition			; local version now <20Nov89smb>
	ELSE
			jsrROM	ROMGetRLPosition
	ENDIF
			move.w	(sp)+,d2					; restore style counter
			tst.b	doneFlag(a6)
			bne.s	@finis
			tst.b	lineEndFlag(a6)
			bne.s	@GetWidth					; must measure rest of style runs on line

; added more robust tests for determining whether need to measure style run or not <8Nov88smb>
			tst.b	scriptDirection(a6)
			bne.s	@ChkRLMeasure				; bra if RL script direction

; in LR script direction <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne		@MeasureLoop				; bra if previous LR run: already measured
			bra.s	@GetWidth					; measure since in cursor run w/ LR direction

@ChkRLMeasure
; in RL script direction <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			beq		@MeasureLoop				; bra if in cursor run: already measured

; cursor's not in this style run, so measure it and save its width for later	OR
; found cursor in it's style run but the script has LR direction so need to measure
@GetWidth
			move.w	d1,-(sp)
		IF hasTextWidthHook THEN				;												<17>
			import	ptchMeasureWholeRun			;												<17>
			jsr		ptchMeasureWholeRun			;												<17>
		ELSE									;												<17>
			jsrROM	ROMMeasureWholeRun
		ENDIF									;												<17>
			add.w	d0,d5
			move.w	(sp)+,d1
			tst.b	WordRedraw					; <4Oct89smb>
			bge.s	@GetNext					; <4Oct89smb>

			SubQ	#1,D2						; dec the style counter
			beq.s	@finis
			bra		@MeasureLoop

@GetNext
			Addq.l	#stStartSize,a0				; get next style
			SubQ	#1,D2						; dec the style counter
			Bne		@Check4Cursor				; must be more than 1 line
			bra.s	@finis

	IF forLocalizability THEN					; Just was added for the patch, the real 
@SetEnds										; code is below <34d-YDS-9/2/91>
; second cursor style run. Must set up the second rectangle for the second cursor
			tst.b	prevStyleFlag(a6)
			bne.s	@InCursorRun				; in cursor script
			move.b	previousScriptDir(a6),d0
			bra.s	@GetScriptDirection
@InCursorRun
			move.b	cursorScriptDir(a6),d0
			
@GetScriptDirection
			bne.s	@RLScript
			
; LR Script <7Nov88smb>
; if in previous style and LR script direction then measure since at end of style run
; otherwise, width is 0 since at beginning of run so, have width to use
			tst.b	prevStyleFlag(a6)
			beq.s	@MeasureRun					; bra to measure if in prevStyle's run
			bra.s	@HaveWidth
			
@RLScript
; if in cursor style and RL script direction then measure since at beginning of style run
; otherwise, width is 0 since at end of run so, have width to use  <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@MeasureRun					; bra to measure if in cursor's run
			bra.s	@HaveWidth
			
@MeasureRun
			move.w	d5,-(sp)					; necessary for two cursors
			import	ptchMeasureWholeRun			;												<17>
			jsr		ptchMeasureWholeRun			;												<17>
			add.w	d0,d5
			bra.s	@HaveWidth
@finis
			tst.b	lineEndFlag(a6)
			beq.w	@done

			move.l		ExpandMem,a0			; <34l-YDS-9/2/91
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)		; if we have one cursor
			beq.w		@done									; skip all the rest

@HaveWidth
; finish setup of 2nd cursor rectangle
			move.l	ExpandMem,a0				; <1Feb89smb>
			lea		ExpandMemRec.emCursor2Rect(a0),a0	; <12July89smb> changed to lea
			addq	#2,a0						; top edge ok
			add.w	selRectL(a6),d5				; add original L. edge
			move.w	d5,(a0)						; left
			sub.w	#1,(a0)+					; cursor posn
			addq	#2,a0						; bottom edge ok
			move.w	d5,(a0)						; right (same as left)
										
												; YS  - added to support a single carret 
												; at styled TE, <34d-YDS-9/2/91>
			clr.l	-(sp)						; make space for function result
			move	#smGenFlags,-(sp)			; put smSysScript verb to get the SMGR general flags
			_GetEnvirons						; now wh have the general flags 
			Move.l	(sp)+, d5					; take return value.
			and.l	#(1<<smfDualCaret),d5		; leave only the right bit
			bne.w	@done						; leave the split carret as is ?

			move.l	ExpandMem,a0				; get the scplit cursor addres into A0
			lea		ExpandMemRec.emCursor2Rect(a0),a0	
			Move.w	top(a0), d5					; some times we get the lower 
			Cmp.w	teSelRect+top(a3), d5		; in selrect & the upper in "ExpandMem"
			bgt.s	@3							; so we would like to sort it out.

			move.l	top(a0),d5							; switch the two rects. keep in mind
			move.l	teSelRect+top(a3),top(a0)			; that the upper one has the width of
			move.l	d5,teSelRect+top(a3)				; zero, while the lower one has the
			move.w	bottom(a0),d5						; witdth of 1, sorry, not my fault,
			move.w	teSelRect+bottom(a3),bottom(a0)		; that's how it is now, and i'm not
			move.w	d5,teSelRect+bottom(a3)				; going to change it.
			move.w	teSelRect+left(a3),teSelRect+right(a3)
			move.w	left(a0),right(a0)
			add.w	#1,right(a0)
			
@3			clr.l	-(sp)						; we will need a place on the stack anyway !
			Tst.b	teCarOn(A3)					; if caret on, we would like to calculate the same caret allways
			bne.s	@1							; carret is going on, calculate a new one <34p-YDS-9/2/91>
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	lastScript(a0),d5 			; push script numberused to highligt (d5) to lastScript
			bra.s	@2
			
@1			move	#smKeyScript,-(sp)			; we will call _GetEnvirons to get the current active (keyboard) script.
			_GetEnvirons						; now we know who the active script
			Move.l	(sp), d5					; take return value (the script number (long !!!)), leave place for return value
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	d5, lastScript(a0)			; push script numberused to highligt (d5) to lastScript

@2			move.w	d5, -(sp)					; push the script (word !!!) for the next call we will need


			move	#smScriptRight,-(sp)		; is that script a right to left script  ?
			_GetScript							; we have smScriptRightflag the stack
			move.l	(sp)+, d0					; do = result
			move.l	ExpandMem,a0				; get the scplit cursor addres into A0
			lea		ExpandMemRec.emCursor2Rect(a0),a0
			cmp.b	TESysJust, d0
			beq.s	@UseTop
@UseBottom
			move.w	teSelRect+top(a3),top(a0)	; strech lower cursor
			move.w	teSelRect+top(a3),teSelRect+bottom(a3)	; make top = bottom in upper cursor
			bra.s	@done
@UseTop	
			move.w	bottom(a0),teSelRect+bottom(a3) ; strech upper cursor
			move.w	bottom(a0),top(a0)			; make top = bottom in lower cursor

	ELSE
@SetEnds	jmpROM	ROM@SetEnds
@finis		jmpROM	ROM@finis
	ENDIF

@done		jmpROM	ROM@done
			endWith

;----------------------------------------------------------------------
;			PROCEDURE ptchGetStylesInOrder
;			<8Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from GetStylesInOrder.
;----------------------------------------------------------------------
ptchGetStylesInOrder
			with	SharedFrame,TEFormatOrder
			bsr		ptchTEGetFormatOrder		; <9Aug89smb>
; get next style in a0 using the results from getFormatOrder
			bsr		ptchGetNextDisplayStyle


; a come-from patch for ChkBounds! YUK! <9Aug89smb>
	IF NOT (Scripts604 | SysVers>= $605) THEN 	; <7Dec89smb>
			cmpROM	ROM@OneStyleTest,(sp)		; Return address in ChkBounds <14Aug89smb>
			beq.s	ptchChkBounds				; <9Aug89smb>
	ENDIF
			cmpROM	BackToDoMeasure,(sp)		; Return address in DoMeasure <9Aug89smb>
			beq.w	ptchDoMeasure
			
;;<14Aug89smb>			jmpROM	EndGetStylesInOrder
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter <14Aug89smb>			
			subq	#1,D2						; dec the style counter <14Aug89smb>
			Rts									; <14Aug89smb>
			endWith

;----------------------------------------------------------------------
;			ptchChkBounds
;			<9Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from ChkBounds. Since
;			this routine is an internal routine to TE, this must be a
;			come-from patch, jumped in from GetStylesInOrder.
;			<7Dec89smb> Fixed problem with setting the boundaries in ChkBounds.
;----------------------------------------------------------------------

ptchChkBounds
	IF Scripts604 | SysVers>= $605 THEN			; <7Dec89smb>
			move.w		(a2),d0					; start of line
			move.w		2(a2),d1				; end of line

; if block begins at start of line, make left a large negative number
; <7Dec89smb>	Tried to fix boundaries for teSysJust conditions
			cmp.w		d0,d3
			bne.s		@TestLineEnd
			tst.w		teSysJust
			bne.s		@FixRightBoundAtStart
			move.w		#UnboundLeft,teSelRect+left(A3)	; assume LR text
			bra.s		@TestLineEnd
@FixRightBoundAtStart
			move.w		#UnboundRight,teSelRect+right(A3)
			
; if block ends at end of line, make right a large positive number
@TestLineEnd
			cmp.w		d1,d4
			bne.s		@EdgesSet
			tst.w		teSysJust
			bne.s		@FixLeftBoundAtEnd
			move.w		#UnboundRight,teSelRect+right(A3)
			bra.s		@EdgesSet
@FixLeftBoundAtEnd
			move.w		#UnboundLeft,teSelRect+left(A3)	; assume LR text
			
@EdgesSet
			Rts
	ELSE
			with	TextFrame,TEFormatOrder

			adda.w	#4, sp						; pop GetStylesInOrder's RA <9Aug89smb>
; added end of GetStylesInOrder code since not returning there <9Aug89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter <9Aug89smb>
			SubQ	#1,D2						; dec the style counter <9Aug89smb>
			beq.s	@OneStyle

			Subq	#1,D2						; dec style count
			move.w	d2,fmtOrderingIndex(a6)		; set to next-to-last style
			move.l	a0,-(sp)					; save style ptr at start

; more than 1 style in mixed directional text, so get the first and next-to-last
; styles using the results from getFormatOrder
			bsr		ptchGetNextDisplayStyle		; <9Aug89smb>
			jmpROM	BackToChkBounds
@OneStyle	jmpROM	ROM@OneStyle
			endWith
	ENDIF
;----------------------------------------------------------------------
;			ptchDoMeasure
;			<9Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from DoMeasure. Since
;			this routine is an internal routine to TE, this must be a
;			come-from patch, jumped in from GetStylesInOrder.
;
;
;			<2/Sep/91 YS> needed to call DoMesure, so had to realy patch all 
;			of it, since the label ptchDoMeasure is realy a patch inside DoMeasure
;			and not the entry point. so the real patch for whole DoMeasure
;			is ptchWholeDoMeasure <34i-YDS-9/2/91> 
;
;----------------------------------------------------------------------

			with	TextFrame,TEFormatOrder		
												; <34i-YDS-9/2/91>
	IF forLocalizability THEN					; here we do a real patch for whole the DoMeasure
ptchWholeDoMeasure								; 
			MoveM.L		D3/D5-D6,-(SP)
			MoveQ		#0,D5					; width accumulator
			Move.W		(A2),D6					; line start
			sf			d3						; not found yet

			Cmp 		D6,D7					; nothing to measure?
			Blo			MeasureDone				; made this unsigned	** <C381/6nov86/MBK> **

			Tst.b		WordRedraw				; reverse order? if <0 then RL script present
			Bge			PlainMeasure			; just do normal roman measure if not
			Tst.W		teSize(A3)				; style record?
			Bpl			LRPlainMeasure			; just do normal L->R measure if not

			sf			useOldMethod(a6)		; flag for getting style runs <28Sept88smb>
			Move.W		(A2),D0					; start of line <12July8smb> moved up here
			Move.W		2(A2),D1				; end of line <12July8smb> moved up here
												; determine if display order is different from 
												; backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			blt.s		RLStyledLine			; RL text in record <17July89smb>
												; moved next 4 lines here to cleanup branching <17July89smb>
			st			useOldMethod(a6)
			jsrROM		ROMGetCurStyle			; get its style	<7Oct88smb>
			jsrROM		ROMGetNumStyles			; # of styles between offsets <7Oct88smb>
			bra.s		MeasureLoop				; <17July89smb>

RLStyledLine
			bsr			ptchGetStylesInOrder	; initialize style run array
												; tests whether any styles to process
			bge.s		MeasureLoop
			bra			MeasureDone
	ENDIF

ptchDoMeasure

			adda.w	#4, sp						; pop GetStylesInOrder's RA <9Aug89smb>
; added end of GetStylesInOrder code since not returning there <9Aug89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter <9Aug89smb>
			SubQ	#1,D2						; dec the style counter <9Aug89smb>
			bge.s	MeasureLoop
			bra		MeasureDone

getStyleNew
; get next style using the results from getFormatOrder
			bsr		ptchGetNextDisplayStyle		; <9Aug89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter
			SubQ	#1,D2						; dec the style counter
			bge.s	MeasureLoop
			bra.w	MeasureDone					; done

@getStyleOld
			st		useOldMethod(a6)
			jsrROM	ROMGetCurStyle				; get its style
			jsrROM	ROMGetNumStyles			; # of styles between offsets

MeasureLoop
; get the style run in d6,d0
			Move.W	startChar(A0),D6		; store actual start of line
			jsrROM	ROMFixFormatEnd			; <6Mar89smb> returns end of style run in d0

; pin d6 (start of the style run) to start of the line

			Cmp.W	(A2),D6						; should not be greater than
			Bhi.S	@D6Pinned2Start				; made this unsigned	** <C381/6nov86/MBK> **
			Move.W	(A2),D6						; the selection start
@D6Pinned2Start

; pin d0 (end of style run) to the end of the line

			Cmp.W	2(A2),D0					; style start
			Bls.S	@D0Pinned2End				; made this unsigned	** <C381/6nov86/MBK> **
			Move.W	2(A2),D0					; line's end
@D0Pinned2End

; now have a valid style run, limited to the line we are on
; this checks for a boundary condition, where d7 is between style runs

			tst.b	d3							; found already?
			bne.w	PlainMeasure				; exit and measure the last one

; if searchpoint not in current style run, then keep measuring

			Cmp.W	D6,D7						; if less than selection start
			Blo.S	@DontExit					; then searchPoint is not in this style
			Beq.S	@CheckDirection				; check for boundary condition
			Cmp.W	D0,D7						; if greater than selection end
			Bhi.S	@DontExit					; then searchPoint is not in this style
			Bne.S	PlainMeasure				; exit & measure (firmly inbetween)

; at this point, on a boundary. Measure & Exit if style direction = TESysJust
@CheckDirection
			jsrROM	ROMGetDirection				; returns script dir in d1
			cmp.b	TESysJust,d1				; TESysJust = 0, -1, so top byte set
			beq.s	PlainMeasure				; exit & measure this last run
			st		d3							; found at least one style run
			bra.s	@GetTheWidth				; already set style, so go for it.

; if searchPoint (d7) on boundary of previous style run and this style run must adjust it to
; be at the end of the style run to get the full measure of the style run. Rather than adjust
; it we force GetWidth to use TextWidth by setting tempVar to true! <27Sept88smb>

@DontExit
			Move.W	D0,-(SP)					; SetStyle destroys this	** <C229/28oct86/MBK> **
			jsrROM	ROMSetStyle					; set the style
			Move.W	(SP)+,D0					; restore length to measure ** <C229/28oct86/MBK> **

@GetTheWidth
			move.l	ExpandMem,a1				; <1Feb89smb>
			st		ExpandMemRec.emMeasureLine(a1)	; full line flag: measure full style run <27Sept88smb>
			move.w	d2,-(sp)					; save style count
	IF Scripts604 | SysVers>= $605 THEN
			bsr		ptchGetWidth				; local version now <14Nov89smb>
	ELSE
			jsrROM	ROMGetWidth					; get string width
	ENDIF
			Add.W	D1,D5						; accumulate width
			move.w	(sp)+,d2					; restore style count
			tst.b	useOldMethod(a6)			; <28Sept88smb>
			beq.s	getStyleNew				; use formatOrder array
			SubQ.L	#stStartSize,A0				; pt to prev style
			Bra.S	MeasureLoop				; keep measuring

	IF forLocalizability THEN					; Fix to support correct mesure for unstyled L->R
LRPlainMeasure									; <34i-YDS-9/2/91> 
			MoveM.l		a0-a1/d0-d2, -(sp)		; text <3.10>
			Move.l		teTextH(A3),A0			; get text handle
			Move.l		(a0),a0					; derefrence it 
			Move.w		teLength(a3), d0
			cmp.w		(a2),d0					; are we at the start of the empty last line ?
			beq.s		@1						; yes !!
			move.w		2(a2), d0				; take next line start to d0
@1			move.w		d7,d1					; offset		
			Tst.W		TESysJust				; check text direction, we want tha max rect !!!	
			bne			@3						; push direction
			move.w		#smRightCaret, d2		; we allways push the oposite direction
			bra.w		@4						; in that way we get tha max mesurement
@3			move.w		#smLeftCaret, d2		; in that way we get tha max mesurement
@4			swap		d2
			clr.w		d2						; slop = 0
			add.w		d6,a0					; point to beginning of current line	<47>
			sub.w		d6,d0					; want length from current line	start	<47>
			sub.w		d6,d1					; want offset on current line			<47>
;Need:
;	textPtr in a0.l, textLen in d0.w, offset in d1.w;
;	d2.l = slop (low word), hilite flag (high word)
			import		ptchTEWidthHook
			jsr			ptchTEWidthHook
			move.w		d1,d5					; mesure result in d5
			MoveM.L		(sp)+,a0-a1/d0-d2
	ENDIF

MeasureDone	
			jmpROM	ROM@MeasureDone
PlainMeasure	
	IF forLocalizability THEN					; <34k-YDS-9/2/91>
			tst.b		WordRedraw				; have L->R script ?
			bge.s		@1						; no, don't allow measure of zero char 
												; strings , do it in the old way
			move.l		ExpandMem,a1			; <1Feb89smb>
			sf			ExpandMemRec.emMeasureLine(a1)	; <27Sept88smb>
			jsrROM		ROMInMeasureIt			; last measurement, skip first test
			Add.W		D0,D5					; final width
			jmpROM		ROM@MeasureDone
	ENDIF
@1			jmpROM		ROM@PlainMeasure

			endWith


;----------------------------------------------------------------------
;			PROCEDURE ptchOnSameLine
;			<9Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from OnSameLine. Must
;			replace this much code since the bug occurs in looping code.
;----------------------------------------------------------------------
ptchOnSameLine
SameLineRegs	reg		d3/d4/d7/a0-a1

			with	SharedFrame,TEFormatOrder
			link	a6,#SharedFrameSz
			movem.l	SameLineRegs,-(sp)
; initialize
			moveq.l	#0,d5						; cleared to accumulate widths of style runs from MeasureWidth and PixelWidths
			moveq.l	#0,d2
			clr.w	totalWidth(a6)
			clr.w	hiliteInbetween(a6)			; set sameStyle and hiliteInbetween to F.
			sf		doneFlag(a6)
			clr.w	foundD4(a6)					; clear D3 and D4 index flag
			clr.l	d4FmtIndex(a6)				; clear D3 and D4 holders
			clr.l	hiliteREndFlag(a6)			; clear left and right end flags

			Move.w	teSelRect+left(A3),selRectL(a6)		; preserve initial L. edge
			Move.w	teSelRect+right(A3),selRectR(a6)	; preserve initial R. edge
			Move.w	selRectL(a6),anchorL(a6)			; initialize L. anchor
			Move.w	selRectR(a6),anchorR(a6)			; initialize R. anchor

; [d3,d4] are on the same line
			tst.w	teSize(a3)
			bpl		@oldStyle					; old style edit record

; get style runs for character offsets
			move.w	d3,d0
			jsrROM	ROMGetCurStyle
			move.l	a0,d3StyleRun(a6)

			jsrROM	ROMFixFormatEnd				; get real end position of run <6Mar89smb>
			cmp.w	d0,d4
			bhi.s	@GetD4Style
			move.l	a0,d4StyleRun(a6)			; in same style run as d3
			bra.s	@GetDisplayOrder
@GetD4Style
			move.w	d4,d0
			jsrROM	ROMGetCurStyle
			move.l	a0,d4StyleRun(a6)
			cmp.w	startChar(a0),d4			; is d4 the start of this run? <29June89smb>
			bne.s	@GetDisplayOrder			; bra if not. the style is correct. <29June89smb>
; Otherwise, want the previous style run since d4 is on a boundary, and it indicates the rightmost
; end of the hilite rectangle. d4StyleRun in this case, should be a pointer to the style run which
; ends w/ d4, not begins w/ d4. GetCurStyle doesn't give us what we need, so fix it! <29June89smb>
			subq.l	#stStartSize,d4StyleRun(a6)

@GetDisplayOrder
			move.l	teStylesH(a3),a0			; oh dopey me! <18Aug89smb> <4.2>
			_HGetState							; oh dopey me! <18Aug89smb> <4.2>
			move.w	d0,-(sp)					; oh dopey me! <18Aug89smb> <4.2>
			_HLock								; oh dopey me! <18Aug89smb> <4.2>
			
			move.w	(a2),d0
			move.w	2(a2),d1
			bsr		ptchTEGetFormatOrder		; <9Aug89smb>
			
			move.w	(sp)+,d0					; oh dopey me! <18Aug89smb> <4.2>
			move.l	teStylesH(a3),a0			; oh dopey me! <18Aug89smb> <4.2>
			_HSetState							; oh dopey me! <18Aug89smb> <4.2>
			
; get the format order indexes for the character offsets (could be the same)
@Loop4Indexes
			bsr		ptchGetNextDisplayStyle		; <9Aug89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr the format ordering array counter
			SubQ	#1,D2						; dec the style counter

; is this the same style run as one of the character offsets?
			cmpa.l	d3StyleRun(a6),a0
			bne.s	@testD4
			move.w	styleRunIndex(a6),d3FmtIndex(a6)
			tst.b	foundD4(a6)
			bne.s	@MeasureNow					; have both offsets' indeces in the fmt array
			st		foundD3(a6)
@testD4
			cmpa.l	d4StyleRun(a6),a0
			bne.s	@Loop4Indexes
			move.w	styleRunIndex(a6),d4FmtIndex(a6)
			tst.b	foundD3(a6)
			bne.s	@MeasureNow					; have both offsets' indeces in the fmt array
			st		foundD4(a6)
			bra.s	@Loop4Indexes

; measure by style runs and highlight where appropriate based on character offsets
; and display ordering of format runs!
@MeasureNow
			move.w	numberOfRuns(a6),d2
			clr.w	fmtOrderingIndex(a6)

; test if [d3,d4] in same style run
			move.w	d3FmtIndex(a6),d0
			cmp.w	d4FmtIndex(a6),d0
			bne.s	@MeasureLoop
			st		sameStyle(a6)

@MeasureLoop
			Bsr		ptchGetNextDisplayStyle		; <9Aug89smb>
			jsrROM	ROMMeasureWidth				; using vector to access ptchMeasureWidth
			tst.b	doneFlag(a6)
			bne.s	@hiliteMore
			addq	#1,fmtOrderingIndex(a6)		; incr the format ordering array counter
			tst.b	WordRedraw					; <4Oct89smb>
			bge.s	@GetNext					; <4Oct89smb>
			SubQ	#1,D2						; dec the style counter
			beq.s	@hiliteMore
			bra.s	@MeasureLoop

@GetNext
			Addq.l	#stStartSize,a0				; get next style
			SubQ	#1,D2						; dec the style counter
			bne.s	@MeasureLoop				; must be more than 1 line
			bra.s	@hiliteMore
;----------------------------------------------------------------------
	IF Scripts604 | SysVers>= $605 THEN			; <7Dec89smb>
			import	ptchHiliteMiddle
@oldStyle
; old-style record: one style for the whole record.  My code is expecting a0 to contain a ptr to 
; the startChar for the current style so must fake the setup.
			clr.l	firstStyleRun(a6)
			clr.w	secondStyleRun(a6)
			move.w	teLength(a3),secondStyleRun(a6)
			lea		firstStyleRun(a6),a0
			jsrROM	ROMteHiliteText
			
@hiliteMore
; test if there's more to hilite: either more style runs or line ends
						
			tst.b	hiliteInbetween(a6)
			beq.s	@testEnds
			jsr		ptchHiliteMiddle		; hilite any remaining runs inbetween offsets
			sf		hiliteInbetween(a6)
@testEnds
			jmpROM	ROM@testEnds
;----------------------------------------------------------------------
	ELSE
@oldStyle	jmpROM	ROMOldStyle
@hiliteMore	jmpROM	ROMHiliteMore
	ENDIF
			endWith

;----------------------------------------------------------------------
;			PROCEDURE ptchTestRunDirection
;			<9Aug89smb>	 I need to patch a bug in the routine
;			GetNextDisplayStyle, which is called from TestRunDirection.
;----------------------------------------------------------------------
ptchTestRunDirection
; ***** d(r) = ld? *****
			movem.w	d1/d2,-(sp)
			move.w	d1,fmtOrderingIndex(a6)		; d1 = r
			bsr		ptchGetNextDisplayStyle		; r is index into FmtOrderingArray
			jmpROM	BackToTestRunDirection

;----------------------------------------------------------------------
;			PROCEDURE ptchTEKey
;			<10Aug89smb>	 Striking an up/down arrow key after a hitdown at
;			either line end caused the caret to display at the opposite end
;			of the line rather than the previous line.  This bug occurred 
;			because teKey was inappropriately setting teLftCaret to T.  
;			It should only be set initially if the key was not a cursor key.
;			<28Sept89smb>	Added text buffering.
;			<16Nov89smb> Must patch to clear the emBufferLen after the paste 
;			rather than the emBufferPtr.
;			<26Nov89smb> Need to use the high caret rectangle in TEKey rather
;			than always using the teSelRect!
;			<1/9/90smb> Now using TEDispatchRec for storage instead of ExpandMem.
;			<1/25/90smb> Fixed up arrow bug that caused the caret to move up multiple 
;			lines according to the size of the largest font on the current line.
;			<2/28/90smb> Added call to SetKeyboard2Font when backspacing to set the
;			keyscript correctly at a script boundary.
;----------------------------------------------------------------------
ptchTEKey

	IF Scripts604 | SysVers>= $605 THEN
; turn off textBuffering bit before calling StdEntry since want to process below <28Sept89smb>
			move.l		4(sp),a1				; teHandle (before the return address)
			move.l		(a1),a1					; need the ptr to the teRec
			move.l		teDispatchH(a1),a1
			move.l		(a1),a1
			move.l		newTEFlags(a1),-(sp)
			move.l		#0,newTEFlags(a1)
			bsr			ptchTEKeyStdEntry		; <28Sept89smb>
; reset textBuffering bit <28Sept89smb>
			move.l		teDispatchH(a3),a1
			move.l		(a1),a1
			move.l		(sp)+,newTEFlags(a1)
					
			_ObscureCursor						; nice knowing you cursor

			Move.W		(A2),D1 				; store char away
			move.b		d1,d0					; get char for comparison
			MoveQ		#1,D2					; assume going down

; Cursor Key support - Added from 'Lonely Hearts' patch 14Jan86
; left: If selStart isn't 0 it decrements it and places the caret there
; right:		Increments selEnd and places caret there
; up:	simulates a click one line above current selStart point
; down: simulates a click one line below current selStart point

	IF 0 THEN									; bye bye for now										<32>
	IF SysVers>= $700 THEN
			cmp.b		#forwardDeleteChar,d0	; is this the extended keyboard function key?			<19>
			bne.s		@CursorKeys				;														<19>
			
			st			teLftCaret(A3)			; jam caret to left cause its nota cursor key			<19>
; be sure d6 is not used in any subroutines called from here!!!!
			st			d6						; tell backspace that we are going forward				<19>
			bra			backspace				; do common backspace code								<19>
@CursorKeys
	ENDIF
	ENDIF										; 														<32>
			subi.b		#downArrowChar,d0
			Beq.S		downArrow
			bhi.s		normalChar				; optimize normal characters
			
			subi.b		#upArrowChar-downArrowChar,d0
			Beq.S		upArrow

			subi.b		#rightArrowChar-upArrowChar,d0
			Beq			rightArrow
			subi.b		#leftArrowChar-rightArrowChar,d0
			Beq			leftArrow

			st			teLftCaret(A3)			; jam caret to left, UNLESS a cursor key <7Aug89smb>
	IF 0 THEN									; bye bye for now										<32>
	IF SysVers>= $700 THEN
; be sure d6 is not used in any subroutines called from here!!!!
			sf			d6						; tell backspace that we are going backward 			<19>
	ENDIF
	ENDIF										; bye bye for now										<32>
			subi.b		#backspaceChar-leftArrowChar,d0
			Beq			backSpace

normalChar			
; test if want text buffering <12June89smb>			
			st			teLftCaret(a3)			; jam caret to left, UNLESS a cursor key <7Aug89smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0
			btst		#teFTextBuffering,d0
			beq			PasteChar				; little mod <15June89smb>
			
			bsr			ptchTEBufferText
			bra			Epilog6

upArrow
;; subtract 2 rather than 1 <1/25/90smb>			MoveQ		#-1,D2					; going up
			MoveQ		#-2,D2					; going up
downArrow
			move		d2,-(SP)				; save D2
			
; dump text buffer before processing cursor key <14Sept89smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops <15Sept89smb>
			btst		#teFTextBuffering,d0	; <15Sept89smb>
			beq.s		@noBuffer
			bsr			ptchDumpBuffer			; dump text from buffer
@noBuffer	
; Call HideCaret to fix problems with old and new teLftClick <1/25/90smb>
			jsrROM		ROMHideCaret			; erase old caret <1/25/90smb>
			move		teSelStart(a3),d3		; pass selStart=selEnd
			move		d3,d4
			moveq		#teCaret,d7				; position pen to caret <03July89smb> 
	IF SysVers < $700 THEN						;											<25>
			bsr 		ptchTEDoText			; the port ret. in A0
	ELSE										;											<25>
			jsrROM		ROMDoText				; use the low mem TEDoText hook!!			<25>
	ENDIF
			move		(sp)+,d2				; restore D2

;-------------------------------------------------------------------------------------
; In order to go down from a line end position to a line whose line height is less than the current
; line height, must back up one position to get the hite for the correct line (when FindLineHite
; calls GetLine and the current position is at the end of a line, it thinks it's at the 
; beginning of the next line so the wrong height is returned. <1/30/90smb>
			movem.l		a2/d3,-(sp)
			tst.b		teLftCaret(a3)
			bne.s		@OffsetOK
			move.w		d3,d0					; offset
			beq.s		@OffsetOK
			lea			teLines(a3),a2
			jsrROM		ROMGetLine				; get line that d3 is on
			cmp.w		(a2),d3					; cmp offset position to line start found
			bne.s		@OffsetOK
			subq.w		#1,d3					; backup to get correct line in FindLineHite
@OffsetOK
			jsrROM		ROMFindLineHite			; get current line hite in d1	** MBK 6/18/86 **
			movem.l		(sp)+,a2/d3
; end of changes <1/30/90smb>
;-------------------------------------------------------------------------------------

;; <1/25/90smb>			muls		d1,d2					; get delta -- a SIGNED 16-bit value<09Dec85 JTC>
; if we are going down (d2 = 1), then add linehite (d1) <1/25/90smb>
; if we are going up (d2 = -2), then subtract 2, just enough to get into the previous line's Rect <1/25/90smb>
			tst.w		d2						; up or down <1/25/90smb>
			blt.s		@DeltaOk				; up = -1 <1/25/90smb>
			move.w		d1,d2					; move in delta <1/25/90smb>
@DeltaOk

; assume whole caret or high caret in teSelRect <26Nov89smb>
			move.l		teSelRect(a3),teSelPoint(a3)	; pass caret point
;-------------------------------------------------------------------------------------
; set teSelPoint(a3) from the high caret position! <26Nov89smb>
			move.l		ExpandMem,a0			; <26Nov89smb>
			cmpi.w		#$FFFF,ExpandMemRec.emTwoCursorsFlag(a0)		; <26Nov89smb>
			bne.s		@UseSelRect				; bra if high caret loc in teSelRect <26Nov89smb>

; use rect stored in emCursor2Rect: this is the high caret location. <26Nov89smb>
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; <26Nov89smb>
			move.l		(a0),teSelPoint(a3)		; pass high caret point <26Nov89smb>
@UseSelRect
;-------------------------------------------------------------------------------------

			add 		d2,teSelPoint(A3)		; adjust v value
		IF SysVers>= $700 THEN					;												<19>
			import		ptchDoFind				;												<19>
			jsr			ptchDoFind				; you guessed it: it's patched now!				<19>
		ELSE
			jsrROM 		ROMDoFind				; the port ret. in A0
		ENDIF									;												<19>

			move.b		teLftClick(a3),teLftCaret(a3)	; <10Aug89smb>
			bra.w		leftRight				; setselect'll force autoscroll

rightArrow
			move		teSelEnd(A3),d6 		; get start
			moveq		#1,d3					; if 2byte char, incr posn <27June88smb>
			bra.s		HorizArrows				; <6Mar89smb>
leftArrow
			move		teSelStart(A3),d6		; get start
			beq.s		HorizArrows				; <13Mar89smb> special case at 0th position
			moveq		#-1,d3					; if 2byte char, decr posn <27June88smb>
HorizArrows

; dump text buffer before processing cursor key <14Sept89smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops <15Sept89smb>
			btst		#teFTextBuffering,d0	; <15Sept89smb>
			beq.s		@noBuffer
			bsr			ptchDumpBuffer			; dump text from buffer
@noBuffer	

			tst.b		WordRedraw				; <9Jan89smb>
			blt.s		@RLText					; <22June89smb> includes RL directional text
			tst.b		teSysJust				; <22June89smb>
			beq.s		@LRLineDir				; <22June89smb> LR text on a LR line
@RLText
; may be RL text on any directioned line OR LR text on a RL line
			bsr			ptchCursorMovement		; <9Jan89smb>

												; <34i-YDS-9/2/91>> supports the single carret corect display
	IF forLocalizability THEN					; when on cluster boundry, syncronize allways to the
												; style with the that his just = teSysJust
			tst.b		WordRedraw				; have L->R script ?
			bge.s		leftRight				; no, do the old way
			tst.w		teSize(a3)				; if unstyled ?
			bpl.s		leftRight				; do the old way for unstyled
			move.w		d6,d0					; GetCurStyle needs offset in d0
			jsrROM		ROMGetCurStyle			; get the current style
			cmp.w		startChar(a0),d6		; are we on a boundry ?
			bne.s		leftRight				; if not do it the old way	
			move.l		a0,-(sp)				; keep a0 (the style) from being trashed
			jsrROM		ROMHideCaret			; hide caret
			jsrROM		ROMHiLite				; unhilite
			Move		d6,teSelEnd(A3) 		; set set start
			Move		d6,teSelStart(A3)		; set sel end
			move.l		(sp)+,a0				; restore style ptr (in a0)
			jsrROM		ROMGetDirection			; get style direction
			cmp.b 		TESysJust,d1			; same as TESysJust ? 
			beq			@setStyle				; yes ! set the style for it.
			move.w		d6,d0					; no ! get the prev style, put offset into d0
			sub.w		#1,d0					; be in prev
			jsrROM		ROMGetCurStyle			; get this style
@setStyle	
			jsrROM		ROMSetStyle				; set the font/style in the grafport
			move.w		d6,d0					; char offset in d0 needed by SetKeyboard2Font
			import		ptchSetKeyboard2Font
			jsr			ptchSetKeyboard2Font	; sync keyboard to font

			jsrROM		ROMHiLite				; Hilite
			jsrROM		ROMSelView 				; insure selection is visible
			jsrROM 		ROMShowCaret			; force caret ON

			bra			epilog6
	ELSE
			bra.s		leftRight				; <9Jan89smb>
	ENDIF

@LRLineDir
			jsrROM		ROMDoubleByte			; middle of char? Fix starting point <27June88smb>
leftRight
			Ext.L		D6						; D6 comes back char loc
			Move.L		D6,-(SP)				; pass start
			Move.L		D6,-(SP)
			Move.L		A4,-(SP)
			_TESetSelect

			jsrROM 		ROMDrawCaret			; force caret ON
	IF 0 THEN									; bye bye for now								<32>
			Bra			epilog6					;												<32>
	ELSE										; 												<32>
			Bra.w		epilog6
	ENDIF										; 												<32>
			
PasteChar
; Go paste the character
			Move.L		A2,D6					; point to the character
			AddQ		#1,D6					; character in lower half
			MoveQ		#1,D5					; one long
			Bsr			ptchBufferChar			; buffer if 2 byte character <27June88smb>
	IF 0 THEN									; bye bye for now								<32>
			blt			epilog6					; the result isn't unsigned! <31Aug89smb>		<32>
	ELSE										; 												<32>
			blt.w		epilog6					; the result isn't unsigned! <31Aug89smb>
	ENDIF										; 												<32>

; Must patch to clear the emBufferLen after the paste rather than the emBufferPtr. <16Nov89smb>
			moveq		#0,D7					; want to call ExtendStyle
			jsrROM 		ROMPasteGuts
			move.l		teDispatchH(a3),a0		; <1/9/90smb> finished w/ character so empty storage
			move.l		(a0),a0
	IF forLocalizability THEN					; <34b-YDS-9/2/91>
			move.w		#0,TwoByteCharBuffer(a0)
	ELSE
			move.l		#0,TwoByteCharBuffer(a0)
	ENDIF
			bra.w		epilog6

backSpace
; dump text buffer before backspacing <14Sept89smb>
			Move.L		teDispatchH(A3),A0
			Move.L		(A0),A0
			move.l		newTEFlags(a0),d0	
			btst		#teFTextBuffering,d0
			beq.s		@noBuffer
			bsr			ptchDumpBuffer			; dump text from buffer
@noBuffer
;;replaced with following backspace code. <2/28/90smb>			jmpROM		ROMbackspace
			move		teSelStart(a3),d0		; see if null selection
			cmp 		teSelEnd(a3),d0
			bne.s		cutit

;------------------------
	IF 0 THEN									; bye bye for now									<32>
	IF SysVers>= $700 THEN
; add support for the forward delete key												<7jan91 fjs><19>
			tst.b		d6						; is this forward delete ?							<19>
			beq.s		@normalBS				; if 0 do normal backspace work						<19>

; since there is no selection, eat characters to the right
; first, check if we are at the extreme right already
			cmp.w		teLength(a3),d0			; at extreme right of text?  (really, the end… think R-L)<19>
			bge.s		epilog6					; yes, skip this									<19>
			jsrROM 		ROMHideCaret			; remove the caret									<19>

; check for double-byte characters and fix starting point
			move.w		teSelEnd(a3),d6			; current position									<19>
			moveq		#1,d3					; direction to move									<19>
			jsrROM		ROMDoubleByte			; middle of char? Fix starting point.				<19>
			move.w		d6,teSelEnd(a3)			; adjust selection									<19>
			bra.s		cutit					; fall into the cut case				<7jan91 fjs><19>
@normalBS
	ENDIF
	ENDIF										; 													<32>
;------------------------

; since there's no selection eat characters to the left.
			tst 		d0						; see if at extreme left (really, the beginning… think R-L)
			beq.w		epilog6 				; skip if so

			jsrROM 		ROMHideCaret			; remove the caret

; check for double-byte characters and fix starting point. <27June88smb>

			move.w		teSelStart(a3),d6		; current position <27June88smb>
			moveq		#-1,d3					; direction to move <27June88smb>
			jsrROM		ROMDoubleByte			; middle of char? Fix starting point <27June88smb>
			move.w		d6,teSelStart(a3)		; adjust selection

cutit
; Need to synchronize keyboard to the font <2/28/90smb>; moved here from DelGuts.
; This must be done before the call to TEDelete in order to synchronize the kbd to
; the style that corresponds to the current selStart.
			tst.w		teSize(a3)				; if unstyled, can't synch keyboard to font  <2/28/90smb>
	IF forLocalizability THEN					; even if we dont have all info <34m-YDS-9/2/91>
			bpl.s		@syncUnStyled			; sync for unstyled
	ELSE
			bpl.s		@JustCut				; <2/28/90smb>
	ENDIF
			move.w		teSelStart(a3),d0		; get new offset position <2/28/90smb>
			jsrROM		ROMGetCurStyle			; <2/28/90smb>
			jsrROM		ROMSetStyle				; <2/28/90smb>
			import		ptchSetKeyboard2Font
			jsr			ptchSetKeyboard2Font	; synch keyboard to font <2/28/90smb>


	IF forLocalizability THEN					; synch for unstyled too <34m-YDS-9/2/91>
			bra			@JustCut				; go to the cut if didn't come with a bpl.s
@syncUnStyled
	IF 0 THEN									; now using 'itlb' flag	in CubeE						<46>
;;			tst.b		WordRedraw				; is it a R->L script ?									<37>
;;			bge.w		@JustCut				; don't synch.											<37>
; Really want to synchronize for unstyled text in ALL scripts. However, this will cause problems for 	<37>
; input methods, so we will skip this code in this case. (WordRedraw only indicates the 				<37>
; types of scripts installed and not the current one…)													<37>
			subq		#2,sp					; result space for Font2Script & GetScript				<37>
			move.w		teFont(a3),-(sp)		; app font id											<37>
			_Font2Script						; it's a non-roman char so get script font				<37>
			move.w		(sp)+,d0				;														<37>
			beq			@UseFont				; if Roman then always synchronize						<37>
			cmp.w		#smEastEurRoman,d0		; Extended Roman?										<40>
			beq			@JustCut				; If so, never synchronize								<40>
			subq		#4,sp					; result space											<37>
			move.w		d0,-(sp)				; script												<37>
			move.w		#smScriptRedraw,-(sp)	;														<37>
			_GetScript							;														<37>
			move.l		(sp)+,d1				;														<37><39>
			tst.b		d1						; leave in d1 for later									<37><39>
			bgt			@JustCut				; if double-byte script	don't synchronize				<37>
			; otherwise, we have a single-byte non-Roman font											<37>
;	IF SysVers > $610 THEN		
;			move.l		teDispatchH(a3),a0		; 
;			move.l		(a0),a0
;			move.l		newTEFlags(a0),d0		; move into reg the flags
;			btst		#teFInlineInput,d0		; are we in an inline input window ?
;			bne.w		@JustCut				; yes, don't synch keyboard.
;	ENDIF		

	ELSE										; now using 'itlb' flag	in CubeE						<46>

			; optimize for Roman-only: do not have to synch font & kbd									<51>
			with		smgrRecord				;														<51>
			GetSMgrCore a0						; load SMgr globals pointer.							<51>
			cmp.b		#1,smgrEnabled(a0)		; how many scripts enabled?								<51>
			beq			@JustCut				; skip synchronization for Roman-only system			<51>
			endwith								;														<51>

			subq		#6,sp					; result space for Font2Script & GetScript				<46>
			move.w		teFont(a3),-(sp)		; app font id											<46>
			_Font2Script						; get script font										<46>
			; script left on stack				;														<46>
			move.w		#smScriptFlags,-(sp)	; now get script-specific flags							<46>
			_GetScript							;														<46>
			move.l		(sp)+,d0				;														<46>
			and.l		#(1<<smsfSynchUnstyledTE),d0	; leave only the synchronize bit				<46>
			beq.s		@JustCut				; 0=> do not synchronize								<46>
			; otherwise synchronize
	ENDIF										; now using 'itlb' flag	in CubeE						<46>


			Move.w		teSelStart(a3), d6		; <33-YDS-10/1/91> d6 was set only for a one char delete, not for a selection delete
; Check char to determine how to synch
			move.l		teTextH(a3),a2			; handle to text										<39>
			move.l		(a2),a0					; ptr to text											<39>
			move.b		0(a0,d6.w),d0			; get character											<39>
			cmp.b		#$20,d0					; control char?											<39>
			blo.s		@JustCut				; if so, don't synch									<39>
			move.b		d1,-(sp)				; save scriptRedraw										<39>
			subq		#2,sp					; room for return
			move.l		a0,-(sp)				; push text ptr on stack								<39>
			move.w		d6,-(sp)				; offset on stack
			_CharType							; what char is it
			move.w		(sp)+,d0				; take result
			move.b		(sp)+,d1				; recover scriptRedraw									<39>

; Mask off what interested in: the Type ($000F) and the Direction ($2000)								<37>
; Want a char whose Direction is LR (smCharLeft, $0000) and whose Type is Roman							<37>
; which can be smCharAscii (1) or smCharEuro (7) or smCharPunct (0).									<37>
;
; New approach. Different behavior for bidi and non-bidi scripts, because of caret						<39>
; requirements for bidi scripts.																		<39>
			bne.s		@doBidi					; check scriptRedraw for bidi							<39>
; For non-bidirectional scripts, set keyboard to Roman for Roman letters,								<39>
; sync to font for script letters, dont sync for anything else.											<39>
			and.w		#smcTypeMask,d0			; isolate info we need									<39>
			cmp.w		#smCharPunct,d0			; non-letter?											<39>
			beq.s		@JustCut				; if so, don't synch keyboard							<39>
			cmp.w		#smCharAscii,d0			; low-ASCII Roman?										<39>
			beq.s		@isRoman				; if so, go set keyboard								<39>
			cmp.w		#smCharEuro,d0			; Extended ASCII Roman?									<39>
			beq.s		@isRoman				; if so, go set keyboard								<39>
			bra.s		@UseFont				; otherwise, sync keyboard to font						<39>
; For bidirectional scripts, don't synch control chars (stripped out above) or low-ASCII				<39>
; (L-R) digits; synch other L-R chars to Roman, and everything else to font script.						<39>
@doBidi											;														<39>
			and.w		#smcTypeMask+smcClassMask+smcRightMask,d0	; isolate info we need				<39>
			cmp.w		#smCharPunct+smPunctNumber+smCharLeft,d0	; is char a low-ASCII digit?		<39>
			beq.s		@JustCut				; if so, don't synch									<39>
			and.w		#smcRightMask,d0		; now just check direction								<39>
			beq.s		@isRoman				; if left-right, sync to Roman							<39>

; Otherwise, synch the font to the script of the character												<37>
@UseFont
			subq		#2,sp					; room for return
			move.w		teFont(a3),-(sp)		; app font id
			_Font2script						; it's a non-roman char so get app font
			; leave script on stack
			bra.s		@SetKbd

@isRoman	move.w		#smRoman,-(sp)			; we think it is roman
@SetKbd
			move.w		(sp), d0				; script param on the stack 
			move.l		teDispatchH(a3),a0		; get teDispatchH addres 
			move.l		(a0),a0					;
			move.b		d0, lastScript(a0)		; push script numberused to highligt (d0) to lastScript
			_KeyScript							; set keyboard
	ENDIF

@JustCut
			move.l		a4,-(sp)				; pass the handle
			_TEDelete							; and cut it (A3 no good after)

epilog6		moveq		#6,d0
			jmpROM		ROMStdExit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	ELSE										; IF NOT (Scripts604 | SysVers>= $605)
			jsrROM	ROMStdEntry
			_ObscureCursor						; nice knowing you cursor

			Move.W	(A2),D1 					; store char away
			Cmp.B	#backspaceChar,D1 			; is it a backspace?
			Beq		@backSpace

; Cursor Key support - Added from 'Lonely Hearts' patch 14Jan86
; left: If selStart isn't 0 it decrements it and places the caret there
; right:		Increments selEnd and places caret there
; up:	simulates a click one line above current selStart point
; down: simulates a click one line below current selStart point
;
			MoveQ	#1,D2					; assume going down

			MoveQ	#$1F,D0 				; range $1C-$1F
			Sub.B	D1,D0					; get key code
			Blt.S	@NormalChar

			Beq.S	@downArrow				; is it a cursor key?
			SubQ.B	#1,D0
			Beq.S	@upArrow
			SubQ.B	#1,D0
			Beq.S	@rightArrow
			SubQ.B	#1,D0
			Beq.S	@leftArrow
			bra.s	@NormalChar
			
@upArrow
			MoveQ	#-1,D2					; going up
@downArrow
			Move	D2,-(SP)				; save D2

			Move	teSelStart(A3),D3		; pass selStart=selEnd
			Move	D3,D4
			MoveQ	#teCaret,D7				; position pen to caret 
	IF SysVers < $700 THEN					;											<25>
			bsr 	ptchTEDoText			; the port ret. in A0 <9Aug89smb>
	ELSE									;											<25>
			; not really necessary since this is for 6.0.4 but, for futures…
			jsrROM	ROMDoText				; use the low mem TEDoText hook!!			<25>
	ENDIF

			Move	(SP)+,D2				; restore D2

			jsrROM	ROMFindLineHite			; get current line hite

			MulS	D1,D2					; get delta -- a SIGNED 16-bit value<09Dec85 JTC>
			Move.L	teSelRect(A3),teSelPoint(A3)	; pass caret point
			Add 	D2,teSelPoint(A3)		; adjust v value
			jsrROM 	ROMDoFind				; the port ret. in A0
			move.b	teLftClick(a3),teLftCaret(a3)	; <10Aug89smb>

			jmpROM	ROMleftRight			; setselect'll force autoscroll
@backSpace
			st		teLftCaret(A3)			; jam caret to left
			jmpROM	ROMbackspace
			
@rightArrow	jmpROM	ROM@RightArrow			; <14Aug89smb>
@leftArrow	jmpROM	ROM@LeftArrow			; <14Aug89smb>

@NormalChar
			st		teLftCaret(A3)			; jam caret to left
			jmpROM	ROM@NormalChar

	ENDIF
;----------------------------------------------------------------------
;			PROCEDURE ptchTEDelete( h: TEHandle );
;			Patching bug at end of DelGuts, which is only called by
;			TEDelete.
;----------------------------------------------------------------------
ptchTEDelete

	IF Scripts604 | SysVers>= $605 THEN
			bsr			ptchStdEntry			; <28Sept89smb>
	ELSE
			jsrROM		ROMStdEntry
	ENDIF
			jsrROM		ROMHideCaret
; fall into ptchDelGuts
;----------------------------------------------------------------------
;			PROCEDURE ptchDelGuts
;			<21July89smb>	Added ConcatStyles to DelGuts - when it deletes
;			a style it doesn't check to see if the two adjacent styles are
;			the same.
;			<1/17/90smb>	Adding call to SetKeyboard2Font to set the
;			keyscript correct when crossing a script boundary.
;			<2/28/90smb>	Removing 1/17/90 fix to call SetKeyboard2Font.
;----------------------------------------------------------------------

			jsrROM		ROMSelSort				; sort selection
			Move		D0,D7					; calc delta amount(selEnd in D0)
			Sub 		(A2),D7 				; ...for ReCalLines (A2 ^selStart)
			Beq			outGuts 				; skip if null selection

; ** <C971/RWW102987>	Inserted test to change the way backspacing/deleting works.
; If you backspace to the beginning of a style, that style is saved to the null scrap.
; This allows you to type a selection, backspace over it, and retype without
; TextEdit reverting to the previous style.
			Tst.W		teSize(A3)				; is this a styled record?			<C971/RWW102987>
			Bpl.S		@1						; oops, never mind					<C971/RWW102987>

			MoveM.L		D0/D7/A2,-(SP)			; we need D0 and A2 temporarily		<C971/RWW102987>
			Move.W		teSelStart(A3),D0		; find start of block to be yanked	<C971/RWW102987>
			jsrROM		ROMGetCurStyle			; find the associated style run
			Move.W		teSelStart(A3),D0		; get start of block again			<C971/RWW102987>
			Cmp.W		startChar(A0),D0		; is it the beginning of a style?	<C971/RWW102987>
			Beq.S		@2						; yes, so continue					<C971/RWW102987>

			jsrROM		ROMClearRsrved			; no null selection!
			Bra.S		@3						;									<C971/RWW102987>

@2			Move.W		styleIndex(A0),D0		; fetch index into style table		<C971/RWW102987>
			jsrROM		ROMGetStyle				; find associated style table entry
			Move.W		#doAll,-(SP)			; build fake frame for SetRsrved	<C971/RWW102987>
			Pea			stFont(A0)				; point at embedded textstyle		<C971/RWW102987>
			Clr.B		-(SP)					; need another word, can't hurt		<C971/RWW102987>
			Move.L		SP,A2					; point A2 at stacked parameters	<C971/RWW102987>
			jsrROM		ROMAltSetRsrved			; set null scrap style
			AddQ.W		#8,SP					; fix up stack						<C971/RWW102987>

@3			MoveM.L		(SP)+,D0/D7/A2			; retrieve saved registers			<C971/RWW102987>
@1												;									<C971/RWW102987>

			Move.W		D0,D1					; selEnd				** MBK 6/18/86 **
			Swap		D0						; selStart				** MBK 6/18/86 **
			jsrROM		ROMDeleteStyle			; del associated styles

			jsrROM		ROMMungeSetup			; set up params for delete

			Move		D7,-(SP)				; length for delete
			Clr 		-(SP)					; fake long length
			Clr.L		-(SP)					; fake p2
			Clr.L		-(SP)					; fake l2
			_Munger 							; sloppy munger
			AddQ.L		#4,SP					; pop result

			Move.L		teTextH(A3),A0			; RecalDraw expects text to be locked
			_Hlock								; and relock it

			Sub 		D7,teLength(A3) 		; length:=length -(selEnd-selStart)
			Move		(A2)+,(A2)				; selEnd:=selStart
			tst.w		teSize(A3)				; is this a styled record? <24July89smb>
			bpl.S		outGuts					; if so, no need to concat - only 1 run <24July8smb>
			jsrROM		ROMConcatStyles			; <21July89smb>
			jsrROM		ROMConcatRuns			; <25June89smb>
outGuts
			jmpROM		EndDelGuts
	
	IF Scripts604 | SysVers>= $605 THEN
;----------------------------------------------------------------------
;			PROCEDURE ptchTEActivate
;			<28Sept89smb> Added outline highlighting.
;			<3Oct89smb>	Fixed caret display for outline highlighting.
;----------------------------------------------------------------------
ptchTEActivate
			with	OutlineFrame
			bsr		ptchStdEntry
			link	a6,#OutlineFrameSz		; only link if outlining

			tst.b	teActive(A3)			; see if already active
			bne		goGoHome
; fix the selection when inactive
			bsr		InitOutline

			move	teSelStart(A3),D0		; Only enable the caret
			cmp 	teSelEnd(A3),D0
			bne.s	@notSelPt
			
			st		teCarAct(a3)			; activate caret
; hide the caret when outline highlight on <2Oct89smb>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq.s	@notSelPt				; no outlining desired
			jsrROM	ROMDrawIt				; hide the caret
@notSelPt
			st		teActive(A3)			; flag as active

			jsrROM 	ROMHiLite
			bra.s	DoneActivate			; rejoin flow of control

;----------------------------------------------------------------------
;			PROCEDURE ptchTEDeactivate
;			<28Sept89smb> Added outline highlighting.
;			<3Oct89smb>	Fixed caret display for outline highlighting.
;----------------------------------------------------------------------
ptchTEDeactivate
			with	OutlineFrame
			bsr		ptchStdEntry
			link	a6,#OutlineFrameSz		; only link if outlining

			tst.b	teActive(A3)			; see if already inactive
			beq.s	goGoHome

			move	teSelStart(a3),d0		; is this a selection point?
			cmp 	teSelEnd(a3),d0
			bne.s	@drawRegion				; fall through for caret processing

; is outlining desired?
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq.s	@drawRegion				; outline bit not on
; if caret on invert it
			tst.b	teCarOn(a3)
			beq.s	@noDraw
			jsrROM	ROMDrawIt			
@noDraw
; turn on flag in case off - want to display an outlined caret
			st		teCarOn(a3)				; will be turned off in HideCaret
@drawRegion

			bsr.s	InitOutline
			jsrROM	ROMHideCaret			; hide the caret
			jsrROM 	ROMHiLite				; Remove old selection
			sf		teActive(A3)			; flag as inactive
			; drop through to common exit
;-----------------------------------------

DoneActivate
			bsr.s	TEOutlineHilite			; outline hilite now
goGoHome
			unlk	a6
			jmpROM	ROMEpilog4
			
;----------------------------------------------------------------------
;			PROCEDURE InitOutline
;			<28Sept89smb>
; 			Test for outline highlighting after setting up teRec.
;			<3Oct89smb>	Cleaned up code a bit!
;----------------------------------------------------------------------
InitOutline
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq.s	@RegHilite

			_OpenRgn
			move.l	teHiHook(a3),oldHighHook(a6)	; save
			move.l	teCarHook(a3),oldCaretHook(a6)	; save
			lea		FrameHook,a0					; just frame it
			move.l	a0,teHiHook(a3)					; stuff it!
			move.l	a0,teCarHook(a3)				; stuff it!
			st		paintFlag(a6)					; init to always paint region <16Oct89smb>
@RegHilite	
			rts
;-----------------------------------------
FrameHook
			_FrameRect
			Rts
;----------------------------------------------------------------------
;			PROCEDURE TEOutlineHilite
;			<28Sept89smb>
;----------------------------------------------------------------------
TEOutlineHilite			
			
			with	OutlineFrame
; do we need anything fancy
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq		@DoneTEOutlineHilite	; don't do fancy stuff!
			
; now do the outlining <20Sept89smb>
			move.l	a4,-(sp)				; save TE handle
			subq.l	#4,sp					; handle to outline region
			_NewRgn
; handle to outline region still on stack
			move.l	(sp),a2					; save outline region
			_CloseRgn			
			subq.l	#4,sp					; handle to view region
			_NewRgn
; handle to view region still on stack
			move.l	(sp),a4					; save view region
			pea		teViewRect(a3)			; view Rectangle
			_RectRgn
			move.l	a4,-(sp)				; view region
			move.l	a2,-(sp)				; outline region
			move.l	a2,-(sp)				; intersection of view and outline regions
			_SectRgn
			move.l	a4,-(sp)				; view region
			_DisposRgn

; set up for drawing
			pea		oldPenState(a6)
			_GetPenState
			move.w	#1,-(sp)
			move.w	#1,-(sp)
			_PenSize
			move.l	GrafGlobals(a5),a0		; get graf globals
			move.w	teSelStart(a3),d0
			cmp.w	teSelEnd(a3),d0
			bne.s	@NoCaret
; got a caret
			lea		gray(a0),a4				; modified a bit <2Oct89smb>
			move.w	#PatXOr,d2
			bra.s	@doPen			
@NoCaret
			lea		black(a0),a4			; @black pattern
; test if color QD available
			move.w	#PatXOr,d2				; assume no color QD
			move.l	#gestaltQuickdrawVersion,d0
			_Gestalt						; result returned in a0
			tst.w	d0						; OSErr result returned here
			bne		SysErr
			move.l	a0,d0					; test result in a0!
			beq.s	@doPen					; no color QD available
			move.w	#50,d2					; hilite
@doPen
			move.w	d2,-(sp)
			_PenMode
			move.l	a4,-(sp)
			_PenPat

; draw
			move.w	teSelStart(a3),d0
			cmp.w	teSelEnd(a3),d0
			beq.s	@Caret
; no caret so outline
			move.l	a2,-(sp)
			_FrameRgn
			tst.b	paintFlag(a6)			; don't paint for Updating <16Oct89smb>
			beq.s	@NoPaint
@Caret
			move.l	a2,-(sp)
			_PaintRgn
@NoPaint			
			move.l	a2,-(sp)
			_DisposRgn
			move.l	(sp)+,a4				; restore TE handle
			
			pea		oldPenState(a6)
			_SetPenState
			
			move.l	oldHighHook(a6),teHiHook(a3)	; restore
			move.l	oldCaretHook(a6),teCarHook(a3)	; restore
@DoneTEOutlineHilite
			rts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;----------------------------------------------------------------------
;----------------------------------------------------------------------
;			PROCEDURE ptchTEDispatch
;			<1/4/91smb>	Fixed bug #66732 in SetStylScrap.								<19>
;			<1/4/91smb> Fixed bug #58512 in TEStylInsert.								<19>
;----------------------------------------------------------------------
ptchTEDispatch
			MoveQ		#1,D0					; tells stdEntry it's a style trap
			Bsr 		ptchStdEntry2			; get addr of procedure in a0
		IF SysVers>= $700 THEN					;										<19>
			cmpROM		ROMSetStylScrap,a0		; are we dispatching to SetStylScrap?	<19>
			bne.s		@TestStylInsert			; nope, test for TEStylInsert call		<19>
;----------------------------------------------------------------------
;			PROCEDURE ptchSetStylScrap
;			<1/4/91smb>	Per documentation, if a NIL StScrpHandle (newStyles)
;			exist, do nothing and exit. 		<19>
;----------------------------------------------------------------------
			tst.l		2(a2)					; is the scrap handle NIL				<19>
			bne			@Go2Proc				; nope, go to SetStylScrap				<19>
			moveq		#20,d0					; Nil handle: # of params to strip		<19>
			jmpROM		ROMStdExit2				; goodbye!								<19>
;----------------------------------------------------------------------
;			PROCEDURE ptchTEStylInsert
;			<1/4/91smb>	Must patch since it calls InsGuts which is now patched.			<19>
;----------------------------------------------------------------------
@TestStylInsert
			cmpROM		ROMTEStylInsert,a0		; are we dispatching to TEStylInsert?	<19>
			bne			@Go2Proc
;-----------
			jsrROM		ROMHideCaret
			jsrROM		ROMHiLite				; remove selection

			move.l		(a2)+,d0				; get style handle
			moveq		#0,d7					; delta = 0(No deletion)
			movem.l 	(a2)+,d5-d6 			; A2 points to length & pointer params

; If length is 0, punt
			tst.l		d5						; length?
			bz.s		@15						; Nope, so leave

			tst.l		d0						; check if handle is NIL
			beq.s		@0						; can't insert styles if NIL

			move.l		d0,a2					; save style handle in A2
			tst.w		teSize(a3)				; check style flag
			bpl.s		@0						; just insert text if not a style record

			jsrROM 		ROMMungeSetup			; setup for the insert
			clr.l		-(sp)					; fake l1
			move.l		d6,-(sp)				; pointer to insert = p2
			move.l		d5,-(sp)				; length to insert = l2
			_Munger 							; use sloppy munger
			addq.l		#4,sp					; pop result
			add 		d5,teLength(a3) 		; adjust length by insert amount

			move.l		teTextH(a3),a0			; get text handle
			_Hlock								; and relock it

			move.l		a2,a0					; get style handle
			_HGetState							; get the style handle's tag
			move.b		d0,-(sp)				; and save the flags
			_HLock								; and lock it

			movem.l		d2-d6/a2/a4,-(sp)		; save stuff
			move.l		a2,a4					; style handle in a4 for call to PstStylGuts

; ** <C851/23Apr87/MBK> ** High word of D3 must be clear for PstStylGuts
			moveq		#0,d3					; clear whole register

			move.w		teSelStart(a3),d3		; selection start
			jsrROM		ROMPstStylGuts			; go do the style paste
			movem.l		(sp)+,d2-d6/a2/a4		; restore stuff
			
			move.b		(sp)+,d0				; get the flags
			move.l		a2,a0					; get style handle
			_HSetState							; set the style handle's tag

; only call ConcatRuns when styles are pasted, hence moved here. Text inserted now so
; okay to call.
			jsrROM		ROMConcatRuns			; <24Nov88smb> don't leave any null style runs
			sub 		d5,d7					; adjust delta amount for ReCalLines
			bra.s		@1						; go recal

@0			bsr			ptchInsGuts 			; no styles to insert, only text!		<19>

@1			jsrROM 		ROMRecalDraw			; redo the line stuff
			add 		d5,teSelStart(a3)		; selStart:=selstart + insert amount
			add 		d5,teSelEnd(a3) 		; selEnd:=selEnd + insert amount

@15
			jsrROM 		ROMShowCaret
			jsrROM		ROMHiLite				; restore selection
			moveq		#18,d0					; # of bytes on stack
			jmpROM 		ROMStdExit2				;	to be removed before exit
;-----------
		ENDIF
@Go2Proc
			jmpROM		ROMinTEDispatch
		
;----------------------------------------------------------------------
ptchTEGetText
			Bsr 		ptchStdEntry
			jmpROM		ROMinTEGetText

;----------------------------------------------------------------------
ptchTESetText
			Bsr 		ptchStdEntry
			jmpROM		ROMinTESetText

;----------------------------------------------------------------------
ptchTECalText
			Bsr 		ptchStdEntry
			jmpROM		ROMinTECalText
			
;----------------------------------------------------------------------
ptchTECopy
			Bsr			ptchStdEntry
			jmpROM		ROMinTECopy

;----------------------------------------------------------------------
ptchTECut
			Bsr			ptchStdEntry
			jmpROM		ROMinTECut
			
;----------------------------------------------------------------------
ptchTEIdle
			Bsr			ptchStdEntry
	IF forLocalizability THEN					; <34p-YDS-9/2/91>
			Tst.B		teCarAct(A3)			; see if active
			Beq.S		goHome

			SubQ		#4,SP					; make room for result
			_TickCount							; Get current time
			Move.L		(SP)+,A0				; use A0 for auto extend

			Cmp.L		teCarTime(A3),A0		; see if done
			Blo.S		goHome

			Add.L		CaretTime,A0			; next time
			Move.L		A0,teCarTime(A3)		
			Not.B		teCarOn(A3) 			; flip the flag
			jsrROM		ROMDrawIt				; flip the caret
goHome
			jmpROM 		ROM@goHome
	ELSE
			jmpROM		ROMinTEIdle
	ENDIF
			
;----------------------------------------------------------------------
ptchTEPaste
			Bsr 		ptchStdEntry
			jmpROM		ROMinTEPaste
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEInsert
;			<1/4/91smb> Fixed bug #58512: Must patch TEInsert since
;			it calls InsGuts which is now patched.		<19>
;----------------------------------------------------------------------
ptchTEInsert
			Bsr 		ptchStdEntry
		IF SysVers>= $700 THEN
			jsrROM		ROMHideCaret			;								<C971/RWW102887>NO
			jsrROM		ROMHiLite				; remove selection				<C971/RWW102887>NO

			moveq		#0,d7					; delta = 0(No deletion)
			movem.l 	(a2)+,d5-d6 			; A2 points to l param
			bsr.s		ptchInsGuts 			; go insert the scrap								<19>
			jmpROM		ROMAfterInsert			;													<19>
		ELSE
			jmpROM		ROMinTEInsert
		ENDIF
		
		IF SysVers >= $700 THEN
;----------------------------------------------------------------------
;			PROCEDURE ptchInsGuts
;			<1/4/91smb>	Must be patched since calls InsRsrved which calls
;			PstStylGuts which has an unlocked null scrap handle that must
;			be locked since it uses it again after moving memory.	<19>
;----------------------------------------------------------------------
ptchInsGuts
			jsrROM 		ROMMungeSetup			; setup for the insert			<C971/RWW102887>NO

			Clr.L		-(SP)					; fake l1
			Move.L		D6,-(SP)				; pointer to insert = p2
			Move.L		D5,-(SP)				; length to insert = l2
			_Munger 							; use sloppy munger
			AddQ.L		#4,SP					; pop result

			Move.L		teTextH(A3),A0			; get text handle
			_Hlock								; and relock it

			Add 		D5,teLength(A3) 		; adjust length by insert amount
			Sub 		D5,D7					; adjust delta amount for ReCalLines

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; no, you're done		** MBK 6/18/86 **

; lock down the nullscrap handle since InsRsrved expects to use it again after moving memory 		<19> 
			move.l		teStylesH(a3),a0		; get style handle
			move.l		(a0),a0					; deref
			move.l		nullStyle(a0),a0		; get reserved handle
			move.l		(a0),a0					; deref
			move.l		nullScrap(a0),a1		; get handle to scrap for null selection
			move.l		a1,-(sp)				; save scrap handle for unlocking later				<19>
; Gotta lock down null scrap!																		<19>
			move.l		a1,a0					;													<19>
			_HLock								;													<19>

			jsrROM		ROMInsRsrved			; insert the style				<C971/RWW102887>NO

; Unlock previously locked null scrap																<19>
			move.l		(sp)+,a0				;													<19>
			_HUnlock							;													<19>
@0
			Rts
		ENDIF									;													<19>	
;----------------------------------------------------------------------
ptchTESetJust
			Bsr 		ptchStdEntry
			jmpROM		ROMinTESetJust
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEScroll
;			<1/4/91smb>	Must be patched since calls Scroll which calls
;			Refresh, which is now patched.
;----------------------------------------------------------------------
ptchTEScroll
			Bsr 		ptchStdEntry
		IF SysVers>= $700 THEN
			jsrROM 		ROMHideCaret

			Move.L		(A2)+,D3				; get dv,dh pair
			Bsr.S		ptchScroll
epilog8
			MoveQ		#8,D0
			jmpROM 		ROMStdExit

;----------------------------------------------------------------------
;			PROCEDURE ptchScroll
;			<1/4/91smb>	Must be patched since calls Refresh, which is
;			now patched.
;----------------------------------------------------------------------
ptchScroll
; Amount to scroll in D3
			Tst.L		D3						; escape if nothing there
			Beq.S		ActCaret				; fix errant HideCaret (and Rts…)	<C971/RWW110587>

			Pea 		teDestRect(A3)			; pass the dest rectangle
			Move.L		D3,-(SP)				; pass dh, dv
			_OffsetRect

			SubQ		#4,SP					; make room for temp region
			_NewRgn 							; get it
			Move.L		(SP)+,A2				; save its handle

			Pea 		teViewRect(A3)			; pass rect to scroll
			Move.L		D3,-(SP)				; pass dh, dv
			Move.L		A2,-(SP)				; pass the temp region
			_ScrollRect

			Bsr.S		ActCaret				; just activate, don't draw		<C971/RWW102887>NO

			Move.L		A2,-(SP)				; clip to it update rgn
			_SetClip

			Move.L		(A2),A0 				; point to region
			Lea 		rgnBBox(A0),A0
			import		ptchRefresh				;												<19>
			jsr			ptchRefresh 			; and redraw those lines						<19>

			Move.L		A2,-(SP)				; get rid of temp region
			_DisposRgn
@0
handyReturn
			Rts
;-----------------------------------------------
; ** <C207/14oct86/MBK> ** Don't draw caret yet, just activate it
ActCaret	Tst.B		teActive(A3)			; do nothing if not active
			Beq.S 		@0						;								<C971/RWW102887>NO

			Move		teSelStart(A3),D0		; see if should be turned on
			Cmp 		teSelEnd(A3),D0
			Bne.S		@0						; if selection <> 0 then escape
			ST			teCarAct(A3)			; replaced ShowCaret

@0			Rts
;-----------------------------------------------
		ELSE									;												<19>
			jmpROM		ROMinTEScroll
		ENDIF									;												<19>
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEPinScroll
;			<1/4/91smb>	Must be patched since calls Refresh, which is 
;			now patched.
;----------------------------------------------------------------------
ptchTEPinScroll
			Bsr 		ptchStdEntry
		IF SysVers>= $700 THEN					;												<19>
			jsrROM 		ROMHideCaret
; get vertical parameter
			move		(a2),d0 				; get dV
			bpl.s		@PinTop					; pin top

			move.w		teNLines(A3),d1			; last line				** MBK 6/18/86 **
			move.w		teLength(A3),d0			; last char				**<C207/14oct86/MBK> **
			tst.w		d0						; anything in file?		**<C207/14oct86/MBK> **
			beq.s		@0						; skip test if not		**<C207/14oct86/MBK> **

			move.l		teTextH(a3),a0			; text handle			**<C207/14oct86/MBK> **
			Move.l		(a0),a0					; dereference			**<C207/14oct86/MBK> **
			cmp.b		#$0D,-1(a0,d0)			; file end with CR?		**<C207/14oct86/MBK> **
			bne.s		@0						; end of file if not	**<C207/14oct86/MBK> **

			addq		#1,d1					; else 1 more line		**<C207/14oct86/MBK> **

@0			moveq		#0,d0					; 1st line				** MBK 6/18/86 **
			jsrROM		ROMGetLineHites			; compile max hites		** MBK 6/18/86 **
			move.w		d0,d1					; hite from 1st to last	** MBK 6/18/86 **
			move.w		(a2),d0					; restore D0			** MBK 6/18/86 **

			add 		teDestRect+top(a3),d1	; get destRect.top

			sub 		teViewRect+bottom(A3),d1; a diff. viewRect.bottom
			ble.s		@2						; dest already gone...
			add 		d1,d0					; see what delta does
			bpl.s		pinH
			bra.s		@2						; should be subtracted because it's negative

@PinTop
; scrolling down
			move		teDestRect+top(a3),d1	; add destRect.top
			sub 		teViewRect+top(a3),d1	; diff. viewRect.top
			bpl.s		@2						; already bad

			add 		d1,d0
			bmi.s		pinH
@2
			sub 		d0,(a2) 				; adjust scroll
pinH
			move		2(a2),d0				; get dH
			bpl.s		@1						; pin top
			move		teDestRect+right(a3),d1 ; add destrect.right
			sub 		teViewRect+right(a3),d1 ; a diff. viewRect.right
			ble.s		@2						; already past, cancel scroll
			add 		d1,d0
			bpl.s		pinDone
			sub			d0,2(a2)				; bug found in MacDTS <12/19/88smb> 
			bra.s		pinDone
@1
			move		teDestRect+left(a3),d1	; add destRect.left
			sub 		teViewRect+left(a3),d1	; diff. viewRect.left
			bpl.S		@2						; already past, cancel scroll
			add 		d1,d0
			bmi.s		pinDone
@2
			sub 		d0,2(a2)				; adjust scroll
pinDone

			move.l		(a2)+,d3				; get dv,dh pair
			bsr 		ptchScroll				; and go scroll it								<19>

			bsr			ActCaret				; just activate, don't draw	** <C207/14oct86/MBK> **
			Bra 		epilog8
		ELSE									;												<19>
			jmpROM		ROMinTEPinScroll
		ENDIF									;												<19>
;----------------------------------------------------------------------
ptchTESelView
			Bsr 		ptchStdEntry			 ; doo dah...
			jmpROM		ROMinTESelView

;----------------------------------------------------------------------
ptchTEAutoView
			Bsr 		ptchStdEntry			 ; doo dah...
			jmpROM		ROMinTEAutoView

;----------------------------------------------------------------------
;			PROCEDURE ptchTEGetOffset
;			<1/4/91smb>	Must patch more since DoFind is now patched.
;----------------------------------------------------------------------
ptchTEGetOffset
			Bsr			ptchStdEntry
	IF SysVers>= $700 THEN
			Move.L		teSelPoint(A3),-(SP)	; save selPoint
; Find the point and get char index of it in D6
			Move.L		(A2)+,teSelPoint(A3)	; pass selPoint
			import		ptchDoFind				;												<19>
			jsr			ptchDoFind				; juggle dispStart/End and do find
			Move.W		D6,(A2)					; dispStart

			Move.L		(SP)+,teSelPoint(A3)	; restore selPoint
			bra.s		Epilog8			; is Epilog8 in this proc? (if not, use jmpROM ROMEpilog8 ????????????)
	ELSE
			jmpROM		ROMinTEGetOffset
	ENDIF
	
;----------------------------------------------------------------------
;			PROCEDURE ptchTESetStyle
;			<7Dec89smb>
;			Testing possible additive combination of mode which could include
;			the font bit before call to SetKeyboard2Font.
;			<16Dec89smb>
;			Remove TEDispatch return address from stack.
;----------------------------------------------------------------------
ptchTESetStyle			
			addq.l		#4,sp					; Clean up from ptchStdEntry jump.<16Dec89smb> 
			tst.w		teSize(A3)				; check style flag
			Bpl.S		@DontSet				; if not, sorry, can't set it

			jsrROM		ROMSetRsrved			; save the style in the grafport
			
; mode may be an additive combination so must test the font bit <3Dec89smb>
			move.w		6(a2),d0				; <3Dec89smb>
			btst		#fontBit,d0				; is mode = doFont? <3Dec89smb>
			beq.s		@KeybdOK				; <3Dec89smb>
;;			cmpi.w		#doFont,6(a2)			; is mode = doFont? <12July89smb>
;;			bne.s		@KeybdOK				; <12July89smb>
			import		ptchSetKeyboard2Font
			jsr			ptchSetKeyboard2Font	; synch keyboard to new font <10Nov88smb>
@KeybdOK
			jmpROM		ROM@KeybdOK
@DontSet
			MoveQ		#14,D0
			jmpROM		ROMStdExit2

;----------------------------------------------------------------------
;			PROCEDURE ptchTEUpdate
;			<16Oct89smb>
;			Added updating of outlined region in TEUpdate.
;----------------------------------------------------------------------
ptchTEUpdate
			Bsr			ptchStdEntry
			Move.L		(A2)+,A0				; get rect
		IF SysVers>= $700 THEN					;											<19>
			import		ptchRefresh				;											<19>
			jsr			ptchRefresh				;											<19>
		ELSE
			jsrROM 		ROMRefresh
		ENDIF
; if window is active, don't bother with outlining. <16Oct89smb>
			tst.b		teActive(a3)
			beq.s		@TestOutline
			
			jmpROM 		ROMEpilog8

@TestOutline
; if outlining is on, redraw outline! <16Oct89smb>
			with		OutlineFrame
			link		a6,#OutlineFrameSz		; only link if outlining
			move		teSelStart(a3),d0		; is this a selection point?
			cmp 		teSelEnd(a3),d0
			bne.s		@drawRegion				; fall through for caret processing

; is outlining desired?
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst		#teFOutlineHilite,d0
			beq.s		@drawRegion				; outline bit not on
; if caret on invert it
			tst.b		teCarOn(a3)
			beq.s		@noDraw
			jsrROM		ROMDrawIt			
@noDraw
; turn on flag in case off - want to display an outlined caret
			st			teCarOn(a3)				; will be turned off in HideCaret
@drawRegion
			bsr			InitOutline
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst		#teFOutlineHilite,d0
			beq.s		@noOutline				; outline bit not on
			st			teActive(a3)			; flag as active for hiliting
			jsrROM		ROMHideCaret			; hide the caret
			jsrROM 		ROMHiLite				; Frame new region
			sf			teActive(a3)			; flag as inactive
			sf			paintFlag(a6)			; don't paint region!
			bsr			TEOutlineHilite
@noOutline
			unlk		a6
			jmpROM 		ROMEpilog8

;----------------------------------------------------------------------

SysErr			
			_SysError						; go bye-bye with error in d0

;----------------------------------------------------------------------
;			PROCEDURE ptchTESetSelect
;			<7Dec89smb> Added new routine ClickKeyboard2Font for unsynching keyboard
;			and font.
;			<9/6/90smb> If inline input is active, then don't unsynch the keyboard.
;----------------------------------------------------------------------
ptchTESetSelect
			bsr 		ptchStdEntry
			jsrROM		ROMClearRsrved				; clear out reserved style

			jsrROM 		ROMHideCaret
			jsrROM 		ROMHiLite

			move		14(a6),teSelEnd(a3) 		; Jam the selection end
			move		18(a6),teSelStart(a3)		; jam selStart
			jsrROM 		ROMCleanUpSel				; sort and clean up selection
			
; set the current font in the grafort so can synch the keyboard to the font <10Nov88smb>
			tst.w		teSize(a3)				; if unstyled, can't synch keyboard to font <1Dec88smb>
			bpl.s		@DoneWithSynch
			
			move.w		teSelStart(a3),d0
			beq.s		@BufferStart			; <6Dec89smb>
			sub.w		#1,d0					; backup one to get previous style <6Dec89smb>
@BufferStart
			move.w		d0,d3					; save offset position <6Dec89smb>
			jsrROM		ROMGetCurStyle
			jsrROM		ROMSetStyle
			move.w		d3,d0					; <6Dec89smb>
	IF hasInlineInput THEN						; 										<16>
; if inline input is on then don't unsynchronize the keyboard! 							<16>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d1		; move into reg for modulo 32 bit ops
			btst		#teFInlineInput,d1		; is Inline Input active?
			bne.s		@DoneWithSynch			; yes, so don't unsynch!
	ENDIF										; 										<16>
			import		ClickKeyboard2Font
			jsr			ClickKeyboard2Font		; <3Dec89smb>
@DoneWithSynch
			jmpROM		ROM@NoSynchInSetSelect
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEClick
;			<7Dec89smb>
;			Added new routine ClickKeyboard2Font for unsynching keyboard
;			and font.
;			<1/23/90emt/smb>
;			Added humane scrolling to DefClikProc.
;----------------------------------------------------------------------
ptchTEClick
			Bsr 		ptchStdEntry
			jsrROM		ROMClearRsrved			; clear out reserved style

; Find the new point and get index of it in d6
			move.l		14(a6),teSelPoint(a3)	; pass selPoint
		IF SysVers>= $700 THEN					;												<19>
			import		ptchDoFind				;												<19>
			jsr			ptchDoFind				; you guessed it: it's patched now!				<19>
		ELSE
			jsrROM 		ROMDoFind				; juggle dispStart/End and do find
		ENDIF									;												<19>

			jsrROM 		ROMHideCaret			; Remove caret

			subq		#4,sp					; make room for the tickCount
			_TickCount
			move.l		(SP)+,d0 				; Ticks in D0

			sub.l		teClikTime(a3),d0		; see if double click
	IF SysVers>= $605 THEN			
			add.l		d0,teClikTime(a3)		; Update click time for click proc.	<4>
	ENDIF
			cmp.l		DoubleTime,d0			; 1/2 second click time
			sle 		d5						; D5 = 0 if single click
			cmp 		teClikLoc(a3),d6		; see if same location
			seq 		d1
			and.b		d1,d5					; D5 ST if double click
			ror.l		#8,d5					; get switch in high D5

			move		d6,teClikLoc(a3)		; double click only if not moved

; synch the keyboard to the font <10Nov88smb>
			tst.w		teSize(a3)				; if unstyled,  synch keyboard to font 
	IF forLocalizability THEN					; even if we dont have all info <34g-YDS-9/2/91>
			bmi.w		@Styled					; styles !!!
			tst.w		teLength(A3)			; do we have text at all ? 
			beq.w		@DoneWithPsynching		; don't synch if no text !!!

	IF 0 THEN									; now using 'itlb' flag in CubeE						<46>
						 						; 6.1 : synch only r->l, for 7.0 synch for double byte 
;;			tst.b		WordRedraw				; is it a R->L script ?									<37>
;;			bge.w		@DoneWithPsynching		; don't synch.											<37>
; Really want to synchronize for unstyled text in ALL scripts. However, this will cause problems for 	<37>
; input methods, so we will skip this code in this case. (WordRedraw only indicates the 				<37>
; types of scripts installed and not the current one…)													<37>
			subq		#2,sp					; result space for Font2Script & GetScript				<37>
			move.w		teFont(a3),-(sp)		; app font id											<37>
			_Font2Script						; it's a non-roman char so get script font				<37>
			move.w		(sp)+,d0				;														<37>
			beq			@UseFont				; if Roman then always synchronize						<37>
			cmp.w		#smEastEurRoman,d0		; Extended Roman?										<40>
			beq			@DoneWithPsynching		; If so, never synchronize								<40>
			subq		#4,sp					; result space											<37>
			move.w		d0,-(sp)				; script												<37>
			move.w		#smScriptRedraw,-(sp)	;														<37>
			_GetScript							;														<37>
			move.l		(sp)+,d1				;														<37><39>
			tst.b		d1						; leave in d1 for later									<37><39>
			bgt			@DoneWithPsynching		; if double-byte script	don't synchronize				<37>
			; otherwise, we have a single-byte non-Roman font											<37>
;	IF SysVers > $610 THEN		
;			move.l		teDispatchH(a3),a0		; <11-YDS-8/5/91>
;			move.l		(a0),a0
;			move.l		newTEFlags(a0),d0		; move into reg the flags
;			btst		#teFInlineInput,d0		; are we in an inline input window ?
;			bne.w		@DoneWithPsynching				; yes, don't synch keyboard.
;	ENDIF		

	ELSE										; now using 'itlb' flag	in CubeE						<46>

			; optimize for Roman-only: do not have to synch font & kbd									<51>
			with		smgrRecord				;														<51>
			GetSMgrCore a0						; load SMgr globals pointer.							<51>
			cmp.b		#1,smgrEnabled(a0)		; how many scripts enabled?								<51>
			beq			@DoneWithPsynching		; skip synchronization for Roman-only system			<51>
			endwith								;														<51>

			subq		#6,sp					; result space for Font2Script & GetScript				<46>
			move.w		teFont(a3),-(sp)		; app font id											<46>
			_Font2Script						; get script font										<46>
			; script left on stack				;														<46>
			move.w		#smScriptFlags,-(sp)	; now get script-specific flags							<46>
			_GetScript							;														<46>
			move.l		(sp)+,d0				;														<46>
			and.l		#(1<<smsfSynchUnstyledTE),d0	; leave only the synchronize bit				<46>
			beq			@DoneWithPsynching		; 0=> do not synchronize								<46>
			; otherwise synchronize
	ENDIF										; now using 'itlb' flag	in CubeE						<46>

			move.w		d6,d3					; don't trash d6			
			tst.b		teLftClick(a3)			; check if the click was on the previos char.
			bne.s		@2						; else sub 1 
			sub.w		#1,d3					; see the char we clicked (from 0 !!!)
@2
; Check char to determine how to synch
			move.l		teTextH(a3),a2			; handle to text										<39>
			move.l		(a2),a0					; ptr to text											<39>
			move.b		0(a0,d3.w),d0			; get character											<39>
			cmp.b		#$20,d0					; control char?											<39>
			blo			@DoneWithPsynching		; if so, don't synch									<39>
			move.b		d1,-(sp)				; save scriptRedraw										<39>
			subq		#2,sp					; room for return
			move.l		a0,-(sp)				; push text ptr on stack								<39>
			move.w		d3,-(sp)				; offset on stack
			_CharType							; what char is it
			move.w		(sp)+,d0				; take result
			move.b		(sp)+,d1				; recover scriptRedraw									<39>

; Mask off what interested in: the Type ($000F) and the Direction ($2000)								<37>
; Want a char whose Direction is LR (smCharLeft, $0000) and whose Type is Roman							<37>
; which can be smCharAscii (1) or smCharEuro (7). smCharPunct (0) should not synch the font.			<37>
;
; New approach. Different behavior for bidi and non-bidi scripts, because of caret						<39>
; requirements for bidi scripts.																		<39>
			bne.s		@doBidi					; check scriptRedraw for bidi							<39>
; For non-bidirectional scripts, set keyboard to Roman for Roman letters,								<39>
; sync to font for script letters, dont sync for anything else.											<39>
			and.w		#smcTypeMask,d0			; isolate info we need									<39>
			cmp.w		#smCharPunct,d0			; non-letter?											<39>
			beq.s		@DoneWithPsynching		; if so, don't synch keyboard							<39>
			cmp.w		#smCharAscii,d0			; low-ASCII Roman?										<39>
			beq.s		@isRoman				; if so, go set keyboard								<39>
			cmp.w		#smCharEuro,d0			; Extended ASCII Roman?									<39>
			beq.s		@isRoman				; if so, go set keyboard								<39>
			bra.s		@UseFont				; otherwise, sync keyboard to font						<39>
; For bidirectional scripts, don't synch control chars (stripped out above) or low-ASCII				<39>
; (L-R) digits; synch other L-R chars to Roman, and everything else to font script.						<39>
@doBidi											;														<39>
			and.w		#smcTypeMask+smcClassMask+smcRightMask,d0	; isolate info we need				<39>
			cmp.w		#smCharPunct+smPunctNumber+smCharLeft,d0	; is char a low-ASCII digit?		<39>
			beq.s		@DoneWithPsynching		; if so, don't synch									<39>
			and.w		#smcRightMask,d0		; now just check direction								<39>
			beq.s		@isRoman				; if left-right, sync to Roman							<39>

; Otherwise, synch the font to the script of the character
@UseFont
			subq		#2,sp					; room for return
			move.w		teFont(a3),-(sp)		; app font id
			_Font2script						; it's a non-roman char so get app font
			; leave script on stack
			bra.s		@SetKbd

@isRoman	move.w		#smRoman,-(sp)			; we think it is roman
@SetKbd
			move.w		(sp), d0				; script param on the stack 
			move.l		teDispatchH(a3),a0		; get teDispatchH addres 
			move.l		(a0),a0					;
			move.b		d0, lastScript(a0)		; push script numberused to highligt (d0) to lastScript
			_KeyScript							; set keyboard
			bra.s		@DoneWithPsynching
	ELSE
			bpl.s		@DoneWithPsynching
	ENDIF
			
@Styled		move.w		d6,d0
			beq.s		@BufferStart			; <6Dec89smb>
	IF forLocalizability THEN					;  <34e-YDS-9/2/91>
			tst.b		WordRedraw				; do we have a R->L script
			bge.s		@BufferStart			; no, take the prev allways
			tst.b		teLftClick(a3)			; check if the click was on the previos char.
			bne.s		@BufferStart			; else sub 1
	ENDIF
			sub.w		#1,d0					; backup one to get previous style <6Dec89smb>
@BufferStart
			move.w		d0,d3					; save offset position <6Dec89smb>
			jsrROM		ROMGetCurStyle				; returns ptr to current style in a0
			jsrROM		ROMSetStyle				; set the font in the grafport
			move.w		d3,d0					; char offset needed in ClickKeyboard2Font <6Dec89smb>
			import		ClickKeyboard2Font
			jsr			ClickKeyboard2Font		; sink up! <3Dec89smb>
@DoneWithPsynching
;--------------------
		IF SysVers>= $700 THEN
; Must patch out the rest of this routine for the other DoFind call (since it's 
; embedded in a loop!)																<19>
;------
; D6 now contains the character location at which to look
;
; Find out if we want an extended selection or a normal one
; For an extended selection, fake out the loop below by fooling it into thinking
; we've already entered it "normally" but with the old selection already
; hilighted, etc.

	IF SysVers >= $700 THEN						;													<29>
			move.l		a4,-(sp)				; preserve teHandle for hook calls					<29>
	ENDIF										;													<29>
			Tst.B		12(A6)					; see if extend flag is on
			Beq.S		notExtended

			MoveM		teSelStart(A3),D0-D1	; get old selection
			Cmp 		D6,D0					; chk side of new loc
			Bhs.S		useRight
			Move		D0,A2					; save anchor left
			Move		D0,A4					; and anchor right
			Bra.S		goToIt
useRight
			Move		D1,A2					; save anchor left
			Move		D1,A4					; and anchor right
goToIt
			Move		D6,D5
			Bra.S		goSelect

notExtended
;			a4 ok here due to bra to this point														<29>
			jsrROM		ROMHiLite				; Remove old selection
			MoveQ		#teWordSelect,D2		; say "ClickExpand, word selection" <EHB 01Oct85>
			jsrROM		ROMClickExpand			;								<C971/RWW102887>NO
; D0/D1 now contain the "bounds" of this click
			MoveM		D0-D1,teSelStart(A3)
			Move		D0,A2					; save anchor left
			Move		D1,A4					; and anchor right
			Move		D6,D5					; save "old" D6
; remember whether initial click was to left or right of character
			Move.B		teLftClick(A3),teLftCaret(A3)

	IF SysVers >= $700 THEN						;													<29>
			move.l		a4,-(sp)				; save current use of a4 across calls				<29>
			move.l		4(sp),a4				; restore teHandle									<29>
	ENDIF										;													<29>
			jsrROM 		ROMShowCaret			; feedback to user
			jsrROM 		ROMHiLite
	IF SysVers >= $700 THEN						;													<29>
			move.l		(sp)+,a4				; restore TEClick's use of a4						<29>
	ENDIF										;													<29>

waitLoop
			Move.L		teClikProc(A3),D0		; call the click proc
			Beq.S		noClikProc
			Move.L		D0,A0
			Jsr 		(A0)
			Beq			done1					; if returns zero abort drag

noClikProc
			Clr 		-(SP)					; make room for result
			_WaitMouseUp						; see if button still down
			Tst.b		(SP)+					; pop result										<38>
			Beq.S		done1

			Pea 		teSelPoint(A3)			; pass address for point
			_GetMouse

	IF SysVers >= $700 THEN						;													<29>
			move.l		a4,-(sp)				; save current use of a4 across calls				<29>
			move.l		4(sp),a4				; restore teHandle									<29>
	ENDIF										;													<29>
			import		ptchDoFind
			jsr			ptchDoFind				; juggle dispStart/End and do find				<19>
	IF SysVers >= $700 THEN						;													<29>
			move.l		(sp)+,a4				; restore TEClick's use of a4						<29>
	ENDIF										;													<29>

			Cmp 		D6,D5					; see if change
			Beq.S		waitLoop

	IF SysVers >= $700 THEN						;													<29>
			move.l		a4,-(sp)				; save current use of a4 across calls				<29>
			move.l		4(sp),a4				; restore teHandle									<29>
	ENDIF										;													<29>
			jsrROM 		ROMHideCaret
	IF SysVers >= $700 THEN						;													<29>
			move.l		(sp)+,a4				; restore TEClick's use of a4						<29>
	ENDIF										;													<29>

; There was a change so highlight only the new part. This is a really tricky part...
; The thing we're trying to do is highlight only the part that changes of the
; selection which is being dragged out in this loop

goSelect
			MoveQ		#teWordDrag,D2			; say "ClickExpand, word dragging"
			jsrROM 		ROMClickExpand 			; Get new points

			Lea 		teSelEnd(A3),A0 		; point between selStart/End

			Cmp 		D6,A4					; see if less than anchor right
			Blo.S		notToLeft				; skip if not to left of anchor
			Move		-(A0),D3				; save previous left
			Move		D0,(A0)+				; save new left (in teSelStart!)
			Move		D0,D4					; save dispEnd too
			Swap		D3
			Swap		D4
			Move		A4,D3					; save other dispStart
			Move		(A0),D4					; save other dispEnd (old teSelEnd)
			Move		A4,(A0)
			Bra.S		hiliteIt


notToLeft
			Cmp 		D6,A2					; see if greater than anchor left
			Bhi.S		keepWaiting 			; skip if not to right of anchor
			Move		(A0),D3					; save previous right
			Move		D1,(A0)					; save new right
			Move		D1,D4					; save dispEnd too
			Swap		D3
			Swap		D4
			Move		-(A0),D3				; save other dispEnd
			Move		A2,D4					; save other dispStart
			Move		A2,(A0)+


hiliteIt
	IF SysVers >= $700 THEN						;													<29>
			move.l		a4,-(sp)				; save current use of a4 across calls				<29>
			move.l		4(sp),a4				; restore teHandle									<29>
	ENDIF										;													<29>
			MoveQ		#teHighlight,D7			; set mark mode
;;			bsr 		ptchTEDoText			; do one half								<25>
			jsrROM		ROMDoText				; use the low mem TEDoText hook!!			<25>

			Swap		D3						; get other dispStart/End
			Swap		D4						; and hilight too
;;			bsr 		ptchTEDoText			; and other half							<25>
			jsrROM		ROMDoText				; use the low mem TEDoText hook!!			<25>
	IF SysVers >= $700 THEN						;													<29>
			move.l		(sp)+,a4				; restore TEClick's use of a4						<29>
	ENDIF										;													<29>

keepWaiting
			Move		D6,D5					; save new end

			Bra.S		waitLoop				; continue on
done1
	IF SysVers >= $700 THEN						;													<29>
			move.l		(sp)+,a4				; restore teHandle for the last time				<29>
	ENDIF										;													<29>
			jsrROM 		ROMShowCaret			; redisplay caret

; ** <C139/23Sep86/MBK> ** Save tick count at the end of TEClick so that
; extra TextEdit computing time will not be counted between clicks

			SubQ		#4,SP					; make room for the tickCount
			_TickCount
			Move.L		(SP)+,teClikTime(A3)	; remember click time

epilog10
			MoveQ		#10,D0
			jmpROM 		ROMStdExit

		ELSE
			jmpROM		ROM@NoSynchInTEClick
		ENDIF
;----------------------------------------------------------------------
;			PROCEDURE ptchTEKeyStdEntry,StdEntry,StdEntry2
;			<28Sept89smb>
;			Added testing of buffer bit at end of routine.  Also added
;			a new entry point for TEKey.
;----------------------------------------------------------------------
ptchTEKeyStdEntry
; Added new entry point for TEKey since need to save/clear textBuffering flag around this routine.<28Sept89smb>
			moveq		#0,d0					; not a style trap
			move.l		(sp)+,a0				; save return address
			move.l		(sp)+,a1				; save newTEFlags
			link		a6,#stdLink 			; stack frame
			movem.l 	d2-d7/a2-a4,-(SP)
			move.l		a1,-(sp)				; newTEFlags to restore
			move.l		a0,-(sp)				; push return address back on stack
			bra.s		NotStyleTrap
ptchStdEntry
			MoveQ		#0,D0					; not a style trap		** <C105/28aug86/MBK **
ptchStdEntry2
			Move.L		(SP)+,A0				; save return address
			Link		A6,#stdLink 			; stack frame
			MoveM.L 	D2-D7/A2-A4,-(SP)
			Move.L		A0,-(SP)				; push return address back on stack

			Tst.W		D0						; is it a style trap?	** <C105/28aug86/MBK **
			Beq.S		NotStyleTrap			; if not, skip this		** <C105/28aug86/MBK **

			Move.W		inHandle(A6),D0			; get the selector		** <C105/28aug86/MBK **
			LeaROM		ROMAddrTable,A0			; table of addresses	** <C105/28aug86/MBK **
			Add.W		D0,D0					; each entry is 2 bytes	** <C381/5nov86/MBK **
			Move.W		0(A0,D0),D0				; get offset to the trap** <C381/5nov86/MBK **
			Lea			0(A0,D0),A0				; get trap's addr		** <C381/5nov86/MBK **
			Move.L		A0,D3					; save addr in D3		** <C381/5nov86/MBK **

			Move.L		inHandle+2(A6),A4		; get TEHandle			** <C105/28aug86/MBK **
			Bra.S		StyleTrap
NotStyleTrap
			MoveQ		#0,D3					; use D3 as a flag		** <C105/28aug86/MBK **
			Move.L		inHandle(A6),A4 		; Pop handle into A4

; Modified to use _HGetState ** <C105/5sep86/MBK> **
StyleTrap
			Move.L		A4,A0					; set up for GetState
			_HGetState							; get handle flags
			Move.B		D0,saveHandle(A6)		; save handle flags

			Pea 		savePort(A6)			; save incoming port
			_GetPort							;

			Move.L		A4,A0					; get the TEHandle
			_HLock

			Move.L		(A4),A3 				; Dereference into A3	** <C381/8nov86/MBK **

; Do all safety related entry stuff
			Move.L		teGrafPort(A3),A2		; save "thePort" for below
			Move.L		A2,-(SP)				; set to our port
			_SetPort

; Get clip from this port into rgn defined above
			SubQ		#4,SP					; make room for clip
			_NewRgn
			Move.L		(SP),saveClip(A6)		; save user's clip in frame
			Move.L		(SP),-(SP)				; stay on stack for sectrgn below
			_GetClip							;

			Pea 		teViewRect(A3)			; clip to viewRect
			_ClipRect

; First param on stack from above.  Do not pass go. Do not collect $200
			Move.L		clipRgn(A2),-(SP)
			Move.L		(SP),-(SP)				; destination
			_SectRgn

		IF SysVers>= $700 THEN
; Set up font, etc. AFTER saving the grafport information!										<19>
			move.l		teGrafPort(a3),a0		; pt to GrafPort
			move.w		txFont(a0),saveFont(a6)	; save current font
			bclr		#7,txFace+1(a0)			; in case direction set here <30May89smb>
			move.w		txFace(a0),saveFace(a6)	; save current face
			move.w		txSize(a0),saveSize(a6)	; save current size
			pea			saveColor(a6)			; place to save color	** <C182/60ct86/MBK> **

			tst.w		teSize(a3)				; check style flag
			bmi.s		DontSet					; don't set style		** MBK 6/20/86 **

			move.l		teFontStuff(A3),txFont(A0)		; set the font/face
			move.l		teFontStuff+4(A3),txFont+4(A0)	; set the mode/size

DontSet
		ELSE
			Move.L		teGrafPort(A3),A0		; pt to GrafPort

			Tst.W		teSize(A3)				; check style flag
			Bmi.S		DontSet					; don't set style		** MBK 6/20/86 **

			Move.L		teFontStuff(A3),txFont(A0)		; set the font/face
			Move.L		teFontStuff+4(A3),txFont+4(A0) ; set the mode/size

DontSet		Move.W		txFont(A0),saveFont(A6)	; save current font
			bclr		#7,txFace+1(a0)			; in case direction set here <30May89smb>
			Move.W		txFace(A0),saveFace(A6)	; save current face
			Move.W		txSize(A0),saveSize(A6)	; save current size
			Pea			saveColor(A6)			; place to save color	** <C182/60ct86/MBK> **
		ENDIF

			Move.W		teMode(A3),txMode(A0)	; do set the mode		** <C815/13feb87/MBK **
			_GetForeColor						; for Ikki				** <C182/6oct86/MBK> **

			Move.L		teTextH(A3),A0			; get handle size

			_HGetState							; get the text handle's tag
			Move.B		D0,saveTH(A6)			; and save the flags
			_HLock								; and lock it

			_GetHandleSize						; get its size
			Move		D0,teLength(A3) 		; stuff its length

; Clean up the selection (This must be the last guy because of alternate entry)

CleanUpSel
			Move		teLength(A3),D0 		; get the text length

			Move		teSelEnd(A3),D1 		; make sure selEnd is cool
			Sub 		D0,D1					; selEnd-length
			Bls.S		okSelEnd				; if >0 then bad selend
			Move		D0,teSelEnd(A3) 		; set to length if > length
okSelEnd

			Move		teSelStart(A3),D1		; make sure selStart is cool
			Sub 		teSelEnd(A3),D1 		; selStart-selend
			Bls.S		okSelStart				; if >0 then bad selStart
			Sub 		D1,teSelStart(A3)		; set to selend if > selend
okSelStart
			jsrROM		ROMSelSort 				; I wish i could fall into it

			Tst.L		D3						; addr of style trap?	** <C105/28aug86/MBK **
			Beq.S		@2						; if not, skip this		** <C105/28aug86/MBK **

			Move.L		D3,A0					; return it in A0		** <C381/5nov86/MBK **
			Lea			inHandle+6(A6),A2		; pt to next param		** <C105/28aug86/MBK **
			Bra.S		endEntry				; that's it				** <C105/28aug86/MBK **

@2			Lea 		inHandle+4(A6),A2		; Point to next to last param
												; (1st on stack after handle)
endEntry
; dump text buffer before processing any calls <28Sept89smb>
			move.l		a0,-(sp)
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst		#teFTextBuffering,d0	; <28Sept89smb>
			beq.s		@noBuffer
			bsr			ptchDumpBuffer			;  dump text from buffer
@noBuffer	
			move.l		(sp)+,a0
			
; if the selector corresponds to TEFeatureFlag then go to patched code here <28Sept89smb>
			cmpROM		ROMTEFeatureFlag,a0
			beq.s		ptchTEFeatureFlag			
; if the selector corresponds to TEGetPoint then go to patched code here <16Nov89smb>
			cmpROM		ROMTEGetPoint,a0
			beq			ptchTEGetPoint
; if the selector corresponds to TESetStyle then go to patched code here <7Dec89smb>
			cmpROM		ROMTESetStyle,a0
			beq.s		ptchTESetStyle
			Rts
			
;----------------------------------------------------------------------
;			ptchTEFeatureFlag
;			<28Sept89smb>
;			Moved newTEFlags longword into a register for modulo 32 bit 
;			operations.
;----------------------------------------------------------------------
ptchTEFeatureFlag
			adda.l		#4,sp					; pop TEDispatch's return address
			moveq		#0,d0
			moveq		#0,d1
			move.w		(a2)+,d0				; action
			move.w		(a2)+,d1				; verb bit (which feature to affect)

			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d2		; move into reg for modulo 32 bit ops <15Sept89smb>
			clr.w		(a2)					; <6Oct89smb> necessary so the return result of 'clear' is correct.
			btst		d1,d2					; <15Sept89smb>
			sne			(a2)					; save result
			
			tst.w		d0						; whatcha wanna do?
			blt.s		@done					; action = testFlag; result already on stack
			beq.s		@clear
			bset		d1,d2					; action = setFlag <15Sept89smb>
			bra.s		@done
@clear
			bclr		d1,d2					; action = clearFlag <15Sept89smb>
@done
			move.l		d2,newTEFlags(a0)		; <15Sept89smb>
			tst.b		(a2)					; <13Sept89smb>
			beq.s		@OK
			move.w		#1,(a2)
@OK
			moveq		#10,d0					; # of bytes on stack (include selector!)
			jmpROM		ROMStdExit2
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEGetPoint
;			<16Nov89smb>	Need TEFormatOrder record due to VisibleLength
;			changes in LineWidth (which is called from here by LineRect.)
;			<7Dec89smb>		Fixed use of teForceLeft justification.
;			<16Dec89smb>	Remove TEDispatch return address from stack.
;			<1/8/90smb>		Special case of 0 length in teRec returned invalid results.
;----------------------------------------------------------------------
ptchTEGetPoint

			addq.l		#4,sp					; Clean up from ptchStdEntry jump.<16Dec89smb> 
			move.w		(a2)+,d0				; get the offset
			move.l		a2,-(sp)				; preserve parameter ptr
			move.w		d0,-(sp)				; preserve offset
			cmp.w		teLength(a3),d0			; pin it to the length
			blo.s		@LengthOK				; ok if less or same
;----------------------------------------------------------------------
; special case of 0 length and any offset: set the point to the DestRect's left/right edge and use
; the lineHeight + the DestRect's top. <1/8/90smb>
			cmpi.w		#0,teLength(a3)			; is it a 0 length record? <1/8/90smb>
			bne.s		@OffsetGELength			; bra if length <> 0 => offset >= length
; set up return point to be valid (or at least more correct than it was!)
			lea 		teDestRect+8(a3),a0 	; point past destRect
			lea 		teSelRect+8(a3),a1		; and past stack rect
			move.l		-(a0),-(a1)				; copying teDestRect to teSelRect
			move.l		-(a0),-(a1)				; copying teDestRect to teSelRect

			move		top(a1),bottom(a1)		; temporarily the same
			moveq		#0,d0					; current line
			jsrROM		ROMGetHite				; height of this line returned in d1
			add 		d1,bottom(a1)			; add line height to get bottom bound of line rect
			addq		#1,teSelRect+left(A3)	; indent for caret in case L just
			adda.l		#2,sp					; pop offset
			bra.s		@AssumeLeftJust
; finished w/ changes <1/8/90smb>			
;----------------------------------------------------------------------
@OffsetGELength

			move.w		teLength(a3),d0			; else pin to end
			move.w		d0,(sp)					; replace offset
			subq		#1,d0					; just for GetLine

@LengthOK
			lea			teLines(a3),a2			; pt to start of array
			jsrROM		ROMGetLine				; get ptr to line it's on

			with		TextFrame,TEFormatOrder	; <1Nov89smb>
			link		a6,#TextFrameSz			; for LineRect: calls FormatOrder code <1Nov89smb>
			jsrROM		ROMLineRect				; sets up selRect from destRect and justification
			unlk		a6						; <1Nov89smb>
			move.w		(a2),d6					; start of line
			move.w		(sp)+,d7				; offset to measure to

; If the last char is a CR, the h coord should be at the beginning of the next line after the CR
; (the v coord was correct, but the h was at the point preceding the CR on the previous line).
			cmp.w		teLength(a3),d7			; is offset = text length?
			bne.s		@DoEndOfLine			; skip CR test if not
			move.l		teTextH(a3),a0
			move.l		(a0),a0
			cmp.b		#returnChar,-1(a0,d7)	; if last char = CR then...
			bne.s		@DoEndOfLine
@AssumeLeftJust
; assume left justification
			move.w		teSelRect+left(a3),d0
			move.w		teJust(a3),d1
			bne.s		@DoNonLeftJust
			move.w		TESysJust,d1
			beq.s		@DoTheJustThing

@DoNonLeftJust
; <7Dec89smb> move test to teForceLeft to where it's useful!
			cmp.w		#teForceLeft,d1			; <7Dec89smb>
			beq.s		@DoTheJustThing			; <7Dec89smb>
			jmpROM		ROMinTEGetPoint			; right or center justification
@DoEndOfLine
	IF forLocalizability THEN					; fix for TEGetPoint Bug <34h-YDS-9/2/91>
			move.l		ExpandMem,a0			; do we have more then the roman script
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)
			beq.s		@romanMeas				; use MeasureIt
			link		a6,#TextFrameSz			; DoMeasure uses a stack frame 
			bsr			ptchWholeDoMeasure		; measure with LR styles
			unlk		a6
			add.w		teSelRect+left(A3),d0	; add in justification
			bra.s		@DoTheJustThing
	ENDIF
@romanMeas	jmpROM		ROM@DoEndOfLine

@DoTheJustThing
			jmpROM		ROM@DoTheJustThing
			endWith

;----------------------------------------------------------------------
;			ptchDumpBuffer
;			<28Sept89smb>
;			Added call to SetFont2Keyboard, wasn't fetching handle 
;			correctly for disposing, turned off buffering bit in newTEFlags, 
;			and fixed setup before PasteGuts call.
;			<16Nov89smb>
;			Replaced use of emBufferPtr by dereferencing emBufferHandle; misc.
;			other cleanup.
;			<7Dec89smb>	Changed d2.l to d2.w to get character at correct address.
;			<1/29/90smb> No longer call SetFont2Keyboard.
;----------------------------------------------------------------------
ptchDumpBuffer
dumpRegs	reg		d0-d7/a1-a2				; don't save a3/a4! creating a dangling ptr w/ a3 <20>

			movem.l	dumpRegs,-(sp)
			moveq.l	#0,d3
			move.l	ExpandMem,a2			; <1Feb89smb> buffer is 0 -> n-1
			lea		ExpandMemRec.emBufferLen(a2),a2		; changed to lea <12July89smb>
			move.w	(a2),d2					; buffer length, n
; test if buffer is empty
			beq		@Empty					; nothing to dump
			
; test last (n-1) character in buffer to see if is double-byte char
			subq.w	#1,d2
			move.l	ExpandMem,a1			; <1Feb89smb> pointer to buffer of chars
			move.l	ExpandMemRec.emBufferHandle(a1),a1		; <13Nov89smb>
			move.l	(a1),a1					; deref for pointer <13Nov89smb>

			movem.l	a1/d2,-(sp)				; preserve, for unstyled too!<17Sept89smb>
			tst.w	teSize(a3)				; if unstyled, can't synch font to keyboard <12Sept89smb>
			bpl.s	@NoSynch				; <12Sept89smb>
			move.w	teSelStart(a3),d0		; pass current position <12Sept89smb>
			beq.s	@ZeroOffset				; skip test if zero <12Sept89smb>
			sub.w	#1,d0					; backup one to get previous style <12Sept89smb>
@ZeroOffset
; just need to use the current position's font: no need to call SetFont2Keyboard! <1/29/90smb>
;; <1/29/90smb> 			bsr		SetFont2Keyboard		; <12Sept89smb>
			jsrROM	ROMGetCurStyle			; <1/29/90smb>
			jsrROM	ROMSetStyle				; <1/29/90smb>
			movem.l	(sp),a1/d2				; restore but don't pop yet <16Nov89smb>
@NoSynch
			clr.w	-(sp)					; room for return
			move.l	a1,-(sp)				; use a1 now not the contents of it! <13Nov89smb>
			move.w	d2,-(sp)				; offset in buffer
			_CharByte
			move.w	(sp)+,d7				; pop result
			movem.l	(sp)+,a1/d2				; restore <13Nov89smb>
			tst.w	d7						; high byte of character?
			bge.s	@GoDump					; no

; yep, gotta save it
			move.b	(a1,d2.w),d3			; changed to d2.w <7Dec89smb>
			subq.w	#1,(a2)					; new length to paste
			beq.s	@Only1Char				; short cut <13Nov89smb>
@GoDump			
; must turn off buffering bit since PasteGuts calls _TEPinScroll which calls StdEntry.
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),-(sp)
			bclr	#teFTextBuffering,newTEFlags+3(a0)
			
;setUp for buffer dump
			move.l	a1,d6					; pointer to text to insert (for PasteGuts) <13Nov89smb>
			moveq	#0,d5					; need high word cleared (for PasteGuts) <14Sept89smb>
			move.w	(a2),d5					; length of text to insert
			movem.l	d3/a1/a2,-(sp)
			moveq	#0,d7					; want to call ExtendStyle
			jsrROM 	ROMPasteGuts
			movem.l	(sp)+,d3/a1/a2

; restore buffering bit
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	(sp)+,newTEFlags(a0)

; test if need to rebuffer 1st byte of double-byte character.
			tst.b	d3						; place holder for character
			beq.s	@DeleteHandle

; last byte in buffer was 1st byte of a double-byte charaacter. Rebuffer it.
			move.b	d3,(a1)					; <13Nov89smb>
@Only1Char
			move.w	#1,(a2)					; incr length for byte
			bra.s	@Empty
			
@DeleteHandle			
; deallocate the handle
			move.l	ExpandMem,a0
			move.l	ExpandMemRec.emBufferHandle(a0),a0	; get to handle! <19Sept89smb>
			_DisposHandle
			bne		SysErr					; <19Sept89smb>
			move.w	#0,(a2)					; set buffer length to zero. Used as a flag.
	IF hasBufferingFix THEN					; 														<17>
			move.l	ExpandMem,a0			; length is initially zero so clear storage for handle	<17>
			clr.l	ExpandMemRec.emBufferHandle(a0)		; flags a disposed handle					<17>
	ENDIF									;														<17>
@Empty
			movem.l	(sp)+,dumpRegs
			rts

;----------------------------------------------------------------------
;			ptchBufferChar
;			<28Sept89smb>
;			Test the length, rather than the ptr, to determine if a byte
;			already buffered.
;			<16Nov89smb>
;			Must set the emBufferLen since it is used to determine if a 
;			char has been buffered.
;			<7Dec89smb>
;			Now using emBufferHandle for storage instead of emBufferPtr.
;			<1/9/90smb>
;			Now using TEDispatchRec for storage instead of ExpandMem.
;----------------------------------------------------------------------
ptchBufferChar
; now buffering a double-byte character in the newTEFlags space off the dispatch record. <1/9/90smb>			move.l	teDispatchH(a3),a0
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			lea			TwoByteCharBuffer(a0),a0	; move into reg for modulo 32 bit ops
			tst.b		(a0)					; test for existance of first byte
			beq.s		Empty

			move.b		1(a2),1(a0)				; 2nd byte of double byte char
			move.l		a0,D6					; pointer to 2byte character (f. PasteGuts)
			add.w		#1,D5					; length = 2 bytes (f. PasteGuts)
			bra.s		GoPaste
			
Empty											; possible first byte of 2 byte char
			move.b		1(a2),(a0)				; buffer character; 2 byte?
			tst.w		teSize(A3)				; check style flag
			bpl.S		@DontSet				; don't set style

			move.w		teSelStart(a3),d0		; pass current position
			beq.s		@1						; skip test if zero
			sub.w		#1,d0					; backup one to get previous style
@1
; On a Kanji script system when the styled teRec is created, the current grafport's font is
; the font in the initial style run of 0 characters.  If it's created with a Roman
; font and then the keyboard is switched to Japanese to enter Kanji, via the input window
; (different unstyled teRec), the font for the 0th posn is still Roman, rather than Kanji,
; when it's used here.  Hence must set the grafport via the SetFont2Keyboard code. <2Sept89smb>
			import		ptchSetFont2Keyboard
			jsr			ptchSetFont2Keyboard	; <2Sept89smb>
@DontSet
; now test with charbyte
			clr.w		-(sp)					; room for return
			move.l		d6,-(sp)				; pointer to character
			move.w		#0,-(sp)				; offset in buffer
			_CharByte
			tst.w		(sp)+					; high byte of character?
GoPaste		
			rts
;----------------------------------------------------------------------
;			ptchTEBufferText
;			<28Sept89smb>
;			Test the length to determine if a byte already buffered. Also,
;			if dumped the buffer here, loop again to add the char.
;			<16Nov89smb>
;			Must dereference the emBufferHandle rather than use the emBufferPtr.
;			<2/28/90smb> Must set d0 before calling SetFont2Keyboard.
;			<9/19/90smb> Preserve the expandmem ptr around the SetFont2Keyboard call,
;			and test if the buffer was dumped during that call. <17>
;----------------------------------------------------------------------
ptchTEBufferText
; does a pointer to a buffer already exist?	
			move.l	ExpandMem,a1						; <1Feb89smb>
;;			tst.w	ExpandMemRec.emBufferLen(a1)		; <14Sept89smb> test for zero len					<18>
			tst.l	ExpandMemRec.emBufferHandle(a1)		; test for no buffer (using handle now for consistency)	<18>
			bne.s	@HaveBuffer
@GetBuffer
			moveq	#BufferSize,d0						; longize											<17>
	IF SysVers>=$700 THEN
			bsr		ptchGetHandle						;													<20>
	ELSE
			jsrROM	ROMGetHandle						; allocate handle for buffer; in a0
	ENDIF
; dereference the handle and save
			move.l	ExpandMem,a1						; <1Feb89smb>
			move.l	a0,ExpandMemRec.emBufferHandle(a1)	; save handle
	
@HaveBuffer
; if keybd changes in the middle of buffering must dump the buffer and synch the font to the keybd. <1/26/90smb>
; must set d0 to the current position before calling SetFont2Keyboard<2/28/90smb>
			tst.w	teSize(a3)							; check style flag
			bpl.S	@DontSet							; don't set style
			move.w	teSelStart(a3),d0					; pass current position <2/28/90smb>
			beq.s	@SynchUp							; skip test if zero <2/28/90smb>
			sub.w	#1,d0								; backup one to get previous style <2/28/90smb>
@SynchUp
			import	ptchSetFont2Keyboard
			jsr		ptchSetFont2Keyboard				; <1/26/90smb>
	IF hasBufferingFix THEN								; 													<17>
			move.l	ExpandMem,a1						; reload ExpandMem ptr								<17>
; SetFont2Keyboard may have called DumpBuffer so test for a deallocated handle								<17>
			tst.l	ExpandMemRec.emBufferHandle(a1)		; is this zero?										<17>
			beq.s	@GetBuffer							; if so, then get another storage handle			<17>
	ENDIF												;													<17>
@DontSet
			move.l	ExpandMemRec.emBufferHandle(a1),a0	; get handle of storage space <13Nov89smb>
			move.l	(a0),a0								; get to storage space <13Nov89smb>
	IF hasBufferingFix THEN								; 													<17>
			moveq	#0,d0								; longize											<17>
	ENDIF												;													<17>
			move.w	ExpandMemRec.emBufferLen(a1),d0		; <1Feb89smb> length = number of bytes already in buffer
; have we maxed out on the buffer?
			cmpi.w	#BufferSize,d0
			bne.s	@MoreRoom
			bsr.s	ptchDumpBuffer
	IF hasBufferingFix THEN								; 													<17>
			tst.l	ExpandMemRec.emBufferHandle(a1)		; the high byte of a char may be in the buffer		<17>
			beq.s	@GetBuffer							; if empty then ok to get another handle			<17>
	ELSE												;													<17>
			bra.s	@GetBuffer
	ENDIF												;													<17>
@MoreRoom
			jmpROM	ROM@MoreRoom

	IF SysVers>= $700 THEN
;----------------------------------------------------------------------
;			ptchGetHandle
;			<17Jan90smb>	Allocate this handle in the System heap now
;			rather than the application's heap since it's a global buffer.									<20>
;----------------------------------------------------------------------
ptchGetHandle
			_NewHandle ,SYS,CLEAR			; allocate & clear a block in System heap now					<20>
			jmpROM	ROMinGetHandle			; back to you, ROM…
	ENDIF
;----------------------------------------------------------------------
;			ptchGetWidth
;			<14Nov89smb>	Added a fix to only measure up to the visible length.
;			<2/8/90smb>		Must patch TEWidthHook which is called here.
;			<9/20/90smb>	Call TETextWidthHook now.														<17>
;----------------------------------------------------------------------
ptchGetWidth
			tst.w	teSize(A3)				; record with style?
			bpl.s	@Unstyled				; if not, A0 is nothing
; styled text
			Move.L	teStylesH(a3),a1		; get style handle
			Move.L	(a1),a1					; dereference
			Sub.L	a1,a0					; save as offset
@Unstyled
			Move.L	a0,-(SP)				; save A0
			Move.L	teTextH(a3),a0			; get text handle
			Move.L	(a0),a0 				; dereference
			
; get start of text into a0, max(d7,d0)-d6 into d1   <27June88smb>

			add.w	d6,a0					; point at real start of text
			move.w	d7,d1					; get the end
  			
; adjust the start of the next style run to max at the end of the line <22Sept88smb>
			cmp.w	2(a2),d0				; length > end of line
			bls.s	@GotStyleEnd			; ok
			move.w	2(a2),d0				; fix it.
@GotStyleEnd

; pick the min of the style run end and the text end <26Sept88smb>
			sub.w	d6,d0					; sub start of text from end
			sub.w	d6,d1					; sub start of text from offset
			blt.s	@FullStyleRun			; d1 outside of range <26Sept88smb>

			cmp.w	d0,d1					; d1 higher than range,
	IF forLocalizability THEN				; <34k-YDS-9/2/91>
			bgt.s		@FullStyleRun		; allow measure when equal too (for R->L)
	ELSE
			bcc.s		@FullStyleRun			; bail: want to bra on equal too. <19June89smb>	<26June89smb> made unsigned
	ENDIF

; if drawing, then try this out! use textWidth for draw and C2P for caret. <21Sept88smb>
			move.l	ExpandMem,a1			; <1Feb89smb> full line flag
			tst.b	ExpandMemRec.emMeasureLine(a1)		; line width flag set?
			beq.s	@UseChar2Pixel			; no, do real stuff <22Sept88smb>

; we are measuring the whole line, BUT we only want to measure up to visible length <6Nov89smb>
			cmp.w	d0,d1					; take the minimum <6Nov89smb>
			bhs.s	@FullStyleRun			; d0 < d1, so skip <6Nov89smb>
			move.w	d1,d0					; stuff the visibleLength <6Nov89smb>

;; replaced next 4 lines <2/8/90smb>
;;@FullStyleRun
;;			jmpROM		ROM@FullStyleRun
;;@UseChar2Pixel
;;			jmpROM		ROM@UseChar2Pixel
; the rest of this routine is new as of <2/8/90smb>
@FullStyleRun
; don't test interior of style run
	IF hasTextWidthHook THEN					; 												<17>
			moveq		#0,d1					; wants offset here								<17>
			import		TETextWidthHook			;												<17>
			jsr			TETextWidthHook			; hook out TextWidth							<17>
	ELSE										;												<17>
			clr.w		-(sp)					; allocate return <21Sept88smb>
			move.l		a0,-(sp)				; pointer
			move.w		#0,-(sp)				; no first byte
			move.w		d0,-(sp)				; bytecount
			_TextWidth							; go for it
			move.w		(sp)+,d1				; got the width
	ENDIF										;												<17>
			bra			@Continue				; rejoin <21Sept88smb>
			
@UseChar2Pixel
			MoveQ		#smHilite,D2			; hilite flag <27June88smb>
			swap		d2						; hilite in high word; slop in low <27June88smb> ** <C139/22Sep86/MBK> **

			import		ptchTEWidthHook			; <2/8/90smb>
			jsr			ptchTEWidthHook			; <2/8/90smb>
@Continue
			Move.L		(SP)+,A0				; restore A0

			Tst.W		teSize(A3)				; record with style?
			Bpl.S		@done					; if not, A0 is nothing

			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1					; dereference
			Add.L		A1,A0					; restore as pointer
@done
			Rts

;----------------------------------------------------------------------
;			ptchGetRLPosition
;			<20Nov89smb>
;			Test if the CR is at the end of the document by checking if
;			at end of lineStarts array. This is necessary since we're 
;			using 2(a2) as a condition for getting the next style run. However,
;			if there isn't another style run, we read random memory and 
;			sometimes crash!  Called only by CaretDisplay.
;			<9/20/90smb>	Patched to call ptchMeasureWholeRun for
;			TextWidth hook.
;----------------------------------------------------------------------
ptchGetRLPosition
RLPosnRegs	reg		a0
			with 	SharedFrame,TEFormatOrder
			movem.l	RLPosnRegs,-(sp)
			sf		doneFlag(a6)
			clr.w	highCaret(a6)				; set lineEndFlag and highCaret to F. <6mar89smb>
			st		gotOneRun(a6)
			clr.l	d2							; used for direction params for C2P
			
; save original edges of selection rectangle
			move.l	a2,-(sp)
			lea		teSelRect+top(a3),a1
			lea		selRectT(a6),a2
			move.l	(a1)+,(a2)+
			move.l	(a1)+,(a2)+
			move.l	(sp)+,a2
			
			tst.b	onBoundaryFlag(a6)			; cursor on boundary of run
			beq		@InRLMiddle
			tst.w	teSize(a3)					; need to test if on a block boundary for
			bpl		@InRLMiddle					; old-styled TE <1Dec88smb>	

; on a boundary so must test scripts of surrounding style runs (backing-store order) to 
; determine if on a cluster boundary.
			jsrROM	ROMGetDirection				; get this style run's direction in byte of d1 <7June89smb>
			tst.b	prevStyleFlag(a6)			; test if at end or beginning of cursor style run
			beq.s	@GotCursorStyle
			
; got script for style run previous to cursor style run
			move.b	d1,previousScriptDir(a6)	; <7June89smb>
			
; test for EOL cluster boundary since in previous style run <8Nov88smb>
			cmp.w	2(a2),d3					; is cursor posn at EOL?
			beq		@LineEnd

; if already at EOL then make sure not looking beyond lineStarts array <20Nov89smb>
			move.l	a0,-(sp)
			lea		2(a2),a0
			lea		teLines(a3),a1				; <20Nov89smb>
			move.w	teNLines(a3),d0				; get num of lines <20Nov89smb>
			add.w	d0,d0						; double for words <20Nov89smb>
			adda.w	d0,a1						; <20Nov89smb>
			cmpa.l	a1,a0						; <20Nov89smb>
			movem.l	(sp)+,a0					; <20Nov89smb>
			bgt.s	@LineEnd					; bra if beyond end <20Nov89smb>

	IF forLocalizability   THEN                 ; <34a-YDS-9/2/91> - big apple link bug                                          <3>
												; had to patch since we call SetUp2Rectangles 
; truly in the lineStarts array!
			move.l	a0,-(sp)					; save <21June89smb>
			addq.l	#stStartSize,a0				; in previous style run, so need next style run
			bra.s	@GetScript
								
@GotCursorStyle
; got script for cursor style run
			move.b	d1,cursorScriptDir(a6)		; <7June89smb>
; test for BOL cluster boundary since in cursor style run <8Nov88smb>
			cmp.w	(a2),d3						; is cursor posn at BOL?
			beq.s	@LineEnd
			move.l	a0,-(sp)					; save <21June89smb>
			subq.l	#stStartSize,a0				; at beginning so need to check previous style run
			
@GetScript
; get the other style run's direction (in display order!)
			jsrROM	ROMGetDirection				; <7June89smb>
			tst.b	prevStyleFlag(a6)
			beq.s	@GotPrevStyleNow
			move.b	d1,cursorScriptDir(a6)		; <7June89smb>
			bra.s	@CmpDirs					; <7June8smb>
			
@GotPrevStyleNow
			move.b	d1,previousScriptDir(a6)	; <7June89smb>
			
@CmpDirs
			move.l	(sp)+,a0					; restore <21June89smb>
; compare scripts to see if on a cluster boundary
			move.b	cursorScriptDir(a6),d0
			cmp.b	previousScriptDir(a6),d0
			bne.s	@ClusterBoundary
; same script so display one cursor
			jsrROM	ROMOneCursor				; added for simplicity <12/13/88smb>
			bra.s	@done						; <12/13/88smb>
			
;**********************
			
@ClusterBoundary
; on a cluster boundary: need split cursors			
			tst.b	prevStyleFlag(a6)
			beq.s	@GetScriptDirection			; in cursor script
			move.b	previousScriptDir(a6),d0

@GetScriptDirection
			move.b	d0,scriptDirection(a6)
			cmp.b	TESysJust,d0				; added <22Dec88smb>
			bne.s	@DiffDirections				; added <22Dec88smb>
			st		highCaret(a6)				; added <22Dec88smb>
@DiffDirections
			tst.b	d0
			bne.s	@RLScript
@LRScript
; if in previous style and LR script direction then measure since at end of style run
; if in cursor style, width is 0 since at beginning of run so, have width to use <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@MeasureRun					; bra to measure if in prevStyle's run
			bra.s	@SetUpTwoRects
@RLScript
; if in cursor style and RL script direction then measure since at beginning of style run
; if in previous style and RL script direction AND
;	 if RL flow, width is 0 since at end of run, so have width to use  <7Nov88smb>
;	 if LR flow, then measure since at beginning of RL script run <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@SetUpTwoRects				; bra to measure since in prevStyle's run <12July89smb>
			
@MeasureRun
			import	ptchMeasureWholeRun
			jsr		ptchMeasureWholeRun
			add.w	d0,d5

@SetUpTwoRects
; Setup two rectangles for the split cursors.
			bsr.s	ptchSetUp2Rectangles			; moved init of rects into proc <12July89smb>
			bra.s	@done

	ELSE		
			jmpROM	ROMinGetRLPosn
@GotCursorStyle
			jmpROM	ROM@GotCursorStyle
	ENDIF

@LineEnd	jmpROM	ROM@LineEnd
@InRLMiddle	jmpROM	ROM@InRLMiddle

	IF forLocalizability  THEN                    ; <34a-YDS-9/2/91>                                        <3>
@done		jmpROM	ROM@RLDone
	ENDIF

	IF forLocalizability   THEN                    ; <34a-YDS-9/2/91>                                         <3>
;----------------------------------------------------------------------
;
;			ptchSetUp2Rectangles
;			34a-YDS-9/2/91> - patched to fix big apple link bug
;
;----------------------------------------------------------------------
ptchSetUp2Rectangles

			with	SharedFrame,TEFormatOrder

			add.w	d5,teSelRect+left(a3)		; left edge of rectangle
			add.w	d5,teSelRect+right(a3)		; right edge of rectangle
; Use half a line heighth for split cursors.
			move.w	teSelRect+bottom(a3),d2
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance
			asr.w	#1,d2						; 1/2 line height - fix Applink bug <3.1> 
			jmpROM	ROMinSetUp2Rectangles	
	ENDIF

;----------------------------------------------------------------------
;			PROCEDURE ptchGetLRPosition
;			<2/8/90smb>	Must patch TEWidthHook which is called here.
;----------------------------------------------------------------------
ptchGetLRPosition
			move.l	a0,-(sp)	
; call Char2Pixel to get the pixel position for the cursor
			move.l	teTextH(a3),a1				; get text handle
			move.l	(a1),a1 					; dereference
			add.w	startChar(a0),a1			; add beginning of the style run to get to desired line
			exg		a1,a0						; C2P wants text ptr here

; test if style run begins on previous line, and if so adjust text ptr & offset posn in run
			moveq	#0,d4
			move.w	(a2),d0
			cmp.w	startChar(a1),d0
			bls.s	@StyleStartOK				; <26June89smb> made unsigned
; pin to lineStart
			sub.w	startChar(a1),d0			; |begin of line - begin of style run|
			add.w	d0,a0						; fix text ptr
			move.w	d0,d4						; save difference for length adjustment
			move.w	d3,d1						; cursor posn: C2P wants offset here
			sub.w	(a2),d1						; offset from start of line
			bra.s	@getLength
			
@StyleStartOK
			move.w	d3,d1
			sub.w	startChar(a1),d1			; cursor posn relative to start of style run

@getLength
; test if style run ends on next line, and if so, pin to end of this line & adjust length
			move.l	a0,-(sp)					; <6Mar89smb>
			move.l	a1,a0						; <6Mar89smb>
			jsrROM	ROMFixFormatEnd				; <6Mar89smb>
			move.l	(sp)+,a0					; <6Mar89smb>
			cmp.w	2(a2),d0
			bls.s	@UseStyleEnd				; <26June89smb> made unsigned
			move.w	2(a2),d0					; pin to line end
			
@UseStyleEnd
			sub.w	startChar(a1),d0			; length of style run
			sub.w	d4,d0						; adjust for lineStart
			
			swap	d2							; direction:slop

			import	ptchTEWidthHook				; <2/8/90smb>
			jsr		ptchTEWidthHook				; returns in d1 <2/8/90smb>
			move.l	(sp)+,a0
			rts


	IF forLocalizability THEN
;----------------------------------------------------------------------
;
;			ptchOnLineEnd
;
;			<34a-YDS-9/2/91> had to patch it to fix big carret bug.
;
;----------------------------------------------------------------------
			
ptchOnLineEnd	
			with	SharedFrame,TEFormatOrder
			
; at EOL/BOL. Is the style run of different persuasion then the line direction? <8Nov88smb>
			jsrROM	ROMGetDirection				; <30May89smb>
			cmp.b	TESysJust,d1				; test if TESysJust = script direction <30May89smb>
			bne.s	@EOLClusterBoundary			; if not then on a EOL cluster boundary

; on a line end but the style run has the same direction as the line, so only one cursor.
			st		doneFlag(a6)				; modified <12/13/88smb>
			tst.b	d1							; <30May89smb>
			bne.s	@RLDirection
			
; LR direction
; if in previous style and LR script direction, then measure since at end of style run
; if in cursor style, width is 0 since at beginning of run, so have width to use <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne		@MeasureRun					; bra to measure if in prevStyle's run
			bra		@finis
			
@RLDirection
; if in cursor style and RL script direction then measure since at beginning of style run
; if in previous style and RL script direction AND
;	 if RL flow, width is 0 since at end of run so, have width to use  <7Nov88smb>
;	 if LR flow, then measure since at beginning of RL script run <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			beq		@MeasureRun					; bra to measure if in cursor's run
			tst.b	TESysJust
			beq		@MeasureRun					; LR flow but RL script
			bra		@finis
			
;***********

@EOLClusterBoundary	
; on a cluster boundary at a line end => script direction different from line direction.
; need split cursors
			tst.b	d1							; <30May89smb>
			beq.s	@LRdirection
; RL script direction
			cmp.w	2(a2),d3
			beq.s	@AtDisplayR					; bra if d3 = lineEnd
			bra.s	@AtDisplayL					; d3 = lineStart
			
@LRdirection
; LR script direction
			cmp.w	(a2),d3
			beq.s	@AtDisplayR					; bra if d3 = lineStart
;-----------------------------------------------------------------------------------------			
@AtDisplayL
; at left end of display line
; if in LR flow, RL script direction, at BOL, OR if in RL flow, LR script direction, at EOL then 
;	1st cursor at left edge of screen (high caret) and
;	2nd cursor at measured end of this style run (low caret)

			move.w	selRectL(a6),teSelRect+left(a3)		; 1st cursor at L. edge
			move.w	selRectL(a6),teSelRect+right(a3)
			
; measure style run for second cursor
			import	ptchMeasureWholeRun
			jsr		ptchMeasureWholeRun
			add.w	d0,d5
			st		doneFlag(a6)
			st		lineEndFlag(a6)
; use half a line heighth for split cursors
			move.w	teSelRect+bottom(a3),d2
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance
			asr.w	#1,d2						; 1/2 line height - fix Applink bug  
			move.w	d2,teSelRect+bottom(a3)		; new bottom (raised by 1/2 the heighth) <12July89smb>
			
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
; The high cursor (T) goes with the line ending. the top edge is ok. Adjust the bottom. Can only
; set the top and bottom edges now.  May need to measure more style runs. <12/13/88smb>
			lea		ExpandMemRec.emCursor2Rect(a0),a0		;  top, left, bottom, right <12July89smb>
			move.w	teSelRect+bottom(a3),(a0)+	; top edge
			addq	#2,a0
			move.w	selRectB(a6),(a0)			; use original bottom
			bra.s	@finis
;-----------------------------------------------------------------------------------------
@AtDisplayR
; at right end of display line
; if in LR flow, RL script direction, at EOL, OR if in RL flow, LR script direction, at BOL then 
;	1st cursor at present measured width (low caret) and
;	2nd cursor at end of all style runs on the display line (high caret) (continue measuring till out of runs)

			add.w	d5,teSelRect+left(a3)				; 1st cursor at present measured width
			add.w	d5,teSelRect+right(a3)
			
; Setup two rectangles for the split cursors. The low cursor goes with this script run. So, 
; adjust the top edge of the rectangle. <12/13/88smb>

			st		lineEndFlag(a6)
; use half a line heighth for split cursors
			move.w	teSelRect+bottom(a3),d2
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance
			asr.w	#1,d2						; 1/2 line height - fix Applink bug <3.1> 
			move.w	d2,teSelRect+top(a3)		; new top (lower by 1/2 the heighth) <12July89smb>
			
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
			
; say high caret in Cursor2Rect space <21Dec88smb> - for TESelView
			ori.w	#$00FF,ExpandMemRec.emTwoCursorsFlag(a0)
			
; The high cursor (T) goes with the line ending. the top edge is ok. Adjust the bottom. Can only
; set the top and bottom edges now.  May need to measure more style runs. <12/13/88smb>
			lea		ExpandMemRec.emCursor2Rect(a0),a0		;  top, left, bottom, right <12July89smb>
			move.w	selRectT(a6),(a0)+			; use original top of line
			addq	#2,a0
			move.w	teSelRect+top(a3),(a0)		; bottom edge
			bra.s	@finis
@MeasureRun
			import	ptchMeasureWholeRun
			jsr		ptchMeasureWholeRun
			add.w	d0,d5
			add.w	d5,teSelRect+left(a3)		; left edge of rectangle
			add.w	d5,teSelRect+right(a3)		; right edge of rectangle
@finis
			rts
			endwith
			
	ENDIF


;----------------------------------------------------------------------
;			PROCEDURE ptchCaretInsideRun
;			<7Dec89smb>	Set flags in caret display code to indicate when
;			in the middle of a style run but on a line end.
;			<2/8/90smb>	Must patch TEWidthHook which is called from PixelWidths.
;			<4/4/90smb> Adding forgotten code for scrolling down bug fix!
;			<9/6/90smb>	Revisited scrolling down bug: must also bra if equal.
;----------------------------------------------------------------------
ptchCaretInsideRun
			with 	SharedFrame,TEFormatOrder
; cursor is in the middle of this run, so call C2P twice to see if split cursors necessary
			st		doneFlag(a6)
			move.w	#smRightCaret,d2			; second offset to measure
			swap	d2
			move.w	#smLeftCaret,d2				; first offset to measure
			
; parameters for PixelWidths routine (calls Char2Pixel twice)
			move.l	a0,a1						; save pointer to current style run
			move.w	d5,-(sp)					; save pixel width from MeasureAndHilite routine
			move.w	d3,d0
			sub.w	startChar(a1),d0			; cursor posn relative to start of style run
; pin to lineStart <5Dec88smb>
			move.w	(a2),d1						; lineStart <5Dec88smb>
			cmp.w	startChar(a1),d1			; <5Dec88smb>
			bls.s	@UseStyleStart				; <5Dec88smb> 			<26June89smb> made unsigned
			sub.w	startChar(a1),d1			; |beginning of line - beginning of style run| <5Dec88smb>
			sub.w	d1,d0						; pin to lineStart! <5Dec88smb>
; may be at lineStart
			bne.s	@UseStyleStart				; <6Dec89smb>
; if at offset 0 of this line then at the lineStart and may need to measure more style runs <6Dec89smb>
			sf		doneFlag(a6)				; <6Dec89smb> 
			st		lineEndFlag(a6)				; <6Dec89smb>
@UseStyleStart
;;<2/8/90smb>			jmpROM	ROM@UseStyleStart
; added 2 more lines since patching PixelWidths
			move.w	d0,d1						; same posn just different direction
			import	ptchPixelWidths				; <2/8/90smb>
			bsr		ptchPixelWidths				; returns pixelwidths in d5 (R block) & d6 (L block)
;;<4/490smb>			jmpROM	ROMbeyond@UseStyleStart
;-----------------------------------------------------------------------------------------
; adding omitted code for scrolling down bug fix! <4/4/90smb>
; <3May89smb> this is a special case that makes this UGLY! If LR text and RL line direction
; and (offset = SOL or EOL), then must setup teSelRect a little differently with the 
; results returned from C2P.
			tst.b	TESysJust
			beq.s	@LRdownstream
; RL line direction. a0 contains the current style.
			jsrROM	ROMGetDirection				; returns script direction in d1
			cmp.b	TESysJust,d1
			beq.s	@RLdownstream				; RL line direction & RL script run
; Otherwise, RL line and LR script
			cmp.w	d5,d6
			beq.s	@RLdownstream
			tst.w	d5
			beq.s	@ZeroWidth
			exg		d5,d6						; want 0 width in d5: L&R edges are already set in teSelRect. 
@ZeroWidth
			add.w	(sp),d6
			bra.s	@SetUp2nd					; set up the second rectangle
			
; test line direction to determine where high caret and low caret should display. <12/13/88smb>
;;			tst.b	TESysJust
;;			bne.s	@RLdownstream
; <3May89smb> done with mods.

; L-R is the downstream direction. d6 is the L block's width. <12/13/88smb>
; Want downstream script's width in d5.  Simplifies set up for second rectangle.
@LRdownstream
			exg		d5,d6
@RLdownstream
; R-L is the downstream direction. d5 is the R block's width. <12/13/88smb>
			add.w	(sp),d5						; add pixel width of previous runs on line				
			add.w	d5,teSelRect+left(a3)
			add.w	d5,teSelRect+right(a3)
			add.w	(sp),d6
; test for one cursor
			cmp.w	d5,d6
			beq.w	@finis
			
; Setup two rectangles for the split cursors.
; The high cursor (T): the top edge is ok. Adjust the bottom. <12/13/88smb>
; use half a line heighth for split cursors
@SetUp2nd
			move.w	teSelRect+bottom(a3),d2
			
	IF NOT forLocalizability THEN				; <34a-YDS-9/2/91>
			bls.s	@ScrollDownBug				; scrolling down in hebrew applelink <1/15/90smb> <14>
	ENDIF
			
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance

	IF forLocalizability THEN					; <34a-YDS-9/2/91>
			asr.w	#1,d2						; 1/2 line height - fix Applink bug <3.1> 
	ELSE
			lsr.w	#1,d2						; 1/2 line height
	ENDIF

			move.w	d2,teSelRect+bottom(a3)		; new bottom (raised by 1/2 the heighth) <12July89smb>
			
; need two cursors because have arabic/english in same run OR on a cluster boundary
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
; <7July89smb> indicate that high caret is not stored in ExpandMem space.
			andi.w	#$FF00,ExpandMemRec.emTwoCursorsFlag(a0)

; set up low cursor (perpendicular symbol). <12/13/88smb>	
; top edge of rectangle
			lea		ExpandMemRec.emCursor2Rect(a0),a0	;  top, left, bottom, right <12July89smb>
			move.w	teSelRect+bottom(a3),(a0)+	; new top of line (same as other rect's bottom edge)
			add.w	selRectL(a6),d6				; add original L. edge
			move.w	d6,(a0)						; left
			sub.w	#1,(a0)+					; cursor posn
			move.w	selRectB(a6),(a0)+			; use original bottom of line
			move.w	d6,(a0)						; right (same as left)


	IF forLocalizability THEN
												;YS  - added to support single carret option 
												; handles unstyled text !!!! <34c-YDS-9/2/91>
			clr.l	-(sp)						; make space for function result
			move	#smGenFlags,-(sp)			; put smSysScript verb to get the SMGR general flags
			_GetEnvirons						; now wh have the general flags 
			Move.l	(sp)+, d5					; take return value.
			and.l	#(1<<smfDualCaret),d5		; leave only the right bit
			bne.w	@finis						; leave the split carret as is ?

			clr.l	-(sp)						; we will need a place on the stack anyway !
			Tst.b	teCarOn(A3)					; if caret on, we would like to calculate the same caret allways
			bne.s	@1							; carret is going on, calculate a new one <34p-YDS-9/2/91>
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	lastScript(a0),d5 			; push script numberused to highligt (d5) to lastScript
			bra.s	@2
			
@1			move	#smKeyScript,-(sp)			; we will call _GetEnvirons to get the current active (keyboard) script.
			_GetEnvirons						; now we know who the active script
			Move.l	(sp), d5					; take return value (the script number (long !!!)), leave place for return value
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	d5, lastScript(a0)			; push script numberused to highligt (d5) to lastScript

@2			move.w	d5, -(sp)					; push the script (word !!!) for the next call we will need
			
			move	#smScriptRight,-(sp)		; is that script a right to left script  ?
			_GetScript							; we have smScriptRightflag the stack
			move.l	(sp)+, d0					; do = result
			move.l	ExpandMem,a0				; get the scplit cursor addres into A0
			lea		ExpandMemRec.emCursor2Rect(a0),a0
			cmp.b	TESysJust, d0
			beq.s	@UseTop
@UseBottom
			move.w	teSelRect+top(a3),top(a0)	; strech lower cursor
			move.w	teSelRect+top(a3),teSelRect+bottom(a3)	; make top = bottom in upper cursor
			bra.s	@finis
@UseTop	
			move.w	bottom(a0),teSelRect+bottom(a3) ; strech upper cursor
			move.w	bottom(a0),top(a0)			; make top = bottom in lower cursor
	ENDIF


@finis
			addq.l	#2,sp						; restore stack (d5 pushed)
			rts
	IF NOT forLocalizability THEN				; <34a-YDS-9/2/91>
@ScrollDownBug
; when scrolling down the selRect top & bottom are negative. this causes a large caret while divided
			move.l	ExpandMem,a0				; <1/15/90smb>
			sf		ExpandMemRec.emTwoCursorsFlag(a0)	; <1/15/90smb>
			addq.l	#2,sp						; restore stack (d5 pushed)
			rts
	ENDIF
			endwith

	ENDIF

;----------------------------------------------------------------------
;			PROCEDURE ptchTrimMeasure
;			<7Aug89smb>	 Added SMgr VisibleLength for trimming white space
;			off the display right of a line.
; 			<31Oct89smb> Fixed TETrimMeasure to call VisibleLength at the 
;			appropriate times for unstyled text: LineRect uses the line direction
;			and justification to determine when to call it.
;----------------------------------------------------------------------
ptchTrimMeasure

	IF Scripts604 | SysVers>= $605 THEN
; <31Oct89smb>
; We need to strip off trailing spaces IF they are trailing in display order (on the L. in a
; R-L line and on the R. in a L-R line.)
; if the line direction = teJust (corrected for teSysJust), then go directly to MeasureIt.
; if teJust = teJustCenter OR teJust = teJustLeft, skip

			cmp 	d6,d7					; nothing to measure? <31Oct89smb>
			bls		zeroExit				; <31Oct89smb>
			move.w	teJust(a3),d0			; <31Oct89smb>
			bge		@MeasureIt				; <31Oct89smb>
; if teJust = teSysJust, skip
			cmp.w	teSysJust,d0			; <31Oct89smb>
			beq		@MeasureIt				; <31Oct89smb> implies teSysJust = RL
; ow, the line direction = LR and teJust = right
			tst.b	WordRedraw				; test if Arabic installed w/ line direction LR
			beq		@RomanTrim				; bra for Roman

;----------------------------------------------------------------------
; Adding call to GetStylesInOrder in order to call VisibleLength for a line's style runs.
; We need to traverse the style runs in display order but backwards! This is because it's 
; possible to have style runs at the end of a line containing only blanks (silly but true!)
			with	TextFrame,TEFormatOrder
			move.l	d5,-(sp)
			clr.w	d5						; flag that signifies we are done w/ VisibleLength
			move.w	d6,-(sp)				; save original lineStart
			tst.w	teSize(a3)				; do something different for unstyled! <7Nov89smb>
			bmi.s	@GetStyles				; bra if styled edit record
			
; old-style record: one style for the whole record.  My code is expecting a0 to contain a ptr to 
; the startChar for the current style so must fake the setup.
			clr.l	firstStyleRun(a6)
			clr.l	secondStyleRun(a6)
			move.w	teLength(a3),secondStyleRun(a6)
			lea		firstStyleRun(a6),a0
			move.l	a0,a2StyleRun(a6)		; save style run of lineStart as a ptr 
;;<16Nov89smb>			move.w	#1,d2
;;<16Nov89smb>			move.w	d2,numberOfRuns(a6)		; save
; cleared since don't need to go thru initial @styleLoop code. <16Nov89smb>
			clr.w	d2						;<16Nov89smb>
			clr.w	numberOfRuns(a6)		;<16Nov89smb>

			lea.l	fmtOrdering(a6),a1
			move.l	a1,fmtOrderingPtr(a6)
;;<16Nov89smb>			move.w	#1,fmtOrderingIndex(a6)	; decrement below @styleLoop
			clr.w	fmtOrderingIndex(a6)	;<16Nov89smb>
			clr.w	(a1)
;;<16Nov89smb>			bra.s	@styleLoop	
			bra.s	@UnStyled				;<16Nov89smb>
			
@GetStyles
			move.w	d6,d0					; start of selection
			move.w	d7,d1					; end of selection
			bsr		ptchTEGetFormatOrder		

			move.w	numberOfRuns(a6),d2
			move.w	d2,fmtOrderingIndex(a6)	; start w/ the last style run
;----------------------------------------------------------------------
@styleLoop
			subq	#1,fmtOrderingIndex(a6)	; decr the style run counter			
			bsr		ptchGetNextDisplayStyle		
			subq	#1,d2					; dec the style counter

;;<16Nov89smb>			tst.w	teSize(a3)				; record with style?
;;<16Nov89smb>			bpl.s	@UnStyled				; if not, go do it the old way
			jsrROM	ROMSetStyle				; set current style
@UnStyled
; If we've already found the first (or visibly last) non-blank style run on the line, the flag
; will be set and we need to loop to determine if this is the greatest style run offset. <7Dec89smb>
			tst.b	d5							; <7Dec89smb>
			bne.s	@GetStyleEnd				; yep  <7Dec89smb>
; must be blanks on the line end <7Dec89smb>
;----------------------------------------------------------------------
; call VisibleLength to correctly determine the text to measure
			movem.l	d2/a0/a2,-(sp)
; pin to style run boundaries
			move.w	startChar(a0),d6
			jsrROM	ROMFixFormatEnd			; if last format run, must decrement end offset

			move.l	teTextH(a3),a0			; get text handle
			move.l	(a0),a0 				; dereference

			add.w	d6,a0					; set to LineStart
			sub.w	d6,d0	
			clr.l	-(sp)					; longint return
			move.l	a0,-(sp)				; textPtr
			swap	d0						; clear high word
			clr.w	d0
			swap	d0
			move.l	d0,-(sp)				; textLen
			_VisibleLength
			
			move.l	(sp)+,d7				; length of visible text
			movem.l	(sp)+,d2/a0/a2
			beq.s	@LoopExit				; if all blanks, keep looping
;----------------------------------------------------------------------
			add.w	d6,d7					; non-blank => done; get real position
; set flag in high word saying done w/ VisibleLength
			st		d5 
@GetStyleEnd
; Once we encounter a non-blank style run, we need to loop through all the previous style runs
; on the line, searching for the largest end offset that is larger then the VisibleLength offset.
; Get the maximum of the style run's end offset and the visibleLength offset.
; per Mark Davis. I'm a believer now! <6Dec89smb>
; d7 = visibleLength initially; is replaced by the end offset of a style run which is larger.
; a0 = ptr to current style run
			jsrROM	ROMFixFormatEnd			; if last format run, must decrement end offset
			cmp.w	d0,d7
			bge.s	@LoopExit				; VisibleLength is the larger, keep looping
			move.w	d0,d7					; prev style run is max.
;----------------------------------------------------------------------
; if all blanks, keep looping
@LoopExit
			tst.w	d2						; more styles?<1Nov89smb>
			bne.s	@styleLoop				; yes, loop again
			move.w	(sp)+,d6				; restore original lineStart 
			move.l	(sp)+,d5
@MeasureIt
			jmpROM	ROMMeasureIt			; if all blanks on this line, will terminate in MeasureIt

@RomanTrim
			jmpROM	ROM@RomanTrim
zeroExit
			moveq		#0,D0				; nothing to measure
			Rts
			endWith
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	ELSE
; If a Roman system then use old TrimMeasure code rather than SMgr VisibleLength <2Aug89smb>
			tst.b	teSysJust
			bne.s	@VisLen					; use VisibleLength for RL line direction
			tst.b	WordRedraw				; test for Arabic w/ line direction LR
			beq.s	@RomanTrim				; bra for Roman

; Use SMgr VisibleLength to measure visible text <2Aug89smb>
@VisLen
			move.l	teTextH(A3),A0			; get text handle
			move.l	(A0),A0 				; dereference

			add.w	d6,a0					; set to LineStart
			sub.w	d6,d7
			clr.l	-(sp)					; longint return
			move.l	a0,-(sp)				; textPtr
			swap	d7						; clear high word
			clr.w	d7
			swap	d7
			move.l	d7,-(sp)				; textLen
			_VisibleLength

			move.l	(sp)+,d7				; length of visible text
			add.w	d6,d7					; get real position
			jmpROM	ROMMeasureIt
@RomanTrim
			jmpROM	ROM@RomanTrim
	ENDIF
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	IF hasTextWidthHook THEN					;													<17>
;----------------------------------------------------------------------
;			PROCEDURE ptchDoErase
;			<9/20/90smb>	New. Call TETextWidthHook now.
;----------------------------------------------------------------------
ptchDoErase
			with		TextFrame,TEFormatOrder
			Move.W		teSelRect+left(A3),-(SP) ; save left side for draw
			Cmp.W		(A2),D3					; at start of line?

			Beq.s		@GoErase				; don't worry if so

; If the mode is XOR, we must erase the previous character as well as redrawing it.
; Redrawing the character in XOR without erasing it first just erases it.  This means
; the italics problem will not be fixed in this mode.
			Cmp.W		#srcXor,teMode(A3)		; is drawing mode XOR?
			Beq.s		@GoErase				; do it the old way if so

			Tst.W		teSize(A3)				; TERec with style?
			Bpl.S		@MeasureChar			; skip style setup if not

; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge.s		@getStyleOld			; nope, only L->R directional text

			Move.W		D3,D0					; start offset
			Move.W		D4,D1					; end of selection
			bsr			ptchGetStylesInOrder	; <15Nov88smb>
			bra.s		@SetPort
			
@getStyleOld
			Move.W		D3,D0					; selection start
			Move.W		D0,D1					; don't care about end
			jsrROM		ROMGetCurStyle			; get its style	<7Oct88smb> replaces GetFirstStyle call
			jsrROM		ROMGetNumStyles			; # of styles between offsets <7Oct88smb>
@SetPort
			jsrROM		ROMSetStyle				; set the port
@MeasureChar
			move.l		teTextH(a3),a0			; text handle									<17>
			move.l		(a0),a0					; wants text ptr here							<17>
			move.w		d3,d1					; wants offset here								<17>
			moveq		#1,d0					; wants length here								<17>
			import		TETextWidthHook			;												<17>
			jsr			TETextWidthHook			; hook out TextWidth							<17>

; Don't want to erase the prev character because that destroys part of the character
; before it (if it's italics or a kerned font).  However, the last pixel should be erased
; in case the application leaves a caret drawn there (like Mac3D does).
			Tst.W		D0						; nothing to do if no width			** <C485/04dec86/MBK> **
			Beq.S		@ZeroWidth				; else subtract one from char width	** <C485/04dec86/MBK> **
			SubQ.W		#1,D0					;	to fix caret erase problem		** <C485/04dec86/MBK> **
@ZeroWidth	jmpROM		ROM@ZeroWidth			;												<17>
@GoErase	jmpROM		ROM@GoErase				;												<17>
			endWith
	ENDIF										;												<17>
			ENDPROC							; one proc since many interdependencies <9Aug89smb>
	





	IF Scripts604 | SysVers>= $605 THEN
;----------------------------------------------------------------------
;			PROCEDURE ptchMeasureWidth
;			<29Aug89smb> A bug occurs in hilighting when the line direction
;			is RL on a system whose normal line direction is from L-R. The
;			code does not completely determine if its done measuring style
;			runs for hiliting.
;			<17Dec89smb> Have to patch a bug in HiliteMiddle.
;			<9/20/90smb>	Patched to call ptchMeasureWholeRun for
;			TextWidth hook.
;----------------------------------------------------------------------
ptchMeasureWidth	PROC	EXPORT
			import	ptchHiliteMiddle
			with	SharedFrame,TEFormatOrder

; is this d3's style run?
			move.w	styleRunIndex(a6),d0
			cmp.w	d3FmtIndex(a6),d0
			beq.s	@MeasureD3Run
			tst.b	sameStyle(a6)
			bne		@justMeasure				; bra if [d3,d4] in same style
			
; is this d4's style run?
			cmp.w	d4FmtIndex(a6),d0
			beq.s	@MeasureD4Run
			blt.s	@inBetween					; bra to check if inbetween d3 & d4 runs
			jmpROM	ROM@justMeasure				; not to be hilited: just measure <17Dec89smb> changed to jmpROM
			
@MeasureD3Run
; measure [d3,end of style]
			move.w	d3,saveD3(a6)
			move.w	d4,saveD4(a6)
			tst.b	sameStyle(a6)
			bne.s	@TestDirection				; when in RL text may need to measure the rest of the line
			jsrROM	ROMFixFormatEnd
			move.w	d0,d4
			bra.s	@dontQuit
			
@MeasureD4Run
; measure [begin of style,d4]
			move.w	d3,saveD3(a6)
			move.w	d4,saveD4(a6)
			move.w	startChar(a0),d3
@TestDirection
			tst.b	teSysJust					; RL line direction (Roman, Kanji or Arabic)? <29Aug89smb>
			bne.s	@dontQuit					; yep, not done at this style run <29Aug89smb>
			tst.b	WordRedraw					; <4Oct89smb
			blt.s	@dontQuit					; <4Oct89smb
;------------------------------------------------
; added <17Dec89smb> to patch HiliteMiddle
@hiliteIt
			st		doneFlag(a6)				; once hilited d4 
@dontQuit
			tst.b	hiliteInbetween(a6)
			beq.s	@HiliteOffsetRun			; nothing inbetween: just hilite the offset's run
			bsr		ptchHiliteMiddle			; hilite runs prior to offset run, then the offset run <17Dec89smb>
			jmpROM	ROM@HiliteOffsetRun
			
@inBetween
; test if style run in between d3 and d4's style runs!
			cmp.w	d3FmtIndex(a6),d0
			bhi.s	@hiliteRun					; bra to be hilited		<26June89smb> made unsigned
			
; not inbetween therefore, only measure. don't hilite
		IF hasTextWidthHook THEN				;												<17>
			import	ptchMeasureWholeRun			;												<17>
			bsr		ptchMeasureWholeRun			;												<17>
		ELSE									;												<17>
			jsrROM	ROMMeasureWholeRun
		ENDIF									;												<17>
			add.w	d0,totalWidth(a6)
			tst.b	hiliteInbetween(a6)
			beq.s	@exit
			bsr		ptchHiliteMiddle			; hilite runs prior to non-hilited run <17Dec89smb>
			move.w	totalWidth(a6),d0
			add.w	d0,anchorL(a6)				; new left anchor
			jmpROM	ROM@exit
			
@justMeasure	jmpROM	ROM@justMeasure
@HiliteOffsetRun
			jmpROM	ROM@HiliteOffsetRun
@hiliteRun	jmpROM	ROM@hiliteRun
@exit		jmpROM	ROM@exit

;------------------------------------------------
;; replaced <17Dec89smb>
;;			jmpROM	ROM@hiliteIt
;;@dontQuit	jmpROM	ROM@dontQuit
;;@inBetween	jmpROM	ROM@inBetween
;------------------------------------------------
			endWith
			ENDPROC
			
;----------------------------------------------------------------------
;			PROCEDURE ptchInvrtRectangle
;			<7Dec89smb> Fixed LR highlighting bug at line ends.
;			<2/8/90smb>	Must patch TEWidthHook which is called from PixelWidths.
;			<9/6/90smb> If inline input is active then don't hilite to the ends
;			of the selRect.
;----------------------------------------------------------------------
ptchInvrtRectangle	PROC	EXPORT

InvrtRectRegs		reg		d0/d1/a0/a1
			with SharedFrame,TEFormatOrder
			
			move.w		d2,-(sp)			
;; moved below since saved in PixelWidths <5Dec89smb>			Movem.l		InvrtRectRegs,-(sp)
			move.w		d5,-(sp)				; save pixel width from MeasureAndHilite routine
			
			move.w		#smHilite,d2			; 1st offset's direction param
			swap		d2
			move.w		#smHilite,d2			; 2nd offset's direction param
;;<2/8/90smb>			jsrROM		ROMPixelWidths			; Calls Char2Pixel for each element of hilite pair
 												; returns pixelwidths of both elements in d5 & d6
			import		ptchPixelWidths			; <2/8/90smb>
			bsr			ptchPixelWidths			; now patching PixelWidths due to TEWidthHook <2/8/90smb>.

; Check pixel widths for stroke direction.

			cmp.w		d5,d6					; which is true left/right edge of rectangle
			bcs.s		@rightLeft				; bra if right-left text

			add.w		selRectR(a6),d5			; need dest rect right edge added on		
			add.w		(sp),d5					; add pixel width of previous runs on line
			add.w		selRectR(a6),d6			; need dest rect right edge added on
			add.w		(sp),d6					; add pixel width of previous runs on line
			bra.s		@edgesOK
			
@rightLeft
; right to left
			add.w		selRectL(a6),d5			; need dest rect left edge added on
			add.w		(sp),d5					; add pixel width of previous runs on line
			add.w		selRectL(a6),d6			; need dest rect left edge added on
			add.w		(sp),d6					; add pixel width of previous runs on line
			exg			d5,d6					; swap for R-L text. 

@edgesOK										; call InvertRect on pair (set up selRect)
			Movem.l		InvrtRectRegs,-(sp)		; <5Dec89smb>
			move.w		d5,teSelRect+left(A3)	; left edge of rectangle
			move.w		d6,teSelRect+right(A3)	; right
			
			Move.L		teHiHook(A3),D0 		; do the inversion via hook if exists
			jsrROM		ROMInvertHook			; hilite it
			
			Movem.l		(sp)+,InvrtRectRegs
			Move.w		(sp)+,d5				; restore pixel width from MeasureAndHilite routine		

; Test whether should also hilite visible (screen) line start and end.  Must first determine 
; whether style run should be pinned to the start of the line.
			move.w		(a2),d2					; <22Dec88smb>
			cmp.w		startChar(a0),d2		; <22Dec88smb>
			bls.s		@UseStyleStart			; <22Dec88smb>		<26June89smb> made unsigned
; pin to lineStart to get buffer position of offsets
			add.w		d2,d0					; <22Dec88smb>
			add.w		d2,d1					; <22Dec88smb>
			bra.s		@TestEnds
@UseStyleStart
			add.w		startChar(a0),d0		; buffer position of 1st offset in line
			add.w		startChar(a0),d1		; buffer position of 2nd offset in line
@TestEnds
			cmp.w		d0,d1					; <5Dec89smb>
			bcc.s		@OffsetsOK				; <5Dec89smb>
			exg			d0,d1					; swap for R-L text <5Dec89smb>
@OffsetsOK
	IF hasInlineInput THEN						; 										<16>
; if inline input is on then don't hilite to the end of the selRect! 					<16>
			movem.l		a0/d2,-(sp)				; must preserve							<16>
			move.l		teDispatchH(a3),a0		;										<16>
			move.l		(a0),a0					;										<16>
			move.l		newTEFlags(a0),d2		; move into reg for modulo 32 bit ops	<16>
			btst		#teFInlineInput,d2		; is Inline Input active?				<16>
			movem.l		(sp)+,a0/d2				; restore now							<16>
			bne.s		@NoLineEnds				; yes, so don't hilite line ends!		<16>
	ENDIF										; 										<16>			
			jsrROM		ROMHiliteLineEnds
@NoLineEnds										;										<16>
			Move.w		(sp)+,d2
			
			Rts

			ENDPROC			
			
;----------------------------------------------------------------------
;			PROCEDURE ptchHiliteMiddle
;			<17Dec89smb>	I need to save d2 since it contains the
;			line's style run count left to be processed. InvertHook
;			wipes it out.
;----------------------------------------------------------------------
ptchHiliteMiddle PROC	EXPORT
			with 	SharedFrame,TEFormatOrder
			
			movem.l	d0/d2/a0,-(sp)							; <17Dec89smb>
; do middle rectangle
			move.w	selRectL(a6), teSelRect+left(a3)		; left edge
			move.w	anchorL(a6),d0
			add.w	d0,teSelRect+left(a3)
			move.w	selRectR(a6), teSelRect+right(a3)		; right edge
			move.w	anchorR(a6),d0
			add.w	d0,teSelRect+right(a3)
; top and bottom edges should be the same
			Move.L	teHiHook(A3),D0 						; do the inversion via hook if exists
			jsrROM	ROMInvertHook							; hilite it
			sf		hiliteInbetween(a6)	
			
			movem.l	(sp)+,d0/d2/a0							; <17Dec89smb>
			Rts
			endWith
			
			ENDPROC
	ENDIF
	
	IF Scripts604 | SysVers>= $605 THEN
			PROC
			EXPORT	ptchInstallIntDispatch
			EXPORT	ptchTENew
			EXPORT	ptchTEStylNew
			EXPORT	OldChar2Pixel				; <2/8/90smb>
;----------------------------------------------------------------------
;			PROCEDURE ptchInstallIntDispatch
;			<1/9/90smb>	Adding storage for double-byte characters
;			at the end of the dispatch record.
;			<2/8/90smb>	Added new hook nWidthHook for SMgr-compatible C2P
;			and restored WidthHook to use old TE C2P.
;			<9/20/90>	Should be using patched C2P for nWidthHook.	 Also
;			initializing new TextWidthHook in the dispatch table.									<17>
;----------------------------------------------------------------------
ptchInstallIntDispatch
			moveq		#intDispSize,d0
			jsrROM		ROMMyNewHandle
			move.l		a0,teDispatchH(a3)		; install it in the record
			move.l		(a0),a0

			leaROM		ROMXEOLHook,a1
			Move.l		a1,EOLHook(a0)

			leaROM		ROMXDRAWHook,a1
			move.l		a1,DRAWHook(a0)

			lea			OldChar2Pixel,a1		; install old routine here <2/8/90smb>
			move.l		a1,WIDTHHook(a0)

			leaROM		ROMPixel2Char,a1
			move.l		a1,HITTESTHook(a0)
			
			clr.l		newTEFlags(a0)

			clr.l		newTEFlags+4(a0)		; <1/9/90smb> storage for double-byte char

; added for SMgr's C2P interface <2/8/90smb>
	IF hasTextWidthHook THEN					; use patched version of C2P							<17>
			lea			ptchTEChar2Pixel,a1		; oops, should have used this before!					<17>
	ELSE										;														<17>			
			leaROM		ROMChar2Pixel,a1		; install SMgr-compatible routine here <2/8/90smb>
	ENDIF										;														<17>
			move.l		a1,nWIDTHHook(a0)		; <2/8/90smb>

	IF hasTextWidthHook THEN					; 														<17>
; added so developers can hook the TextWidth calls in TextEdit											<17>
			lea			OldChar2Pixel,a1		; install TextWidth routine	as the default for the hook	<17>
			move.l		a1,TextWidthHook(a0)	; 														<17>
	ENDIF
			rts

;----------------------------------------------------------------------
;			PROCEDURE ptchTENew
;			<1/9/90smb>	Need to patch the dispatch record install code,
;			InstallIntDispatch.
;----------------------------------------------------------------------
ptchTENew
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; Save regs

			Clr.L		16(A6)					; return NIL

			MoveQ		#teRecSize,D0			; Allocate a record
			_NewHandle	,CLEAR
			Bne			badExit					; escape if error				<C971/RWW102887>NO

			Move.L		A0,A4					; save handle

			_HLock								; get object handle and lock it
			Move.L		(A4),A3 				; dereference it

			MoveQ		#0,D0					; get text handle
			_NewHandle
			Bne			badExit					; escape if error				<C971/RWW102887>NO
			Move.L		A0,teTextH(A3)

; Dest and view rect must be together in record
			Lea 		teDestRect(A3),A0		; point to rects in beginning
			Move.L		12(A6),A2				; Get dest rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+
			Move.L		8(A6),A2				; Get view rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+

; Get line height, etc. for font
			jsrROM		ROMGetSize				; get ascent & hite		** <C207/10oct86/MBK> **
			Move.W		D0,teAscent(A3)		 	; save in ascent		** <C207/10oct86/MBK> **
			Move.W		D1,teLineHite(A3)		; save in line height	** <C207/10oct86/MBK> **

; Get the font and face and save away
			Move.L		GrafGlobals(A5),A2		; get lisagraf globals and then
			Move.L		thePort(A2),A2			; thePort
			Move.L		A2,teGrafPort(A3)		; save this port
			Move.L		txFont(A2),teFontStuff(A3)		; save the font/face
			Move.L		txFont+4(A2),teFontStuff+4(A3) ; save the mode/size

; set the direction of the font in the high bit of the high-order byte <30May89smb>
			move.l		a0,-(sp)				; save
			move.w		teFontStuff(a3),d1		; font
			lea			teFace+1(a3),a0			; store direction here
			jsrROM		ROMSetDirection
			move.l		(sp)+,a0
			
			Move.L		TEWdBreak,teWordBreak(A3)	; Set global word breaker

	ENDIF						; Endif applies to: 	IF Scripts604 | SysVers>= $605 THEN

; Fixed a bug in DefClikProc so have to load the patch address for builds >= 6.0.5	
	IF SysVers>= $605 THEN	
			import		ptchDefClikProc			; <1/23/90smb> <4>
			lea			ptchDefClikProc,A0		; setup default click proc <4>
	ELSEIF Scripts604 THEN
			leaROM		ROMDefClikProc,A0		; setup default click proc
	ENDIF
	IF Scripts604 | SysVers>= $605 THEN
			Move.L		A0,teClikProc(A3)

			Bsr			ptchInstallIntDispatch	; install new internal dispatch tbl	<C971/RWW110387>
			jmpROM		ROMinTENew
			
;----------------------------------------------------------------------
;			PROCEDURE ptchTEStylNew
;			<1/9/90smb>	Need to patch the dispatch record install code,
;			InstallIntDispatch.
;----------------------------------------------------------------------
ptchTEStylNew
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; Save regs

			Clr.L		16(A6)					; return NIL

			MoveQ		#teRecSize,D0			; Allocate a record
			_NewHandle	,CLEAR
			Bne			badExit					; escape if error				<C971/RWW102887>NO

			Move.L		A0,A4					; save handle

			_HLock								; get object handle and lock it
			Move.L		(A4),A3 				; dereference it

			MoveQ		#0,D0					; get text handle
			_NewHandle
			Bne			badExit					; escape if error				<C971/RWW102887>NO
			Move.L		A0,teTextH(A3)

; Dest and view rect must be together in record
			Lea 		teDestRect(A3),A0		; point to rects in beginning
			Move.L		12(A6),A2				; Get dest rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+
			Move.L		8(A6),A2				; Get view rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+

; Set size to -1 to indicate this is a stylish record & allocate handle to style
			Move.W		#-1,teSize(A3)			; set style flag (Go style)
			MoveQ		#teStylSize,D0			; min size is for 1 style descriptor
			jsrROM		ROMMyNewHandle			; get handle to style info		** <C381/7nov86/MBK> **
			Move.L		A0,teStylesH(A3)		; former txFont location

; Get Style Handle for storing font, face, size, and color
			MoveQ		#stRecSize,D0			; size of style descriptor
			jsrROM		ROMMyNewHandle			; get StyleHandle				<C971/RWW102887>NO
			Move.L		teStylesH(A3),A2		; handle to style info
			Move.L		(A2),A2					; dereference
			Move.L		A0,styleTab(A2)			; store handle to styles array

; Get handle to array of largest line height on each line
			MoveQ		#4,D0					; Make room for one entry in line height array
			jsrROM		ROMMyNewHandle			; allocate handle to line hites	<C971/RWW102887>NO
			Move.L		A0,A1					; save handle

			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; dereference
			Move.L		A1,lhTab(A0)			; store line hites handle

; Save the GrafPort and save default style from GrafPort
			Move.L		GrafGlobals(A5),A1		; get lisagraf globals and then
			Move.L		thePort(A1),A1			; thePort
			Move.L		A1,teGrafPort(A3)		; save this port
			Move.W		txMode(A1),teMode(A3)	; save the mode

			MoveQ		#1,D0					; length of text + 1
			jsrROM		ROMGetDefStyle			; save default style in StyleRec

; Store one entry in line height array
			Move.L		teStylesH(A3),A0		; style handle
			Move.L		(A0),A0					; dereference
			Move.L		lhTab(A0),A1			; handle to line height table
			Move.L		(A1),A1					; dereference
			Move.L		styleTab(A0),A0			; handle to StyleRec's
			Move.L		(A0),A0					; dereference

			Move.W		stAscent(A0),2(A1)		; save ascent
			Move.W		stHeight(A0),(A1)		; save line height

			Move.W		#$FFFF,teAscent(A3) 	; won't be used unless somebody
			Move.W		#$FFFF,teLineHite(A3)	; sets the ascent and line height

			Move.L		TEWdBreak,teWordBreak(A3)	; Set global word breaker
	ENDIF
; Endif applies to: 	IF Scripts604 | SysVers>= $605 THEN
; Fixed a bug in DefClikProc so have to load the patch address for builds >= 6.0.5	
	IF SysVers>= $605 THEN	
			import		ptchDefClikProc			; <1/23/90smb> <4>
			lea			ptchDefClikProc,A0		; setup default click proc <4>
	ELSEIF Scripts604 THEN
			leaROM		ROMDefClikProc,A0		; setup default click proc
	ENDIF

	IF Scripts604 | SysVers>= $605 THEN
			Move.L		A0,teClikProc(A3)

			Bsr			ptchInstallIntDispatch	; install new internal dispatch tbl	<C971/RWW110387>
			jmpROM		ROMinTEStylNew

badExit
			Move.W		#dsMemFullErr,D0		; memory full error
			_SysError							; go away and never come back
			rts
			
;----------------------------------------------------------------------
;
;			OldChar2Pixel
;
;			Using if the old WidthHook is preferred over the nWidthHook.
;			Never come here for script systems; always use new Char2Pixel.
;			See ScriptChar2Pixel and TEWidthHook dispatch code. <2/8/90smb>
;			Also coming here as the default for TextWidthHook (see TETextWidthHook)	<17>
;
;	Entry:	a0		ptr to text
;			d0.w	length of text to be measured
;			d1.w	offset into text
;
;	Exit:	d1.w	width of measured text
;
;----------------------------------------------------------------------
OldChar2Pixel
			subq		#2,sp					; room for result
			move.l		a0,-(sp)				; pass pointer
			move.w		d1,-(sp)				; offset
			move.w		d0,-(sp)				; length
			_TextWidth							; get width
			move.w		(sp)+,d1				; resulting width

			rts

			ENDPROC
	ENDIF



	IF SysVers>= $605 THEN	
;----------------------------------------------------------------------
;			PROCEDURE ptchDefClikProc
;			<1/23/90emt/smb> Added humane scrolling (slower) to DefClikProc
;			(also see TEClick).
;----------------------------------------------------------------------
ptchDefClikProc	PROC	EXPORT
			MoveM.L 	D0-D7/A0-A4,-(SP)		; save ALL regs
			Move.L		teDispatchH(A3),A0		; <PMAB381/RWW020488>
			Move.L		(A0),A0					; <PMAB381/RWW020488>
			Move.L		newTEFlags(A0),D0		; <PMAB381/RWW020488>
			BTst		#teFAutoScr,D0			; <PMAB381/RWW020488>
			
			Beq.S		doneAuto				; if not, must skip

			Lea 		teViewRect+8(A3),A0 	; point to view rect
			Lea 		TempRect+8,A2			; copy into TempRect
			Move.L		-(A0),-(A2)
			Move.L		-(A0),-(A2)

			SubQ		#4,SP					; room for pt
			Move.L		SP,-(SP)
			_GetMouse
			Move		(SP)+,D6				; get V coordinate
			Move		(SP)+,D7				; get H coordinate

			MoveQ		#0,D4					; horz scroll amt
			Move		teLineHite(A3),D1		; vert scroll amt
			Bpl.S		@1						; use if not negative				** <C207/13oct86/MBK> **

			Move.W		D6,D0					; find D6 line						** <C207/13oct86/MBK> **
			Cmp.W		teDestRect+bottom(A3),D0 ; pt below the rect?				** <C207/13oct86/MBK> **
			Ble.S		@0						; okay if less or same				** <C207/13oct86/MBK> **

			Move.W		teDestRect+bottom(A3),D0 ; else reset to bottom				** <C207/13oct86/MBK> **

@0
		IF SysVers>= $700 THEN					;													<19>
			import		ptchPtToLine			;													<19>
			bsr			ptchPtToLine			; try to find its line # in the patched version!	<19>
		ELSE
			jsrROM		ROMPtToLine				; try to find its line #			** <C207/13oct86/MBK> **
		ENDIF									;													<19>
			Bge.S		noAuto					; no scroll if line doesn't exist	** <C207/13oct86/MBK> **	<4>
			jsrROM		ROMGetHite				; else get its height

@1			Cmp 		(A2)+,D6				; subtract top of viewRect
			Blt.S		scrollUp				; scroll up

			Cmp 		(A2)+,D7				; subtract left of viewRect
			Blt.S		scrollLeft				; scroll left

			Cmp 		(A2)+,D6				; subtract bottom of viewRect
			Bgt.S		scrollDown				; scroll down

			Cmp 		(A2)+,D7				; subtract right of viewRect
			Bgt.S		scrollRight 			; scroll right

noAuto											;											<4>
			clr.l		teClikTime(a3)			; clear it out because we're not scrolling	<4>
doneAuto
			MoveQ		#1,D0					; cc's <> 0
			MoveM.L 	(SP)+,D0-D7/A0-A4		; restore ALL regs
			Rts

scrollDown
			Neg 		D1						; flip direction
scrollUp
			Bra.S		scrollEm

scrollRight
			Neg 		D1						; flip direction
scrollLeft
			Exg 		D4,D1					; switch axes
scrollEm

; Finally do the scroll
			lea			-10(sp), sp				; reserve space for call to ScrollDelay		<4>
			move.w		#1,-(sp)				; itemsVisible = smallest possible (1)		<4>
			move		d4,-(sp)				; pass dh
			move		d1,-(sp)				; pass dv
			move.l		8(a6),-(sp) 			; tehandle

			subq.l		#4,sp					;											<4>
			_TickCount							; Get a time stamp.							<4>
			move.l		(sp)+,d1				; Copy it into D1.							<4>
			move.l		d1,10(sp)				; And put it on the stack for ScrollDelay.	<4>

; Note:	teClikTime is a state variable in the TERecord which is used by TEClick.
;		Fortunately, TEClick does not use at all within its body; it only checks its
;		value on entry and sets it on exit.  This code relies on it also being set on
;		entry, just after it has been tested.  Of course, this restricts its use to
;		click procs, but that's okay.

			move.l		teClikTime(a3),d0		; See if it's a new scroll					<4>
			bne.s		@gotTime				; Skip if not								<4>
			move.l		d1,teClikTime(a3)		; Otherwise, put in a new stamp				<4>
			move.l		d1,d0					; in D0 too									<4>

@gotTime
			move.l		d0,14(sp)				; D0 is startTicks for ScrollDelay			<4>
			_TEPinScroll 						;_TEPinScroll		** <C381/6nov86/MBK> **

			_ScrollDelay						;											<4>
			AddQ.L		#2,SP					; Toss the result							<4>
			Bra.S		doneAuto				;								<C971/RWW102887>NO
			ENDPROC
	ENDIF
	
	IF Scripts604 | SysVers>= $605 THEN
			PROC
			EXPORT	ptchTEWidthHook
			EXPORT	ScriptChar2Pixel
			EXPORT	TETextWidthHook				;											<17>
;----------------------------------------------------------------------
;
;			ptchTEWidthHook
;			modified <2/8/90smb>
;			This internal interface still uses TextEdit's old Char2Pixel routine
;			for backwards compatibility for developers.  Specifically, if a developer
;			has been using this interface, and chains his routine in, the new Char2Pixel
;			routine would have broken his application. We now have a new interface, 
;			ScriptChar2Pixel (below) that allows a developer to replace our new 
;			Char2Pixel routine or chain with it instead.
;
;			However, if a script system is installed, we override this hook and 
;			automatically use the new hook. Also, if a developer has not replaced our 
;			internal measuring routine (OldChar2Pixel) then we use the new routine. 
;			Hence, the only time we use the OldChar2Pixel code is when a developer has
;			used this hook. <2/8/90smb>
;
; 			Measures from start of text to offset, length means length of style run!!!!
;
;			ENTRY:
;				a0.l	=>	ptr to text to measure
;				d0.w	=	Length of text to be measured
;				d1.w	=	Offset into text
;				d2.l	=	Slop (low word)
;						Hilite flag (high word)
;
;			EXIT:
;				d1.w	=	Width of measured text
;
;----------------------------------------------------------------------
ptchTEWidthHook
; If a non-Roman system then use new WidthHook routine.
			move.l		ExpandMem,a1				; <2/8/90smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a1)	; total number of installed scripts
			bne.s		ScriptChar2Pixel			; <2/8/90smb>
			
; Test if the hook contains our internal address <2/8/90smb>
			move.l		teDispatchH(a3),a1
			move.l		(a1),a1
			move.l		WIDTHHook(a1),a1
			
; if the address of the TEWidthHook is our own OldChar2Pixel routine then use the 
; new Char2Pixel routine.  Otherwise, use the old routine. <2/8/90smb>
			pea			OldChar2Pixel				; <2/8/90smb>
			cmpa.l		(sp)+,a1					; <2/8/90smb>
			beq.s		ScriptChar2Pixel			; <2/8/90smb>
			
; set up the length and offset correctly for the OldChar2Pixel (at this point they have
; been set up for the new Char2Pixel that calls the SMgr's C2P routine.
; adjust the length to reflect the length to measure (from the offset) rather than the
; whole length of the text that the SMgr's C2P expects. <2/8/90smb>
			move.w		d1,d0						; the C2P offset (d1) should be the byte count or length (d0) <2/8/90smb>
			move.w		#0,d1						; set the offset to 0. <2/8/90smb>
			
			jmp			(a1)						; default is to call OldChar2Pixel which calls TextWidth

;----------------------------------------------------------------------
;
;			ScriptChar2Pixel
;
;			new <2/8/90smb>
;			This internal interface uses the new width hook which allows 
;			a developer to replace TextEdit's new Char2Pixel code that
;			uses the Script Manager's Char2Pixel routine.
;
;			If a developer chains in his routine w/o understanding our new interface
;			(ie - he expects the old TEWidthHook registers to be used) then his code
;			will not work.
;
;			Stock version only calls new Char2Pixel.
;
; 			Measures from start of text to offset, length means length of style run!!!!
;
;			ENTRY:
;				a0.l	=>	ptr to text buffer
;				a2.l	=>	ptr to current lineStart (from teLines)
;				d0.w	=	overall style run length, pinned to the line end
;				d1.w	=	offset position within the style run, pinned to the line start
;				d2.l	=	slop (low word) (see SMgr C2P routine)
;							direction flag (high word) (see SMgr C2P routine)
;
;			EXIT:
;				d1.w	=	width of measured text
;----------------------------------------------------------------------
ScriptChar2Pixel									; renamed from nTEWidthHook				<17>
			move.l		teDispatchH(a3),a1
			move.l		(a1),a1
			move.l		nWIDTHHook(a1),a1			; default is Char2Pixel
			jmp			(a1)

	IF hasTextWidthHook THEN						; 										<17>
;----------------------------------------------------------------------
;
;			TETextWidthHook																	<17>
;
;			new <9/19/90smb>
;
;			This internal interface uses the new TextWidth hook which allows 
;			a developer to replace the TextWidth calls in TextEdit with their
;			own measuring code.
;
;			The default is to use the OldChar2Pixel routine which calls
;			_TextWidth.
;
;			ENTRY:
;				a0.l	=>	ptr to text to measure
;				d0.w	=	Length of text to be measured
;				d1.w	=	Offset into text
;
;			EXIT:
;				d0.l,
;				 d1.l	=	Width of measured text, with result in low word and high word clear
;							(using both registers since some callers use d0 for the result and
;							 others use d1)
;----------------------------------------------------------------------
TETextWidthHook
			move.l		teDispatchH(a3),a1			;										<17>
			move.l		(a1),a1						;										<17>
			move.l		TextWidthHook(a1),a1		;										<17>
			jsr			(a1)						; result in d1.w						<17>
			moveq		#0,d0						;										<17>
			move.w		d1,d0						; result in longized d0					<17>
			move.w		d0,d1						; result in longized d1					<17>
			rts										; 										<17>
	ENDIF											;										<17>		
			ENDPROC
			
;----------------------------------------------------------------------
;			PROCEDURE ptchPixelWidths
;			<2/8/90smb>	Must patch TEWidthHook which is called here.
;			<6/12/90smb> Must test for EOD and if hit it, use style end.
;----------------------------------------------------------------------
ptchPixelWidths	PROC	EXPORT

	IF SysVers >= $700 THEN
; remove a4 from these lists of registers													<29>
PixelWidthRegs		reg		d0-d4/a0-a2			;											<29>
C2Pparams			reg		d0/a0/a1			; length, direction, textPtr, styleRunPtr	<29>
	ELSE										;											<29>
PixelWidthRegs		reg		d0-d4/a0-a2/a4
C2Pparams			reg		d0/a0/a1/a4			; length, direction, textPtr, styleRunPtr, direction locale
	ENDIF										;											<29>

			movem.l		PixelWidthRegs,-(sp)
	IF SysVers >= $700 THEN						;											<29>
			move.l		a4,-(sp)				; save the teHandle							<29>
	ENDIF										;											<29>
			move.l		ExpandMem,a4			; <1Feb89smb>
			move.l		d2,ExpandMemRec.emDirection(a4)		; <27Oct88smb> direction for both offsets passed in 

			Movea.l		a0,a1					; save beginning posn of current style			
			Move.L		teTextH(a3),a0			; get text handle
			Move.L		(a0),A0 				; dereference
			Add.w		(a1),a0					; add beginning of the style run to get to desired line

; 1st offset's width
			move.w		d1,-(sp)				; save 2nd offset
; test if style run starts on previous line, and if so adjust textptr & offset posn in run
			move.w		d0,d1					; Char2Pixel wants the start offset here

			moveq		#0,d4
			move.w		(a2),d0					; linestart
			cmp.w		startChar(a1),d0
			bls.s		@getLength				; bra if so => offset is ok		<26June89smb> made unsigned
			
; pin to beginning of this line			 
			sub.w		startChar(a1),d0		; |begin of line - begin of the style run|
			add.w		d0,a0					; fix text ptr
			move.w		d0,d4					; save difference for length adjustment
@getLength
; test if style run ends on next line, and if so pin to end of this line & adjust length
			move.l		a0,-(sp)				; <6Mar89smb>
			move.l		a1,a0					; <6Mar89smb>
			jsrROM		ROMFixFormatEnd			; <6Mar89smb> returns in d0
			move.l		(sp)+,a0				; <6Mar89smb>
			move.w		teLength(a3),d2			; 											<13>
			cmp.w		(a2),d2					; at the end of the text?					<13>
			beq.s		@UseStyleEnd			; yes -> use style end						<13>
			cmp.w		2(a2),d0				; style contained in the line?
			bls.s		@UseStyleEnd			; yes -> use style end.
			move.w		2(a2),d0				; pin to end of line.
@UseStyleEnd
			sub.w		startChar(a1),d0 		; Char2Pixel wants the length here
			sub.w		d4,d0					; adjust for lineStart
			
			clr.l		d2						; <27Oct88smb>
			move.l		ExpandMem,a4			; <1Feb89smb>
			lea			ExpandMemRec.emDirection(a4),a4		; changed to lea <12July89smb>
			move.w		(a4)+,d2				; <27Oct88smb>
			swap		d2						; 1st offset's direction in high word; slop in low

	IF SysVers >= $700 THEN						;											<29>
			move.l		a4,-(sp)				; save direction values						<29>
			move.l		6(sp),a4				; restore teHandle to a4					<29>
	ENDIF										;											<29>
			movem.l		C2Pparams,-(sp)			; save to be used again
			import		ptchTEWidthHook			; <2/8/90smb>
			bsr			ptchTEWidthHook			; <2/8/90smb>
			move.w		d1,d5					; 1st element's pixel width
			
; 2nd offset's width
; restore params: length, direction, textPtr, styleRunPtr, direction locale
			movem.l		(sp)+,C2Pparams
	IF SysVers >= $700 THEN						;											<29>
			move.l		(sp)+,a4				; restore direction values					<29>
	ENDIF										;											<29>
			move.w		(sp)+,d1				; restore offset2
									
			clr.l		d2						; <7Nov88smb>
			move.w		(a4),d2					; <27Oct88smb>
			swap		d2						; 2nd offset's direction in high word; slop in low
				
	IF SysVers >= $700 THEN						;											<29>
			move.l		(sp)+,a4				; restore teHandle							<29>
	ENDIF										;											<29>
			bsr			ptchTEWidthHook			; <2/8/90smb>
			move.w		d1,d6					; 2nd element's pixel width

			movem.l		(sp)+,PixelWidthRegs
			rts		
			ENDPROC
	ENDIF

	IF hasTextWidthHook THEN					;												<17>
			PROC								;												<17>
			EXPORT		ptchMeasureWholeRun		;												<17>
;----------------------------------------------------------------------
;			PROCEDURE ptchMeasureWholeRun
;			<9/20/90smb>	New. Call TETextWidthHook now.
;----------------------------------------------------------------------
ptchMeasureWholeRun

WholeRunRegs		reg		d2/a0/a4
			
	IF SysVers >= $700 THEN						;												<29>
			movem.l	d2/a0,-(sp)					; 												<29>
			move.l	a4,-(sp)					; separate out so can restore teHandle to a4 before hook call	<29>
	ELSE										;												<29>
			movem.l	WholeRunRegs,-(sp)
	ENDIF										;												<29>
			
			movea.l	a0,a1						; save beginning posn of current style			
			move.l	teTextH(a3),a0				; get text handle
			move.l	(a0),a0 					; dereference
			add.w	(a1),a0						; add beginning of the style run to get to desired line
			move.l	a0,a4
			movea.l	a1,a0						; restore current style run
			
; If style run starts on previous line, then pin text pointer to start of current line
			moveq	#0,d1						; used to adjust length
			move.w	(a2),d0						; beginning of line
			cmp.w	startChar(a0),d0
			bls.s	@getLength					; bra if lineStart is prior or equal to the styleRun start <21June89smb>
			
; Adjust text pointer and length for lineStart within styleRun
			sub.w	startChar(a0),d0			; difference from start of styleRun to lineStart
			add.w	d0,a4						; pin pointer to beginning of line
			move.w	d0,d1						; save for length adjustment below

; If style run ends on next line, then use the current line's end for determining length!
@getLength
			jsrROM	ROMFixFormatEnd				; <6Mar89smb> returns end of style run in d0
			cmp.w	2(a2),d0					; inside the line's end?
			bls.s	@UseStyleEnd				; <26June89smb> made unsigned
			move.w	2(a2),d0					; use the line's end
@UseStyleEnd
			sub.w	startChar(a0),d0
			sub.w	d1,d0						; adjust for LineStart
			tst.w	teSize(a3)					; <1Dec88smb>
			bpl.s	@DontSet

			movem.l	d0/d1,-(sp)					; SetStyle mucks with this guy - not good!
			jsrROM	ROMSetStyle					; set grafport style from current style in a0
			movem.l	(sp)+,d0/d1
			
@DontSet
;get PixelWidth of this style on this line
			move.l	a4,a0						; wants text ptr here							<17>
			moveq	#0,d1						; wants offset here								<17>

	IF SysVers >= $700 THEN						;												<29>
			move.l	(sp)+,a4					; restore teHandle to a4						<29>
	ENDIF										;												<29>
			import	TETextWidthHook				;												<17>
			bsr		TETextWidthHook				; hook out TextWidth							<17>
	IF SysVers >= $700 THEN						;												<29>
			movem.l	(sp)+,d2/a0					; already restored a4 before TETextWidthHook call	<29>
	ELSE										;												<29>
			movem.l	(sp)+,WholeRunRegs
	ENDIF										;												<29>
			rts
			ENDPROC								;												<17>
	ENDIF										; IF hasTextWidthHook							<17>

;----------------------------------------------------------------------

	IF SysVers >= $700 THEN						;												<19>
			PROC								;												<19>
			EXPORT		ptchReCalLines			;												<19>
			EXPORT		ptchPtToLine			;												<19>
			EXPORT		ptchDoFind				;
			EXPORT		ptchPinDisplay			;												<19>
			EXPORT		ptchPinA0Rect			;												<19>
			EXPORT		ptchRefresh				;												<19>
;----------------------------------------------------------------------
;			PROCEDURE ptchReCalLines
;			<1/4/91smb>	KT bug: Only draw line when wordRedraw is <1 (was
;			testing <> 0).
;----------------------------------------------------------------------
ptchReCalLines
			link		a6,#RecalLink
			movem.l 	d3/d5-d6/a2,-(sp)		; save regs (SEE .EQU ABOVE)

			move.w		teNLines(a3),oldNLines(a6) ; save old # of lines		** <C229/28oct86/MBK> **
			clr.w 		teNLines(a3)	 		; prime nLines:=0

			clr.w		savedD2(a6)				; default redraw beginning
			move		teLength(a3),savedD4(a6); default redraw end
			tst.w		teLength(a3)			; any text?
			beq			ClrLineSts				; <19Mar89smb> if not, nothing to recal			

; D3 contains the start point to recal from, so find the line containing D3
			lea			teLines(a3),a2			; point to line starts
			moveq		#teFromRecal,d2 		; say ReCalLines is calling 		<EHB 01Oct85>
			move		teSelStart(a3),d0		; put start position in D0			<EHB 01Oct85>
			jsrROM		ROMFindWord				; get word around selstart for...<C971/RWW102887>NO		vectored so jsr to ROM addr	<21>
			move		d0,d3					; comparison

stage1
			move		(a2)+,d6				; i(start):=lineStarts[line]
			move		d6,savedD2(a6)			; save away as default redraw start

			cmp 		(a2),d3 				; while selWord<lineStarts[line+1]
			blo.s		stage2x 				; if inclusive
			beq.s		stage2y 				; if at next line start

			addq		#1,teNLines(A3) 		; one more line, keep looking for
			bra.s		stage1					; line containing selStart(D3)

; Return the refresh start in savedD2

stage2x
			jsrROM		ROMFindLine				; get line after D6				<C971/RWW102887>NO		vectored so jsr to ROM addr	<21>
			cmp 		d0,d3					; did the line break change?
			bhs.s		stageBad				; if so, must redraw whole thing
stageGood										;									<EHB 05-Nov-85>
			tst.b		WordRedraw				; should we redraw the whole word?	<EHB 31-Oct-85>
			bgt.s		stageBad				; => yes, app wants whole word		<EHB 31-Oct-85>
			blt.s		stage2A 				; => app wants whole line			<EHB 01-Nov-85>

			move		teSelStart(a3),d3		; return selStart
stageBad

	IF forLocalizability THEN					; <42-YDS-2/5/92>
			Cmp.w		#teForceLeft,teJust(A3)	; are we forcing left ?
			Beq.S		@1						; if so, skip the TESysJust test.
	ENDIF

			tst.W		teJust(A3)				; see what format, for right or
			bne.S		stage2A 				; centered, must use linestart

			tst.W		TESysJust				; check text direction	** <C105/14aug86/MBK> **
			bne.s		stage2A					; not left				** <C105/14aug86/MBK> **

; Special case: redraw line didn't work because stage2x jumped here w/o checking the redraw flag.
@1			tst.b		WordRedraw				; should we redraw the whole word?	** <C454/21nov86/MBK> **
			blt.s		stage2A 				; => app wants whole line	<19> replaced bne.s w/ original blt.s above

			move		d3,savedD2(a6)			; return word start-1
			beq.s		stage2A
	IF SysVers >= $700 THEN						; fix for KanjiTalk redrawing								<27>
; must call DoubleByte here to backup to the correct position												<27>
			subq		#1,savedD2(a6)
			tst.b		wordRedraw				; if Roman then don't call DoubleByte						<27>
			beq.s		stage2A					;															<27>
			movem.l		d0-d4/d6/d7/a2,-(sp)	; save regs across call	(better safe than sorry!)			<27>
			move.w		d3,d6					; DoubleByte wants offset here								<27>
			move.w		#-1,d3					; incremental direction to move								<27>
			jsrROM		ROMDoubleByte			;															<27>
			move.w		d6,savedD2(a6)			;															<27>
			movem.l		(sp)+,d0-d4/d6/d7/a2	;															<27>
	ELSE										;															<27>
			subq		#1,savedD2(a6)
	ENDIF										;															<27>	
			bra.s		stage2A					;															<21>

stage2y		jmpROM		ROMstage2y
stage2A		jmpROM		ROMstage2A
ClrLineSts	jmpROM		ROMClrLineSts

;----------------------------------------------------------------------
;			PROCEDURE ptchPtToLine
;			<1/4/91smb>	Fixed bug # 35646 (fixed for SS-6.0.4 and 6.0.5 
;			in ptch0) - up-arrow key doesn't get to beginning of text.
;----------------------------------------------------------------------
ptchPtToLine
			MoveM.L		D2/D6-D7/A0,-(SP)

			Sub 		teDestRect+top(A3),D0	; origin to destRect
			Ext.L		D0						; extend to long
			Move.W		teNLines(A3),D7			; save total # of lines
			Beq.S		@4						; if none, quit now
			
; special check for negative, return negative! <1/30/90smb>
			tst.l		d0						; before start of rect? <1/30/90smb>
			blt.s		@4						; yes, return above top line <1/30/90smb>
			jmpROM		ROMinPtToLine
			
@4			Cmp 		D7,D0 					; compare the max # lines
			MoveM.L		(SP)+,D2/D6-D7/A0
			Rts

;----------------------------------------------------------------------
;			PROCEDURE ptchDoFind
;			<1/4/91smb>	Must be patched since calls PtToLine, which is 
;			now patched.
;----------------------------------------------------------------------
ptchDoFind

; find out which text line it's on
			Move		teSelPoint+v(A3),D0 	; i:=(selPoint.v-destRect.top)
			Bsr 		ptchPtToLine			; line index in D0
			jmpROM		ROMinDoFind				;											<19>

;----------------------------------------------------------------------
;			PROCEDURE ptchPinDisplay
;			PROCEDURE ptchPinA0Rect
;			<1/4/91smb>	Must be patched since calls PtToLine, which is 
;			now patched.
;----------------------------------------------------------------------
ptchPinDisplay
			Lea 		teViewRect(A3),A0		; use viewRect
ptchPinA0Rect
			Move		top(A0),D0				; load D0 w/top

			Bsr.S		ptchPtToLine			; turn into a lineStart in d0				<19>
			Bge.S		@4						; escape if top gone
			Add 		D0,D0					; double for array ref.
			Blt.S		@1
			Cmp 		teLines(A3,D0),D3		; pin D3 to viewRect.top
			Bhs.S		@0
			Move		teLines(A3,D0),D3		; dispStart = lines[i]
@0
			Cmp 		teLines(A3,D0),D4		; pin D4 to viewRect.top
			Bhs.S		@1
			Move		teLines(A3,D0),D4		; dispEnd = lines[i]
@1
			Move		bottom(A0),D0			; get bottom in D0
			SubQ		#1,D0
			Bsr.S		ptchPtToLine			;											<19>
			jmpROM		ROMinPinDisplay

@4
			Move		D3,D4					; nothing in range
			Rts

;----------------------------------------------------------------------
;			PROCEDURE ptchRefresh
;			<1/4/91smb>	Must be patched since calls PinA0Rect, which is 
;			now patched.
;----------------------------------------------------------------------
ptchRefresh

			MoveQ		#0,D3					; min/max redraw pins in DoDraw
			MoveQ		#-1,D4
			Bsr 		ptchPinA0Rect			; pass A0 rect to Pin code					<19>
			jmpROM		ROMinRefresh
			ENDPROC
	ENDIF

	IF SysVers>=$700 THEN
			


	IF forLocalizability THEN					; <41-YDS-1/30/92>
;----------------------------------------------------------------------
;			PROCEDURE ptchTextBox
;			bug #1018683 ,  for TextBox with #teForceLeft, don't set 
;			the justification to the system just.
;----------------------------------------------------------------------
			PROC
			EXPORT		ptchTextBox	
ptchTextBox
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; save StdRegs on stack

			Tst.W		TBJust(A6)				; “left” justified?					<C971/RWW110987>
			Bne.S		@05						; no => skip this					<C971/RWW110987>

			Move.W		TESysJust,TBJust(A6)	; he meant, “default justification”	<C971/RWW110987>
			
@05			jmpROM		RONInTextBox
			ENDPROC
	ENDIF


	IF forLocalizability THEN					; <43-YDS-2/6/92>
;----------------------------------------------------------------------
;			PROCEDURE ptchTextBoxAfterGetFontInfo
;			<2/6/92YDS>	Patched to handle the font info of an associated font
;						if has one.
;						come from patch on _GetFontInfo in TextBox.
;						If we are here, it is unstyled text & we dont have a teRecord !
;
;----------------------------------------------------------------------
ptchTextBoxAfterGetFontInfo		ComeFromAfterPatchProc		_GetFontInfo,ROMAfterGetFInfoInTextBox,(IIci)		;	<30>

												; see <43> <43-YDS-2/6/92>.we are in
												; an un styled record, give the hight of the assoc
												; font or the script font (the bigger)
			Subq		#2,sp					; make room on stack
			_FontScript							; get the script
			Move.W		(SP)+, D4				; into D4
			Beq.W		@DoNothing				; it roman ! do nothing
			Subq		#4,sp					; make room on stack, will use it later
			Move.W		D4, -(SP)				; push script number on stack for later
			Move.L		GrafGlobals(A5),A3		; get lisagraf globals and then
			Move.L		thePort(A3),A3			; thePort
			Move.W		txFont(A3),D5			; get the font <44-YDS-4/2/92>
			Cmp.W		#sysFont, D5			; is it system font ?
			Beq.S		@SystemFont				; yes
			Cmp.W		#applFont, D5			; is it app font ?
			Beq.S		@AppFont				; yes
			Subq		#4,sp					; make room on stack for result
			Move.W		D4, -(SP)				; push script # on stack
			Move.W		#smScriptSysFond, -(SP)	; push verb
			_GetScript							; get the system pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		D5, D0					; are you sure it's not system font ?
			Beq.S		@SystemFont				; it is !
			Subq		#4,sp					; make room on stack for result
			Move.W		D4, -(SP)				; push script # on stack
			Move.W		#smScriptAppFond, -(SP)	; push verb
			_GetScript							; get the application pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		D5, D0					; are you sure it's not application font ?
			Beq.S		@AppFont				; it is !
@OtherFont	Move.W		#smScriptFntBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@SystemFont	Move.W		#smScriptSysBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@AppFont	Move.W		#smScriptAppBase ,-(SP)	; we have result space & script # on stack allready		
@GetTheFont	_GetScript							; so push the right verb
			Move.L		(SP)+, D0				; get the associated font
			Tst.W		D0						; test the low byte <44-YDS-4/2/92>
			Beq.S		@DoNothing				; no associated font ? bail out !
			Move.W		D0, txFont(A3)			; set the font to the assoc font
			SubQ		#8,SP					; space on stack
			Move.L		SP,-(SP)				; push addres
			_GetFontInfo						; get the assoc font info
			Move.W		D5, txFont(A3)			; restore port font
			Move.W		(SP), D0				; get assoc font ascent
			Cmp.W		8(SP), D0				; compare with script font ascent  
			Bgt.S		@3
			Move.W		D0, 8(SP)				; let the bigger one win !
@3			AddQ		#8,SP					; strip stack
@DoNothing
			jmpROM	ROMAfterGetFInfoInTextBox	; …it's back to you, TE!
			ENDPROC
	ENDIF


;----------------------------------------------------------------------
;			PROCEDURE ptchTextBoxPreserveGlyph
;			<1/21/91smb>	Patched to set PreserveGlyph FALSE before 
;			drawing, and then restoring it afterwards.
;----------------------------------------------------------------------
ptchTextBoxPreserveGlyph		ComeFromAfterPatchProc		_MoveTo,AfterMoveToInTextBox,(IIci)		;	<30>
;;ptchTextBoxPreserveGlyph		ComeFromAfterPatchProc		_DrawText,AfterMoveToInTextBox,(IIci)	;	<30>
; come from patch on _MoveTo in TextBox
			tst.w		TBJust(a6)				; look at justification and leave high byte for others
			beq.s		@2						; if left go do it
	IF forLocalizability THEN					; <41-YDS-1/30/92> don't forget to check
			Cmp.W		#teForceLeft,TBJust(A6)	; for #teForceLeft here
			Beq.S		@2						; 
	ENDIF
; assume centered
			move.l		TBBox(a6),a0			; point to rect
			move		right(a0),d0			; calc width
			sub 		left(a0),d0
			sub 		d3,d0					; subtract text width
			subq		#1,d0					; caret space TE compatibility

			tst.w		TBJust(a6)				; look at justification
			bmi.s		@1						; if right skip right shift
			asr 		#1,d0					; divide by two
@1
			move		d0,-(sp)				; move over
			clr 		-(sp)					; dv = 0
			_Move
@2

;-----------------------------------------------												<22>
; Turn PreserveGlyph off before drawing, but save its previous setting							<22>
			clr.w		-(sp)					; boolean result								<22>
			_GetPreserveGlyph					;												<22>
			; leave result on stack
			tst.w		(sp)					; preserve or squash? (byte result but cleared word)
			beq.s		@IsFalse				;												<22>
			move.b		#0,-(sp)				; set PreserveGlyph FALSE						<22>
			_SetPreserveGlyph					;												<22>
@IsFalse
;-----------------------------------------------												<22>

			move.l		TBText(a6),-(sp)		; pass text
			clr 		-(sp)
			move		TBLength+2(a6),-(sp)	; pass length (low word)
			_DrawText

;-----------------------------------------------												<22>
; Restore PreserveGlyph							
			; previous PreserveGlyph value still on stack
			_SetPreserveGlyph					;												<22>						
;-----------------------------------------------												<22>

			jmpROM	ROMGo14Exit					; …it's back to you, TE!
			ENDPROC



	IF forLocalizability THEN					; <43-YDS-2/6/92>
;----------------------------------------------------------------------
;			PROCEDURE ptchGetSizeAfterGetFontInfo
;			<2/6/92YDS>	Patched to handle the font info of an associated font
;						if has one.
;						come from patch on _GetFontInfo in GetSize
;						can be styled or unstyled. A3 is the teRect.
;
;----------------------------------------------------------------------
ptchGetSizeAfterGetFontInfo		ComeFromAfterPatchProc		_GetFontInfo,ROMAfterGetFInfoInGetSize,(IIci)		;	<30>

												; see <43> <43-YDS-2/6/92>.if we are in
												; an un styled record, give the hight of the assoc
												; font or the script font (the bigger)
			Tst.W		teSize(a3)				; is it styled ?	
			Bmi.W		@NoAssocFont			; if yes, don't do anything
			Move.L		D3, -(SP)				; save d3 on stack for now
			Subq		#2,sp					; make room on stack
			_FontScript							; get the script
			Move.W		(SP)+, D3				; into D3
			Beq.W		@DoNothing				; it roman ! do nothing
			Subq		#4,sp					; make room on stack, will use it later
			Move.W		D3, -(SP)				; push script number on stack for later
			Cmp.W		#sysFont, teFont(A3)	; is it system font ?
			Beq.S		@SystemFont				; yes
			Cmp.W		#applFont, teFont(A3)	; is it app font ?
			Beq.S		@AppFont				; yes
			Subq		#4,sp					; make room on stack for result
			Move.W		D3, -(SP)				; push script # on stack
			Move.W		#smScriptSysFond, -(SP)	; push verb
			_GetScript							; get the system pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		teFont(A3), D0			; are you sure it's not system font ?
			Beq.S		@SystemFont				; it is !
			Subq		#4,sp					; make room on stack for result
			Move.W		D3, -(SP)				; push script # on stack
			Move.W		#smScriptAppFond, -(SP)	; push verb
			_GetScript							; get the application pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		teFont(A3), D0			; are you sure it's not application font ?
			Beq.S		@AppFont				; it is !
@OtherFont	Move.W		#smScriptFntBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@SystemFont	Move.W		#smScriptSysBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@AppFont	Move.W		#smScriptAppBase ,-(SP)	; we have result space & script # on stack allready		
@GetTheFont	_GetScript							; so push the right verb
			Move.L		(SP)+, D0				; get the associated font
			Tst.W		D0						; teat the low word <44-YDS-4/2/92>
			Beq.S		@DoNothing				; no associated font ? bail out !
			Move.L		(SP)+, D3				; restore D3, we need a fresh stack
			Move.L		teGrafPort(A3),A0		; get thePort
			Move.W		D0, txFont(A0)			; set the font to the assoc font
			SubQ		#8,SP					; space on stack
			Move.L		SP,-(SP)				; push addres
			_GetFontInfo						; get the assoc font info
			Move.L		teGrafPort(A3),A0		; get thePort
			Move.W		teFont(A3), txFont(A0)	; restore the font
			Move.W		(SP)+, D0				; get assoc font ascent
			Cmp.W		6(SP), D0				; compare with script font ascent  
			Bgt.S		@1
			Move.W		D0, 6(SP)				; let the bigger one win !
@1			Move.W		(SP)+, D0				; get assoc font descent
			Cmp.W		6(SP), D0				; compare with script font ascent  
			Bgt.S		@2
			Move.W		D0, 6(SP)				; let the bigger one win !
@2			AddQ		#2,SP					; skip max wid
			Move.W		(SP)+, D0				; get assoc font leading
			Cmp.W		6(SP), D0				; compare with script font ascent  
			Bgt.S		@3
			Move.W		D0, 6(SP)				; let the bigger one win !
@3			Bra.S		@NoAssocFont			; back to normal !
@DoNothing
			Move.L		(SP)+, D3				; restore D3, 
@NoAssocFont
			jmpROM		ROMAfterGetFInfoInGetSize	; …it's back to you, TE!
			ENDPROC
	ENDIF



;----------------------------------------------------------------------
;
;			PROCEDURE ptchTEDispose
;			
;			<1/16/91smb>	Patched to call DumpBuffer (since not
;			everyone calls TEIdle like they should) to empty
;			text buffer, clear byte count, and dispose of handle.								<20>
;
;			Entry: teHandle on stack
;			
;----------------------------------------------------------------------
ptchTEDispose PROC EXPORT

			link		a6,#0
			movem.l 	d2-d7/a2-a4,-(SP)		; save stdregs
			move.l		8(a6),a4				; Pop handle into A4
			move.l		(a4),a3 				; Dereference into A3

; dump text buffer before exiting (cleanup!)		 													<21>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops 			<20>
			btst		#teFTextBuffering,d0
			beq.s		@noBuffer
			import		ptchDumpBuffer
			bsr			ptchDumpBuffer			; dump text from buffer
@noBuffer	
			jmpROM		ROMinTEDispose			; finish disposing all other handles
			ENDPROC

;----------------------------------------------------------------------							<29>
;			PROCEDURE ptchHiliteTextPreserveA4													<29>
;			<2/12/91smb>	Patched to preserve a4 across call to 								<29>
;			ptchInvrtRectangle.																	<29>
;----------------------------------------------------------------------							<29>
ptchHiliteTextPreserveA4		ComeFromAfterPatchProc		_ScriptUtil,AfterHiliteText,(IIci)	; <29>
; come from patch on _HiliteText in teHiliteText												<29>

HiliteTxtRegs		reg		d2-d4/a0/a1		;													<29>

			movem.l	(sp)+,HiliteTxtRegs		;													<29>
			
; HiliteText returns 3 pairs of possibly disjoint char offsets within a style run for highlighting. <29>
			moveq	#2,d7					; set up dbra:counter for OffsetTable pairs			<29>
@tblLoop									;													<29>
			move.w	(a4)+,d0				; get offset1 of pair								<29>
			move.w	(a4)+,d1				; get offset2 of pair								<29>
			cmp.w	d0,d1					; equal?											<29>
			beq.s	@nxtPair				; yes,skip: pair is empty							<29>

; process a pair from HiLiteText																<29>
			move.l	a4,-(sp)				; preserve pairs counter and offset pairs			<29>
; want to restore a4 to contain the teHandle													<29>
			move.l	4(sp),a4				; teHandle on the stack								<29>
			bsr		ptchInvrtRectangle		; skip the vector to avoid wiping out a4!			<29>
			move.l	(sp)+,a4				;													<29>
			
@nxtPair									;													<29>
			dbra	d7,@tblLoop				; loop thru record									<29>
			move.l	(sp)+,a4				; restore original value <22Dec88smb>				<29>			
			rts								;													<29>
			ENDPROC							;													<29>
	ENDIF									; IF SysVers>=$700 THEN
;----------------------------------------------------------------------
	
			MakePatch	ptchSetFont2Keyboard,ExpandMemRec.vSetFont2Keyboard
			MakePatch	ptchCursorMovement,ExpandMemRec.vCursorMovement
			MakePatch	ptchTEGetFormatOrder,ExpandMemRec.vteGetFormatOrder
			MakePatch	ptchCaretDisplay,ExpandMemRec.vCaretDisplay
			MakePatch	ptchGetStylesInOrder,ExpandMemRec.vGetStylesInOrder
			MakePatch	ptchOnSameLine,ExpandMemRec.vOnSameLine
			MakePatch	ptchTestRunDirection,ExpandMemRec.vTestRunDirection
			MakePatch	ptchMeasureWidth,ExpandMemRec.vMeasureWidth
			MakePatch	ptchTEBufferText,ExpandMemRec.vTEBufferText
			MakePatch	ptchDumpBuffer,ExpandMemRec.vDumpBuffer
			MakePatch	ptchBufferChar,ExpandMemRec.vBufferChar
			MakePatch	ptchGetWidth,ExpandMemRec.vGetWidth
			MakePatch	ptchGetRLPosition,ExpandMemRec.vGetRLPosition
			MakePatch	ptchCaretInsideRun,ExpandMemRec.vCaretInsideRun
			MakePatch	ptchInvrtRectangle,ExpandMemRec.vInvrtRectangle
			MakePatch	ptchSetKeyboard2Font,ExpandMemRec.vSetKeyboard2Font
			MakePatch	ptchGetLRPosition,ExpandMemRec.vGetLRPosition
			MakePatch	ptchPixelWidths,ExpandMemRec.vPixelWidths
	IF hasTextWidthHook THEN												;					<17>
			MakePatch	ptchMeasureWholeRun,ExpandMemRec.vMeasureWholeRun	;					<17>
			MakePatch	ptchDoErase,ExpandMemRec.vDoErase					;					<17>
	ENDIF																	;					<17>
	IF forLocalizability THEN
			MakePatch	ptchOnLineEnd,ExpandMemRec.vOnLineEnd				; <34a-YDS-9/2/91>
	ENDIF
			MakePatch	ptchTEInit,$A9CC
			MakePatch	ptchTEStylNew,$A83E
			MakePatch	ptchTESetSelect,$A9D1
			MakePatch	ptchTENew,$A9D2
			MakePatch	ptchTEUpdate,$A9D3
			MakePatch 	ptchTEClick,$A9D4	
			MakePatch	ptchTEDispatch,$A83D
			MakePatch	ptchTEGetText,$A9CB	
			MakePatch	ptchTESetText,$A9CF
			MakePatch	ptchTECalText,$A9D0
			MakePatch	ptchTECopy,$A9D5
			MakePatch	ptchTECut,$A9D6
			MakePatch	ptchTEIdle,$A9DA
			MakePatch	ptchTEPaste,$A9DB
			MakePatch	ptchTEInsert,$A9DE
			MakePatch	ptchTESetJust,$A9DF
			MakePatch	ptchTEScroll,$A9DD
			MakePatch	ptchTEPinScroll,$A812
			MakePatch	ptchTESelView,$A811
			MakePatch	ptchTEAutoView,$A813
			MakePatch	ptchTEGetOffset,$A83C
			MakePatch	ptchTEKey,$A9DC
			MakePatch	ptchTEDelete,$A9D7
			MakePatch	ptchTEActivate,$A9D8
			MakePatch	ptchTEDeactivate,$A9D9
			MakePatch 	ptchTrimMeasure,TETrimMeasure
			MakePatch	ptchTEDoText,TEDoText
	IF SysVers>= $700 THEN													;					<19>
			MakePatch	ptchReCalLines,TERecal								;					<19>
			MakePatch	ptchTEDispose, $A9CD								;					<20>
	ENDIF																	;					<19>
	IF forLocalizability THEN					; <41-YDS-1/30/92>, istall a new patch
			MakePatch	ptchTextBox, $A9CE
	ENDIF
GestaltTEInstall	InstallProc
			IMPORT		GestaltTEciVersion
			move.l		#gestaltTextEditVersion, d0
			leaResident	GestaltTEciVersion, a0
			_NewGestalt
			rts
			EndProc
	
			END
;———————————————————————————————————————————————————————————
;****************** EOP (End of Patch!) **************
;———————————————————————————————————————————————————————————

