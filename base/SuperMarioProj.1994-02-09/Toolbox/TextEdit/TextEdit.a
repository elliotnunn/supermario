;
;	File:		TextEdit.a (formerly te68k.a)
;
;	Contains:	TextEdit for ROM or (when included in TextEditPatch.a) 'ptch' 0
;
;	Written by:	SC	Steve Capps
;				EHB	Ernie Beernink
;				MBK	Margie Kaptanoglu
;				RWW	Russ Wetmore
;				SMB	Sue Bartalo
;				YS	Yishai Steinhart (most recently)
;
;	Copyright:	© 1982-1993 by Apple Computer, Inc., all rights reserved.
;
;	Change History (most recent first):
;
;	   <SM9>	10/12/93	RC		Stop using A6 in the DefClikProc callback.  Instead grad the
;									teHandle from a RecoverHandle on the tePtr
;	   <SM8>	 6/28/93	kc		Init TEDoText,TERecal and TEWdBreak at TEGlobalInit time so work
;									around a QuickTime bug. (Movies containing text as StartupItems)
;	   <SM7>	10/22/92	CSS		Change some branch short instructions to word branches.
;	   <SM6>	 10/6/92	PN		# 1040150 Get rid of Sysvers conditionals and bring the code to
;									the current state (7.1)
;		<50>	 8/11/92	SMB		#1036481 <gbm>: #1036481 <gbm>: Removed font/keyboard
;									synchronization for Roman-only systems.  It's unnecessary and
;									slows things down!
;		<49>	 7/15/92	SMB		## <ys>: Renamed DoText selectors: teMark is now teHighlight and
;									teLoc is teCaret.
;		<48>	  7/8/92	PKE		Fix up previous comment (I was too quick with the Return key).
;		<47>	  7/8/92	PKE		#1035214 <csd>: Fix DoSearch so that it always exits by calling
;									FreeFmtOrderArray at exit, which will dispose of any fmtOrdering
;									handle and clear the ExpandMemRec.emFmtOrderHFlag flag which
;									says that the handle is valid. This will prevent subsequent
;									calls from thinking they have a valid handle before they
;									actually allocate one.
;		<46>	  7/7/92	PKE		#1030684 <yds>: TEGetPoint failed in multiline text if a R->L
;									script was present because in this case DoMeasure measured from
;									the beginning of the buffer, not the beginning of the current
;									line. Fixed.
;		<45>	 6/23/92	SMB		#1029263,<pke>: Now checking the script's 'itlb' flags to
;									determine if the keyboard and font should be synchronized. Added
;									new IM 2nd Ed. routine names to the file for easier searching of
;									routines.
;		<44>	 4/27/92	DTY		Get rid of hasSplineFonts conditionals.
;		<43>	 4/20/92	YS		#1027783, a wrong label @1 instead of @3 caused the wrong jump,
;									and the stack was not cleared, causing the registers not to be
;									restored.<43-YDS-4/19/92>
;		<42>	  4/3/92	YS		#1025998, in TextBox, when trying to find the right line highet
;									in systems that use associated font (see <41>), saving and
;									restoring of the font saves a LONG (instead of a word) creating
;									the problem of loosing the port font. Another connected problem
;									was the way Script Manager handeld those privete verb calls in
;									the roman. This was fixed in the Script Manager. <42-YDS-4/2/92>
;		<41>	  2/6/92	YS		#1014691, Cube-E, In the old days, the Hebrew/Arabic extention
;									used to calculate the highet of a script font as Max(script font
;									size, associated font size). The problem with that is that if
;									you use style runs, like styled TE & WP's, you can't get the
;									real size of of a script font, and you allways have the
;									associated font size in it. The universal one byte init no
;									longer handles it. TE will calculate it itself if it is: 1)
;									unstyled text. 2) script font. 3) Has associated font (other
;									then 0). <41-YDS-2/6/92>
;		<40>	  2/4/92	YS		#1015382, Cube-E, don't redraw the whole line for a left 2 right
;									system when justification is teForceLeft. <40-YDS-2/5/92>
;		<39>	 1/30/92	YS		#1018683, Cube-E: TextBox should handle #teForceLeft correctly
;									and not set it to #teJustLeft allways. <39-YDS-1/30/92>
;		<38>	 1/13/92	PKE		#1019673, Bruges: Unstyled TE should not sync the keyboard at
;									all for smEastEurRoman script.
;		<37>	12/17/91	PKE		#1017647: Fix keyboard synchronization in unstyled one-byte
;									non-Roman text. For bidi scripts: don't synchronize control
;									chars and L-R numbers, set keyboard to Roman for other L-R
;									chars, and sync keyboard to font for R-L chars. For other
;									scripts: sync keyboard to font for script letters, set keyboard
;									to Roman for Roman letters, and don't sync anything else.
;		<36>	12/12/91	DCL		#1009157: Changed a Tst to Tst.b so as not to test the potential
;									garbage in the other byte. Changed procedure noClickProc in
;									TextEdit.a, StyledTextEdit.a, and TextEditPatchIIciROM.a
;		<35>	11/12/91	JL		fixed the broken build. The previous change had a <34> after an
;									EndIf with no comment marker - - ooops! The build was broken for
;									a day and no one complained.
;		<34>	11/12/91	SMB		#1014705 - for CubeE and Bruges. Keyboard and font synch'ing
;									isn't correct for punctuation and numbers: TE allows a Roman
;									keyboard & a non-Roman font combination for ascii characters and
;									european characters (or high ascii chars.) and it should also
;									allow this for numbers and punctuation marks. This was reported
;									against the Eastern European systems. Actually, this code will
;									be optimized to only allow this unsynchronized state for a
;									2-byte fontScript and a Roman kbd. See ClickKeyboard2Font. Also
;									fixed some bugs in the synchronization of the font & kbd for
;									unstyled text in TEClick and TEKey.
;		<33>	 9/30/91	YS		Used to syncronize the keyboard wrong for L->R scripts
;									(unstyled) when was backspacing a selection (and not a single
;									delete), d6 wasn't set up corectly. use teSelStart(a3) instead.
;									(bug #1013159) <33-YDS-10/1/91>
;		<32>	 9/23/91	PKE		For Cube-E (and Bruges): If non-Roman scripts are installed,
;									TEInit should no longer set TESysJust to its idea of system
;									default, since users can now set the default. Also: Define
;									forLocalizability here if it is not defined in BBSStartup.
;		<31>	 9/13/91	YS		Rolled in the fixes made for SS-6.1. 
;									<31p>	Fix the wrong placment of the caret for one blinking cycle when
;											changing a language and typing a char. (bug #1006971)
;											<31p-YDS-8/27/91>
;		 							<31n>	when backspacing, sync the keyboard to the right language enen
;											for unstyled (single byte only). (bug #1006972) <31n-YDS-8/27/91>
;		 							<31m>	Fix the Big cursor bug, this is NOT the old big applelink cursor
;											bug (fix YSD <3.1>). In the case where the cursor is on a line
;											start, we used to fall into the single caret code
; 											(but we didn't have any split caret !!!), so while switching
;											the cursor rect's  for a single caret, we used to garbage the 
;											selRect. so, we now test ExpandMemRec.emTwoCursorsFlag in this 
;											case to avoid it. (bug #1007065) <31m-YDS-8/27/91>
;		 							<31l>	Fix TEGetPoint for styled TE for R->L scripts, used to asume
;											that if we are on a begining of a style run, the width is 0, and
;											if we are on the end, we should TextWidth all of it, which is
;											not true for R->L scripts. (bug #1007067) <31l-YDS-8/27/91>
;									<31k>	Added support for a single caret while handling an Arrow (left
;											or right) key, for styled L->R text. have to change the Keyboard
;											in a different way to support the corect display of a 
;											single caret. <31k-YDS-8/27/91>
;									<31j>	Fix in xStyleGuts, don't change font's when their are not from the same 
;											script, has a minor fix in SetGuts to.(commented) <31j-YDS-8/27/91>
;									<31i>	Fix DoMeasure for Right to left text in unstyled TE, in order to 
;											support fix <31h> for unstyled, use _Pixel2Char instead of
;											 MeasureIt. <31i-YDS-8/27/91>
;									<31h>	Fix TEGetPoint Bug for Right to left text, use DoMeasure 
;											instead of MeasureIt. <31h-YDS-8/27/91>
;									<31g>	Synch Keyboard to click even with an unstyled TE record, 
;											this is not only a nice thing to do, but very importent when
;											handling a single cursor on a bi-direction script, if we 
;											would like your single-split carret to be displayed 
;											correctly.  <31g-YDS-8/27/91> 
;									<31f>	when click on script boundry, take care of the next cursor
;											update, has to do with the split carret stuff. This was fixed
;											in SetKeyboard2Font and ClickKeyboard2Font.<31f-YDS-8/27/91>
;									<31e>	find where the click was (to define the right script).<31e-YDS-8/27/91>
;									<31d>	Support for a single carret, this supports the styled 
;											TE part.<31d-YDS-8/27/91>
;									<31c>	Added support for a single carret, it will expand & shrink 
;											the the right part of a cursor to show only "one" cursor, 
;											depending on the language, so we will gwt a moving cursor 
;											(when switching scripts). this supports the unstyled TE part.<31c-YDS-8/27/91>
;									<31b>	using the byte after the TwoByteCharBuffer in teDispatchH for
;											fixes <31c> and <31d> (lastScript), so change the place it clears 
;											so only a word will be cleared there (instead of a long).<31b-YDS-8/27/91>
;									<31a>	Fixing Hebrew/Arabic AppleLink bug that causes a big cursor: 
;											the  right way! this fix is in four places.<31a-YDS-8/27/91>
;		<30>	  4/3/91	SMB		jdr,#86089: (also, pke) Fixing appl-crashing bug in
;									NewRomanFindLine - should be clearing the high word of d0 before
;									doing a long operation. Shows up when applications use
;									TEHitTestHook and have multiple styles on a line.
;		<29>	 2/14/91	SMB		pke,#70628: Unfortunately, forced to remove support for Forward
;									Delete that was added in <20>. Conditionalizing it out so it can
;									be added again later. See <29>.
;		<28>	 2/14/91	SMB		pke,#82817: After Dark and Chooser string clipping bug -
;									NewRomanFindLine's dependency on _NPixel2Char takes into account
;									the caret width when determining linebreaks. This 1 pixel
;									difference caused strings that were 1 pixel too long to no
;									longer completely display since the linebreak occured in a
;									different place. The problem was that the measurement occured on
;									the character boundary (after the final character of the string)
;									and the leading edge value returned was F. TextEdit deals with
;									these results by backing up one character to guarantee that all
;									characters completely display when drawn. In the case of calling
;									_NPixel2Char this is not necessary since it will still return
;									the correct results and TextEdit will behave correctly based on
;									these results. So, to fix this problem we no longer subtract one
;									for the caret width before calling _(N)Pixel2Char.
;		<27>	 2/14/91	SMB		pke,#DTS FT: Quit trashing a4 across Hook calls!
;		<26>	 2/11/91	SMB		pke,#SMB-2/9/91-1: TextEdit didn't always erase characters when
;									deleting them. Another symptom of this same bug is that TextEdit
;									didn't line break at a CR. The problem was that when TE looked
;									ahead for blanks at the end of a line in NewRomanFindLine, it
;									skipped over blanks, CRs and any other character whose value was
;									<=$20. Now it checks each breaking character for a CR and once
;									found, forces a line break there.
;		<25>	 2/11/91	SMB		jdt,#TEBug.ReCaLines: KanjiTalk bug fix in ReCalLines - need to
;									back up 2 bytes for correct redrawing of double-byte text.
;		<24>	 2/11/91	SMB		pke,#OYDBB002: Fixed the MathCad (application) bug in
;									NewRomanFindLines by ckecking for a dummy style run at the end
;									of the StyleRun array whose startChar = endChar.
;		<23>	  2/1/91	SMB		pke,#HIG-JS-048,#81519,#82169: In NewRomanFindLine: testing for
;									a blank at a line break before calling TE's FindWord routine.
;									Fixed problem with styles in balloons: was comparing a final
;									result to the linestart in d6, but it was modified for styles,
;									so needed to compare to actual value saved in lineStart(a6).
;									Fixed performance problem: change in algorithm caused unstyled
;									TE to call TextWidth on the entire document (pinned to each
;									lineStart) when determining line breaks. Major slowdown! Are now
;									calling _NPixel2Char instead of _TextWidth & _Pixel2Char in TE's
;									Pixel2Char routine (TEHitTestHook). Should make TE FAST(er)!
;									Renamed leftSide to leadingEdge in P2CFrame and added
;									WidthRemaining member (see TextEditPriv.a).
;		<22>	 1/22/91	SMB		(pke) Re-fixing bug #68221. The previous fix required calling
;									OutlineMetrics for the whole font in order to get an ascent &
;									height in TextEdit. This wasn't acceptable due to reformatting
;									problems. So, the code to support OutlineMetrics has been
;									removed and we are now turning off PreserveGlyph before drawing
;									in order to draw squished characters when their ascent or
;									descent is larger than the font's metrics. GetFontInfo will
;									still be used to get ascent & height, as in the past, and we
;									will be backwards compatible although not pretty.
;		<21>	 1/18/91	SMB		(pke) Fixed bug # 62963 - No longer preserving a3/a4 across
;									DumpBuffer routine. Saving a3 caused a dangling ptr and it's not
;									necessary to save a4. Also, added a call to DumpBuffer in
;									TEDispose in case an app never calls TEIdle (which empties the
;									buffer). Changed _NewHandle call in GetHandle to allocate the
;									handle in the System heap in order to prevent orphaning the
;									handle when an application quit without emptying the text
;									buffer. • Also fixed a linebreaking bug in Pixel2Char - wasn't
;									calling DoubleByte with the correct offset (was using the offset
;									for the line not the offset w/in the whole text buffer thus
;									far.)
;		<20>	 1/14/91	SMB		(jdt) • Fixed bug #66732 & #57858: if the scrap handle parameter
;									(newStyles) in SetStylScrap was NIL should do nothing and exit.
;									• Fixed bug #58512: Must lock scrap handle in InsRsrved before
;									calling PstStylGuts since PstStylGuts expects to use the handle
;									again after moving memory. Also fixes bug #65043. • Fixed bug
;									#77962: TE was determining line breaks by measuring words rather
;									than style runs for a Roman-only system. This was causing
;									drawing to be significantly different than the measuring when
;									FractEnable was on or a scaled font was used. Rewrote code (now
;									called NewRomanFindLine) to do the right thing! • fjs fixed bug
;									#70628: adding forwardDeleteChar support in TEKey so that this
;									function key on the extended keyboard works. • Fixed bug #67699:
;									StdTxMeas did not detect overflow when measuring long lines, so
;									the widths returned to TE in this case were small, causing TE to
;									write all the text on one line. StdTxMeas was modified to keep
;									the last count and width before the overflow. This info is used
;									to call _Pixel2Char to get the correct character offset for line
;									breaking. • Fixed bug #66900: TextBox did not clip text
;									correctly for long words due to the incorrect use of _P2C's
;									LeadingEdge flag. See changes in TE's P2C and DoSearch. • Fixed
;									bug #68221: did not calculate the ascent & descent of an outline
;									font correctly if preserveGlyph is true. Now calling
;									OutlineMetrics for this. See routine GetOutlineMetrics and the
;									routines calling it, TextBox & GetSize. • Fixed Finder bugs
;									#80728 & 75607: in StdEntry, for unstyled text, save the
;									grafport's font info before setting the TERec's style info into
;									the grafport.
;		<19>	12/15/90	SMB		(gbm) KT bug: Only draw line in ReCalLines when wordRedraw is <1.
;									Added support for another gestalt selector, gestaltTE5, for the
;									new TextWidthHook.
;		<18>	10/30/90	SMB		Fix text buffering bugs: must preserve register containing
;									ExpandMem ptr around a call to another procedure. Also, moved
;									code that dumps the buffer in SetFont2Keyboard after determing
;									that synchronizing was necessary. Then, must test for an empty
;									buffer in TEBufferText after the SetFont2Keyboard call and after
;									a full buffer has been dumped. Using hasBufferingFix conditional
;									for these changes. Added TextWidthHook to dispatch table and the
;									internal interface which uses the hook, TETextWidthHook to hook
;									out the TextWidth calls to keep our developers happi(er)!.
;									Renamed nTEWidthHook to ScriptChar2Pixel. Using hasTextWidthHook
;									conditional for these changes. Moved frame for TextBox into
;									TextEditPriv.a Added teFUseTextServices to comment although TE
;									doesn't use it. This allows an application to disable inline
;									input. The teFInlineInput bit will be used to enable the
;									features added for Inline Input. This bit is set by the inline
;									input service and may also be set by a developer who desires
;									these features even when inline input is inactive.
;		<17>	 9/13/90	BG		Removed <15>. 040s are behaving more reliably now.
;		<16>	 9/11/90	SMB		Fix teCROnly bug that crashes the system: pre-incrementing
;									caused us to compare one too many in the text and then the +1 to
;									point beyond the CR caused the line breaks to be one off. Moved
;									InlineInput test into TESetSelect instead of ClickKeyboard,
;									since never want to call KeyScript while doing inline. If in
;									Inline, then not hilighting to the EOLs anymore, only to edge of
;									text (see InvrtRectangle). Modified highlighting code to modify
;									the middle rectangle line by line in order to call highHook for
;									Inline. Moved HiliteFrame into TextEditPriv.a.
;		<15>	 7/25/90	BG		Added some EclipseNOPs for flakey 040s.
;		<14>	 7/25/90	SMB		NEEDED for SS-6.0.5, SIXPACK & 7.0: Fixed Hebrew/Arabic
;									scrolling down bug - caused selRect's top & bottom values to be
;									negative which caused a BIG caret to be drawn. Fixed in
;									CaretInsideRun.
;		<13>	 7/10/90	SMB		NEEDED for 7.0 & SIXPACK: Must export GestaltTEVersion.
;		<12>	 7/10/90	SMB		NEEDED for 7.0 & SIXPACK: Oops! Moved GestaltTEVersion back into
;									here for SIXPACK+ builds from TextEditInit.a.
;		<11>	 6/22/90	SMB		NEEDED for 7.0 & SIXPACK: Moved TEGlobalInit, GestaltTEVersion
;									and its vectors to TextEditInit.a. Exported routine labels for
;									TextEditInit.a. NEEDED for SS-6.0.5, SIXPACK & 7.0: fixed Arabic
;									line end bug for unstyled text, where the system slowed down
;									because was reading off the end of the line starts.
;		<10>	 6/11/90	SMB		NEEDED FOR SIXPACK & 7.0: Added Inline Input bit to
;									TEFeatureFlag and support for it in ClickKeyboard2Font.
;		 <9>	 5/29/90	DDG		NEEDED FOR SIXPACK: Changed all the sixpack conditionals from
;									six-point-oh-seven to six-point-oh-six.
;		 <8>	 4/27/90	SMB		NEEDED for SIXPACK - Fixed old bug for old FindWord: when using an
;									application's teWordBreak routine must save d1!
;*********** End of SS-6.0.4 f4 (for KanjiTalk 6.0.4 only!) changes ******************************************************
;		 <7>	 3/20/90	SMB		NEEDED for 6.0.5 and SS-6.0.4 - Added call to SetKeyboard2Font
;									in TEKey (rather than DelGuts, see 1/16/90) for script systems;
;									whenever backspacing over a script boundary the keyscript wasn't
;									updated. Bug #59422. - In TEBufferText, must set d0 to the
;									current position before calling SetFont2Keyboard (in case of a
;									kbd change while buffering)
;		 <6>	 2/18/90	SMB		NEEDED in 6.0.5 - DoSearch didn't work correctly if the
;									TEHitTestHook had been replaced. We needed to check a
;									terminating condition when hooked out: the high word of d0 was
;									set T if found a char offset.
;*********** End of domestic 6.0.5 changes; SS-6.0.4, SS-6.0.5 and 7.0 changes still occurring ***************************
;		 <5>	 2/13/90	SMB		NEEDED for 6.0.5 - Fixed broken TEWidthHook by putting back in
;									the old C2P code and adding a new hook nTEWidthHook for the SMgr
;									compatible C2P.
;		 <4>	 1/30/90	SMB		NEEDED FOR 6.0.5 - multiple bugs fixed: see history below.
;				 1/30/90	smb		- Fix in TEKey so that when the current position is at a line end and
;									the height of the current line is > the height of the next line, the 
;									down arrow will put the caret on the next line.  Bug #53697.
;				 1/30/90	smb		- Fix to PtToLine to leave the line # negative when going up on the
;									top line. Makes DoFind do the right thing. Fixes bug 35646: up-arrow 
;									key doesn't get to beginning of text.
;				 1/29/90	smb		- No longer call SetFont2Keyboard for DumpBuffer.
;									- Added patch to DoCaret to pin the caret in view when 
;									blanks exceed the edge of the view rect.
;				 1/26/90	smb		- Before synchronizing the font to the keybd, dump the text buffer: user
;									could change the keyboard in the middle of buffering. (see TEBufferText and
;									SetFont2Keyboard)
;				 1/25/90	smb		- Call HideCaret for up & down arrows to erase the old caret before
;									setting teLftCaret in TEKey. Fixes bug #52887!
;									- Fixed up arrow bug, #51967, that caused the caret to move up multiple 
;									lines according to the size of the largest font on the current line.
;									- If zero width in DoSearch, want to branch ow this one pixel difference
;									causes the caret to display on the wrong line ending. Roman fix. 
;									Bugs #58921,59247.
;				 1/24/90	smb		- Found bug in DoSearch where needed to setup a2 as current line again.
;*********** End of SS-6.0.4 f3 (for Arabic and Hebrew 6.0.4 only!) changes **********************************************
;*********** Did not add humane scrolling or move the equates (see 1/22-1/23 comments) for SS-6.0.4! *********************
;				 1/23/90			- Changed FindWord branch for linebreaking to 'bge' instead of 'bgt'.
;							emt		- Added humane scrolling (slower) to DefClikProc (also see TEClick).
;				 1/22/90			- Moved private equates and frames into TextEditPriv.a.
;				 1/16/90	SMB		NEEDED FOR SS-6.0.4 and 6.0.5 - (added 1/22/90 to Scripts604 build)
;									Added call to SetKeyboard2Font in DelGuts for Script Systems: 
;									whenever backspacing over a script boundary the keyscript wasn't
;									updated. Bug #59422.
;									Reorg beginning of FindWord in order to be compatible with applications
;									using incorrect char breaking algorithms for Script Systems.
;		 <3>	 1/16/90	SMB		NEEDED FOR 6.0.5 - Fixed bug in TEGetPoint, added double-byte
;									buffer at end of dispatch record, fixed bug in r-to-l processing
;									of caret that showed up when scrolling down.
;				 1/15/90	smb		Fixed Hebrew/Arabic scrolling down bug - caused selRect's top & bottom
;									values to be negative which caused a BIG caret to be drawn. Fixed in
;									CaretInsideRun.
;				 1/9/90		smb		Using private space in TEDispatchRec for buffering of a double-byte
;									char rather than using ExpandMem as a global buffer which can affect
;									any active TE record.  This fixes a bug seen in KanjiTalk (AppleShare)
;									when an application uses two TE records. Buffering in one record can 
;									be dumped into the other record due to the global storage space not
;									knowing which record it applies to.
;				 1/8/90		smb		NEEDED FOR 6.0.5: bug 58823, TEGetPoint returned incorrect values
;									when there's no text in the TERec.
;		 <2>	 1/4/90		PKE		NEEDED FOR 6.0.5 (smb's changes from SS-6.0.4b23 to SS-6.0.4f1):
;									•<15Dec89smb> Set the offset parameter to non-zero for
;									StyledLineBreak for unstyled text. •<17Dec89smb> Preserve
;									register d2 in HiliteMiddle. ALSO: Changed conditionals from
;									(Scripts604 | SysVers >= $700) to (Scripts604 | SysVers >=
;									$605). Updated header to BBS format.
;		<1>		12/18/89	CCH		Adding for the first time into BBS.
; BBS versions above:
;___________________________________________________________________________________________________
; EASE versions below:
;	   <3.2>	12/11/89	smb		See history of bug fixes below dated Nov. 22, 1989 -> Dec. 7,
;									1989.
;				 12/7/89	smb		Fixed problem with setting the boundaries in ChkBounds. Also set
;									boundary in DoDraw based on WordRedraw rather than teSysJust.
;								•	Corrected test of teForceLeft in iTEGetPoint.
;								•	Fixed bug of a large cursor (#52888) due to RomanFindLine (really
;									StylMeasure & P2C) incorrectly increasing the char count due to
;									an invalid leftSide flag set in TE's P2C. This caused ReCalLines
;									to read beyond the end of the line heights record. Fixed by
;									setting a flag which said to ignore the leftSide flag if TextWidth
;									did the measuring in P2C.
;				 12/6/89	smb		Unconditionalized code in VisibleLength to fix a LR line w/ R
;									justification display bug. Mark was right!
;								•	Set flags in caret display code to indicate when in the middle 
;									of a style run but on a line end (see CaretInsideRun).
;								•	Fixed bug in {hit-down on,cursor movement to} a script boundary
;									to set the keyboard to the preceeding style run rather than the
;									succeeding one. (see calls to ClickKeyboard2Font).
;								•	In BufferChar & DumpBuffer backed up one offset posn to get
;									previous style run for SetFont2Keybaord call.
;				 12/5/89	smb		Fixed LR highlighting bug at line ends; in InvrtRectangle.
;				 12/3/89	smb		Added a new keyboard/font synchronization routine to be used
;									when doing a hit-down which allows a Roman keyboard with a
;									non-Roman font, specifically because KanjiTalk wants to enter
;									Roman text from a Japanese font.
;								•	Fixed potential bug in TESetStyle: must test the doFont bit in
;									the mode since it's possible for the mode to be an additive
;									combination of styles.
;								•	Use application font for SetFont2Keyboard rather than system
;									font.
;								•	Have to use emBufferPtr for a flag to indicate when I
;									unsynchronize the font & keyboard in ClickKeyboard2Font. These
;									will be used to keep SetFont2Keyboard from synchronizing the
;									font & keyboard when trying to paste a character in this
;									unsynchronized situation.
;								•	Also had to add a call to ClickKeyboard2Font from TESetSelect in
;									order for horizontal cursor movement to work correctly in this
;									new unsynchronized situation.
;				11/26/89	smb		More cursor movement pinning, this time in GetStyleEnd. Also,
;									need to use the high caret rectangle in TEKey rather than always
;									using the teSelRect!
;				11/22/89	smb		In CursorMovement had to pin the style run to the line end for
;									correct position.
;	   <3.1>	11/21/89	smb		See history of bug fixes below dated Oct. 4, 1989 -> Nov. 20,
;									1989.
;				11/20/89	smb		Added a test in ptchGetRLPosition because when processing a CR
;									entered at the EOD, the current line (a2) is the next line. This
;									causes TE to look beyond the end of the lineStarts array.
;				11/17/89	smb		Bug in DumpBuffer for unstyled textEdit: screwed up stack since
;									was popping the stack w/o doing the push! Now doing the push as
;									well!
;				11/16/89	smb		Fixed TrimMeasure for unstyled TE. Also moved the firstStyleRun
;									and secondStyleRun to the top of the the FmtOrderFrame.
;				11/13/89	smb		Bug fix for buffering 2 byte text on Kanji! see DumpBuffer and
;									TEBufferText.
;				 11/8/89	smb		Moved secondStyleRun and firstStyleRun from SharedFrame to
;									FmtOrderFrame since TextFrame needs this info for XTrimMeasure
;									changes.
;				 11/6/89	smb		Fixed buffering bug in BufferChar & TEKey; must set emBufferLen
;									non-zero when buffer the 1st byte of a 2-byte character.
;				 11/1/89	smb		Adding call to GetStylesInOrder in order to call VisibleLength
;									for a line's style runs. We need to traverse the style runs in
;									display order but backwards!
;				10/31/89	smb		Fixed TETrimMeasure to call VisibleLength at the appropriate
;									times for unstyled text: LineRect uses the line direction and
;									justification to determine when to call it.
;				10/26/89	smb		Bug fix in FindWord for Chinese Script System: clear
;									fwLeadingEdge flag!
;				10/16/89	smb		Added updating of outlined region in TEUpdate.
;				 10/6/89	smb		Had to clear (a2) in iTEFeatureFlag so that the return result
;									was set right for an initial state of clear (vs. set).
;				 10/4/89	smb		Removed LRTextFlag since it's based on WordRedraw. Will tst
;									WordRedraw instead!
;	   <3.0>	10/12/89	smb		Checked in fix below dated 10/3/89.
;				 10/3/89	smb		Fixed the caret display in TEActivate and TEDeactivate for
;									outline highlighting. Put in old DoHilite code for Roman systems
;									for HyperCard outlining.
;	   <2.9>	 9/26/89	smb		Checked in fixes below dated 8/31/89-9/19/89, plus: Saving the
;									bit in the upper byte of the ExpandMemRec.emBufferLen word.
;				 9/19/89	smb		Adding Outline Hilighting to TEActivate/TEDeactivate.
;				 9/17/89	smb		Fixed TEKey to turn off and reset the text buffering bit around
;									the StdEntry call.
;				 9/15/89	smb		Must move newTEFlags into a data reg for modulo 32 bit ops
;									(bset,bclr,btst).
;				 9/14/89	smb		Added calls to dump the text buffer in StdEntry and TeKey.
;				 9/12/89	smb		Fixed up DumpBuffer and TeFeatureFlag code.
;				  9/6/89	smb		Removed call to SetFont2Keyboard in TEKey since I added it to
;									BufferChar.
;				  9/5/89	smb		Complete rewrite of SetFont2Keyboard.
;				  9/2/89	smb		Fixed bug #52736, CursorMovement should jump 2 bytes for Kanji
;									on a RL line. Had to also add call to SetFont2Keyboard in
;									BufferChar since changing the styled teRec's initial kbd setting
;									(from Roman to Japanese) before entering Kanji text caused the
;									character to display incorrectly. It was using the initial
;									setting in the style run array, rather than synchronizing the
;									font to the current keyboard before displaying.
;				 8/31/89	smb		Fixed TEKey bug: when returning from BufferChar should branch
;									signed rather than unsigned. Also fixing bug in SetFont2Keyboard
;									to always modify the Rsrved font if it exists. Both fixes for
;									bug #51962.
;	   <2.8>	 8/30/89	smb		NEEDED FOR 604 Script Systems AND BIG BANG ...(see additional
;									comments below dated 7/31/89 - 8/29/89) 
;				 8/29/89	smb		Fixed Roman RL hiliting. Wasn't hiliting correctly for line
;									ends. See MeasureWidth. (added to SS-6.0.4 and 7.0 PTCH!)
;				 8/25/89	smb		Fixed Kanji word dragging bug, #51603, by comparing the char
;									offset to the Left anchor and setting the leadingEdgeFlag
;									accordingly. (added to SS-6.0.4 and 7.0 PTCH!)
;				 8/19/89	smb		Fixed another unlocked handle bug. Similar to bug #51602. Made
;									d3StyleRun(a6) and d4StyleRun(a6) offsets rather than pointers.
;									See OnSameLine. (added to 6.0.4 PTCH!)
;				 8/10/89	smb		Added one more fix in teKey for arrow keys to work after a
;									hit-down on the R. end of a line. (added to 6.0.4 PTCH!)
;				  8/8/89	smb		Added Gestalt function. (added to 6.0.4 PTCH!)
;				  8/7/89	smb		Fixed bug #51640 - the hyphenation bug - the right way in
;									FindWord. When RecalLines calls FindWord on a Roman system
;									should use the old FindWord code. (not added to 6.0.4 PTCH!)
;				  8/5/89	smb		Fixed multiple cursor bug, #51602 - was saving a ptr to the
;									styleRun array in a2StyleRun(a6) (see teGetFormatOrder) when the
;									handle to the styleRec wasn't locked! Oh-Dopey-Me! ANY memory
;									movement could cause this bug! Fixed in GetNextDisplayStyle,
;									DoSearch, TEGetFormatOrder by saving it as an offset, and then
;									restoring it to a ptr when I need it. This is just for styled
;									text. I save it as a pointer for unstyled text since I create it
;									myself (see GetFormatOrdering). (added to 6.0.4 PTCH!) Fixed bug
;									#51961 - striking an up/down arrow key after a hitdown at either
;									line end caused the caret to display at the opposite end of the
;									line rather than the previous line. This bug occurred because
;									teKey was inappropriately setting teLftCaret to T. It should
;									only be set initially if the key was not a cursor key. (added to
;									6.0.4 PTCH!)
;				  8/4/89	smb		Fixed Roman line breaking bug, #51677 - must incr to the next
;									char posn in StylMeasure when the LeftSide flag from P2C is
;									False. RomanFindLine expects the result back to be a LeftSide
;									hit, not a rightSide hit! (added to 6.0.4 PTCH!)
;				  8/2/89	smb		Added SMgr VisibleLength code. (added to 6.0.4 PTCH!)
;				  8/1/89	smb		In yesterday's fix I had a bug in swapping d2 around a test of
;									the CCs. Fixed by saving d2 and restoring it w/ a "movem" which
;									won't affect my CCs!
;				 7/31/89	smb		Fixed an Arabic highlighting bug that occured by having an
;									arabic word followed by a long Roman word that forced a
;									linewrap. The problem was that code was added to TE's C2P to use
;									TextWidth for hit-test on line ends rather than SMgr C2P.
;									However, it should still use SMgr C2P for hiliting and it
;									wasn't. So, fixed it so it would! (not added to 6.0.4 PTCH!)
;	   <2.7>	 7/25/89	smb		NEEDED FOR 604 Script Systems AND BIG BANG … (see comments below
;									dated 7/17/89 - 7/24/89)
;				 7/24/89	smb		ConcatStyles should only be called in DelGuts for a styled
;									record. Oops! NOT ADDED TO 604 AURORA PTCH: Cleanup of nEqu.d
;									file: renamed nStyle to nStyles, as it should be.
;				 7/21/89	smb		Added ConcatStyles to DelGuts - when it deletes a style it
;									doesn't check to see if the two adjacent styles are the same.
;									Found this in Arabic.
;				 7/20/89	smb		Before using an existing NullStyle in SetFont2Keyboard must make
;									sure the font's script is the same as the keyScript. Otherwise,
;									use script's default font.
;				 7/19/89	smb		Fixed Roman FindWord hyphenation bug. Problem was occurring
;									because RecalLines used the SMgr-compatible FindWord for
;									determining a word boundary but when it called FindLine for the 
;									line break, FindLine used the oldFindLine code (RomanFindLine)
;									which used the old FindWord code. This inconsistency caused
;									RecalDraw to only redraw the second line where the word
;									following the hyphen was to be displayed. It needed to also
;									redraw the first line where the first half of the hyphenated
;									word existed. There was also a problem with "where" the second
;									part of the hyphenated word was being displayed on the next
;									line. Because performance dictated the need to use the old
;									FindLine code for Roman systems, we can't easily fix these
;									problems. The best and easiest fix for this is to always use the
;									old FindWord for all of Roman word breaking needs. Removed code
;									from RomanFindLine that said the caller of FindWord was
;									RomanFindLine. It's no longer necessary.
;				 7/18/89	smb		TEInit fix: replaced d1 w/ d3 for WordRedraw determination, and
;									fixed loop incremental. Replaced call to AltSetRsrved in
;									SetFont2Keyboard to SetRsrved. Changed in v2.2.
;				 7/17/89	smb		NOT ADDED TO 604 AURORA PTCH: Cleanup of branching in DoMeasure.
;									NOT ADDED TO 604 AURORA PTCH: Faster clearing of d0's high word
;									in FindLine.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 6.0.4 patches and 7.0 ptch0 from here up ;;;;;;;;;;;;;;;;;;;;
;	   <2.6>	 7/13/89	smb		NEEDED FOR AURORA! (see comments below dated 7/3/89-7/12/89)
;				 7/12/89	smb		Misc. cleanup after code review.
;				 7/10/89	smb		Cleaned up TEFeatureFlag routine, and added another feature bit,
;									teFForceScriptFont (to be used in SetFont2Keyboard for Script
;									Systems).
;				  7/7/89	smb		Fixed bugs for Arabic and Kanji.
;				  7/5/89	smb		Fixed dummy run bug in DupStyle - had fixed in PstStylGuts but
;									then I broke inserting a style in the middle of another style,
;									and in fixing this discovered an easier fix to the original bug!
;				  7/3/89	smb		Moved vector initialization above SMgr init code in TEInit in
;									order to boot script systems before they are enabled. (They were
;									calling TENew, and since vectors weren't initialized it was
;									crashing.)
;	   <2.5>	  7/9/89	smb		Moved include of ScriptPriv.a back into casm statement! V2.4
;									broke my ROM build. Since ROMS and System files are built from
;									this file, I had to modify the System patch file for TE instead.
;	   <2.4>	  7/8/89	smb		Moved include statement for ScriptPriv.a out of a casm statement
;									for Big Bang build.
;	   <2.3>	 6/30/89	smb		NEEDED FOR AURORA! Mucho worko accompli! (see comments below
;									dated 6/19/89 - 6/30/89)
;				 6/30/89	smb		Fixed bug in TEInit code for setting wordRedraw in order to use
;									on Script Systems.
;				 6/29/89	smb		Fixed signed/unsigned bugs. Added vectors. Misc. clean up,
;									performance improvements, and bug fix.
;				 6/24/89	smb		Fixed problem of a dummy run being created in DupStyle when only
;									one style was being pasted. For more than one style, fixed the
;									problem by calling ConcatRuns in teStyleInsert, InsRsrved,
;									DelGuts, and PasteGuts. Cleared out ExpandMem space that I use.
;									Misc. bug fix and clean up.
;				 6/23/89	smb		Fixed many direction bugs: teSysJust and wordRedraw problems.
;				 6/20/89	smb		Fixed Arabic lineEnd bugs in C2P. Was breaking highlighting and
;									hitdown.
;				 6/19/89	smb		Fixed obscure measuring bugs for Arabic in DoMeasure and
;									GetWidth. Was breaking display of two adjacent Roman fonts on an
;									Arabic SIS w/ RL line direction.
;	   <2.2>	 6/13/89	smb		Check-in (see comments below dated 5/30/89-6/12/89)
;				 6/12/89	smb		Fixed FindLine to work w/ Peter's correct version of
;									StyledLineBreak. Fixed script run boundary bug in FindWord.
;									Added TEFeatureFlag interface and activated buffering code (was
;									casm'd out.
;				  6/8/89	smb		Fixed RomanFindLine to call the old FindWord code rather than
;									the SMgr FindWord code.
;				  6/7/89	smb		Modified CaretDisplay code for RL text by calling new
;									GetDirection rather than GetStyleDirection.
;				  6/5/89	smb		Finally found the style run bug: problem was caused by
;									subtracting two pointers to get a length; one of the pointer had
;									the high byte set; fixed by calling StripAddress. Fixed for
;									other guilty code!
;				 5/30/89	smb		Added direction of font to high-order byte of stFace in the
;									array of stElements for performance. Also added TEFeatureFlag
;									interface for outline highlighting and text buffering.
;	   <2.1>	 5/30/89	smb		Check in (see comments below dated 5/16/89-5/23/89)
;				 5/23/89	smb		Fixing FindWord problems for double-byte text by replacing a
;									huge piece of logic with some simple statements for determining
;									the leadingEdge flag for SMgr's FindWord. Also fixed some bugs
;									in FindLine for MultiScript and Kanji systems.
;				 5/17/89	smb		Must lock the StScrpHandle for SetStylScrap to work correctly:
;									see bug #36986.
;				 5/16/89	smb		Had to reset A2 to selStart(a3) in TECopy after a NewHandle
;									call, which may have invalidated the pointer to the teRecord
;									(upon which A2 was based!). See bug #46036.
;	   <2.0>	 5/13/89	smb		Added back in mods for v1.8. Also fixed more bugs: see comments
;									below dated 5/12/89-5/13/89.
;				 5/13/89	smb		In TE's P2C had to test if pixelWidth passed in was = to
;									TextWidth's result; if so, done. Exit w/o calling SMgr's P2C.
;									Fix for bugs #47756,48159.
;				 5/12/89	smb		Had to save a1 in FindLine before calling GetEnvirons since
;									RecalLines depended on it. Also added FindLineRegs to old
;									FindLine for this.
;	   <1.9>	  5/5/89	smb		Backed out v1.8!
;	   <1.8>	  5/5/89	smb		Check in (see comments below dated 5/2/89-5/5/89)
;				  5/5/89	smb		Added the old FindLine code back in for Roman text: performance
;									hit!
;				  5/4/89	smb		Bug fix in DoSearch: hit-test on line ends wasn't correct for
;									Arabic SIS. Fix for HyperCard bug 47857: clicking at the left of
;									a line was placing the cursor at the end of the previous line.
;									Needed to add a test for CR in order to fix this.
;				  5/2/89	smb		Changed branch condition after test of teCROnly. Fix for bug
;									39276: changed add operation in TECustomHook from a long op to a
;									word op.
;	   <1.7>	 3/29/89	smb		Misc. bugs fixed: see comments below dated 3/17/89-3/21/89
;				 3/21/89	smb		Bug fix: should be a word op and not a long op!
;				 3/19/89	smb		Bug when number of lines in a teRec is zero, but lineStarts
;									array still contains values from previous times. Either first
;									two words in array should be zeroed or should always test for
;									teNLines(a3) before accessing these words. (in RecalLines)
;				 3/17/89	smb		Another TEFindLine bug in CRonly mode: branching on exit to the
;									wrong label.
;	   <1.6>	 3/15/89	smb		Double-byte char fix in BufferText.
;				 3/15/89	smb		Fixed teCROnly bug in FindLine - was returning one character too
;									soon.
;				 3/13/89	smb		Broke out the common part of TextFrame, SharedFrame, and Cursor
;									Frame and created FmtOrderFrame. Bug fix for Cobra II! Left
;									cursor key at the beginning of a teRecord wraps to the end of
;									the teRecord! Fix in DoubleByte.
;				 3/12/89	smb		More synch'ing problems: must use nullStyle if it exists in
;									SetFont2Keyboard; Also fixed a bug in TeKey for
;									SetFont2Keyboard, to use the style of the char previous to the
;									selection start/end. This will handle the case of being on a
;									format boundary.
;				 3/10/89	smb		Fixed problem in synch'ing Font 2 Keyboard: needed a pointer to
;									ExpandMemRec.emNewFont for SetRsrved.
;				  3/6/89	smb		Performance enhancements; called FixFormatEnd for problem of
;									last style run in record.
;				  3/4/89	smb		Fixed bug in BufferChar; wasn't saving 1st byte of double byte
;									char in the correct place in ExpandMem.
;	   <1.5>	 2/22/89	smb		Removed casm flags from code in RangeRect since included all
;									configurations!
;	   <1.4>	 2/19/89	smb		Removed rom casms (see comment below) and removed extraneous
;									routines not being used due to my new code. If needed can back
;									up a version or two.
;				 2/17/89	smb		Removed Rom casms that I added yesterday.
;	   <1.3>	 2/17/89	smb		Check in; see comment below.
;				 2/16/89	smb		Fixed bug in TEInit: reset a0 w/ ExpandMem address after calling
;									StripAddress. Also adding Rom casms for pre-Cobra II roms to use
;									TE code that's not Script Manager compatible,
;									<Not(NuMac|HcMac|MacPP)>. Also fixed bug in TEBufferText,
;									although it's code not being used yet.
;	   <1.2>	 2/15/89	SMB		Merged System File version with Rom version + added code to make
;									TE Script Manager compatible (see non-EASE comments below dated
;									31Aug88SMB and later)
;	   <1.1>	11/10/88	CCH		Fixed Header.
;	   <1.0>	 11/9/88	CCH		Adding to EASE.
;___________________________________________________________________________________________________
; old EASE versions:
;	   <1.7>	 11/2/88	GGD		Got rid of machine specific conditionals in favor of feature
;									based conditionals.
;	   <1.6>	10/27/88	PKE		added script manager support in teinit.
;	  <•1.5>	 9/23/88	CCH		Got rid of inc.sum.d and empty nFiles
;	   <1.4>	  9/6/88	BBM		changed routine names, so they would not conflict with mpw
;									includes.
;	   <1.3>	  5/2/88	RWW		Fixed last-minute System Tools 6.0 bugs - caretHook was never
;									being called, and Pixel2Char was being called directly in one
;									place instead of TEHitTestHook.
;	  <•1.2>	 3/25/88	RWW		Fixed bug in iTEGetHeight when no characters in buffer.
;	  <•1.1>	 3/16/88	RWW		Roll-in of System Tools changes
;	   <1.0>	 2/11/88	BBM		Adding file for the first time into EASE…
;___________________________________________________________________________________________________
; non-EASE/pre-EASE versions:
;				 2/13/89	smb		Fixed bug in FindLine, where I wasn't adding the finalLength to
;									the overall length of the line.
;				  2/1/89	smb		Modified TeKey for textBuffering, but casm for a later build.
;									Also defined new bits in the newTEFlags field (long) in the
;									TEDispatchRec: bit 0 = teFAutoScr (already being used as such,
;									just made a constant) and bit 1 = teFBuffText. Added ExpandMem
;									calls, and removed equates that have been moved to ToolEqu.a.
;									Added ExpandMemRec in place of with/endwith pair around all uses
;									of ExpandMem fields.
;				 1/25/89	smb		Modified SMgr calls for MPW 3.0 Equates.
;				 1/24/89	smb		Fixed a bug in hiliting for unstyled text. Was wiping out my
;									fake style run array when I hilited the left end of the line,
;									and before I used it for the right end of the line.
;				 1/21/89	smb		Removed ChkBounds fixes since didn't appear to be working with
;									them.
;				 1/20/89	smb		Modified CursorMovement to remove unneccessary code and to
;									branch correctly.
;				 1/18/89	smb		CodeReview mods: added FreeFmtOrderArray. Modified ChkBounds,
;									added R-to-L test for TrimMeasure, and reorganized
;									formatOrdering code.
;				12/21/88	smb		Fixed teDrawHook bug: at entry, a4 was not the handle to the
;									teRecord as documented. Replaced Lo3Bytes code in FindWord with
;									_StripAddress. Added code to keep the high caret in view
;									(TESelView+) when split cursors occur.
;				12/13/88	smb		Modified GetRLPosition routine to correctly display split
;									cursors. The rule is to display the high cursor at the script
;									run whose direction corresponds to the line direction
;									(downstream flow), and the low cursor at the script run whose
;									direction is opposite of the line direction (upstream flow).
;				 12/9/88	smb		Added new conditionals and creating one file for Rom and System
;									File builds.
;				 12/5/88	smb		Modified teHiliteText to work correctly for mixed directional
;									text. Must pin not only to style run but also current line. 
;									Results from SM HiliteText vary due to line direction; Modified
;									PixelWidths to call C2P with the offsets returned. Cleanup all
;									this new code for unstyled text. Fixed FindLine bug that caused
;									a crash when adding new styles that forced a line wrap.
;				11/29/88	smb		Fixed FindLine code to use the correct parameters for script
;									changes when calling StyledLineBreak. Added a routine,
;									ConcatRuns, to clean up the styleRun array. A null run (not
;									entry) was being added to the array the first time a style was
;									added to the teRec (this is after the default run is set up.)
;									Also fixed a bug in SetOneStyle. Was creating the initial run
;									with a length of teLength rather than teLength+1.
;				10/25/88	smb		In DoMeasure, changed test for reverse order from TESysJust to
;									WordRedraw. Added code for caret positioning. Also synched the
;									keyboard to the font and the font to the keyboard.
;				10/25/88	smb		Find correct WordRedraw value in TEInit; fixed GetWidth to
;									measure with TextWidth when trying to measure a whole line or a
;									complete style run, otherwise to measure with Char2Pixel. This
;									fixed the problem of the selRect falling outside the right edge
;									of the view rectangle when TESysJust is set R->L. (23Sept) Fixed
;									the selection problem in Pixel2Char when TESysJust is set R->L.
;									Rewrote highlighting code now that I can see the right results
;									for display and hiliting. (25Oct) GetFormatOrder was added to
;									display style runs correctly on a line.
;				 8/31/88	SMB		ALTAIR enhancements: changes made to FindLine, FindWord, and
;									DoHilite to call SMgr routines to get the job done. Also added a
;									new routine GetCurScript to return the current script at a given
;									character position for a styled teRec. Renamed routines (by
;									adding an 'i' for internal) due to MPW name collisions in the
;									rom.
;	  <S508>	  8/2/88	RWW		S508 revisited, since it got copied over. Figured out a much
;									simpler method of handling the problem (handle being
;									dereferenced over a call to InstallIntDispatch which could
;									thrash the heap) involving only a one line change - calling
;									MyNewHandle instead of _NewHandle.
;				 6/27/88	SMB		ALTAIR Changes: Incorporate changes to support different script
;									systems in order to be SMgr compatible. East Asian support and
;									left-dominant Middle Eastern complete. Changes made in:TEInit,
;									Pixel2Char, Char2Pixel, TeKey, MeasureIt. Added DoubleByte and
;									BufferChar.
;	  <S425>	 3/16/88	RWW		Fixed bug in TEContinuousStyle and changed the way it handles
;									face attributes
;	<PMAB387>	 2/10/88	DBG		Fixed bug in TEDispose where dispatch vector was not getting
;									released for unstyled TE records.
;	<PMAB381>	  2/4/88	RWW		Took out some redundancies and moved autoscroll flag from its
;									position in "teFlags" (née teRecBack) to the new dispatch
;									record. Ooops. It acted as a high bit set in the new handle to
;									the TEDispatchRec
;	  <C971>	 11/4/87	RWW		Yanked SetEraseFlag and associated logic. Only bought us about
;									10% - not enough to get excited over. Added TECustomHook to give
;									a high end way to stuff new internal dispatch table addresses
;	  <C971>	 11/3/87	RWW		Added new internal dispatch table to (quasi-) support tabs. We
;									won't officially support tabs, but these hooks will make the job
;									a lot simpler for those who need it. (It used to be a lot easier
;									to hook in tab support than it is now that styles have to be
;									reckoned with.)
;	  <C971>	10/30/87	RWW		Added some hysteresis to lineStarts hack, to try to prevent some
;									heap thrashing from constant SetHandleSize calls
;	  <C971>	10/29/87	RWW		Changed fail test in SetGuts to masking uninteresting bits Added
;									doToggle functionality to SetGuts, StyleGuts, SetRsrved,
;									CheckMatch
;	  <C971>	10/28/87	RWW		Changed branches to optimal form. Those patches marked
;									"<C971/RWW102887>NO" are for new ROMs and total replacement
;									patches only. (There were an awful lot of word branches where
;									shorts would do!) Added SetStyleScrap
;	  <C971>	10/27/87	RWW		Changed references to faces to be byte instead of word length
;	  <C971>	10/26/87	RWW		InitRsrved had some strangeness in it Added TESetEraseFlag and
;									TEContinuousStyle. Added in code to check for erase flag before
;									performing _EraseRect's
;	  <C971>	10/23/87	RWW		Broke out some common code, trying not to reinvent the wheel:
;									AnyNullStyle, GetTrueStyle, GetOneStyle Changed GetStylScrap to
;									return a proper scrap record, even if there is no selection
;									range. Prevents apps from having to special case insertion
;									points Rewrote most of TEGetHeight to properly sort and pin
;									start/end Added conditional inclusion of TEDispatch'ed routine
;									addresses so I can find them without a Cray
;	  <C971>	10/22/87	RWW		Patched ReCalLines to properly shrink lineStarts array
;	  <C971>	10/21/87	RWW		Added conditional equates to make RAM-based testing easier
;	  <C971>	10/19/87	RWW		Fixed 0 length bug in TEStylInsert
;	  <C971>	10/12/87	RWW		Did some personal cleanup. Added new equates for new structures.
;									Changed Bcc's and Bcs's to more logical forms. Began comparing
;									various patches against this source to resolve differences.
;
;------------------------------ System 6.0 from here up ----------------------------
;
;	  <C914>	10/29/87	rwh		Port to Modern Victorian
;	  <C905>	10/13/87	MSH		Port to HcMac (Laguna). No color on this machine
;	  <C858>	  6/4/87	MBK		Fixed problems of TEStylInsert destroying the StScrpHandle,
;									style duplication problem in PstStylGuts, and TEGetPoint
;									returning incorrect offset when text ends in CR. Removed
;									conditionals around bug fixes.
;	  <C854>	 5/21/87	MBK		Changed TECalText delta to 8001, fixed Pixel2Char disposhandle
;									problem, fixed find style problem in PstStylScrap, fixed
;									GetLineHites to work with fixed height, fixed recal deletion
;									problem, restored input parameter order of TEGetHeight.
;	  <C851>	 4/27/87	MBK		Miscellaneous bug fixes (search on 851 to get more detailed
;									descriptions); added code to handle setting styles on null
;									selections.
;
; ** BETA 8 from here up **
;
;	  <C815>	 2/13/87	MBK		Fixed StdEntry to set the Grafport's txMode from TERec.teMode.
;									Fixed RangeRect to set pnLoc correctly for compatibility with
;									old applications. Fixed FindLine to check for a CR at the end of
;									a string of unwrapped blanks.
;	  <C788>	 2/11/87	MBK		Fixed TEStylInsert to get the input parameters in the correct
;									order.
;	  <C766>	  2/5/87	MBK		Fixed CopyStyle to lock my style handle before calling PutScrap.
;									Fixed DelGuts to relock text handle after munging. Removed call
;									to StdEntry from TEStylInsert because TEDispatch does it.
;
; ** BETA 6 from here up **
;
;	  <C734>	 1/30/87	MBK		I changed PutStylScrap to TEStylInsert, which unlike
;									PutStylScrap will insert the text as well as the style info.
;									Fixed StyleGuts to check for point sizes <= 0 when an addSize is
;									done. It now converts such values to 1. Modified TEGetHeight to
;									subtract 1 from startLine because GetLineHites wants it 0-based.
;									SetStylHandle fixed to dispose of old style handle before
;									setting new one.
;
; ** BETA 5 from here up **
;
;	  <C719>	 1/29/87	MBK		I removed the C717 change to SetHiteAscent. The ptr there was
;									not an offset from styleTab, it was an addr on the stack.
;	  <C717>	 1/28/87	MBK		Made changes in GetDefStyle, DoDraw, MeasureIt, StylMeasure,
;									SetHiteAscent, and SetStyle to protect unlocked pointers from
;									memory reallocation. Added startLine and endLine input to
;									TEGetHeight. Added RecalDraw to PutStylScrap.
;
; ** BETA 4 from here up **
;
;	  <C676>	 1/23/87	MBK		Added GetStylScrap, PutStylScrap, TEGetPoint, and TEGetHeight.
;
; ** BETA 3 from here up **
;
;	  <C622>	 1/13/87	MBK		Changed to clear the color highlight bit only if a highlight
;									hook has not been installed (this was a problem with
;									highlighting in the hex editor of ResEdit). Modified DoErase to
;									erase the previous character if the mode is XOR, otherwise
;									redrawing it will wipe it out (this was a problem in NetTrek).
;									Modified StylMeasure to lock the style Record so that
;									dereferenced pointer doesn't end up pointing to garbage. Also
;									fixed Pixel2Char to do a signed comparison on the stack space.
;									This bug was discovered by tEx, when the RAM cache was set high.
;	  <C597>	  1/6/87	MBK		Restore A3 ptr after RGBForeColor call in StdExit, in case TERec
;									gets moved.
;	  <C574>	12/30/86	MBK		Fixed SetStyle to save D2 on the stack because _RGBForeColor
;									destroys it. Fixed Pixel2Char to restore D0 from D1 if NewPtr
;									has to be called.
;	  <C513>	12/12/86	MBK		Changed to clear bit in HiliteMode instead of setting bit in
;									pnMode for color hilighting. Fixed selection bug in Pixel2Char.
;	  <C485>	 12/4/86	MBK		Set the error code in D0 before calling SysError. Fixed bug in
;									which carets left on the screen were not getting erased (in
;									Mac3D).
;	  <C475>	 12/2/86	MBK		Set the high bit of the pnMode before highlighting, to use the
;									new background color highlighting method.
;	  <C454>	11/21/86	MBK		Fixed bug in RangeRect that caused selection to be off in
;									MultiPlan. Fixed special case in which line redraw did not work,
;									in RecalLines.
;	  <C440>	11/19/86	MBK		Fixed SetLineHite to take the line height from the only style
;									when text length is 0 (instead of using the system font as a
;									default). Fixed RecalLines to consider the next character the
;									start of the next line if the width of the viewRect is less than
;									the width of a single character. Fixed styleGuts to access
;									FmDefaultSize as a byte, not a word. Fixed RecalLines bug in
;									which lines are not recalibrated when text is typed over a
;									single CR.
;
;--------------------------------- ROM 77 from here up ----------------------------
;
;	  <C393>	11/10/86	MBK		Fixed CopyStyle and InsertRecal to reset ptr values after a
;									memory allocation call (the ptrs were pointing to trash).
;	  <C381>	 11/8/86	MBK		Made all changes resulting from code review.
;	  <C229>	10/29/86	MBK		Fixed 2 register preservation problems. Fixed InsertRecal memory
;									overload problem. Redesigned method of updating line heights.
;	  <C207>	10/16/86	MBK		Fixed problem in which CR at bottom of ViewRect did not cause
;									scrolling (cleaned up DefClikProc, which fixed the problem seen
;									in the Poke program). Changed Pixel2Char not to expect a buffer
;									ptr as input, and to allocate the space itself on the stack.
;									Added StylTextBox. Changed scrpStartChar to a LONGINT. Changed
;									TECopy and TEPaste not to touch the desk scrap if the TERec is
;									an old one (since David G. mentioned a lot of old applications
;									may need to preserve the desk scrap for Undo). Changed DoHilite
;									back to what it was (except with middle lines being highlighted
;									as a block for speed) because the International version was just
;									too slow; this means I also removed the HiliteText hook.
;									Modified RecalDraw to adjust the redraw selection according to
;									changes in line height.
;	  <C182>	 10/6/86	MBK		Changed colorBit to clrBit since colorBit is a Quickdraw Trap
;									already. Modified DoHilite to always measure from start of line,
;									to fix highlighting problem with scaled fonts. Got rid of
;									special code in PasteStyle to prevent style duplication, And
;									just call ConcatStyles at the end. Added DoErase to fix italics
;									erase problem. Removed code to shrink style runs array in
;									ConcatStyles. Fixed problem of not clearing flag bits in ptrs
;									before doing operations on an address. Changed color from
;									LONGINT to RGBColor, and added Ernie's RGBForeColor and
;									GetForeColor to handle this for the Alladin world.
;	  <C139>	 9/10/86	MBK		Fixed TEGetStyle to return the grafport settings for records
;									without style. Made addSize OR'able in StyleGuts. Fixed "index
;									expected in D0" bug in DoSearch. Added DoMeasure, ChkBounds, and
;									made FindLine call Pixel2Char for International. Fixed
;									word-wrapping with spaces. Put local equates back in this file
;									and put the rest of the equates in nToolEqu.a. Got rid of scrp
;									equates, since they were the same as the st- equates.
;	  <C105>	  9/3/86	MBK		Renamed TEGetStyle to GetStylHandle and TEFindStyle to
;									TEGetStyle. Added SetStylHandle. Added TEDispatch to handle All
;									style traps (except TEStylNew) with only 1 real trap for them
;									all. Made the following changes for International: added the
;									Pixel2Char, Char2Pixel, and HiliteText hooks; modified doSearch
;									and doDraw to test TESysJust and perform their functions
;									backwards if it's set; totally rewrote DoHilite. Added
;									NextLineRect to speed up DoDraw. Rewrote stages 2 and 3 of Recal
;									for speed. Added new feature of Not resetting the line heights
;									in Recallines if the high bit of the line height already stored
;									is set. Changed the TESetStyle and TEReplaceStyle input modes to
;									be OR'able. Also combined the body of these 2 routines for
;									efficiency. Added stuff to compute distance to be auto-scrolled
;									for TERecs with style, in DefClikProc. Changed BSET and BCLR of
;									handles to _HLock and _HUnlock.
;	   <C95>	  8/4/86	MBK		Fixed the scrolling problem in SelView; Modified Recallines to
;									take into account changes in point size.
;	   <C94>	 7/29/86	MBK		Added 3 more traps (TEReplaceStyle, TEGetOffset, TEFindStyle);
;									renamed TEGetStyle to TEFindStyle (TEGetStyle now returns the
;									style handle); fixed selection bug, the problem was in
;									ScanMeasure and DoSearch. Fixed bug in CharByChar. Started
;									fixing recalibration problem.
;	   <C78>	 7/17/86	MBK		removed equates to an external file; added four new traps
;									(TEStylNew, TEStylPaste, TESetStyle, TEGetStyle); added the
;									following new routines: SetOneStyle, GetDefStyle, ScanMeasure,
;									GetLineHites, GetHite, CopyStyle, DeleteStyle, DecStyleCount,
;									StylMeasure, SetLineHite, PasteStyle, MakeRoom, DupStyle,
;									FindStyle, CompareStyles, AddStyle, ExtendStyle, FindLineHite,
;									GetCurStyle, GetNumStyles, GetStyle, RecalstStarts,
;									SetHiteAscent, SetStyle, ConcatStyles, ChangeStyle, and
;									FindFeature; modified the following routines: TESetText,
;									LineRect, PinDisplay, StdEntry, TECopy, DelGuts, RecalDraw,
;									FindLine, RecalLines, SetLineArray, TEPaste, InsGuts, TEKey,
;									TEPinScroll and TESelView.
;
;--------------------------------- ROM 76 from here up ----------------------------
;
;				 2/19/86	BBM		Made some modifications to work under MPW
;				 1/14/86?	EHB		In PasteGuts, call SelSort and get sel length for preflight Fix
;									longize bug in the beginning of DoSearch Added cursor key
;									support to TEKey
;
;--------------------------------- Lonely Heifer ROMs from here up ----------------------------
;
;				 11/5/85	EHB		Moved label to make WordRedraw fix work right
;				 11/3/85	SC		Fixed special case D3=0 in DoCaret
;				 11/1/85	EHB		If WordRedraw=0->draw normal, if >0 -> draw word, if <0 -> draw
;									line
;				10/31/85	EHB		Fast TextBox was scanning 0 len strings for CR's
;				10/31/85	EHB		In RecalDraw, draw whole words if WordRedraw (new lowMem) is
;									TRUE
;				10/30/85	EHB		In DoFind, set up D3/D4 with selStart/selEnd before calling
;									DoText
;				 10/1/85	EHB		Set up D2 for all calls to CallBreak (identifies caller)
;				 10/1/85	EHB		Added hooks for TrimMeasure, FindWord, and FindLine.
;				 7/26/85	EHB		Added ShowCaret to end of TEPinScroll (needed for null scroll)
;				 7/16/85	SC		PinDisplay has new entry point for TEUpdate compatability
;									Refresh changed to take A0 pointing to an update rect not D0/D1,
;									calls PinA0Rect.
;				 6/15/85	SC		Undid "teLftClick not a byte, now the tefLeftClk bit in teFlags"
;									had to drop back to old one for compatibility. TERecback is now
;									the TEFlags
;				 6/15/85	SC		DoText must return ThePort in A0 for compatibility
;				 6/10/85	SC		CharbyChar had a BLT that should've been a BLE (It gets there by
;									a BGE so it should stay in loop if BLE).
;				 6/10/85	SC		DoText links a stack frame/DoBye and findDone UNLK
;				 6/10/85	SC		In rangeRect, stuff the rect.left in TempRect and set pen to
;									right for compatibility with old DoText
;				 6/10/85	SC		DoSearch returns in D0 as before
;				  6/7/85	EHB		Fast TextBox shouldn't catch zero strings else no
;									EraseRect(oops)
;				 5/23/85	SC		Dropped port save/restore font
;				 5/21/85	SC		Added negative length to Fast TextBox
;				 5/20/85	SC		SelView called before caret view in DelGuts and PasteGuts;
;									should be after (leaves carets behind in Dialogs)
;				 5/20/85	SC		CleanupSel saved teTextH flags twice!!
;				 5/20/85	SC		DoSearch longize D3-D4 (Thanks Bill and Larry)
;				 5/20/85	SC		Fast TextBox didn't catch zero string length case (oops)
;				 5/18/85	SC		Made DefClikProc obey autoScroll bit
;				 5/18/85	SC		LineWidth didn't handle the line past teLength correctly
;				 5/18/85	SC		Merged LineWidth and TrimMeasure
;				 5/18/85	SC		Made trim measure skip wordBreak code and only trim chars <=
;									space. This should truly measure only the black characters And
;									not the word break chars now. (Deja Vu - did this on 3 May but a
;									bug in FindLine made it LOOK as though it didn't work so I undid
;									it on 9-May)
;				 5/18/85	SC		New routine PinDisplay replaces pin code in Hilite and Refresh
;				 5/18/85	SC		Put back DoText funnel for compatibility
;				 5/18/85	SC		Dropped printable trim in FindLine @ end
;				 5/15/85	SC		Multiple standard entries with stack peel amount in D1. Does a
;									preflight and then escapes if the preflight fails
;				 5/13/85	SC		Save/Restore text stuff in std entry/exit and made setlinarray
;									avoid calling _GethandleSize(done once in stdEntry)
;				 5/13/85	SC		Added preflight routine to check memory. Called from pasteguts,
;									insertGuts, and TextBox. Did similar to TENew
;				 5/12/85	SC		New local proc MungeSetup to do common munger stuff
;				 5/12/85	SC		Use D5 in recallines to hold telength
;				 5/11/85	SC		Added TEAutoView trap to enable/disable the auto scrolling
;				 5/11/85	SC		Local proc Scroll broken out for use by TEScroll and TEPinScroll
;				 5/11/85	SC		Use _XMunger instead of _Munger
;				 5/11/85	SC		Reinstated teSelPoint, it's in documentation
;				 5/11/85	SC		Completely trashed DoText, OffsetStuff, DoFormat and replaced
;									them with a clean versions of DoFind, DoHilite, DoDraw, DoCaret.
;									This was to clean up the scaled fonts problem, the direct pen
;									adjustment and general mayhem With the old DoText.
;				  5/9/85	SC		Made a local CalText proc to avoid StdEntry
;				  5/9/85	SC		StdEntry/Exit save restore teTextH flags
;				  5/9/85	SC		Made SelView local proc
;				  5/9/85	SC		Dropped trim measure black stuff
;				  5/9/85	SC		teLftClick not a byte, now the tefLeftClk bit in teFlags
;				  5/8/85	SC		Added TEPinScroll which does a pinned scroll (Not upward
;									compatible so I couldn't include in real scroll, but it is used
;									by the default click proc and TEScrollView
;				  5/8/85	SC		Added TEScrollView which insures selection is visible before
;									doing something. Called from TEKey, TEPaste, TECut, TEIdle, etc.
;				  5/8/85	SC		Added default click proc for auto scrolling
;				  5/7/85	SC		Undo refresh hilite stuff, moved similar stuff to Hilite
;				  5/6/85	SC		DoFormat had an extra measure for left justify that was not
;									needed
;				  5/6/85	SC		DoText used TempRect, use stack frame instead
;				  5/5/85	SC		Longized all the 0(A0,DX.L) and call to _TextWidth and _DrawText
;				  5/5/85	SC		Made StdEntry/Exit use LINK instructions not SP based
;				  5/5/85	SC		Fixed up recalLines to reduce flashiness
;				  5/5/85	SC		Dropped teSelPoint usage, get off stack frame instead of
;									TeHandle
;				  5/5/85	SC		Tricks played with A0 and teCarOn, teCarAct in DrawCaret,
;									cleaned up for readability.
;				  5/5/85	SC		TESetSelect trashed teSelPoint, cleaned up code a bit
;				  5/4/85	SC		SkipLoop in TrimMeasure could go negative
;				  5/4/85	SC		Dropped DelGuts and InsGuts call from PasteGuts and made a
;									combined inline call for munger speed. Could make DelGuts and
;									InsGuts inline since only 1 caller, but left that for another
;									day
;				  5/4/85	SC		Changed D2 usage in TEClick to D5 long sign bit
;				  5/3/85	SC		Made trim measure skip wordBreak code and only trim chars <=
;									space. This should truly measure only the black characters And
;									not the word break chars now.
;				  5/3/85	SC		Dropped forROM and for44T compile switches for readability
;				  5/3/85	SC		New version of FindLine, cleaner and fixes bugs. Still
;									inefficient because it measures whole line repeatedly, but
;									faster quickdraw fixes this.
;				  5/3/85	SC		Fixed the <CR>-in-1st-char bug with word select. FindWord would
;									abort if the left char scan got to the beginning, but it
;									wouldn't check if the 0th char was a break character or not
;				 1/25/85	EHB		Fixed Refresh to only hilight visible part of selection
;				 1/25/85	EHB		Added Capp's TextBox fix
;				 1/24/85	EHB		Added patch in RecalDraw
;				 1/23/85	LAK		Adapted for new equate files.
;				 1/16/85	EHB		Fixed center/right justify in TextBox fix
;
;-----------------------------------------------------------------------
;
;				 9/12/83			Made InvertHook push the rectangle
;				  9/9/83			Fixed caret activate problem w/ inactive records Dropped
;									background stuff(Finally gave up) Added global word break for
;									Europe.
;				  9/4/83			Fixed First char select bug in DoText
;				 8/25/83			Fixed Insert D7 bug
;				 8/25/83			Fixed unwind bug in stdexit
;				 8/21/83			Added DoText and recal hooks
;				 8/19/83			Added system double/caret times
;				 8/17/83			Fixed Rony bug in RecalDraw
;				  8/8/83			Dropped pinrects and used extended rects in DoText to save code
;				  8/7/83			Reinstated total dobackgnd from recal(FUCK!)
;				  8/6/83			Dropped total dobackgnd from recal(I guess addition IS
;									communitive)
;				  8/5/83			Fixed a bug in FindLine Fixed bug in Recaline (now waits for
;									whole text to finish) Optimized dobackgnd to always stop at end
;				  8/3/83			Cleaned up TEKey a bit Cleaned up refresh a bit Changed all
;									indices to unsigned (BGE's) Added idle proc for scroll and key
;									Addes TEInsert Fixed the Bryan Stearns memorial 1-char bug in
;									RecalDraw Added hilite hook for MicroSoft and other bizarre
;									things Added caret hook too SetSelect uses longs Added
;									TESetJust, TEGetText
;				  8/2/83			Code review changes: added std2Offset constant stdEntry points
;									to param via A2 changed #7 to #Lock moved epilog4 flags trick in
;									lock/unlock in stdentry/exit cleaned up selection safety chk in
;									stdentry used grafGlobals(A5) instead of 0(A5) cleaned up(Ha!)
;									TEClick Changed DoFind to handle top and pin H to DestRect
;									switched end checks for teFind in DoText Changed and commented
;									selsort- now returns A2^ to selStart callers of selSort now use
;									A2 Shortened rect stuff in RecalDraw CallBreak uses reg
;									arguments instead of stack
;				 7/23/83			New Today
;
;<<<END HISTORY>>>	<- This is to make the end of these comments easy to find with MPW.
;___________________________________________________________________________________________________
;	To Do:
;	Remove extraneous code from NewRomanFindLine. Marked with (XX).
;	There may be a measuring bug using TextWidth, due to StdTxMeas' use of pnLoc. TE doesn't seem to 
;	 initialize the pnLoc to 0 before it measures w/ TextWidth.
;___________________________________________________________________________________________________
;	Useful MPW commands
;
;	'/<RWW[0-9]«6»>[¬NO]/'
;
;Set teversion 'SMgrTE';Export teversion
;Delete -i "{SystemFolder}TEPatcher"
;rez -o "{SystemFolder}TEPatcher" "{RIncludes}"Types.r TEPatcher.r
;SetFile "{SystemFolder}TEPatcher" -t INIT -c tept -a B
;	Set opt "-d OnNuMac=0,OnMvMac=0,OnMacPP=0,OnHcMac=0,forR0M=0"
;Asm {opt} TEPatcher.a -o TEPatcher.a.o -d &RWWDebug -i {MyIncludes}
;link -rt INIT=0 -o "{SystemFolder}TEPatcher" TEPatcher.a.o ShowINIT.a.o
;___________________________________________________________________________________________________


			Blanks		On
			String		AsIs

	If &TYPE('&RWWDebug') = 'UNDEFINED' Then
		If &TYPE('InsideTEPatch') = 'UNDEFINED' Then		; <S383>
			LOAD		'StandardEqu.d'
			INCLUDE		'ScriptPriv.a'
			INCLUDE		'TextEditPriv.a'					; <1/9/90smb>
			INCLUDE		'fontPrivate.a'						; <20>
		EndIf												; <S383>
	EndIf
	
  		IF  &TYPE('Scripts604') = 'UNDEFINED' THEN 
Scripts604 	EQU 		0
  		ENDIF
  		IF  &TYPE('SysVers') = 'UNDEFINED' THEN 
SysVers 	EQU 		0
  		ENDIF
  		IF  &TYPE('forLocalizability') = 'UNDEFINED' THEN	;					<32>
forLocalizability 	EQU 1									;					<32>
  		ENDIF												;					<32>

			INCLUDE		'GestaltEqu.a'						; <18Aug89smb>
; *************************************************************************************************
; *************************************************************************************************
; *************************************************************************************************

TextEdit	Proc		Export

			Export		TextBox
			Export		TEActivate
			Export		TEClick
			Export		TECopy
			Export		TECut
			Export		TEDeactivate
			Export		TEDelete
			Export		TEInit
			Export		TENew
			Export		TEDispose
			Export		TEKey
			Export		TEPaste
			Export		TEIdle
			Export		TEUpdate
			Export		TEInsert
			Export		TESetText
			Export		TECalText
			Export		TESetSelect
			Export		TEScroll
			Export		TESetJust
			Export		TEGetText
			Export		TEAutoView
			Export		TEPinScroll
			Export		TESelView

			Export		TEStylNew
			Export		TEGetOffset

			Export		TEDispatch

; exported for debugging use

			Export		DoMeasure
			Export		MeasureIt
			Export		HideCaret
			Export		DoFind
			Export		DoCaret
			Export		DoText
			Export		DoHilite
			Export		DoSearch
			Export		RangeRect
			Export		PrepLine
			Export		LineRect
			Export		xGetWidth
			Export		xteGetFormatOrder
			Export		xDoErase
			Export		DoDraw
			Export		ChkBounds
			Export		xCaretDisplay
			Export		xGetRLPosition
			Export		xOnSameLine
			Export		iTESetStyle
			Export		xSetKeyboard2Font
			Export		xSetFont2Keyboard
			Export		xCursorMovement
			Export		xTEBufferText
			Export		xDumpBuffer
			Export		iTEFeatureFlag
			Export		xConcatRuns							; <11>
			Export		xStyleGuts							; <11>
			Export		xBufferChar							; <11>
			Export		xTestRunDirection					; <11>
			Export		xPixelWidths						; <11>
			Export		xInvrtRectangle						; <11>
			Export		xHiliteLineEnds						; <11>
			Export		xMeasureWholeRun					; <11>
			Export		xMeasureWidth						; <11>
			Export		xGetCurScript						; <11>
			Export		xGetStylesInOrder					; <11>
			Export		xGetDirection						; <11>
			Export		xSetDirection						; <11>
			Export		xCaretInsideRun						; <11>
			Export		xOnLineEnd							; <11>
			Export		xGetLRPosition						; <11>

; hooks to be stored in the trap table

			Export		XTrimMeasure
			Export		XFindWord
			Export		XFindLine
			Export		XReCalLines

			Export		vPixel2Char
			Export		vChar2Pixel
			
; sets up vectors to be used for patching TextEdit and clears ExpandMem TE globals <28June89smb>
			Export		GestaltTEVersion					; <13>
			Export		TEGlobalInit					; <13>
;-------------------------------------------------------------------------------------------------

AddrTable	DC.W		iTEStylPaste-AddrTable				; 0
			DC.W		iTESetStyle-AddrTable				; 1
			DC.W		iTEReplaceStyle-AddrTable			; 2
			DC.W		iTEGetStyle-AddrTable				; 3
			DC.W		iGetStylHandle-AddrTable			; 4
			DC.W		iSetStylHandle-AddrTable			; 5
			DC.W		iGetStylScrap-AddrTable				; 6
			DC.W		iTEStylInsert-AddrTable				; 7
			DC.W		iTEGetPoint-AddrTable				; 8
			DC.W		iTEGetHeight-AddrTable				; 9

			; ** <C971/RWW102687>	New entry points
			DC.W		iTEContinuousStyle-AddrTable		; 10
			DC.W		iSetStylScrap-AddrTable				; 11
			DC.W		iTECustomHook-AddrTable				; 12
			DC.W		iTENumStyles-AddrTable				; 13
			DC.W		iTEFeatureFlag-AddrTable			; 14

;-------------------------------------------------------------------------------------------------

; Add new vectors <28June89smb>
; EMVectorTable contains the offset in ExpandMemRec which holds the routine address
; and the offset to the routine from here.

EMVectorTable
			with	ExpandMemRec
			dc.w	vDoErase,			xDoErase-EMVectorTable
			dc.w	vCaretDisplay,		xCaretDisplay-EMVectorTable
			dc.w	vGetLRPosition,		xGetLRPosition-EMVectorTable
			dc.w	vGetRLPosition,		xGetRLPosition-EMVectorTable
			dc.w	vOnLineEnd,			xOnLineEnd-EMVectorTable
			dc.w	vCaretInsideRun,	xCaretInsideRun-EMVectorTable
			
			dc.w	vSetDirection,		xSetDirection-EMVectorTable
			dc.w	vGetDirection,		xGetDirection-EMVectorTable
			
			dc.w	vGetStylesInOrder,	xGetStylesInOrder-EMVectorTable			
			dc.w	vteGetFormatOrder,	xteGetFormatOrder-EMVectorTable
			
			dc.w	vGetWidth,			xGetWidth-EMVectorTable
			dc.w	vGetCurScript,		xGetCurScript-EMVectorTable

			dc.w	vOnSameLine,		xOnSameLine-EMVectorTable
			dc.w	vMeasureWidth,		xMeasureWidth-EMVectorTable
			dc.w	vMeasureWholeRun,	xMeasureWholeRun-EMVectorTable
			dc.w	vHiliteLineEnds,	xHiliteLineEnds-EMVectorTable
			dc.w	vInvrtRectangle,	xInvrtRectangle-EMVectorTable
			dc.w	vPixelWidths,		xPixelWidths-EMVectorTable
			
			dc.w	vTEBufferText,		xTEBufferText-EMVectorTable
			dc.w	vDumpBuffer,		xDumpBuffer-EMVectorTable
			
			dc.w	vCursorMovement,	xCursorMovement-EMVectorTable
			dc.w	vTestRunDirection,	xTestRunDirection-EMVectorTable
			
			dc.w	vBufferChar,		xBufferChar-EMVectorTable
			
			dc.w	vSetFont2Keyboard,	xSetFont2Keyboard-EMVectorTable
			dc.w	vSetKeyboard2Font,	xSetKeyboard2Font-EMVectorTable
			
			dc.w	vStyleGuts,			xStyleGuts-EMVectorTable
			dc.w	vConcatRuns,		xConcatRuns-EMVectorTable
			dc.w	0,0

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEGlobalInit
;			<27June89smb>
;
;			To be called from StartInit, in order to assign vectors 
;			and clear expandMem globals only once.
;
;----------------------------------------------------------------------
TEGlobalInit
			movem.l	a2/a3,-(sp)
												;							<SM8>
			Lea 		XDoText,A0				; set up doText hook		<SM8>
			Move.L		A0,TEDoText				;							<SM8>
			Lea 		XReCalLines,A0			; set up recal hook			<SM8>
			Move.L		A0,TERecal				;							<SM8>
			Lea 		DefWordBrk,A0			; get default word break	<SM8>
			Move.L		A0,TEWdBreak			;							<SM8>
												;							<SM8>
; initialize expandMem with my TE vectors
			lea		EMVectorTable,a0			; base address of vector table
			move.l	a0,a1					
			move.l	ExpandMem,a2				; get pointer to expandMem
VectorLoop
			move.l	(a1)+,d0					; get routine offset from EMVectorTable
			beq.s	LoopXit
			lea		0(a0,d0.w),a3				; get routine address
			swap	d0							; get expandMem offset (vector place holder)
			move.l	a3,0(a2,d0.w)				; load into expandMem
			bra.s	VectorLoop
LoopXit
			movem.l	(sp)+,a2/a3
			
; when TextEdit 3.0 is ptch0, need this code			
			move.l	#gestaltTextEditVersion, d0	; <8Aug89smb>
			lea		GestaltTEVersion, a0
			_NewGestalt
			rts

;----------------------------------------------------------------------
;			PROCEDURE GestaltTEVersion
;			<8Aug89smb>
;			The following Gestalt Function is an interface using the Gestalt
;			mechanism to determine the current version of TextEdit.
;
;			 FUNCTION	GestaltTEVersion (	gestaltSelector: 	OSType;
;											VAR gestaltResult:	Longint;): OSErr;
;
;			The versions for the gestaltTextEditVersion selector are:
;				gestaltUndefSelectorErr = old styled TextEdit (pre-MacIIci TE)
;			All the following versions of TE are based on the SMgr-compatible version:
;				gestaltTE1 (1) = MacIIci ROM/PTCH 67c
;				gestaltTE2 (2) = 604 Script Systems PTCH 67c (Script bug fixes for MacIIci)
;				gestaltTE3 (3) = 604 Script Systems ptch0/parallels Big Bang (for MacII, MacSE, Mac+)
;				gestaltTE4 (4) = Big Bang ptch0/PTCH 67c
;				gestaltTE5 (5) = TextWidthHook available in System 7
;
;			THE OBVIOUS: since this is here for the MacIIci ROM patch, we have 
;			hardcoded the ONLY value that is appropriate to be returned! sigh.
;_________________________________________________________________________________

GestaltTEVersion

			move.l	(sp)+,a0			; return address
			move.l	(sp)+,a1			; address of result
			move.l		#gestaltTE5, (a1)	; 													<19>
			adda.w	#4,sp				; pop the selector type
			move.w	#noErr,(sp)			; it always works
			jmp		(a0)

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEInit
;
;----------------------------------------------------------------------
TEInit
	
			MoveQ		#0,D0
			Move		D0,TEScrpLength 		; save in global space
			_NewHandle
			Move.L		A0,TEScrpHandle 		; Save in global space

			Lea 		XDoText,A0				; set up doText hook
			Move.L		A0,TEDoText
			Lea 		XReCalLines,A0			; set up recal hook
			Move.L		A0,TERecal
			Lea 		DefWordBrk,A0			; get default word break
			Move.L		A0,TEWdBreak

 	IF 0 THEN
;IF &TYPE('&SMgrINIT') <> 'UNDEFINED' THEN		;<1Feb89smb> added for Init testing of ExpandMem
												; only necessary for Init's before Cobra II and 6.0.4.
 	ENDIF

; Defensive reset in case an application changed teSysJust contrary to system default.
;
; Now, we just reset it for Roman-only systems (because TE in such a system cannot currently	<32>
; handle R-L direction; we will fix this eventually). For other scripts, the Text Control		<32>
; Panel lets users choose the default line direction, so we don't want to override it.			<32>
			WITH	smgrRecord,scriptRecord
			GetSMgrCore a0						; load SMgr globals pointer.
	IF 1 THEN									;												<32>
			move.b	smgrEnabled(a0),d0			; how many scripts enabled?						<32>
			ble.s	@bail						; if 0 (or neg!), can't initialize				<32>
			subq.b	#1,d0						; Roman-only?									<32>
			bne.s	@doneSetSysJust				; if not, don't reset 							<32>
			clr.w	TESysJust					; Roman-only, force to L-R (else TE screws up)	<32>
@doneSetSysJust									;												<32>
	ELSE										; (keep old code for reference for a while)		<32>
			tst.b	smgrEnabled(a0)				; script manager disabled?
			beq.s	@bail						; yes -> bail out.
			move.w	smgrSysScript(a0),d0		; get system script code.
			lsl.w	#2,d0						; script code is long offset.
			move.l	smgrEntry(a0,d0.w),a0		; load system script entry.
			move.b	scriptJust(a0),d0			; load script just.
			ext.w	d0							; sign extend just.
			move.w	d0,TESysJust				; set global just.
	ENDIF										;												<32>
			endWith								;
 
;<2Feb89smb>
; initialize NewStyle params for SetRsrved call in SetFont2Keyboard (flag.b, textStylePtr.l, mode.w)
			move.l		ExpandMem,a0
			lea			ExpandMemRec.emNewStyle(a0),a0		; changed from add to lea <12July89smb>
			move.b		#$FF,(a0)				; flag.b
			move.w		#1,6(a0)				; mode.w

;  Find correct WordDraw value.  Used for redrawing for line calculation
;	after character input. A WordDraw value of:
;			0 = redraw the char in front of the inputted char,
;			1 = redraw the word in front of the inputted char,
;			FF = redraw the whole line.
; To set the correct value walk through the scripts (32 of them!),
; 	<OR> in 1 for each double-byte script and <OR> in FF for each right-left script.
			move.b		#0,WordRedraw			; default case
			move.l		d3,-(sp)				; save <18July89smb>
			moveq		#0,d3					; init d3; for d3 := 0 to 32 do
@WordRedrawLoop
			clr.l		-(sp)					; allocate return
			move.w		d3,-(sp)				; script number
			move.w		#smScriptRedraw,-(sp)	; verb
			_GetScript							; if disabled, will return zero.
			move.l		(sp)+,d0				; values are 0, 1, FF
			or.b		d0,WordRedraw			; add it in: 1 ++ x, FF ++ x
; if all FFs, then dont need to go further-so check for negative
			bmi.s		@WRLoopXit
			addq.w		#1,d3					; next script to check <18July89smb>
			cmpi.w		#32,d3					; beyond last script? <18July89smb>
			bls.s		@WordRedrawLoop			; keep going until done w/ scripts
@WRLoopXit
			move.l		(sp)+,d3				; restore <18July89smb>
			
; Get number of scripts installed <9Nov88smb>
			clr.l		-(sp)
			move.w		#smEnabled,-(sp)		; verb
			_GetEnvirons
			move.l		(sp)+,d0
			move.l		ExpandMem,a0			; <1Feb89smb>
			move.b		d0,ExpandMemRec.emScriptsInstalled(a0)	; total number of installed scripts
			
; guarantee default WordBreak address is 32-bit clean <21Dec88smb>
			lea			DefWordBrk,a1			
			move.l		a1,d0
			_StripAddress
			move.l		ExpandMem,a0			; <16Feb89smb> StripAddress wipes out a0!
			move.l		d0,ExpandMemRec.emCleanWordBrk(a0)

@bail
			Rts
ErrorXit
			_SysError
			

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION	TEGetText( h: TEHandle	): Handle;
;
;			Returns the text handle
;
;----------------------------------------------------------------------
TEGetText
			Bsr 		StdEntry
			Move.L		teTextH(A3),(A2)		; return the text handle
			Bra 		epilog4

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEDispose( h: TEHandle )
;
;			** <C207/13oct86/MBK> **	Added code to dispose of style
;			related handles if this TERec has style.
;
;----------------------------------------------------------------------
TEDispose
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; save stdregs
			Move.L		8(A6),A4				; Pop handle into A4
			Move.L		(A4),A3 				; Dereference into A3

; dump text buffer before exiting (cleanup!)		 													<21>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops 					<21>
			btst		#teFTextBuffering,d0
			beq.s		@noBuffer
			bsr			DumpBuffer				; dump text from buffer
@noBuffer	
			Move.L		teTextH(A3),A0			; get rid of text
			_DisposHandle

; Following lines moved here from within "styled" section below.
			Move.L		teDispatchH(A3),A0		; Added to (quasi-) support tabs <C971/RWW110387><PMAB387/DBG021088>
			_DisposHandle						; <PMAB387/DBG021088>

			Tst.W		teSize(A3)				; record with style?
			Bpl.S		@0						; more to dispose if so

			Move.L		teStylesH(A3),A2		; get style handle
			Move.L		(A2),A2					; dereference
			Move.L		styleTab(A2),A0			; handle to distinct styles
			_DisposHandle

			Move.L		lhTab(A2),A0			; handle to line heights
			_DisposHandle

			Bsr.S		DisposRsrved			; dispose of reserved handle

			Move.L		teStylesH(A3),A0		; get rid of itself
			_DisposHandle

@0			Move.L		A4,A0					; get rid of itself
			_DisposHandle

			MoveQ		#4,D0
			Bra 		Std2Exit

;----------------------------------------------------------------------
;
;			PROCEDURE DisposRsrved;
; 			** <C851/14Apr87/MBK> **
;
;			I changed teReserved to a handle to the following structure:
;				Record
;					newReserved : LONGINT;
;					nullScrap	: stScrpHandle;
;				End;
;			nullScrap is used to store a style which is set when the
;			selection is NIL in TESetStyle.  I store it in the scrap
;			format so that it can easily be inserted using PstStylGuts.
;			This procedure is called to dispose of the nullStyle handle.
;----------------------------------------------------------------------
DisposRsrved
			Move.L		teStylesH(A3),A0		; get style handle
			Move.L		(A0),A0					; deref
			Move.L		nullStyle(A0),A0		; get reserved handle
			Move.L		A0,-(SP)				; save this handle
			Move.L		(A0),A0					; deref
			Move.L		nullScrap(A0),A0		; get handle to scrap for null selection
			_DisposHandle						; get rid of null scrap handle
			Move.L		(SP)+,A0				; get back nullStyle handle
			_DisposHandle						; get rid of nullStyle handle
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TextBox( Text: Ptr; Length: LONGINT; r: Rect; style: INTEGER );
;								18			14				10			8
;
;moved following equates to TextEditPriv.a														<18>
;TBJust		Equ			8
;TBBox		Equ			10
;TBLength	Equ			14
;TBText		Equ			18
;----------------------------------------------------------------------
;TETextBox										; comment out for now				<45>
TextBox
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; save StdRegs on stack

			Tst.W		TBJust(A6)				; “left” justified?					<C971/RWW110987>
			Bne.S		@05						; no => skip this					<C971/RWW110987>

			Move.W		TESysJust,TBJust(A6)	; he meant, “default justification”	<C971/RWW110987>
	IF NOT forLocalizability THEN				; <39-YDS-1/30/92> don't set to 0 for #teForceLeft !!!
@05			Cmp.W		#teForceLeft,TBJust(A6)	; _real_ left justification?		<C971/RWW110987>
			Bne.S		@08						; no => skip this					<C971/RWW110987>
			Clr.W		TBJust(A6)				; clear justification				<C971/RWW110987>
@08												;								<C971/RWW110987>
	ELSE
@05
	ENDIF

; here's Capp's code to make TextBox fast for drawing single lines
; Added EHB 25-Jan-85.

			Move.L		TBText(A6),A0			; see if any CR's in text
			Move.L		TBLength(A6),D0			; get length
			Blt			tbExit					; escape if illegal string		<C971/RWW102887>NO
			Beq.S		NoZeroScan				; => don't scan NIL strings		<EHB 31-Oct-85>
@0
			Cmp.B		#returnChar,(A0)+
			Beq			UseRealOne
			SubQ.L		#1,D0
			Bne.S		@0

; no carriage returns, try in rect

NoZeroScan
			subq		#2,sp					; see how big it is?
			move.l		TBText(a6),-(sp)		; pass text
			clr.w		-(sp)
			move		TBLength+2(a6),-(sp)	; pass length (low word)
			_TextWidth
			move.w		(sp)+,d3				; save it
			Move.L		TBBox(A6),A0			; point to rect
			Move		right(A0),D0
			Sub 		left(A0),D0
			SubQ		#2,D0
			Cmp 		D3,D0
			Ble.W		UseRealOne

			Move.L		A0,-(SP)				; erase the rect
			_EraseRect

			SubQ		#8,SP
			Move.L		SP,-(SP)
			_GetFontInfo

	IF forLocalizability THEN					; see <41> <41-YDS-2/6/92>.we are in
												; an un styled record, give the hight of the assoc
												; font or the script font (the bigger)
			Subq		#2,sp					; make room on stack
			_FontScript							; get the script
			Move.W		(SP)+, D4				; into D4
			Beq.W		@DoNothing				; it roman ! do nothing
			Subq		#4,sp					; make room on stack, will use it later
			Move.W		D4, -(SP)				; push script number on stack for later
			Move.L		GrafGlobals(A5),A3		; get graf globals and then thePort
			Move.L		thePort(A3),A3			; 
			Move.W		txFont(A3),D5			; get the font face  <42-YDS-4/2/92>
			Cmp.W		#sysFont, D5			; is it system font ?
			Beq.S		@SystemFont				; yes
			Cmp.W		#applFont, D5			; is it app font ?
			Beq.S		@AppFont				; yes
			Subq		#4,sp					; make room on stack for result
			Move.W		D4, -(SP)				; push script # on stack
			Move.W		#smScriptSysFond, -(SP)	; push verb
			_GetScript							; get the system pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		D5, D0					; are you sure it's not system font ?
			Beq.S		@SystemFont				; it is !
			Subq		#4,sp					; make room on stack for result
			Move.W		D4, -(SP)				; push script # on stack
			Move.W		#smScriptAppFond, -(SP)	; push verb
			_GetScript							; get the application pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		D5, D0					; are you sure it's not application font ?
			Beq.S		@AppFont				; it is !
@OtherFont	Move.W		#smScriptFntBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@SystemFont	Move.W		#smScriptSysBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@AppFont	Move.W		#smScriptAppBase ,-(SP)	; we have result space & script # on stack allready		
@GetTheFont	_GetScript							; so push the right verb
			Move.L		(SP)+, D0				; get the associated font
			Tst.W		D0						; we have to test, since only the word counts <42-YDS-4/2/92>
			Beq.S		@DoNothing				; no associated font ? bail out !
			Move.W		D0, txFont(A3)			; set the font to the assoc font
			SubQ		#8,SP					; space on stack
			Move.L		SP,-(SP)				; push addres
			_GetFontInfo						; get the assoc font info
			Move.W		D5, txFont(A3)			; restore port font
			Move.W		(SP), D0				; get assoc font ascent
			Cmp.W		8(SP), D0				; compare with script font ascent  
			Bgt.S		@3						; used to be '@1' by mistake <43-YDS-4/19/92>
			Move.W		D0, 8(SP)				; let the bigger one win !
@3			AddQ		#8,SP					; strip stack
@DoNothing
	ENDIF

			Move		(SP)+,D0				; get ascent
			AddQ		#6,SP					; skip rest
			Move.L		TBBox(A6),A0			; point to rect
			Move.L		(A0),-(SP)				; push topleft
			Add 		D0,(SP) 				; go down ascent
			AddQ		#1,2(SP)				; indent 1 for TE compatibility
			_MoveTo

			Tst.W		TBJust(A6)				; look at justification
			Beq.S		@2						; if left go do it
	IF forLocalizability THEN					; <39-YDS-1/30/92> don't forget to check
			Cmp.W		#teForceLeft,TBJust(A6)	; for #teForceLeft (if we had 0, we had set
			Beq.S		@2						; it allready to system justification)
	ENDIF

; assume centered
			Move.L		TBBox(A6),A0			; point to rect
			Move		right(A0),D0			; calc width
			Sub 		left(A0),D0
			Sub 		D3,D0					; subtract text width
			SubQ		#1,D0					; caret space TE compatibility

			Tst.W		TBJust(A6)				; look at justification
			Bmi.S		@1						; if right skip right shift
			AsR 		#1,D0					; divide by two
@1
			Move		D0,-(SP)				; move over
			Clr 		-(SP)					; dv = 0
			_Move
@2

;-----------------------------------------------												<22>
; Turn PreserveGlyph off before drawing, but save its previous setting							<22>
			clr.w		-(sp)					; boolean result								<22>
			_GetPreserveGlyph					;												<22>
			; leave result on stack
			tst.w		(sp)					; preserve or squash? (byte result but cleared word)
			beq.s		@IsFalse				;												<22>
			move.b		#0,-(sp)				; set PreserveGlyph FALSE						<22>
			_SetPreserveGlyph					;												<22>
@IsFalse
;-----------------------------------------------												<22>

			Move.L		TBText(A6),-(SP)		; pass text
			Clr 		-(SP)
			Move		TBLength+2(A6),-(SP)	; pass length (low word)
			_DrawText

;-----------------------------------------------												<22>
; Restore PreserveGlyph							
			; previous PreserveGlyph value still on stack
			_SetPreserveGlyph					;												<22>						
	
;-----------------------------------------------												<22>

tbExit
			Bra.S		Go14Exit				; go to standard exit

; end of TextBox patch	<EHB 25-Jan-85>

UseRealOne
												; watch out for wierd (SP) offsets
			SubQ		#4,SP					; make room for return handle
			Move.L		TBBox(A6),-(SP)			; pass rect to init code
			Move.L		(SP),-(SP)				; pass rect twice
			Move.L		(SP),-(SP)				; pass rect twice
			_EraseRect
			_TENew
			Move.L		(SP)+,A4				; save handle

			Move.L		(A4),A0 				; dereference
			Move.W		TBJust(A6),teJust(A0)	; and set style

			Move.L		TBLength(A6),D0			; get length
			Beq.S		noTextBox

			Move.L		TBText(A6),-(SP)		; pass text pointer
			Move.L		D0,-(SP)				; pass text length
			Move.L		A4,-(SP)				; pass tehandle

			_TESetText

			Move.L		TBBox(A6),-(SP)			; pass rect to update
			Move.L		A4,-(SP)				; pass tehandle
			_TEUpdate							; and draw it

noTextBox
			Move.L		A4,-(SP)				; pass tehandle
			_TEDispose							; and dispose it
Go14Exit
			MoveQ		#14,D0
			Bra 		Std2Exit

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TESetText( text: Ptr; l: Length; h: TEHandle	);
;
;			** Modified 6/18/86 by MBK **
;
;			Makes the text passed in, the current text to edit
;
;----------------------------------------------------------------------
TESetText
			Bsr 		StdEntry

			Move.L		(A2)+,D0				; get length passed

			Move		D0,teSelStart(A3)		; save as selection
			Move		D0,teSelEnd(A3)
			Move		D0,teLength(A3) 		; save as length

			Move.L		teTextH(A3),A0			; handle to stuff into
			Move.L		D0,-(SP)
			_HUnlock							; and unlock it
			Move.L		(SP)+,D0
			Move.L		(A2)+,A0				; set up ptr
			Move.L		teTextH(A3),A1			; handle to stuff into
			_PtrToXHand

			Move.L		teTextH(A3),A0			; handle to stuff into
			_HLock								; relock it

			Bsr.S		SetOneStyle				; set GrafPort's style			<C971/RWW102887>NO

			Bsr			CalText 				; go do it
noText
go12
			Bra 		epilog12


;----------------------------------------------------------------------
;
;			PROCEDURE SetOneStyle
;
;			** Added 6/2/83 by MBK **
;
;			Called by TESetText to set the entire body of the new text
;			to a single style, which is taken from the GrafPort by
;			default.
;
;----------------------------------------------------------------------
SetOneStyle
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; quit if no style

; Set style handle to minimum size (i.e., 1 style for entire text)
			Move.L		teStylesH(A3),A0		; get style handle
			MoveQ		#teStylSize,D0			; size of record with 1 style
			Bsr.S		MySetHandleSize			; reset handle size				<C971/RWW102887>NO
			Move.L		(A0),A0					; dereference

; Reset StyleRec's handle size to just 1 StyleRec
			Move.L		styleTab(A0),A0			; handle to StyleRec's
			MoveQ		#stRecSize,D0			; size of 1 style record
			Bsr.S		MySetHandleSize			; reset handle size				<C971/RWW102887>NO

			Move.L		teStylesH(A3),A0		; get style handle
			Move.L		(A0),A0					; dereference to A0

			Move.W		teLength(A3),D0			; get length of text
			addq.w		#1,d0					; increment for dummy character <23Nov88smb>
			Bsr.S		GetDefStyle				; store default style in StyleRec <C971/RWW102887>NO

@0			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE MySetHandleSize
;
;			** <C381/7nov86/MBK> **
;
;			MySetHandleSize unlocks the TEHandle and the text handle, attempts
;			to set the input handle size, calls system error if there is one,
;			And otherwise relocks TEHandle and the text handle.
;
;	Entry:
;			D0:		requested handle size
;			A0:		a handle
;			A3:		Ptr to TERec
;			A4:		Handle to TERec
;
;	Exit:
;			A3:		Could have a different value if memory was shifted
;
;----------------------------------------------------------------------

MySetHandleSize
			MoveM.L		D0/A0,-(SP)				; save input
			Move.L		teTextH(A3),A0			; text handle
			_HUnLock							; unlock it
			MoveM.L		(SP)+,D0/A0				; restore input

			_SetHandleSize						; do it
			Bne.S		badExit					; fly away if system error

			MoveM.L		D0/A0,-(SP)				; save input
			Move.L		teTextH(A3),A0			; text handle
			_HLock								; lock that too
			MoveM.L		(SP)+,D0/A0				; restore input

			Rts

badExit
			Move.W		#dsMemFullErr,D0		; memory full error			** <C485/03dec86/MBK> **

			_SysError							; go away and never come back

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetDefStyle
;
;			** Added 6/2/86 by MBK **
;
;			GetDefStyle gets the default style for this TERec (taken
;			from its GrafPort) and stores it in the styleRec pointed
;			to by A0.
;
;	Entry:
;			D0:		length of text
;			A0:		dereferenced TEStylesH
;			A3:		Ptr to TERec
;
;----------------------------------------------------------------------
GetDefStyle
			Move.W		#1,nRuns(A0)			; always 1 style to start
			Move.W		#1,nStyles(A0)			; # of STElements <24July89smb> changed to nStyles
			Lea			runs(A0),A1				; point to start of style array
			Clr.L		(A1)+					; start offset and index
			Move.W		D0,(A1)+				; 1 beyond the end
			Move.W		#$FFFF,(A1)				; make it no style

			Move.L		styleTab(A0),A0			; handle to StyleRec's
			Move.L		(A0),A0					; dereference
			Move.W		#1,stCount(A0)			; so set count to 1

			Bsr			GetSize					; get ascent & hite				<C971/RWW102887>NO

; Dereference the handle again. GetSize calls GetFontInfo, which could
; move memory around.
			Move.L		teStylesH(A3),A0		; style handle
			Move.L		(A0),A0					; dereference
			Move.L		styleTab(A0),A0			; handle to StyleRec's
			Move.L		(A0),A0					; dereference

			Move.W		D0,stAscent(A0)		 	; save in ascent		** <C207/10oct86/MBK> **
			Move.W		D1,stHeight(A0)			; save in line height	** <C207/10oct86/MBK> **

; Get the font, face, size and color and save away
			Move.L		teGrafPort(A3),A1		; get this port
			Move.W		txFont(A1),stFont(A0)	; save the font
			Move.W		txFace(A1),stFace(A0)	; save the face
			
; set the direction of the font in the high bit of the high-order byte <30May89smb>
			move.l		a0,-(sp)
			move.w		stFont(a0),d1
			lea			stFace+1(a0),a0
			Bsr			SetDirection
			move.l		(sp)+,a0

			Move.W		txSize(A1),stSize(A0) 	; save the size
			Pea			stColor(A0)				; place to store color	** <C182/6oct86/MBK> **

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; are we on a color system?	(as per Jerome) <C971/RWW112487>
			Bnz.S		@1						; Nope								<C971/RWW112487>
			_GetForeColor						;									<C971/RWW112487>
			Bra.S		@2						;									<C971/RWW112487>
@1			Bsr			GetForeColor			;									<C971/RWW112487>
@2
	ElseIf hasCQD THEN							; <9Dec88smb>
			_GetForeColor						; for Ikki				** <C182/6oct86/MBK> **
	Else
			Bsr			GetForeColor			; for Alladin			** <C182/6oct86/MBK> **
	EndIf

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetSize
;
;			** <C207/10oct86/MBK> **
;
;			Get ascent and line height from current font.
;
;	Exit:
;			D0:		ascent
;			D1:		line height (= ascent + descent + leading!)
;
;----------------------------------------------------------------------
GetSize
			Move.L		A0,-(SP)				; calling routines need this

; Get line height, etc. for font
			SubQ		#8,SP					; make room for font info stuff
			Move.L		SP,-(SP)				; push address
			_GetFontInfo

	IF forLocalizability THEN					; see <41> <41-YDS-2/6/92>.if we are in
												; an un styled record, give the hight of the assoc
												; font or the script font (the bigger)
			Tst.W		teSize(a3)				; is it styled ?	
			Bmi.W		@NoAssocFont			; if yes, don't do anything
			Move.L		D3, -(SP)				; save d3 on stack for now
			Subq		#2,sp					; make room on stack
			_FontScript							; get the script
			Move.W		(SP)+, D3				; into D3
			Beq.W		@DoNothing				; it roman ! do nothing
			Subq		#4,sp					; make room on stack, will use it later
			Move.W		D3, -(SP)				; push script number on stack for later
			Cmp.W		#sysFont, teFont(A3)	; is it system font ?
			Beq.S		@SystemFont				; yes
			Cmp.W		#applFont, teFont(A3)	; is it app font ?
			Beq.S		@AppFont				; yes
			Subq		#4,sp					; make room on stack for result
			Move.W		D3, -(SP)				; push script # on stack
			Move.W		#smScriptSysFond, -(SP)	; push verb
			_GetScript							; get the system pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		teFont(A3), D0			; are you sure it's not system font ?
			Beq.S		@SystemFont				; it is !
			Subq		#4,sp					; make room on stack for result
			Move.W		D3, -(SP)				; push script # on stack
			Move.W		#smScriptAppFond, -(SP)	; push verb
			_GetScript							; get the application pref fond id
			Move.L		(SP)+, D0				; take result font
			Cmp.W		teFont(A3), D0			; are you sure it's not application font ?
			Beq.S		@AppFont				; it is !
@OtherFont	Move.W		#smScriptFntBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@SystemFont	Move.W		#smScriptSysBase ,-(SP)	; we have result space & script # on stack allready		
			Bra.S		@GetTheFont				; so push the right verb
@AppFont	Move.W		#smScriptAppBase ,-(SP)	; we have result space & script # on stack allready		
@GetTheFont	_GetScript							; so push the right verb
			Move.L		(SP)+, D0				; get the associated font
			Tst.W		D0						; test the low word <42-YDS-4/2/92>
			Beq.S		@DoNothing				; no associated font ? bail out !
			Move.L		(SP)+, D3				; restore D3, we need a fresh stack
			Move.L		teGrafPort(A3),A0		; get thePort
			Move.W		D0, txFont(A0)			; set the font to the assoc font
			SubQ		#8,SP					; space on stack
			Move.L		SP,-(SP)				; push addres
			_GetFontInfo						; get the assoc font info
			Move.L		teGrafPort(A3),A0		; get the port
			Move.W		teFont(A3),txFont(A0)	; restore the font	
			Move.W		(SP)+, D0				; get assoc font ascent
			Cmp.W		6(SP), D0				; compare with script font ascent  
			Bgt.S		@1
			Move.W		D0, 6(SP)				; let the bigger one win !
@1			Move.W		(SP)+, D0				; get assoc font descent
			Cmp.W		6(SP), D0				; compare with script font ascent  
			Bgt.S		@2
			Move.W		D0, 6(SP)				; let the bigger one win !
@2			AddQ		#2,SP					; skip max wid
			Move.W		(SP)+, D0				; get assoc font leading
			Cmp.W		6(SP), D0				; compare with script font ascent  
			Bgt.S		@3
			Move.W		D0, 6(SP)				; let the bigger one win !
@3			Bra.S		@NoAssocFont			; back to normal !
@DoNothing
			Move.L		(SP)+, D3				; restore D3, 
@NoAssocFont
	ENDIF

			Move		(SP)+,D0				; get ascent
			Move		D0,D1
			Add 		(SP)+,D1				; add descent
			AddQ		#2,SP					; skip max wid
			Add 		(sp)+,d1				; add leading

			move.l		(sp)+,a0
			Rts

;----------------------------------------------------------------------
;
;			PROCEDURE TECalText{ ( h: TEHandle	) };
;
;			When the user installs his own text handle/rectangle in the record,
;			this routine should be called to calibrate the line array to it
;
;----------------------------------------------------------------------

CalText
			Move.L		teSelStart(A3),-(SP)	; save selStart/End

			Clr 		teSelStart(A3)			; recall from beginning

; The delta must be 32,767 for the recalibration to work correctly when the insert length
; is 32,767 and the text length is 0. (an arbitrarily large negative number won't do).
			Move		#$8001,D7				; fake delta(large - number)

			Clr.L		teLines(A3) 			; insure total recal

			Bsr 		ReCalLines				; redo the line stuff

			Move.L		(SP)+,teSelStart(A3)	; restore selStart/End

			Rts

TECalText
			Bsr 		StdEntry

			Bsr.S		CalText					;								<C971/RWW102887>NO
epilog4
			MoveQ		#4,D0
			;fall into std exit

;formFeed
;----------------------------------------------------------------------
;
;			Std Exit assumes original argument is good
;
;----------------------------------------------------------------------

StdExit
			Move.L		inHandle(A6),A4 		; Place handle into A4
			Bra.S		RealExit

; ** <C105/29aug86/MBK> ** For style routines, which also have a routine
;							selector on the top of the stack

StdExit2	Move.L		inHandle+2(A6),A4 		; Place handle into A4

RealExit	Move.L		(A4),A3 				; re-dereference it

			Move		D0,D4					; save strip amount

			Move.L		teTextH(A3),A0			; get text handle
			Move.B		saveTH(A6),D0			; get the text handle flags
			_HSetState							; set up the handle

			Move.L		saveClip(A6),-(SP)
			Move.L		(SP),-(SP)
			_SetClip							; restore caller's clip
			_DisposRgn							; and dispose of our copy

			Move.L		A4,A0					; get the handle
			Move.B		saveHandle(A6),D0		; get the handle's flags
			_HSetState							; restore the handle

			Pea			saveColor(A6)			; set foreground color 		** <C182/6oct86/MBK> **

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; are we on a color system?	(as per Jerome) <C971/RWW112487>
			Bnz.S		@1						; Nope								<C971/RWW112487>
			_RGBForeColor						;									<C971/RWW112487>
			Move.L		(A4),A3					;									<C971/RWW112487>
			Bra.S		@2						;									<C971/RWW112487>
@1			Bsr			RGBForeColor			;									<C971/RWW112487>
@2
	ElseIf hasCQD THEN							; <9Dec88smb>
			_RGBForeColor						; for Ikki					** <C182/6oct86/MBK> **
			Move.L		(A4),A3					; restore ptr just in case	** <C597/06jan87/MBK> **
	Else
			Bsr			RGBForeColor			; for Alladin				** <C182/6oct86/MBK> **
	EndIf
			Move.L		teGrafPort(A3),A0		; restore GrafPort stuff
			Move.W		saveSize(A6),txSize(A0)	; restore Grafport's size
			Move.W		saveFace(A6),txFace(A0)	; restore Grafport's face
			Move.W		saveFont(A6),txFont(A0)	; restore Grafport's font

			Move.L		savePort(A6),-(SP)		; restore port to user's passed
			_SetPort

			Move		D4,D0					; restore strip amount
Std2Exit
			MoveM.L 	(SP)+,D2-D7/A2-A4		; restore regs
			Unlk		A6
			
			Move.L		(SP)+,A0				; remove return add
			Add 		D0,SP					; strip parameters
			Jmp 		(A0)

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TESetSelect{ ( selStart, selEnd: LONGINT; h: TEHandle	) };
;
;			Sets the current select range
;
;----------------------------------------------------------------------
TESetSelect
			Bsr 		StdEntry

			Bsr			ClearRsrved				; clear out reserved style

			Bsr 		HideCaret
			Bsr 		HiLite

			Move		14(A6),teSelEnd(A3) 	; Jam the selection end
			Move		18(A6),teSelStart(A3)	; jam selStart
			Bsr 		CleanUpSel				; sort and clean up selection
			
; set the current font in the grafort so can synch the keyboard to the font <10Nov88smb>
			tst.w		teSize(a3)				; if unstyled, can't synch keyboard to font <1Dec88smb>
			bpl.s		@NoSynch
			
			move.w		teSelStart(a3),d0
			beq.s		@BufferStart			; <6Dec89smb>
			sub.w		#1,d0					; backup one to get previous style <6Dec89smb>
@BufferStart
			move.w		d0,d3					; save offset position <6Dec89smb>
			bsr			GetCurStyle
			bsr			SetStyle
			move.w		d3,d0					; <6Dec89smb>
	IF hasInlineInput THEN						; 										<16>
; if inline input is on then don't unsynchronize the keyboard! 							<16>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d1		; move into reg for modulo 32 bit ops
			btst		#teFInlineInput,d1		; is this Inline Input feature desired?
			bne.s		@NoSynch				; yes, so don't unsynch!
	ENDIF										; 										<16>
			bsr			ClickKeyboard2Font		; <3Dec89smb>
;;			Bsr			SetKeyboard2Font		; synch keyboard to font <10Nov88smb>
@NoSynch
			Bsr 		ShowCaret
			Bsr 		HiLite

			Bsr 		SelView 				; insure selection is visible

			Bra 		go12
			
;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION TENew{ ( destRect, viewRect: Rect ): TEHandle };
;
;			Called when creating an unstyled TERecord.
;----------------------------------------------------------------------
TENew
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; Save regs

			Clr.L		16(A6)					; return NIL

			MoveQ		#teRecSize,D0			; Allocate a record
			_NewHandle	,CLEAR
			Bne			badExit					; escape if error				<C971/RWW102887>NO

			Move.L		A0,A4					; save handle

			_HLock								; get object handle and lock it
			Move.L		(A4),A3 				; dereference it

			MoveQ		#0,D0					; get text handle
			_NewHandle
			Bne			badExit					; escape if error				<C971/RWW102887>NO
			Move.L		A0,teTextH(A3)

; Dest and view rect must be together in record
			Lea 		teDestRect(A3),A0		; point to rects in beginning
			Move.L		12(A6),A2				; Get dest rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+
			Move.L		8(A6),A2				; Get view rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+

; Get line height, etc. for font
			Bsr			GetSize					; get ascent & hite		** <C207/10oct86/MBK> **
			Move.W		D0,teAscent(A3)		 	; save in ascent		** <C207/10oct86/MBK> **
			Move.W		D1,teLineHite(A3)		; save in line height	** <C207/10oct86/MBK> **

; Get the font and face and save away
			Move.L		GrafGlobals(A5),A2		; get lisagraf globals and then
			Move.L		thePort(A2),A2			; thePort
			Move.L		A2,teGrafPort(A3)		; save this port
			Move.L		txFont(A2),teFontStuff(A3)		; save the font/face
			Move.L		txFont+4(A2),teFontStuff+4(A3) ; save the mode/size

; set the direction of the font in the high bit of the high-order byte <30May89smb>
			move.l		a0,-(sp)				; save
			move.w		teFontStuff(a3),d1		; font
			lea			teFace+1(a3),a0			; store direction here
			Bsr			SetDirection
			move.l		(sp)+,a0
			
			Move.L		TEWdBreak,teWordBreak(A3)	; Set global word breaker

			Lea 		DefClikProc,A0			; setup default click proc
			Move.L		A0,teClikProc(A3)

			Bsr.S		InstallIntDispatch		; install new internal dispatch tbl	<C971/RWW110387>

			Move.L		teTextH(A3),A0			; need to unlock text handle	<S555/RWW080488>
			_HUnlock							; MyNewHandle locked it			<S555/RWW080488>

			Move.L		A4,A0					; set up for HUnlock
			_HUnlock
			Move.L		A4,16(A6)				; return handle

			MoveQ		#8,D0
			Bra			Std2Exit				;								<C971/RWW102887>NO


;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE ClearRsrved;
; 			** <C851/14Apr87/MBK> **
;
;			I changed teReserved to a handle to the following structure:
;				Record
;					newReserved : LONGINT;
;					nullScrap	: stScrpHandle;
;				End;
;			nullScrap is used to store a style which is set when the
;			selection is NIL in TESetStyle.  I store it in the scrap
;			format so that it can easily be inserted using PstStylGuts.
;			This procedure is called to set the style count to 0 whenever
;			the selection is changed.
;----------------------------------------------------------------------

ClearRsrved
			Tst.W		teSize(A3)				; record with style?
			Bpl.S		@0						; this hdl isn't there if not

			Move.L		teStylesH(A3),A0		; get style handle
			Move.L		(A0),A0					; deref
			Move.L		nullStyle(A0),A0		; get reserved handle
			Move.L		(A0),A0					; deref
			Move.L		nullScrap(A0),A0		; get handle to scrap for null selection
			Move.L		(A0),A0					; deref
			Move.W		#0,scrpNStyles(A0)		; indicate no style
@0			Rts

;formFeed
;----------------------------------------------------------------------
;	
;			InstallIntDispatch
;			<C971/RWW110387>
;	
;			Added this code to (quasi-) support tabs
;
;----------------------------------------------------------------------
InstallIntDispatch
			moveq		#intDispSize,d0
			bsr			MyNewHandle				; Replaces next two lines			<S508/RWW080288>
;			_NewHandle							;									<S508/RWW080288>
;			bne			badExit					;									<S508/RWW080288>

			move.l		a0,teDispatchH(a3)		; install it in the record
			move.l		(a0),a0

			lea			XEOLHook,a1
			move.l		a1,EOLHook(a0)

			lea			XDRAWHook,a1
			move.l		a1,DRAWHook(a0)

;;<2/8/90smb>			Lea			Char2Pixel,A1
			lea			OldChar2Pixel,a1		; install old routine here <2/8/90smb>
			move.l		a1,WIDTHHook(a0)

			lea			Pixel2Char,a1			;									<C971/RWW111887>
			move.l		a1,HITTESTHook(a0)		;									<C971/RWW111887>
			
			clr.l		newTEFlags(a0)			; <PMAB381/RWW020488>

			clr.l		newTEFlags+4(a0)		; <1/9/90smb> storage for double-byte char

; added for SMgr's C2P interface <2/8/90smb>
			lea			Char2Pixel,a1			; install SMgr-compatible routine here <2/8/90smb>
			move.l		a1,nWIDTHHook(a0)		; <2/8/90smb>
			
	IF hasTextWidthHook THEN					; 														<17>
; added so developers can hook the TextWidth calls in TextEdit																	<18>
			lea			OldChar2Pixel,a1		; install TextWidth routine	as the default for the hook	<18>
			move.l		a1,TextWidthHook(a0)	; 														<18>
	ENDIF										; 														<17>
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION TEStylNew{ ( destRect, viewRect: Rect ): TEHandle };
;			** Added 5/23/86 by MBK **
;
;			TEStyleNew sets txSize to -1 and stores a handle to the
;			style information in txFont, txFace. The LineHeight and
;			FontAscent fields are set to -1.
;
;----------------------------------------------------------------------
;TEStyleNew										; comment out for now				<45>
TEStylNew
			Link		A6,#0
			MoveM.L 	D2-D7/A2-A4,-(SP)		; Save regs

			Clr.L		16(A6)					; return NIL

			MoveQ		#teRecSize,D0			; Allocate a record
			_NewHandle	,CLEAR
			Bne			badExit					; escape if error				<C971/RWW102887>NO

			Move.L		A0,A4					; save handle

			_HLock								; get object handle and lock it
			Move.L		(A4),A3 				; dereference it

			MoveQ		#0,D0					; get text handle
			_NewHandle
			Bne			badExit					; escape if error				<C971/RWW102887>NO
			Move.L		A0,teTextH(A3)

; Dest and view rect must be together in record
			Lea 		teDestRect(A3),A0		; point to rects in beginning
			Move.L		12(A6),A2				; Get dest rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+
			Move.L		8(A6),A2				; Get view rectangle arg
			Move.L		(A2)+,(A0)+ 			; save away in record
			Move.L		(A2)+,(A0)+

; Set size to -1 to indicate this is a stylish record & allocate handle to style
			Move.W		#-1,teSize(A3)			; set style flag (Go style)
			MoveQ		#teStylSize,D0			; min size is for 1 style descriptor
			Bsr			MyNewHandle				; get handle to style info		** <C381/7nov86/MBK> **
			Move.L		A0,teStylesH(A3)		; former txFont location

; Get Style Handle for storing font, face, size, and color
			MoveQ		#stRecSize,D0			; size of style descriptor
			Bsr			MyNewHandle				; get StyleHandle				<C971/RWW102887>NO
			Move.L		teStylesH(A3),A2		; handle to style info
			Move.L		(A2),A2					; dereference
			Move.L		A0,styleTab(A2)			; store handle to styles array

; Get handle to array of largest line height on each line
			MoveQ		#4,D0					; Make room for one entry in line height array
			Bsr			MyNewHandle				; allocate handle to line hites	<C971/RWW102887>NO
			Move.L		A0,A1					; save handle

			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; dereference
			Move.L		A1,lhTab(A0)			; store line hites handle

; Save the GrafPort and save default style from GrafPort
			Move.L		GrafGlobals(A5),A1		; get lisagraf globals and then
			Move.L		thePort(A1),A1			; thePort
			Move.L		A1,teGrafPort(A3)		; save this port
			Move.W		txMode(A1),teMode(A3)	; save the mode

			MoveQ		#1,D0					; length of text + 1
			Bsr			GetDefStyle				; save default style in StyleRec

; Store one entry in line height array
			Move.L		teStylesH(A3),A0		; style handle
			Move.L		(A0),A0					; dereference
			Move.L		lhTab(A0),A1			; handle to line height table
			Move.L		(A1),A1					; dereference
			Move.L		styleTab(A0),A0			; handle to StyleRec's
			Move.L		(A0),A0					; dereference

			Move.W		stAscent(A0),2(A1)		; save ascent
			Move.W		stHeight(A0),(A1)		; save line height

			Move.W		#$FFFF,teAscent(A3) 	; won't be used unless somebody
			Move.W		#$FFFF,teLineHite(A3)	; sets the ascent and line height

			Move.L		TEWdBreak,teWordBreak(A3)	; Set global word breaker

			Lea 		DefClikProc,A0			; setup default click proc
			Move.L		A0,teClikProc(A3)


			Bsr			InstallIntDispatch		; install new internal dispatch tbl	<C971/RWW110387>
			Bsr.S		InitRsrved				; init reserved handle

			Move.L		teTextH(A3),A0			; need to unlock text handle	** <C381/7nov86/MBK> **
			_HUnlock							; MyNewHandle locked it			** <C381/7nov86/MBK> **

			Move.L		A4,A0					; set up for HUnlock
			_HUnlock
			Move.L		A4,16(A6)				; return handle

			MoveQ		#8,D0
			Bra			Std2Exit				;								<C971/RWW102887>NO

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE InitRsrved;
; 			** <C851/14Apr87/MBK> **
;
;			I changed teReserved to a handle to the following structure:
;				Record
;					newReserved : LONGINT;
;					nullScrap	: stScrpHandle;
;				End;
;			nullScrap is used to store a style which is set when the
;			selection is NIL in TESetStyle.  I store it in the scrap
;			format so that it can easily be inserted using PstStylGuts.
;			This procedure is called to create the nullStyle handle.
;----------------------------------------------------------------------
InitRsrved
			Move.L		A2,-(SP)				; save reg
			MoveQ		#nullStSize,D0			; size of reserved handle
			Bsr.S		MyNewHandle				; NewHandle with error checking
			Move.L		teStylesH(A3),A2		; get style handle
			Move.L		(A2),A2					; deref
			Move.L		A0,nullStyle(A2)		; store new handle
; <S508/RWW062388>	MyNewHandle could thrash the heap.  Gotta save this handle for later.
			Move.L		A0,-(SP)				; Save off the handle				<S508/RWW062388>

			MoveQ		#scrpRecSize+2,D0		; size of scrap handle
; what?			AddQ	#2,D0					; include room for # of styles		<C971/RWW102687>
			Bsr.S		MyNewHandle				; NewHandle with error checking
; <S508/RWW062388>	This pulls off the nullStyle handle we saved a few lines ago.
; not needed.	Move.L	nullStyle(A2),A2		; get reserved handle
			Move.L		(SP)+,A2				; Retrieve nullStyle handle			<S508/RWW062388>
			Move.L		(A2),A2					; deref
			Move.L		A0,nullScrap(A2)		; store new scrap handle

; what?			Move.L	nullScrap(A2),A0		; get handle to scrap for null selection <C971/RWW102687>
			Move.L		(A0),A0					; deref
			Move.W		#0,scrpNStyles(A0)		; indicate no style

			Move.L		(SP)+,A2				; restore reg
			Rts

;----------------------------------------------------------------------
;
;			PROCEDURE MyNewHandle
;			** <C381/7nov86/MBK> **
;
;			MyNewHandle unlocks the TEHandle and the text handle, attempts
;			to allocate memory for a handle, calls system error if there is one,
;			And otherwise relocks TEHandle and the text handle.
;
;	Entry:
;			D0:		requested handle size
;			A3:		Ptr to TERec
;			A4:		Handle to TERec
;
;	Exit:
;			A0:		the handle
;			A3:		Could have a different value if memory was shifted
;
;----------------------------------------------------------------------

MyNewHandle
			Move.L		D0,-(SP)				; save input
			Move.L		teTextH(A3),A0			; text handle
			_HUnlock							; make it easy to get memory
			Move.L		A4,A0					; TEHandle
			_HUnlock							; make it easy to get memory
			Move.L		(SP)+,D0				; get the input
			_NewHandle							; do it
			Bne			badExit					; fly away if system error

			Move.L		A0,-(SP)				; save handle
			Move.L		A4,A0					; get TEHandle
			_HLock								; relock it
			Move.L		(A4),A3					; reset TEPtr
			Move.L		teTextH(A3),A0			; text handle
			_HLock								; lock that too
			Move.L		(SP)+,A0				; restore handle

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEUpdate( r: Rect; h: TEHandle )
;
;			Redraws the entire object sected by r
;
;----------------------------------------------------------------------
TEUpdate
			Bsr 		StdEntry

			Move.L		(A2)+,A0				; get rect
			Bsr 		Refresh

; if window is active, don't bother with outlining. <16Oct89smb>
			tst.b		teActive(a3)
			beq.s		@TestOutline
			
			Bra 		epilog8

@TestOutline
; if outlining is on, redraw outline! <16Oct89smb>
			with		OutlineFrame
			link		a6,#OutlineFrameSz		; only link if outlining
			move		teSelStart(a3),d0		; is this a selection point?
			cmp 		teSelEnd(a3),d0
			bne.s		@drawRegion				; fall through for caret processing

; is outlining desired?
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst		#teFOutlineHilite,d0
			beq.s		@drawRegion				; outline bit not on
; if caret on invert it
			tst.b		teCarOn(a3)
			beq.s		@noDraw
			bsr			DrawIt			
@noDraw
; turn on flag in case off - want to display an outlined caret
			st			teCarOn(a3)				; will be turned off in HideCaret
@drawRegion
			bsr			InitOutline
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst		#teFOutlineHilite,d0
			beq.s		@noOutline				; outline bit not on
			st			teActive(a3)			; flag as active for hiliting
			bsr			HideCaret				; hide the caret
			bsr.s		HiLite					; Frame new region
			sf			teActive(a3)			; flag as inactive
			sf			paintFlag(a6)			; don't paint region!
			bsr			TEOutlineHilite
@noOutline
			unlk		a6
			Bra 		epilog8


;----------------------------------------------------------------------
;
;			A local cover for do find called from TEClick
;
;			This takes a character index in D6 and expands it into D0,D1
;			For character select mode, it simply copies it into D0,D1, but
;			for word select, it locates the surrounding word and returns
;			D0,D1 pointing to the word start and end(Respectively)
;			Long at D5 negative if word select
;
;----------------------------------------------------------------------
ClickExpand
			Move		D6,D0					; default for no-word select
			Move		D6,D1					;
			Tst.L		D5						; see if word select (if negative)
			Bpl.S		byebye
			Bsr 		FindWord				; find word @D0
byebye
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE HiLite;
;
;			A3 is dereferenced object
;
;			Now this pins the selStart and selEnd to the viewRect lines
;
;----------------------------------------------------------------------
HiLite
			Tst.B		teActive(A3)			; don't do if not active
			Beq.S		byebye

			MoveM		teSelStart(A3),D3-D4	; disp start is D3, disp end is D4

			MoveQ		#teHighlight,D7			; set mark mode
			Bra 		DoText					; Remove old selection

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEClick( pt: Point; extend: BOOLEAN; h: TEHandle );
;
;		Uses:
;			D6 as a character index corresponding to the current mouse point
;			D5 a copy of the previous D6
;			D5 long sign minus if word select
;			A2 anchor left point for hilighting selection
;			A4 anchor right for hilighting selection (bad! bad! bad!)						<27>
;			a4 teHandle across other TE routines											<27>
;			D0 for left of word at click spot
;			D1 for right of word at click spot
;			D3 split dispStarts for left and right piece of highlight
;			D4 split dispEnds for left and right piece of highlight
;
;----------------------------------------------------------------------
TEClick			
			Bsr 		StdEntry
			Bsr			ClearRsrved				; clear out reserved style

; Find the new point and get index of it in D6
			Move.L		14(A6),teSelPoint(A3)	; pass selPoint
			Bsr 		DoFind					; juggle dispStart/End and do find

			Bsr 		HideCaret				; Remove caret

			SubQ		#4,SP					; make room for the tickCount
			_TickCount
			Move.L		(SP)+,D0 				; Ticks in D0

			Sub.L		teClikTime(A3),D0		; see if double click
			add.l		d0,teClikTime(a3)		; Update click time for click proc.	<4>
	
			Cmp.L		DoubleTime,D0			; 1/2 second click time
			Sle 		D5						; D5 = 0 if single click
			Cmp 		teClikLoc(A3),D6		; see if same location
			Seq 		D1
			And.B		D1,D5					; D5 ST if double click
			RoR.L		#8,D5					; get switch in high D5

			Move		D6,teClikLoc(A3)		; double click only if not moved

; synch the keyboard to the font <10Nov88smb>
			tst.w		teSize(a3)				; if unstyled, try synch keyboard even if we don't
	IF forLocalizability THEN					; have all info <31g-YDS-8/27/91>
			bmi.w		@Styled					; styles !!! 
			tst.w		teLength(A3)			; do we have text at all ? 
			beq.w		@NoSynch				; don't synch if no text !!!

	IF 0 THEN									; now using 'itlb' flag in CubeE						<45>
						 						; 6.1 : synch only r->l, for 7.0 synch for double byte 
;;			tst.b		WordRedraw				; is it a R->L script ?									<34>
;;			bge.w		@NoSynch				; don't synch.											<34>
; Really want to synchronize for unstyled text in ALL scripts. However, this will cause problems for 	<34>
; input methods, so we will skip this code in this case. (WordRedraw only indicates the 				<34>
; types of scripts installed and not the current one…)													<34>
			subq		#2,sp					; result space for Font2Script & GetScript				<34>
			move.w		teFont(a3),-(sp)		; app font id											<34>
			_Font2Script						; it's a non-roman char so get script font				<34>
			move.w		(sp)+,d0				;														<34>
			beq			@UseFont				; if Roman then always synchronize						<34>
			cmp.w		#smEastEurRoman,d0		; Extended Roman?										<38>
			beq			@NoSynch				; If so, never synchronize								<38>
			subq		#4,sp					; result space											<34>
			move.w		d0,-(sp)				; script												<34>
			move.w		#smScriptRedraw,-(sp)	;														<34>
			_GetScript							;														<34>
			move.l		(sp)+,d1				;														<34><37>
			tst.b		d1						; leave in d1 for later									<34><37>
			bgt			@NoSynch				; if double-byte script	don't synchronize				<34>
			; otherwise, we have a single-byte non-Roman font											<34>
;	IF SysVers > $610 THEN		
;			move.l		teDispatchH(a3),a0		; 
;			move.l		(a0),a0
;			move.l		newTEFlags(a0),d0		; move into reg the flags
;			btst		#teFInlineInput,d0		; are we in an inline input window ?
;			bne.w		@NoSynch				; yes, don't synch keyboard.
;	ENDIF		

	ELSE										; now using 'itlb' flag	in CubeE						<45>

			; optimize for Roman-only: do not have to synch font & kbd									<50>
			with		smgrRecord				;														<50>
			GetSMgrCore a0						; load SMgr globals pointer.							<50>
			cmp.b		#1,smgrEnabled(a0)		; how many scripts enabled?								<50>
			beq			@NoSynch				; skip synchronization for Roman-only system			<50>
			endwith								;														<50>
			
			subq		#6,sp					; result space for Font2Script & GetScript				<45>
			move.w		teFont(a3),-(sp)		; app font id											<45>
			_Font2Script						; get script font										<45>
			; script left on stack				;														<45>
			move.w		#smScriptFlags,-(sp)	; now get script-specific flags							<45>
			_GetScript							;														<45>
			move.l		(sp)+,d0				;														<45>
			and.l		#(1<<smsfSynchUnstyledTE),d0	; leave only the synchronize bit				<45>
			beq			@NoSynch				; 0=> do not synchronize								<45>
			; otherwise synchronize
	ENDIF										; now using 'itlb' flag	in CubeE						<45>


			move.w		d6,d3					; don't trash d6			
			tst.b		teLftClick(a3)			; check if the click was on the previos char.
			bne.s		@2						; else sub 1 
			sub.w		#1,d3					; see the char we clicked (from 0 !!!)
@2
; Check char to determine how to synch
			move.l		teTextH(a3),a2			; handle to text										<37>
			move.l		(a2),a0					; ptr to text											<37>
			move.b		0(a0,d3.w),d0			; get character											<37>
			cmp.b		#$20,d0					; control char?											<37>
			blo			@NoSynch				; if so, don't synch									<37>
			move.b		d1,-(sp)				; save scriptRedraw										<37>
			subq		#2,sp					; room for return
			move.l		a0,-(sp)				; push text ptr on stack								<37>
			move.w		d3,-(sp)				; offset on stack
			_CharType							; what char is it
			move.w		(sp)+,d0				; take result
			move.b		(sp)+,d1				; recover scriptRedraw									<37>

; Mask off what interested in: the Type ($000F) and the Direction ($2000)								<34>
; Want a char whose Direction is LR (smCharLeft, $0000) and whose Type is Roman	letter					<34>
; which can be smCharAscii (1) or smCharEuro (7) or smCharPunct (0).									<34>
;
; New approach. Different behavior for bidi and non-bidi scripts, because of caret						<37>
; requirements for bidi scripts.																		<37>
			bne.s		@doBidi					; check scriptRedraw for bidi							<37>
; For non-bidirectional scripts, set keyboard to Roman for Roman letters,								<37>
; sync to font for script letters, dont sync for anything else.											<37>
			and.w		#smcTypeMask,d0			; isolate info we need									<37>
			cmp.w		#smCharPunct,d0			; non-letter?											<37>
			beq.s		@NoSynch				; if so, don't synch keyboard							<37>
			cmp.w		#smCharAscii,d0			; low-ASCII Roman?										<37>
			beq.s		@isRoman				; if so, go set keyboard								<37>
			cmp.w		#smCharEuro,d0			; Extended ASCII Roman?									<37>
			beq.s		@isRoman				; if so, go set keyboard								<37>
			bra.s		@UseFont				; otherwise, sync keyboard to font						<37>
; For bidirectional scripts, don't synch control chars (stripped out above) or low-ASCII				<37>
; (L-R) digits; synch other L-R chars to Roman, and everything else to font script.						<37>
@doBidi											;														<37>
			and.w		#smcTypeMask+smcClassMask+smcRightMask,d0	; isolate info we need				<37>
			cmp.w		#smCharPunct+smPunctNumber+smCharLeft,d0	; is char a low-ASCII digit?		<37>
			beq.s		@NoSynch				; if so, don't synch									<37>
			and.w		#smcRightMask,d0		; now just check direction								<37>
			beq.s		@isRoman				; if left-right, sync to Roman							<37>

; Otherwise, synch the font to the script of the character												<34>
@UseFont
			subq		#2,sp					; room for return
			move.w		teFont(a3),-(sp)		; app font id
			_Font2Script						; it's a non-roman char so get script font
			; leave script on stack
			bra.s		@SetKbd

@isRoman	move.w		#smRoman,-(sp)			; we think it is roman
@SetKbd
			move.w		(sp), d0				; script param on the stack 
			move.l		teDispatchH(a3),a0		; get teDispatchH addres 
			move.l		(a0),a0					;
			move.b		d0, lastScript(a0)		; push script number used to highlight (d0) to lastScript
			_KeyScript							; set keyboard
			bra.s		@NoSynch
	ELSE
			bpl.s		@NoSynch
	ENDIF
			
@Styled		move.w		d6,d0
			beq.s		@BufferStart			; <6Dec89smb>
	IF forLocalizability THEN					; <31e-YDS-8/27/91>
			tst.b		WordRedraw				; do we have a R->L script
			bge.s		@BufferStart			; no, take the prev allways
			tst.b		teLftClick(a3)			; check if the click was on the previos char.
			bne.s		@BufferStart			; else sub 1;
	ENDIF
			sub.w		#1,d0					; backup one to get previous style <6Dec89smb>
@BufferStart
			move.w		d0,d3					; save offset position <6Dec89smb>
			bsr			GetCurStyle				; returns ptr to current style in a0
			bsr			SetStyle				; set the font in the grafport
			move.w		d3,d0					; char offset needed in ClickKeyboard2Font <6Dec89smb>
			bsr			ClickKeyboard2Font		; sink up! <3Dec89smb>
;;			bsr			SetKeyboard2Font		; sink up!
@NoSynch

; D6 now contains the character location at which to look
;
; Find out if we want an extended selection or a normal one
; For an extended selection, fake out the loop below by fooling it into thinking
; we've already entered it "normally" but with the old selection already
; hilighted, etc.

			move.l		a4,-(sp)				; preserve teHandle for hook calls					<27>
											;													<27>
			Tst.B		12(A6)					; see if extend flag is on
			Beq.S		notExtended

			MoveM		teSelStart(A3),D0-D1	; get old selection
			Cmp 		D6,D0					; chk side of new loc
			Bhs.S		useRight
			Move		D0,A2					; save anchor left
			Move		D0,A4					; and anchor right
			Bra.S		goToIt
useRight
			Move		D1,A2					; save anchor left
			Move		D1,A4					; and anchor right
goToIt
			Move		D6,D5
			Bra.S		goSelect

notExtended
;			a4 ok here due to bra to this point														<27>
			Bsr			HiLite					; Remove old selection
			MoveQ		#teWordSelect,D2		; say "ClickExpand, word selection" <EHB 01Oct85>
			Bsr			ClickExpand				;								<C971/RWW102887>NO
; D0/D1 now contain the "bounds" of this click
			MoveM		D0-D1,teSelStart(A3)
			Move		D0,A2					; save anchor left
			Move		D1,A4					; and anchor right
			Move		D6,D5					; save "old" D6
; remember whether initial click was to left or right of character
			Move.B		teLftClick(A3),teLftCaret(A3)

			move.l		a4,-(sp)				; save current use of a4 across calls				<27>
			move.l		4(sp),a4				; restore teHandle									<27>
			Bsr 		ShowCaret				; feedback to user
			Bsr 		HiLite
			move.l		(sp)+,a4				; restore TEClick's use of a4						<27>

waitLoop
			Move.L		teClikProc(A3),D0		; call the click proc
			Beq.S		noClikProc
			Move.L		D0,A0
			Jsr 		(A0)
			Beq			done1					; if returns zero abort drag						<SM7> CSS 

noClikProc
			Clr 		-(SP)					; make room for result
			_WaitMouseUp						; see if button still down
			Tst.b 		(SP)+					; pop result, only check significant byte			<36>
			Beq.S		done1

			Pea 		teSelPoint(A3)			; pass address for point
			_GetMouse

			move.l		a4,-(sp)				; save current use of a4 across calls				<27>
			move.l		4(sp),a4				; restore teHandle									<27>
			Bsr.S		DoFind					; juggle dispStart/End and do find
			move.l		(sp)+,a4				; restore TEClick's use of a4						<27>

			Cmp 		D6,D5					; see if change
			Beq.S		waitLoop

			move.l		a4,-(sp)				; save current use of a4 across calls				<27>
			move.l		4(sp),a4				; restore teHandle									<27>
			Bsr 		HideCaret
			move.l		(sp)+,a4				; restore TEClick's use of a4						<27>

; There was a change so highlight only the new part. This is a really tricky part...
; The thing we're trying to do is highlight only the part that changes of the
; selection which is being dragged out in this loop

goSelect
			MoveQ		#teWordDrag,D2			; say "ClickExpand, word dragging"
			Bsr 		ClickExpand 			; Get new points

			Lea 		teSelEnd(A3),A0 		; point between selStart/End

			Cmp 		D6,A4					; see if less than anchor right
			Blo.S		notToLeft				; skip if not to left of anchor
			Move		-(A0),D3				; save previous left
			Move		D0,(A0)+				; save new left (in teSelStart!)
			Move		D0,D4					; save dispEnd too
			Swap		D3
			Swap		D4
			Move		A4,D3					; save other dispStart
			Move		(A0),D4					; save other dispEnd (old teSelEnd)
			Move		A4,(A0)
			Bra.S		hiliteIt


notToLeft
			Cmp 		D6,A2					; see if greater than anchor left
			Bhi.S		keepWaiting 			; skip if not to right of anchor
			Move		(A0),D3					; save previous right
			Move		D1,(A0)					; save new right
			Move		D1,D4					; save dispEnd too
			Swap		D3
			Swap		D4
			Move		-(A0),D3				; save other dispEnd
			Move		A2,D4					; save other dispStart
			Move		A2,(A0)+


hiliteIt
			move.l		a4,-(sp)				; save current use of a4 across calls				<27>
			move.l		4(sp),a4				; restore teHandle									<27>
			MoveQ		#teHighlight,D7			; set mark mode
			Bsr 		DoText					; do one half

			Swap		D3						; get other dispStart/End
			Swap		D4						; and hilight too
			Bsr 		DoText					; and other half
			move.l		(sp)+,a4				; restore TEClick's use of a4						<27>

keepWaiting
			Move		D6,D5					; save new end

			Bra.S		waitLoop				; continue on
done1
			move.l		(sp)+,a4				; restore teHandle for the last time				<27>
			Bsr 		ShowCaret				; redisplay caret

; ** <C139/23Sep86/MBK> ** Save tick count at the end of TEClick so that
; extra TextEdit computing time will not be counted between clicks

			SubQ		#4,SP					; make room for the tickCount
			_TickCount
			Move.L		(SP)+,teClikTime(A3)	; remember click time

epilog10
			MoveQ		#10,D0
			Bra 		StdExit



;formFeed
;----------------------------------------------------------------------
;
;			DoFind
;
;			Take the teSelPoint(A3) and return D6 w/corresponding char index
;
;		Exit
;			D6 contains the selection index returned from DoText
;
;----------------------------------------------------------------------

DoFind

; find out which text line it's on

			Move		teSelPoint+v(A3),D0 	; i:=(selPoint.v-destRect.top)
			Bsr 		PtToLine				; line index in D0
			Bge.S		southPole				; below the last line

			Add 		D0,D0					; double D0
			Bpl.S		noPole					; default if i < 0 is D6 = 0
northPole
			MoveQ		#0,D6					; if above point to beginning
			Rts
southPole
			Move		teLength(A3),D6 		; return index(t):=length
			Rts
noPole
			MoveM		teLines(A3,D0),D3-D4	; dispStart := lines[i]
			MoveQ		#teFind,D7				; set find mode
			Bsr 		DoText					; return index(t) in D0
			Move		D0,D6					; return in D6
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			Pixel2Char
;			** Added 6/18/86 MBK **
;
;	Entry:
;			D0.W:			length of block (style run)
;			D1.W:			pixel width relative to start of block
;			D2.W:			slop
;			A0:				ptr to start of block
;
;	Exit:
;			D0 (low word)	pixel width to character offset in block
;				(high word)	boolean = TRUE (0001) if offset corresponding to
;							the given pixel width was found
;			D1.W:			character offset
;			D2.W:			flagged (0001) if hit on leading edge of char
;
;			Must preserve A2 for DoSearch.
;----------------------------------------------------------------------
Pixel2Char
			Move.L		JPixel2Char,-(SP)		; call the Pixel2Char Routine
			Rts

vPixel2Char
			with	P2CFrame
			link	a6,#locals
			move.l	a0,textPtr(a6)				; save for result
			move.w	d1,pixelWidth(a6)			; save for SMgr P2C (and width used for 7.0)

; use NPixel2Char now for a faster and more powerful hit-test routine!							<23>
			subq	#2,sp
			move.l	a0,-(sp)					; pass text ptr to buffer
			and.l	#$0000FFFF,d0				; want length as a longint
 			move.l	d0,-(sp)
			swap	d2							; here's the slop
			clr.w	d2							;  as a FIXED
			move.l	d2,-(sp)
			move.w	d1,txtWidth(a6)				; save for result
			swap	d1							; pass de pixel width
			clr.w	d1							;  as a FIXED
			move.l	d1,-(sp)
			pea		leadingEdge(a6)				; leadingEdge is a var
			pea		widthRemaining(a6)			; width remaining is a var & FIXED			
			move.w	#smOnlyStyleRun,-(sp)		; default style run position
			move.l	#$00010001,d0				; default 1/1 scaling
			move.l	d0,-(sp)					; push numer
			move.l	d0,-(sp)					; push denom
			_NPixel2Char
			move.w	(sp)+,d1					; returns the char offset
			move.w	txtWidth(a6),d0				; return initial width for a hit
			moveq	#0,d2						; must clear since DoSearch tests it
			tst.w	widthRemaining(a6)			; is there a hit? (FIXED result)
			bmi.s	@SetLEFlag					; yep
			sub.w	widthRemaining(a6),d0		; return actual measured width

@SetLEFlag
; indicate to DoSearch that SMgr's P2C used hence leadingEdge flag is valid
			bset	#16,d2						; flag that P2C used						
			move.b	leadingEdge(a6),d2			; renamed from leftSide							<23>
			bne.s	@finis						; bra if leadingEdge is T since whole character fits	<20>
; decrement if LeadingEdge is F to be sure whole character will display							<20>
; backup correctly for either single or double byte text
			movem.l	d0/d2/d3/d6,-(sp)			;												<20>
			move.l	textPtr(a6),a0				; pointer to text measured						<21>
			move.l	teTextH(a3),a1				;												<21>
			move.l	(a1),a1						;												<21>
			suba.l	a1,a0						; offset of this text							<21>
			move.w	a0,-(sp)					; save for decrement							<21>
			move.w	d1,d6						; DoubleByte wants offset here					<21>
			add.w	a0,d6						; current position								<20>
			move.w	#-1,d3						; incremental direction to move					<20>
			bsr		DoubleByte					;												<20>
			move.w	d6,d1						; new position									<20>
			sub.w	(sp)+,d1					; restore as an offset w/in this text			<21>
			movem.l	(sp)+,d0/d2/d3/d6			;												<20>
@finis
			unlk	a6
			rts
			endWith
;formFeed
;----------------------------------------------------------------------
;
;			DoSearch
;			** Rewritten 6/18/86 MBK **
;
;			Used to determine hit-test of a character
;			<4May89smb> gave DoSearch a face-lift
;			On Entry:
;				d3	start offset
;				d4	end offset
;				a3	ptr to teRecord
;
;			On Exit:
;				d0	character offset where hit
;				leftSide (leading Edge!) set for knowing where the caret should appear
;----------------------------------------------------------------------
DoSearch

; ** <C139/10Sep86/MBK> ** Modified to call Preamble to get A2; the index
;							is in D0, but don't use it since it's not
;							documented in Inside Mac
			
			with		TextFrame,TEFormatOrder
			Bsr			Preamble				; get A2 from D3

			Move		(A2),D3 				; set left anchor			<14Jan86>
			Move		D3,D4 					; init char counter

			Bsr 		LineRect				; set rLine to A2 line

			Move		(A2),D7 				; set left anchor
			sf			teLftClick(A3)			; assume false for later!	<4May89smb>

			Move.W		teSelPoint+h(A3),D5		; get h coord
			Sub.W		teSelRect+left(A3),D5	; subtract justification

; set d0 and teLftClick(a3) if at left of selRect <4May89smb>
			ble			@BailToLeft				; special case on left of whole line
;;<1/25/90smb> if zero width, want to branch ow this one pixel difference causes the 
;;<1/25/90smb> caret to display on the wrong line ending. (Roman fix)
;;<1/25/90smb> 			blt			@BailToLeft				; special case on left of whole line <16Aug89smb>

			Move		teSelRect+left(A3),teSelRect+right(A3); init right side to left
			Move.W		#UnboundLeft,teSelRect+left(A3); bogus left

			Move.W		2(A2),D6				; end of line
			
			Tst.W		teSize(A3)				; check style flag
			Bmi.S		@StyledRecord

			st			useOldMethod(a6)
			MoveQ		#1,D2					; just 1 style
			Move.W		D3,D1					; start of line
			Move.W		D6,D0					; whole line
			Bra			@DoMeasure

@StyledRecord
			sf			useOldMethod(a6)		; flag for getting style runs <28Sept88smb>
; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge.s		@getStyleOld			; nope, only L->R directional text

			Move.W		D3,D0					; start offset
			Move.W		D6,D1					; end of selection
			bsr			GetStylesInOrder		; <15Nov88smb>		
; tests whether any styles to process <15Nov88smb>
			bge.s		@GetStyleHandle			; <15Nov88smb>
			bra			@NoMoreStyles			; done <15Nov88smb>

@getStyleNew
; get next style using the results from getFormatOrder <28Sept88smb>
;; <5Aug89smb>			movea.l		a2StyleRun(a6),a0
; Made a2StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!)
; Get to posn in styleRun array via the Style Handle and saved offset <5Aug89smb>
			move.l		teStylesH(a3),a0		; <5Aug89smb>
			move.l		(a0),a0					; deref <5Aug89smb>
			add.l		a2StyleRun(a6),a0		; add in offset to desired posn in the array <5Aug89smb>
			move.w		fmtOrderingIndex(a6),d0	; index (0-d2) into array for next style run
;;			mulu		#2,d0					; index into fmtOrdering array
			lsl.w		#1,d0					; index into fmtOrdering array <28June89smb>
			lea.l		fmtOrderingPtr(a6),a1	; get ptr to array of format runs ordering <15Nov88smb>
			move.l		(a1),a1					; dereference for ordering <15Nov88smb>
			move.w		0(a1,d0.w),d0			; index of next style run
;;			mulu		#stStartSize,d0			; offset in styleRun array from d3 style run 
			lsl.w		#lnStStartSize,d0		; offset in styleRun array from d3 style run <28June89smb>
			lea.l		0(a0,d0.w),a0			; next style run		
			addq		#1,fmtOrderingIndex(a6)	; incr the style run counter			
			subq		#1,d2					; dec the style counter
			bge.s		@GetStyleHandle
			bra			@NoMoreStyles			; done 

@getStyleOld
			st			useOldMethod(a6)
			Move.W		D3,D0					; get selection start!!!
			Move.W		D6,D1					; end of line
			Bsr			GetCurStyle				; get its style	<7Oct88smb>
			Bsr			GetNumStyles			; # of styles between offsets <7Oct88smb>
			Move.W		D0,D2					; preserve # of styles
			
@GetStyleHandle
			Move.L		A0,A2					; preserve ptr to current style
			Move.L		teStylesH(A3),A0		; handle to style info	** <C381/6nov86/MBK> **
			_HLock								; lock it up			** <C381/6nov86/MBK> **
			Move.L		A2,A0					; restore style ptr		** <C381/6nov86/MBK> **

@StyleLoop
			Move.L		A0,A2					; save ptr to style start
			Bsr			SetStyle				; set the style
			Move.W		startChar(A0),D1		; get start of style
			
			AddQ.L		#stStartSize,A0			; pt to next style run in StyleRun array 
			Move.W		startChar(A0),D0		; want end of this style run
			
			Cmp.W		D3,D1					; compare styleStart to beginning of line
			Bhs.S		@OnSameLine				; made this unsigned	** <C381/6nov86/MBK> **
			Move.W		D3,D1					; set beginning of style to beginning of line

@OnSameLine
			Move.W		D1,D7
			Cmp.W		D0,D6					; compare styleEnd to end of line
			Bhs.S		@DoMeasure				; made this unsigned	** <C381/6nov86/MBK> **
			Move.W		D6,D0					; set end of style to end of line

@DoMeasure
			Move.W		D2,-(SP)				; style count
			Sub.W		D1,D0					; length
			Move.L		teTextH(A3),A0			; handle to text
			Move.L		(A0),A0					; dereference
			AddA.W		D1,A0					; add offset to start of line
			Move.W		D5,D1					; get pixel offset
			MoveQ		#0,D2					; slop					** <C139/22Sep86/MBK> **
;			Bsr			Pixel2Char				; measure all at once
			Bsr			TEHitTestHook			; call our hook instead				<C971/RWW111887>
			Add.W		D0,teSelRect+right(A3)	; update selRect
			Add.W		D1,D7					; update char offset
			Sub.W		D0,D5					; update pixel offset

; find out if the pixel position was within the style run. <9Nov88smb>

			ble.s		@HitIt					; got a hit! (D5 <= 0)
;----------------------------------------------------------------------
; if at the last style, and pixel width > 0, and the TEHitTestHook is replaced, then
; must check the high word of d0 to see if we REALLY got a hit! <2/16/90smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		HITTESTHook(a0),a0
			pea			Pixel2Char
			cmpa.l		(sp)+,a0
			beq.s		@NotAHit
; we've been hooked out so test per the old interface specs for a hit.
			swap		d0
			tst.b		d0
			bne.s		@HitIt
@NotAHit
;----------------------------------------------------------------------
			Move.L		A2,A0					; ptr to current style
			moveq		#0,d2					; clear P2C flag from high word <7Dec89smb>
			Move.W		(SP)+,D2				; restore style count
; if no more style runs (at right of selRect), set exit info <4May89smb>
			beq.s		@NoMoreStyles			; replaced next 2 lines			<10>
;;			bne.s		@getNextStyle			; last style on line?			<10>
;;			bra.s		@NoMoreStyles			;								<10>
; get next style			
@getNextStyle
			tst.b		useOldMethod(a6)		; is this a styled, RL record? <28Sept88smb>
			beq			@getStyleNew			; yes, use formatOrder array

; either unstyled or styled, LR record.
			Addq.l		#stStartSize,a0			; get next style <7Oct88smb>
			SubQ		#1,D2					; dec # of styles
			Bne.S		@StyleLoop				; keep looping if more			<C971/RWW102887>NO

@NoMoreStyles
			move.w		#UnboundRight,teSelRect+right(A3) ; else store bogus right			
; <29Mar89smb> need to set up a2 again w/ lineStart
			move.w		d3,d0
			lea 		teLines(a3),a2
			bsr			GetLine
			bra.s		@BailToRight

; All of Bail new: <4May89smb>
; if at the Left of selRect then
;	if TESysJust = 0
;		then set (a2) and teLftClick = T.
; 	else set 2(a2) and teLftClick = F.
; if at the Right of selRect then
;	if TESysJust = FFFF
;		then set (a2) and teLftClick = T.
; 	else set 2(a2) and teLftClick = F.

; set d2 to indicate which side of rectangle we are on: 0 = Right, FF = Left. Cmp to line direction.
@BailToLeft
			st			d2						; flag on L. side of selRect (ow is 0 for R. side)
@BailToRight
			move.w		2(a2),d7				; assume at end of line
			cmp.b		TESysJust,d2			; compare edge of rectangle to line direction
			beq.s		@CRTest					; at EOL (R. edge of LR line OR L. edge of RL line)
			move.w		(a2),d7					; know at Start of line
			st			teLftClick(a3)			; mark on left to keep caret on same line (see doCaret)

			tst.b		d2						; since at Start of line don't need to test for CR
			bne.s		Done					; on left of selRect, no handle allocated
			bra.s		findDone				; test for style handle

; moved here <4May89smb>
@HitIt
			addq.l		#2,sp					; remove style count from stack
; if SMgr's P2C measured the text then the leftSide flag is valid <7Dec89smb>
			tst.l		d2						; flag in high word; whole reg 0 if TextWidth used <7Dec89smb>
			beq.s		findDone				; TextWidth used, not SMgr's P2C <7Dec89smb>
			bclr		#16,d2					; clean up! <7Dec89smb>						

			tst.b		d2						; left or right side of char? (set in P2C) ; <7Dec89smb> flag in byte
; undo what did in Pixel2Char (it was done for linebreaking and there's no way to know who called)
			st			teLftClick(A3)			; mark it to left
			bne.s		findDone				; bra if leadingEdge is T						<20>
			movem.l		d2/d3/d6,-(sp)			;												<20><23>
			move.w		d7,d6					; current position								<20>
			move.w		#1,d3					; incremental direction	to move					<20>
			bsr			DoubleByte				;												<20>
			move.w		d6,d7					; new position									<20>
			movem.l		(sp)+,d2/d3/d6			;												<20><23>
			sf			teLftClick(A3)			; mark it to right
; Only want to test for a CR if the charOffset = 2(a2) and the leftSide = T.
; CR is a neutral character therefore, if it follows a style run whose direction is
; different from the line direction, it will always occur at the EOL posn, in the
; line direction. <5May89smb>
; <1/24/90smb> need to set up a2 again w/ lineStart
			move.w		d3,d0					; <1/24/90smb>
			lea 		teLines(a3),a2			; <1/24/90smb>
			bsr			GetLine					; <1/24/90smb>
			cmp.w		2(a2),d7				; EOL?
			bne.s		@doneTest

; Test for a CR <4May89smb>
@CRTest
			Move.L		teTextH(A3),A0			; get text handle
			Move.L		(A0),A0 				; dereference
			Move.B		-1(A0,D7),D0			; <C971/RWW110387>
			Bsr.S		TEEOLHook				; normally compare d0 with $0D		<C971/RWW110387>
			beq.s		HitCR					; is a CR, so backup 1 char and set teLftClick(a3)
@doneTest
			tst.w		d5
			ble.s		done					; if neg pixelWidth, no locked style handle
			bra.s		findDone				; not a CR			
			
HitCR
			SubQ		#1,D7					; adjust result to left half
			ST			teLftClick(A3)			; mark it to left

findDone
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		Done

			Move.L		teStylesH(A3),A0		; handle to style info
			_HUnlock							; unlock it
Done											; moved here						<47>
			bsr			FreeFmtOrderArray		; <18Jan89smb>			
;;Done
			Move		D7,D0					; return in D0
			Bra			doBye

;formFeed
;----------------------------------------------------------------------
;
;			TEEOLHook
;			<C971/RWW110387>
;
;			This vectored routine was added to make life simpler for those who
;			wanted to add tabs to TextEdit.  We won't officially support it,
;			but it's here for people who need it.
;
;----------------------------------------------------------------------

TEEOLHook
			Move.L		teDispatchH(A3),A0
			Move.L		(A0),A0					; get at table
			Move.L		EOLHook(A0),A0
			Jmp			(A0)

;----------------------------------------------------------------------
;
;			XEOLHook
;			<C971/RWW110387>
;
;			Actual routine that tests character as end-of-line character.  Stock
;			version only checks for CR.  To support tabs you'd add a
;			test for TAB here as well, and then determine if the TAB puts
;			you over the length for “end of line”.
;
;			ENTRY:	D0.B	=	character to check
;
;----------------------------------------------------------------------
XEOLHook	Cmp.B		#returnChar,D0			; is it a CR?
			Rts									; return with telltale CCR


;----------------------------------------------------------------------
;
;			TEWidthHook
;			<C971/RWW110387>
;
;			Added hook for those needing to intercept the measurement of a line
;
;			Stock version only calls Char2Pixel.  To support tabs, you'd check
;			the selection to be measured for tabs and add in the appropriate
;			tab widths.
;
;			modified <2/8/90smb>
;			This internal interface still uses TextEdit's old Char2Pixel routine
;			for backwards compatibility for developers.  Specifically, if a developer
;			has been using this interface, and chains his routine in, the new Char2Pixel
;			routine would have broken his application. We now have a new interface, 
;			ScriptChar2Pixel (below) that allows a developer to replace our new 
;			Char2Pixel routine or chain with it instead.
;
;			However, if a script system is installed, we override this hook and 
;			automatically use the new hook. Also, if a developer has not replaced our 
;			internal measuring routine (OldChar2Pixel) then we use the new routine. 
;			Hence, the only time we use the OldChar2Pixel code is when a developer has
;			used this hook. <2/8/90smb>
;
; 			Measures from start of text to offset, length means length of style run!!!!
;
;			ENTRY:
;				a0.l	=>	ptr to text to measure
;				d0.w	=	Length of text to be measured
;				d1.w	=	Offset into text
;				d2.l	=	Slop (low word)
;						Hilite flag (high word)
;
;			EXIT:
;				d1.w	=	Width of measured text
;
;----------------------------------------------------------------------
TEWidthHook
; If a non-Roman system then use new WidthHook routine.
			move.l		ExpandMem,a1				; <2/8/90smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a1)	; total number of installed scripts
			bne.s		ScriptChar2Pixel			; <2/8/90smb>
			
; Test if the hook contains our internal address <2/8/90smb>
			move.l		teDispatchH(a3),a1
			move.l		(a1),a1
			move.l		WIDTHHook(a1),a1
			
; if the address of the TEWidthHook is our own OldChar2Pixel routine then use the 
; new Char2Pixel routine.  Otherwise, use the old routine. <2/8/90smb>
			pea			OldChar2Pixel				; <2/8/90smb>
			cmpa.l		(sp)+,a1					; <2/8/90smb>
			beq.s		ScriptChar2Pixel			; <2/8/90smb>
			
; set up the length and offset correctly for the OldChar2Pixel (at this point they have
; been set up for the new Char2Pixel that calls the SMgr's C2P routine.
; adjust the length to reflect the length to measure (from the offset) rather than the
; whole length of the text that the SMgr's C2P expects. <2/8/90smb>
			move.w		d1,d0						; the C2P offset (d1) should be the byte count or length (d0) <2/8/90smb>
			move.w		#0,d1						; set the offset to 0. <2/8/90smb>
			
			jmp			(a1)						; default is to call OldChar2Pixel which calls TextWidth
			
;----------------------------------------------------------------------
;
;			ScriptChar2Pixel
;
;			new <2/8/90smb>
;			This internal interface uses the new width hook which allows 
;			a developer to replace TextEdit's new Char2Pixel code that
;			uses the Script Manager's Char2Pixel routine.
;
;			If a developer chains in his routine w/o understanding our new interface
;			(ie - he expects the old TEWidthHook registers to be used) then his code
;			will not work.
;
;			Stock version only calls new Char2Pixel.
;
; 			Measures from start of text to offset, length means length of style run!!!!
;
;			ENTRY:
;				a0.l	=>	ptr to text buffer
;				a2.l	=>	ptr to current lineStart (from teLines)
;				d0.w	=	overall style run length, pinned to the line end
;				d1.w	=	offset position within the style run, pinned to the line start
;				d2.l	=	slop (low word) (see SMgr C2P routine)
;							direction flag (high word) (see SMgr C2P routine)
;
;			EXIT:
;				d1.w	=	width of measured text
;----------------------------------------------------------------------
ScriptChar2Pixel									; renamed from nTEWidthHook				<18>
			move.l		teDispatchH(a3),a1
			move.l		(a1),a1
			move.l		nWIDTHHook(a1),a1			; default is Char2Pixel
			jmp			(a1)

	IF hasTextWidthHook THEN						; 										<18>
;----------------------------------------------------------------------
;
;			TETextWidthHook																	<18>
;
;			new <9/19/90smb>
;
;			This internal interface uses the new TextWidth hook which allows 
;			a developer to replace the TextWidth calls in TextEdit with their
;			own measuring code.
;
;			The default is to use the OldChar2Pixel routine which calls
;			_TextWidth.
;
;			ENTRY:
;				a0.l	=>	ptr to text to measure
;				d0.w	=	Length of text to be measured
;				d1.w	=	Offset into text
;
;			EXIT:
;				d0.l,
;				 d1.l	=	Width of measured text, with result in low word and high word clear
;							(using both registers since some callers use d0 for the result and
;							 others use d1)
;----------------------------------------------------------------------
TETextWidthHook
			move.l		teDispatchH(a3),a1			;										<18>
			move.l		(a1),a1						;										<18>
			move.l		TextWidthHook(a1),a1		;										<18>
			jsr			(a1)						; result in d1.w						<18>
			moveq		#0,d0						;										<18>
			move.w		d1,d0						; result in longized d0					<18>
			move.w		d0,d1						; result in longized d1					<18>
			rts										;										<18>
	ENDIF											;										<18>		

;----------------------------------------------------------------------
;
;			TEHitTestHook
;			<C971/RWW111887>
;
;			Added hook for those needing to intercept hit testing on a line
;
;			Stock version only calls Pixel2Char.  To support tabs, you'd check
;			the selection to be tested and add in the appropriate tab widths.
;
;			ENTRY:
;				A0.L	=>	ptr to start of block
;				D0.W	=	Length of block
;				D1.W	=	Pixel width relative to start of block
;				D2.L	=	Slop
;
;			EXIT:
;				D0.L	=	Pixel width to last offset (low word)
;							BOOLEAN = TRUE if offset corresponding to
;							the given pixel width was found (high word)
;				D1.W	=	Character offset
;				D2.W	=	Flagged if hit on left of char
;----------------------------------------------------------------------
TEHitTestHook
			Move.L		teDispatchH(A3),A1
			Move.L		(A1),A1
			Move.L		HITTESTHook(A1),A1
			Jmp			(A1)

;----------------------------------------------------------------------
;
;			TEDrawHook
;			<C971/RWW110387>
;
;			Added hook for those needing to intercept the drawing of a line
;
;----------------------------------------------------------------------
TEDrawHook
			Move.L		teDispatchH(A3),A1
			Move.L		(A1),A1					; get at table
			Move.L		DRAWHook(A1),A1
			Jmp			(A1)

;----------------------------------------------------------------------
;
;			XDRAWHook
;			<C971/RWW110387>
;
;			Actual routine that does drawing.  Stock version only does _DrawText.
;			To support tabs, you'd check the selection to be drawn for tabs,
;			and take appropriate action on the intervening pieces.
;
;			ENTRY:
;				A0.L	=>	text to draw
;				D0.W	=	starting character
;				D1.W	=	length to draw
;
;----------------------------------------------------------------------
XDRAWHook	Move.L		A0,-(SP)
			Move.W		D0,-(SP)
			Move.W		D1,-(SP)
			_DrawText
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			DoDraw
;
;			** Rewritten 6/18/86 by MBK **
;
;			Given display start and end in [D3..D4], this draws the text
;
;----------------------------------------------------------------------

DoDraw
			with		TextFrame,TEFormatOrder
			Bsr 		PinDisplay
			Bsr			Preamble				; set rLine to A2 line

; ** <C105/14aug86/MBK> Only call LineRect at start to avoid height search **
			Bsr			LineRect

;-----------------------------------------------												<22>
; Turn PreserveGlyph off before drawing, but save its previous setting							<22>
			clr.w		-(sp)					; boolean result								<22>
			_GetPreserveGlyph					;												<22>
			; leave result on stack
			tst.w		(sp)					; preserve or squash? (byte result but cleared word)
			beq.s		@IsFalse				;												<22>
			move.b		#0,-(sp)				; set PreserveGlyph FALSE						<22>
			_SetPreserveGlyph					;												<22>
@IsFalse
;-----------------------------------------------												<22>

@lineLoop
			Bsr			PrepLine				; pin D4 at line end
			Bls			@Test4Handle			; done...

			Bsr			ChkBounds				; extend bounds if necessary
;; <7Dec89smb>			Tst.W		TESysJust				; reverse order?
;; <7Dec89smb>			Beq.S		@LROrientation			; no, left->right flow
			tst.b		WordRedraw				; if R-L script (-1), then erase whole line <7Dec89smb>
			bge.s		@LROrientation			; no, left->right flow <7Dec89smb>

			Move.W		#UnboundLeft,teSelRect+left(A3) 	; else, set unbound left
			Move.W		#UnboundRight,teSelRect+right(A3) 	; else, set unbound right <7Dec89smb>

@LROrientation
			Move.W		D4,D6					; selEnd
			Bsr			DoErase					; to fix italics problem** <C182/2oct86/MBK> **

			Move.W		saveLeft(A6),-(SP)		; saved true left value	** <C105/18aug86/MBK> Got rid of rTrue **
			Move.W		teSelRect+top(A3),-(SP) ; position pen
			Move		teAscent(A3),D0

			Tst.W		teSize(A3)				; check style flag
			Bmi.S		@styledRecord

; record has no style, so draw all at once	(the old way)
			Add 		D0,(SP) 				; drop pen to baseline
			_MoveTo

			Move.L		teTextH(A3),A0			; get text handle
			Move.L		(A0),A0 				; dereference
			Add.L		D3,A0					; offset pointer

; ** <C971/RWW110387>	Added code to support tabs
;			Move.L		A0,-(SP)				; pass pointer
;			Clr 		-(SP)					; no offset
;			Move		D4,-(SP)				; range
;			Sub 		D3,(SP) 				; draw amt := range-i
;			_DrawText							; draw it

			Clr.W		D0						; D0-D1 aren't a concern, since…	<C971/RWW110387>
			Move.W		D4,D1					; …one would expect _DrawText…		<C971/RWW110387>
			Sub.W		D3,D1					; …to blow them away anyways		<C971/RWW110387>
			Bsr.S		TEDrawHook				; go draw it						<C971/RWW110387>

			Bra			@nxtLine				;									<C971/RWW102887>NO

; record has style, so draw one style at a time
@styledRecord
			Tst.W		D0						; check default ascent
			Bpl.S		@ascentSet				; use it if set

			Bsr			PtrToLine				; convert A2 ptr to line #
			Ext.L		D0						; make it long just in case	** <C381/6nov86/MBK> **
			LsL.L		#2,D0					; mult by 4					** <C381/6nov86/MBK> **

			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; deref
			Move.L		lhTab(A0),A0			; array of max hite indeces
			Move.L		(A0),A0					; deref
			Move.W		2(A0,D0.L),D0			; max ascent

@ascentSet
			Add 		D0,(SP) 				; drop pen to baseline
			_MoveTo
			
			sf			useOldMethod(a6)		; init flag for getting style runs <28Sept88smb>
; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge.s		@getStyleOld			; nope, only L->R directional text (unsigned!)

			Move.W		D3,D0					; start offset
			Move.W		D4,D1					; end of selection
			bsr			GetStylesInOrder		; <15Nov88smb>
; tests whether any styles to process <15Nov88smb>
			bge.s		@styleLoop				; <15Nov88smb>
			bra			@nxtLine				; <15Nov88smb>
			
@getStyleNew
; get next style using the results from getFormatOrder <28Sept88smb>
			bsr			GetNextDisplayStyle		; <4Jan89smb>
			addq		#1,fmtOrderingIndex(a6)	; incr the style run counter			
			SubQ		#1,D2					; dec the style counter
			bge.s		@styleLoop
			bra.s		@nxtLine

@getStyleOld
			st			useOldMethod(a6)
			Move.W		D3,D0					; start offset
			Move.W		D4,D1					; end of selection
			Bsr			GetCurStyle				; get its style	<7Oct88smb> replaces GetFirstStyle call
			Bsr			GetNumStyles			; # of styles between offsets <7Oct88smb>
			Move.W		D0,D2					; save style count

@styleLoop
			Move.L		A0,-(sp)				; ptr to style: preserve a4	<21Dec88smb>
;;			Move.L		A0,A4					; ptr to style
			Bsr			SetStyle				; set style
			Move.W		startChar(A0),D0		; get start of style
			AddQ		#stStartSize,A0			; ptr to next style
			Move.W		D6,D4					; init to end of line
			Cmp.W		startChar(A0),D6		; compare to end of line
			Blo.S		@4
			Move.W		startChar(A0),D4		; set to end of style

@4			Move.W		D2,-(SP)				; save the count
			Move.L		teTextH(A3),A0			; get text handle
			Move.L		(A0),A0 				; dereference

			Cmp.W		D3,D0
			Bhs.S		@5						; made this unsigned	** <C381/6nov86/MBK> **
			Move.W		D3,D0					; reset if needed

@5			AddA.W		D0,A0					; offset pointer


; ** <C971/RWW110387>	Added code to support tabs
;			Move.L		A0,-(SP)				; pass pointer
;			Clr 		-(SP)					; no offset
;			Move		D4,-(SP)				; range
;			Sub 		D0,(SP) 				; draw amt := range-i

			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1
			move.l		a1,d1					; <21Dec88smb>
			Sub.L		d1,2(A7)				; save as an offset <21Dec88smb>
;;			Sub.L		A1,A4					; save as an offset

;			_DrawText							; draw it

			Move.W		D4,D1					; amount := range - i				<C971/RWW110387>
			Sub.W		D0,D1					;									<C971/RWW110387>
			Clr.W		D0						; no offset							<C971/RWW110387>
			Bsr			TEDrawHook				; go draw it						<C971/RWW110387>

; Unlock the style handle when through with pointer.
			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1
			move.l		a1,d1					; <21Dec88smb>
			Add.L		d1,2(A7)				; restore as pointer <21Dec88smb>
;;			Add.L		A1,A4					; restore as pointer

			Move.W		(SP)+,D2				; restore the count
			Move.L		(sp)+,A0				; ptr to style <21Dec88smb>
;;			Move.L		A4,A0					; ptr to style

			tst.b		useOldMethod(a6)		; <28Sept88smb>
			beq.s		@getStyleNew			; use formatOrder array

			Addq.l		#stStartSize,a0			; get next style <7Oct88smb> replaces GetNextStyle call
			SubQ		#1,D2					; dec the style counter
			Bne.S		@styleLoop				; must be more than 1 line

; ** <C105/14aug86/MBK> NextLineRect will not search for height from start **

@nxtLine

			Bsr			PtrToLine				; convert A2 to line #
			AddQ		#1,D0					; next line
			Bsr			NextLineRect			; set next line's rect
			Move		(A2),D3 				; get start
			Bra 		@lineLoop				; keep going

@Test4Handle

;-----------------------------------------------												<22>
; Restore PreserveGlyph							
			; previous PreserveGlyph value still on stack
			_SetPreserveGlyph					;												<22>						
;-----------------------------------------------												<22>

			bsr			FreeFmtOrderArray		; <18Jan89smb>
doBye
			MoveM.L 	(SP)+,D2-D7/A2-A4		; restore regs
			Unlk		A6						; unlink DoText frame
			Move.L		GrafGlobals(A5),A0		; get the port in A0 for
			Move.L		thePort(A0),A0			; compatibility
			Rts
			endWith

;formFeed
;----------------------------------------------------------------------
;
;			DoErase
;
;			** <C182/2oct86/MBK> **
;
;			DoErase was added to solve the problem of half the previous
;			character getting erased when an EraseRect is done before
;			drawing the current character. (This is a problem for Italics
;			And certain special fonts). In DoErase, if the offset is the
;			same as the line start, I still erase the whole line, in case
;			of a change in line height (and the offset must be the same as
;			a line start if the line height has changed); otherwise, I
;			don't erase the previous character since it's going to be
;			drawn over anyway.
;
;	Entry:
;			D3:		start offset
;			A2:		line start
;
;------------------------------------------------------------------------
DoErase
			move.l		ExpandMem,a0			; <28June89smb>
			move.l		ExpandMemRec.vDoErase(a0),a0
			jmp			(a0)

xDoErase

			with		TextFrame,TEFormatOrder
			Move.W		teSelRect+left(A3),-(SP) ; save left side for draw
			Cmp.W		(A2),D3					; at start of line?

			Beq.s		@GoErase				; don't worry if so

; If the mode is XOR, we must erase the previous character as well as redrawing it.
; Redrawing the character in XOR without erasing it first just erases it.  This means
; the italics problem will not be fixed in this mode.
			Cmp.W		#srcXor,teMode(A3)		; is drawing mode XOR?
			Beq.s		@GoErase				; do it the old way if so

			Tst.W		teSize(A3)				; TERec with style?
			Bpl.S		@MeasureChar			; skip style setup if not

; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge.s		@getStyleOld			; nope, only L->R directional text

			Move.W		D3,D0					; start offset
			Move.W		D4,D1					; end of selection
			bsr			GetStylesInOrder		; <15Nov88smb>
			bra.s		@SetPort
			
@getStyleOld
			Move.W		D3,D0					; selection start
			Move.W		D0,D1					; don't care about end
			Bsr			GetCurStyle				; get its style	<7Oct88smb> replaces GetFirstStyle call
			Bsr			GetNumStyles			; # of styles between offsets <7Oct88smb>
@SetPort
			Bsr			SetStyle				; set the port
@MeasureChar
	IF hasTextWidthHook THEN					; 												<18>
			move.l		teTextH(a3),a0			; text handle									<18>
			move.l		(a0),a0					; wants text ptr here							<18>
			move.w		d3,d1					; wants offset here								<18>
			moveq		#1,d0					; wants length here								<18>
			bsr			TETextWidthHook			; hook out TextWidth							<18>
	ELSE										;												<18>
			subq.l		#2,sp					; room for result
			move.l		teTextH(a3),a0			; text handle
			move.l		(a0),-(sp)				; ptr on stack
			move.w		d3,-(sp)				; offset to current char
			move.w		#1,-(sp)				; just one char
			_TextWidth							; how wide is it?
			move.w		(sp)+,d0				; this wide
	ENDIF										;												<18>

; Don't want to erase the prev character because that destroys part of the character
; before it (if it's italics or a kerned font).  However, the last pixel should be erased
; in case the application leaves a caret drawn there (like Mac3D does).
			Tst.W		D0						; nothing to do if no width			** <C485/04dec86/MBK> **
			Beq.S		@ZeroWidth				; else subtract one from char width	** <C485/04dec86/MBK> **
			SubQ.W		#1,D0					;	to fix caret erase problem		** <C485/04dec86/MBK> **
@ZeroWidth
			Add.W		D0,teSelRect+left(A3) 	; adjust left

@GoErase
			Pea 		teSelRect(A3)			; erase the expanded rect
			_EraseRect
			Move.W		(SP)+,teSelRect+left(A3) ; restore left side for draw

			bsr			FreeFmtOrderArray		; <18Jan89smb>		
			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			PrepLine
;
;			Given display start and end in [D3..D4], and a line start in
;			(A2), this gets the line's rectangle in rLine(A6).  Then pins
;			D4 at the lineStart of the next line.  Then gets the range's
;			rectangle in rTrue.  And, the expanded rect in teSelRect(A3).
;			(It calls range rect to do this).  Finally exits with CC's
;			Set according to D3 and D5(the length).
;
;		Exit:
;			CC's set to relationship of D3 to dispEnd in D5
;
;
;----------------------------------------------------------------------
PrepLine
			Move		D5,D4					; get right
			Cmp 		2(A2),D4				; pin to right (compare to lineStart of next line)
			Blo.S		@0
			Move		2(A2),D4				; set to line end (= start of next line)
@0
			Bsr 		RangeRect				; get rect from D3 to D4 in teSelRect

			Cmp 		D3,D5					; finished?
			Rts


;----------------------------------------------------------------------
;
;			Preamble
;
;			Given display start and end in [D3..D4], this first sorts the
;			two, and copies D4 into D5.  Then, it skips to the lineStart
;			entry containing D3.  It sets up A2 to point to that line.
;
;		Exit:
;			CC's set to relationship of D3 to the next line's start, 2(A2)
;			D5 a copy of incoming D4
;			a2 a pointer to the current line for d3
;
;----------------------------------------------------------------------
Preamble
			Move.L		(SP)+,A0				; get local RTS
			MoveM.L 	D2-D7/A2-A4,-(SP)
			Move.L		A0,-(SP)				; replace RTS

			Cmp 		D3,D4					; sort range
			Bhs.S		@0
			Exg 		D4,D3					; swap regs
@0
			Cmp 		teLength(A3),D4 		; pin disp end
			Blo.S		@1
			Move		teLength(A3),D4 		; pin disp end
@1

			Lea 		teLines(A3),A2			; point to line starts

			And.L		lo16,D4 				; longize D4
			Move		D4,D5					; save D5 as limit
			And.L		lo16,D3 				; longize D3

			Beq.S		@2						; skip out if 1st line(for empty rec.)

			Move.W		D3,D0
			Bsr.S		GetLine					; get its line ptr				<C971/RWW102887>NO
@2
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			GetLine
;
;			Given an offset, find the ptr to the line it's on.
;
;	Entry:	D0:		offset
;			A2:		ptr to line from which to start search
;
;	Exit:	A2:		ptr to line on which offset is found
;
;----------------------------------------------------------------------

GetLine
@0			Cmp 		2(A2),D0				; D0 past or at next linestart?
			Bls.S		@1						; if at next line start

			AddQ		#2,A2					; next lineStart
			Bra.S		@0
@1
			Bne.S		@2						; if AT next line start
			AddQ		#2,A2					; next lineStart
@2
			Rts


;----------------------------------------------------------------------
;
;			DoText funnel proc for compatibility
;			On entry d7: 
;				teFind	(0)
;				teMark	(1)		renamed to teHighlight
;				teDraw	(-1)
;				teLoc	(-2)	renamed to teCaret
;----------------------------------------------------------------------

DoText
			Move.L		TEDoText,-(SP)
			Rts
XDoText
			with		TextFrame,TEFormatOrder
			Link		A6,#TextFrameSz 		; link frame for DoText procs

			Tst 		D7						; check dispatch code
			Beq 		DoSearch
			Bgt			DoHilite
			Cmp 		#teDraw,D7
			Beq 		DoDraw					; fall into doCaret

;formFeed
;----------------------------------------------------------------------
;
;			DoCaret
;
;			Given display start sets up the caret rect in teSelRect.  Note
;			all the weird shit it has to do because of caret positioning
;			around the end of a line and at the end of the text. (That's nothing
;			compared to the weird shit it has to do for split carets! -.ed)
;
;----------------------------------------------------------------------

DoCaret
			Bsr.S		Preamble				; set rLine to A2 line

			Tst 		D3						; special case @ 1st character		<03Nov85> SC
			Beq.S		@GetSelRect				; if so skip all these checks		<03Nov85> SC

			Cmp 		(A2),D3 				; at line start?
			Bne.S		@GetSelRect				; skip if not next-line start

			Move		teLength(A3),D0 		; are we past last char?
			Beq.S		@GetSelRect				; (and is there a last char?)
			Cmp 		D0,D3					; are we past last char?
			Blo.S		@LeftCaret				; if not, skip special case

			Move.L		teTextH(A3),A0			; get text handle
			Move.L		(A0),A0 				; dereference

; ** <C971/RWW110387>	Added this code to support tabs
;			Cmp.B		#returnChar,-1(A0,D3)	; if last char <> CR then...

			Move.B		-1(A0,D3),D0			; THESE TWO LINES REPLACE PREVIOUS	<C971/RWW110387>
			bsr			TEEOLHook				;									<C971/RWW110387>
			beq.s		@GetSelRect				; skip the line
			bra.s		@PrevLine
@LeftCaret
			Tst.B		teLftCaret(A3)			; to left?
			Bne.S		@GetSelRect				; skip line pull back if so
@PrevLine
			SubQ		#2,A2					; skip to previous line
@GetSelRect
; determines the boundaries of the selection rectangle that contains the cursor, setting left = right
			bsr			LineRect				; removed from Prep		** <C105/14aug86/MBK> **

			tst.w		teSize(a3)				; <27Oct88smb>
			bmi.s		@GetCursors				; bra if styled text
			tst.b		WordRedraw				; old style record, test for Roman/double-byte system
;;<22June89smb>			bmi.s		@OldStyleRecord
			bmi.s		@GetCursors				; bra if RL unstyled text <22June89smb>
			tst.b		teSysJust				; <22June89smb>
			beq.s		@OldStyleRecord			; bra if LR text on a LR line <22June89smb>
@GetCursors
; styled text OR unstyled RL text OR unstyled LR text on a RL line
			bsr			CaretDisplay			; possibly split cursors <27Oct88smb>
			move.w		teSelRect+left(a3),d0
			move.w		d0,saveLeft(a6)
			bra.s		@Fix4Cursor
			
; Old style edit record for Roman; process as before <27Oct88smb>
@OldStyleRecord
			bsr			PrepLine				; get selRect from D3..D4		<C971/RWW102887>NO
			Move		saveLeft(A6),D0			; get caret loc
			Move		D0,teSelRect+right(A3)	; and set in teSelRect
@Fix4Cursor
			SubQ		#1,D0
			Move		D0,teSelRect+left(A3)
;-----------------------------------------------------------------------------------------			
; pin caret to edge of view rect if it's displaying out of view <1/29/90smb>
; make sure it's a caret position (selStart = selEnd)
			move.w		teSelStart(a3),d0
			cmp.w		teSelEnd(a3),d0
			bne			@Done
			
			tst.b		teSysJust
			bne.s		@RLDirection
; for a left-to-right line:
; if the viewRect.right >= the destRect.right and
; if the selRect.left >= the viewRect.right
; 	then selRect.right = viewRect.right
; 		 selRect.left = viewRect.right-1.
; is the viewRect.right >= the destRect.right?
			move.w		teViewRect+right(a3),d0
			cmp.w		teDestRect+right(a3),d0
			blt.s		@Done
; is the selRect.left >= the viewRect.right?
			move.w		teViewRect+right(a3),d0
			cmp.w		teSelRect+left(a3),d0
			bgt.s		@Done
; pin caret to edge of view rect
			move.w		d0,teSelRect+right(a3)
			subq.w		#1,d0
			move.w		d0,teSelRect+left(a3)
; test for split carets
			move.l		ExpandMem,a0
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)
			beq.s		@Done
; test if 2nd (split) caret is out of view also:is the Left edge greater than the view rect's Right edge
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; top, left, bottom, right of 2nd caret
			addq.w		#1,d0								; view rect still here: get back to right edge.
			cmp.w		left(a0),d0
			bgt.s		@Done
; pin split caret to edge of view rect also.
			move.w		d0,right(a0)
			subq.w		#1,d0
			move.w		d0,left(a0)
			bra.s		@Done
@RLDirection
; for a right-to-left line:
; if the viewRect.left <= the destRect.left and
; if the selRect.right <= the viewRect.left
; 	then selRect.left = viewRect.left
; 		 selRect.right = viewRect.left+1.
; is the viewRect.left <= the destRect.left?
			move.w		teViewRect+left(a3),d0
			cmp.w		teDestRect+left(a3),d0
			bgt.s		@Done
; is the selRect.right <= the viewRect.left?
			move.w		teViewRect+left(a3),d0
			cmp.w		teSelRect+right(a3),d0
			blt.s		@Done
; pin caret to edge of view rect
			move.w		d0,teSelRect+left(a3)
			addq.w		#1,d0
			move.w		d0,teSelRect+right(a3)
; test for split carets
			move.l		ExpandMem,a0
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)
			beq.s		@Done
; test if 2nd (split) caret is out of view also:is the Right edge less than the view rect's Left edge
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; top, left, bottom, right of 2nd caret
			subq.w		#1,d0								; view rect still here: get back to left edge.
			cmp.w		right(a0),d0
			blt.s		@Done
; pin split caret to edge of view rect also.
			move.w		d0,left(a0)
			addq.w		#1,d0
			move.w		d0,right(a0)
@Done
; end of changes <1/29/90smb>
;-----------------------------------------------------------------------------------------			
			Bra 		doBye
			
;formFeed
;----------------------------------------------------------------------
;
;			CaretDisplay
;			<27Oct88smb>
;
;			This routine will be used to display cursors, split cursors
;			when necessary.  Will not enter this routine with an old styled
;			TE record for a left-to-right directional script.  Walk through
;			a line, style run by style run, measuring and accumulating
;			widths until hit a run containing a cursor.
; 
;	Input
;			a2		LineStart of current line containing d3 (from TE LineStarts array)
;			a3		pointer to locked edit record
;
;			d3		position of cursor
;			d4		position of cursor
;
;	Uses
;			d2		number of style runs on the line
;			d5		pixelWidth of the measured style runs
;			a0		pointer to current style
;			a1		format ordering array
;			a2		lineStart
;			a4		pointer to cursor's style run
;			d5		pixelWidth of the measured style runs
;----------------------------------------------------------------------
CaretDisplay
			move.l	ExpandMem,a0			; <28June89smb>
			move.l	ExpandMemRec.vCaretDisplay(a0),a0
			jmp		(a0)

xCaretDisplay
			
			with	SharedFrame,TEFormatOrder
			link	a6,#SharedFrameSz
			move.l	ExpandMem,a0				; <1Feb89smb> initialize for only 1 cursor
			sf		ExpandMemRec.emTwoCursorsFlag(a0)
			sf		ExpandMemRec.emFmtOrderHFlag(a0) ; no handle allocated for styles 
			clr.w	gotOneRun(a6)				; set gotOneRun and onBoundaryFlag to F.
			sf		scriptDirection(a6)			; initialize to LR
			clr.w	d5
			
			bsr		GetFormatOrdering			; <8Mar89smb>

; accumulate widths of style runs until hit one containing a cursor.
@MeasureLoop
			bsr		GetNextDisplayStyle			; <4Jan89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr for the next measurement			

; does this style contain a cursor?
@Check4Cursor
			cmp.w	startChar(a0),d3			; cursor at beginning of run?
;;			bhi.s	@CheckUpperBound			; <26June89smb> made unsigned				<11>
			beq.s	@CursorRun					; cursor on start boundary of it's run
;;			bra		@GetWidth					; cursor outside of run						<11>
			blo		@GetWidth					; 											<11>
			
@CheckUpperBound
			bsr		FixFormatEnd				; if last format run, must decrement <17Jan89smb>
			cmp.w	d0,d3						; cursor at end of run? <17Jan89smb>
			bhi.s	@GetWidth					; cursor outside of run <26June89smb> made unsigned
			blt.s	@FoundCursor				; cursor in middle of run
			
; in style previous to cursor's run
			tst.b	gotOneRun(a6)				; set up second rectangle now?
			bne		@SetEnds					; yup, already have top and bottom
			st		prevStyleFlag(a6)			; cursor at end of this run (previous style)
			bra.s	@OnBoundary			
@CursorRun
; in cursor's run
			tst.b	gotOneRun(a6)				; set up second rectangle now?
			bne		@SetEnds					; yup, already have top and bottom
			sf		prevStyleFlag(a6)			; cursor at beginnning of it's run
@OnBoundary
			st		onBoundaryFlag(a6)			; cursor on boundary of run
			
; cursor either in middle of the style run or on a boundary			
@FoundCursor			
			tst.w	teSize(a3)					; <1Dec88smb>
			bpl.s	@DontSet
			bsr		SetStyle
@DontSet
			tst.b	WordRedraw					; <4Oct89smb>
			blt.s	@ContainsRLText				; <4Oct89smb>
			tst.b	teSysJust
			bne.s	@ContainsRLText
; in LR text only on a LR directional line: done stepping thru style <
			clr.l	d2							; #smLeftCaret set in low word of d2
			bsr		GetLRPosition
			add.w	d1,d5						; add C2P width to totalWidth of line thus far (d5)
			
			add.w	d5,teSelRect+left(a3)		; add width to left and right edges of selRect
			add.w	d5,teSelRect+right(a3)
			bra		@done
			
@ContainsRLText			
			move.w	d2,-(sp)					; save style counter
			bsr		GetRLPosition
			move.w	(sp)+,d2					; restore style counter
			tst.b	doneFlag(a6)
			bne.s	@finis
			tst.b	lineEndFlag(a6)
			bne.s	@GetWidth					; must measure rest of style runs on line

; added more robust tests for determining whether need to measure style run or not <8Nov88smb>
			tst.b	scriptDirection(a6)
			bne.s	@ChkRLMeasure				; bra if RL script direction
			
; in LR script direction <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne		@MeasureLoop				; bra if previous LR run: already measured
			bra.s	@GetWidth					; measure since in cursor run w/ LR direction
			
@ChkRLMeasure
; in RL script direction <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			beq		@MeasureLoop				; bra if in cursor run: already measured

; cursor's not in this style run, so measure it and save its width for later	OR
; found cursor in it's style run but the script has LR direction so need to measure
@GetWidth
			move.w	d1,-(sp)
			bsr		MeasureWholeRun			
			add.w	d0,d5
			move.w	(sp)+,d1
			tst.b	WordRedraw					; <4Oct89smb>
			bge.s	@GetNext					; <4Oct89smb>
			
			SubQ	#1,D2						; dec the style counter
			beq.s	@finis
			bra		@MeasureLoop
			
@GetNext
			Addq.l	#stStartSize,a0				; get next style
			SubQ	#1,D2						; dec the style counter
			Bne		@Check4Cursor				; must be more than 1 line
			bra.s	@finis
@SetEnds
; second cursor style run. Must set up the second rectangle for the second cursor
			tst.b	prevStyleFlag(a6)
			bne.s	@InCursorRun				; in cursor script
			move.b	previousScriptDir(a6),d0
			bra.s	@GetScriptDirection
@InCursorRun
			move.b	cursorScriptDir(a6),d0
			
@GetScriptDirection
			bne.s	@RLScript
			
; LR Script <7Nov88smb>
; if in previous style and LR script direction then measure since at end of style run
; otherwise, width is 0 since at beginning of run so, have width to use
			tst.b	prevStyleFlag(a6)
			beq.s	@MeasureRun					; bra to measure if in prevStyle's run
			bra.s	@HaveWidth
			
@RLScript
; if in cursor style and RL script direction then measure since at beginning of style run
; otherwise, width is 0 since at end of run so, have width to use  <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@MeasureRun					; bra to measure if in cursor's run
			bra.s	@HaveWidth
			
@MeasureRun
			move.w	d5,-(sp)					; necessary for two cursors
			Bsr		MeasureWholeRun
			add.w	d0,d5
			bra.s	@HaveWidth
@finis
			tst.b	lineEndFlag(a6)
			beq.w	@done

	IF forLocalizability THEN					; <31m-YDS-8/27/91>
			move.l		ExpandMem,a0
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)	; if we have one cursor
			beq.w		@done								; skip all the rest
	ENDIF

			
@HaveWidth
; finish setup of 2nd cursor rectangle
			move.l	ExpandMem,a0				; <1Feb89smb>
			lea		ExpandMemRec.emCursor2Rect(a0),a0	; <12July89smb> changed to lea
			addq	#2,a0						; top edge ok
			add.w	selRectL(a6),d5				; add original L. edge
			move.w	d5,(a0)						; left
			sub.w	#1,(a0)+					; cursor posn
			addq	#2,a0						; bottom edge ok
			move.w	d5,(a0)						; right (same as left)

	IF forLocalizability THEN					; <31d-YDS-8/27/91>
												; added to support a single carret at styled TE,
			clr.l	-(sp)						; make space for function result
			move	#smGenFlags,-(sp)			; put smSysScript verb to get the SMGR general flags
			_GetEnvirons						; now wh have the general flags 
			Move.l	(sp)+, d5					; take return value.
			and.l	#(1<<smfDualCaret),d5		; leave only the right bit
			bne.w	@done						; leave the split carret as is ?

			move.l	ExpandMem,a0				; get the scplit cursor addres into A0
			lea		ExpandMemRec.emCursor2Rect(a0),a0	
			Move.w	top(a0), d5					; some times we get the lower 
			Cmp.w	teSelRect+top(a3), d5		; in selrect & the upper in "ExpandMem"
			bgt.s	@3							; so we would like to sort it out.

			move.l	top(a0),d5							; switch the two rects. keep in mind
			move.l	teSelRect+top(a3),top(a0)			; that the upper one has the width of
			move.l	d5,teSelRect+top(a3)				; zero, while the lower one has the
			move.w	bottom(a0),d5						; witdth of 1, it ws set later tio the correct values,
			move.w	teSelRect+bottom(a3),bottom(a0)		; but that's how it is now, and i'm not
			move.w	d5,teSelRect+bottom(a3)				; going to change it.
			move.w	teSelRect+left(a3),teSelRect+right(a3)
			move.w	left(a0),right(a0)
			add.w	#1,right(a0)
			
@3			clr.l	-(sp)						; we will need a place on the stack anyway !
			Tst.b	teCarOn(A3)					; if caret on, we would like to calculate the same caret allways
			bne.s	@1							; carret is going on, calculate a new one  
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	lastScript(a0),d5 			; push script numberused to highligt (d5) to lastScript
			bra.s	@2
			
@1			move	#smKeyScript,-(sp)			; we will call _GetEnvirons to get the current active (keyboard) script.
			_GetEnvirons						; now we know who the active script
			Move.l	(sp), d5					; take return value (the script number (long !!!)), leave place for return value
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	d5, lastScript(a0)			; push script numberused to highligt (d5) to lastScript

@2			move.w	d5, -(sp)					; push the script (word !!!) for the next call we will need

			move	#smScriptRight,-(sp)		; is that script a right to left script  ?
			_GetScript							; we have smScriptRightflag the stack
			move.l	(sp)+, d0					; do = result
			move.l	ExpandMem,a0				; get the scplit cursor addres into A0
			lea		ExpandMemRec.emCursor2Rect(a0),a0
			cmp.b	TESysJust, d0
			beq.s	@UseTop
@UseBottom
			move.w	teSelRect+top(a3),top(a0)	; strech lower cursor
			move.w	teSelRect+top(a3),teSelRect+bottom(a3)	; make top = bottom in upper cursor
			bra.s	@done
@UseTop	
			move.w	bottom(a0),teSelRect+bottom(a3) ; strech upper cursor
			move.w	bottom(a0),top(a0)			; make top = bottom in lower cursor

	ENDIF

@done
			bsr		FreeFmtOrderArray			; <18Jan89smb>		
			unlk	a6
			rts
			endWith
						
;formFeed
;----------------------------------------------------------------------
;
;			GetLRPosition
;			<27Oct88smb>
;
;			The cursor is in this style run and there's only LR text in this 
;			teRecord.  Sets up for and call Char2Pixel for pixel width in
;			this style run and adds this to the total width of the line
;			thus far.  Then puts this width in the selRect so the cursor
;			can be drawn.
;
;			Input
;				a0:	style run of cursor (could be previous run w/ cursor at end)
;				a2: pointer at current line in lineStart array
;				d2: direction parameter for C2P
;				d3:	absolute position of cursor
;				d5:	total pixelWidth of style runs thus far in the line
;			Uses
;				a1
;				d0: length of style run to measure (may not be whole run) for C2P
;				d1:	start offset for C2P
;				d4:	diffence between lineStart and style start
;			Output
;				d1:	pixel width
;----------------------------------------------------------------------
GetLRPosition
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vGetLRPosition(a1),a1
			jmp		(a1)

xGetLRPosition

			move.l	a0,-(sp)	
; call Char2Pixel to get the pixel position for the cursor
			move.l	teTextH(a3),a1				; get text handle
			move.l	(a1),a1 					; dereference
			add.w	startChar(a0),a1			; add beginning of the style run to get to desired line
			exg		a1,a0						; C2P wants text ptr here

; test if style run begins on previous line, and if so adjust text ptr & offset posn in run
			moveq	#0,d4
			move.w	(a2),d0
			cmp.w	startChar(a1),d0
			bls.s	@StyleStartOK				; <26June89smb> made unsigned
; pin to lineStart
			sub.w	startChar(a1),d0			; |begin of line - begin of style run|
			add.w	d0,a0						; fix text ptr
			move.w	d0,d4						; save difference for length adjustment
			move.w	d3,d1						; cursor posn: C2P wants offset here
			sub.w	(a2),d1						; offset from start of line
			bra.s	@getLength
			
@StyleStartOK
			move.w	d3,d1
			sub.w	startChar(a1),d1			; cursor posn relative to start of style run

@getLength
; test if style run ends on next line, and if so, pin to end of this line & adjust length
			move.l	a0,-(sp)					; <6Mar89smb>
			move.l	a1,a0						; <6Mar89smb>
			bsr		FixFormatEnd				; <6Mar89smb>
			move.l	(sp)+,a0					; <6Mar89smb>
			cmp.w	2(a2),d0
			bls.s	@UseStyleEnd				; <26June89smb> made unsigned
			move.w	2(a2),d0					; pin to line end
			
@UseStyleEnd
			sub.w	startChar(a1),d0			; length of style run
			sub.w	d4,d0						; adjust for lineStart
			
			swap	d2							; direction:slop

			Bsr		TEWidthHook					; returns in d1
			move.l	(sp)+,a0
			rts
			
;formFeed
;----------------------------------------------------------------------
;
;			GetRLPosition
;			<27Oct88smb>
;
;			The cursor is in this style run and there's RL text in this 
;			teRecord OR there's only LR text but the line direction is RL.
;
;			If the cursor is not on a boundary of the run then
;			call C2P twice (with the values smLeftCaret and
;			smRightCaret).  If the values returned are different then
;			two cursors must be drawn, otherwise only one.
;
;			If the cursor is on a cluster boundary, then the cursor 
;			must be drawn in two places.  A cluster boundary also applies
;			to the beginning and end of a line, when the style run at these 
;			positions is different then the directional flow of the line.
;			Otherwise, the cursor is drawn in one place.
;		
;
;			Input
;				a0:	style run containing cursor
;				a2:	lineStart array
;				d3:	absolute position of cursor
;				d5:	total pixelWidth of style runs thus far in the line
;			Uses
;				d0: total length of style run for C2P
;				d1:	start offset for C2P
;				a1:	other style run for cursor
;----------------------------------------------------------------------
GetRLPosition
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vGetRLPosition(a1),a1
			jmp		(a1)

xGetRLPosition

RLPosnRegs	reg		a0
			with 	SharedFrame,TEFormatOrder
			movem.l	RLPosnRegs,-(sp)
			sf		doneFlag(a6)
			clr.w	highCaret(a6)				; set lineEndFlag and highCaret to F. <6mar89smb>
			st		gotOneRun(a6)
			clr.l	d2							; used for direction params for C2P
			
; save original edges of selection rectangle
			move.l	a2,-(sp)
			lea		teSelRect+top(a3),a1
			lea		selRectT(a6),a2
			move.l	(a1)+,(a2)+
			move.l	(a1)+,(a2)+
			move.l	(sp)+,a2
			
			tst.b	onBoundaryFlag(a6)			; cursor on boundary of run
			beq		@InMiddle
			tst.w	teSize(a3)					; need to test if on a block boundary for
			bpl		@InMiddle					; old-styled TE <1Dec88smb>	

; on a boundary so must test scripts of surrounding style runs (backing-store order) to 
; determine if on a cluster boundary.
			Bsr		GetDirection				; get this style run's direction in byte of d1 <7June89smb>
			tst.b	prevStyleFlag(a6)			; test if at end or beginning of cursor style run
			beq.s	@GotCursorStyle
			
; got script for style run previous to cursor style run
			move.b	d1,previousScriptDir(a6)	; <7June89smb>
			
; test for EOL cluster boundary since in previous style run <8Nov88smb>
			cmp.w	2(a2),d3					; is cursor posn at EOL?
			beq		@LineEnd

; if already at EOL then make sure not looking beyond lineStarts array <20Nov89smb>
			move.l	a0,-(sp)
			lea		2(a2),a0
			lea		teLines(a3),a1				; <20Nov89smb>
			move.w	teNLines(a3),d0				; get num of lines <20Nov89smb>
			add.w	d0,d0						; double for words <20Nov89smb>
			adda.w	d0,a1						; <20Nov89smb>
			cmpa.l	a1,a0						; <20Nov89smb>
			movem.l	(sp)+,a0					; <20Nov89smb>
			bgt.s	@LineEnd					; bra if beyond end <20Nov89smb>

; truly in the lineStarts array!
			move.l	a0,-(sp)					; save <21June89smb>
			addq.l	#stStartSize,a0				; in previous style run, so need next style run
			bra.s	@GetScript
								
@GotCursorStyle
; got script for cursor style run
			move.b	d1,cursorScriptDir(a6)		; <7June89smb>
; test for BOL cluster boundary since in cursor style run <8Nov88smb>
			cmp.w	(a2),d3						; is cursor posn at BOL?
			beq.s	@LineEnd
			move.l	a0,-(sp)					; save <21June89smb>
			subq.l	#stStartSize,a0				; at beginning so need to check previous style run
			
@GetScript
; get the other style run's direction (in display order!)
			Bsr		GetDirection				; <7June89smb>
			tst.b	prevStyleFlag(a6)
			beq.s	@GotPrevStyleNow
			move.b	d1,cursorScriptDir(a6)		; <7June89smb>
			bra.s	@CmpDirs					; <7June8smb>
			
@GotPrevStyleNow
			move.b	d1,previousScriptDir(a6)	; <7June89smb>
			
@CmpDirs
			move.l	(sp)+,a0					; restore <21June89smb>
; compare scripts to see if on a cluster boundary
			move.b	cursorScriptDir(a6),d0
			cmp.b	previousScriptDir(a6),d0
			bne.s	@ClusterBoundary
; same script so display one cursor
			Bsr		OneCursor					; added for simplicity <12/13/88smb>
			bra.s	@done						; <12/13/88smb>
			
;**********************
			
@ClusterBoundary
; on a cluster boundary: need split cursors			
			tst.b	prevStyleFlag(a6)
			beq.s	@GetScriptDirection			; in cursor script
			move.b	previousScriptDir(a6),d0

@GetScriptDirection
			move.b	d0,scriptDirection(a6)
			cmp.b	TESysJust,d0				; added <22Dec88smb>
			bne.s	@DiffDirections				; added <22Dec88smb>
			st		highCaret(a6)				; added <22Dec88smb>
@DiffDirections
			tst.b	d0
			bne.s	@RLScript
@LRScript
; if in previous style and LR script direction then measure since at end of style run
; if in cursor style, width is 0 since at beginning of run so, have width to use <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@MeasureRun					; bra to measure if in prevStyle's run
			bra.s	@SetUpTwoRects
@RLScript
; if in cursor style and RL script direction then measure since at beginning of style run
; if in previous style and RL script direction AND
;	 if RL flow, width is 0 since at end of run, so have width to use  <7Nov88smb>
;	 if LR flow, then measure since at beginning of RL script run <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@SetUpTwoRects				; bra to measure since in prevStyle's run <12July89smb>
			
@MeasureRun
			Bsr		MeasureWholeRun
			add.w	d0,d5

@SetUpTwoRects
; Setup two rectangles for the split cursors.
			bsr.s	SetUp2Rectangles			; moved init of rects into proc <12July89smb>
			bra.s	@done

;**********************

@LineEnd
			Bsr.s	OnLineEnd					; added for simplicity <12/13/88smb>
			bra.s	@done
@InMiddle
			Bsr		CaretInsideRun				; added for simplicity <12/13/88smb>
@done
			movem.l	(sp)+,RLPosnRegs			
			rts
			endWith
			
;formFeed
;----------------------------------------------------------------------
;
;			SetUp2Rectangles
;			<12/16/88smb>
;			Only set up top and bottom edges of split cursor rectangles.
;			The left and right edges will be setup in CaretDisplay.
;
;			d2 = midpoint (pixels) between top and bottom edges of selRect
;----------------------------------------------------------------------
SetUp2Rectangles

			with	SharedFrame,TEFormatOrder

			add.w	d5,teSelRect+left(a3)		; left edge of rectangle
			add.w	d5,teSelRect+right(a3)		; right edge of rectangle
; Use half a line heighth for split cursors.
			move.w	teSelRect+bottom(a3),d2
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance
	IF forLocalizability THEN					; <31a-YDS-8/27/91>
			asr.w	#1,d2						; 1/2 line height - fix Applink bug 
	ELSE
			lsr.w	#1,d2						; 1/2 line height
	ENDIF
			
; need two cursors because have arabic/english in same run OR on a cluster boundary
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
			lea		ExpandMemRec.emCursor2Rect(a0),a0		; top, left, bottom, right <12July89smb>
			tst.b	highCaret(a6)
			beq.s	@LowCaret
			
; In High Caret run (T): the top edge is ok. Adjust the bottom.
			move.w	d2,teSelRect+bottom(a3)		; new bottom (raised by 1/2 the heighth) <12July89smb>
			
; Setup low cursor (perpendicular symbol) now. Save in Cursor2Rect space. <12/13/88smb>	
			move.w	teSelRect+bottom(a3),(a0)+	; new top of line
			addq	#2,a0
			move.w	selRectB(a6),(a0)			; use original bottom
			bra.s	@done
			
@LowCaret
; in Low Caret run (perpendicular symbol): the bottom edge is ok. Adjust the top.
			move.w	d2,teSelRect+top(a3)		; new top (lowered by 1/2 the heighth) <12July89smb>
			
; Setup high cursor (T) now. Save in Cursor2Rect space.
			move.w	selRectT(a6),(a0)+			; use original top
			addq	#2,a0
			move.w	teSelRect+top(a3),(a0)		; new bottom of line
; say high caret in Cursor2Rect space <21Dec88smb> - for TeSelView
			move.l	ExpandMem,a0				; <1Feb89smb>
			ori.w	#$00FF,ExpandMemRec.emTwoCursorsFlag(a0)
@done
			rts
			endWith
			
;formFeed
;----------------------------------------------------------------------
;
;			OnLineEnd
;			<12/13/88smb>
;
;			The cursor is on a line ending, either the start or end.
;			If the style run is in a direction different than the overall
;			line direction then, on a cluster boundary and need split 
;			cursors.
;
;			Input
;				a0:	style run containing cursor
;				a2: ptr to lineStarts array
;				a3: pointer to TE record
;				d0: present style run's script id number
;				d3:	absolute position of cursor
;				d5:	total pixelWidth of style runs thus far in the line
;
;----------------------------------------------------------------------
OnLineEnd
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vOnLineEnd(a1),a1
			jmp		(a1)
			
xOnLineEnd	

			with	SharedFrame,TEFormatOrder
			
; at EOL/BOL. Is the style run of different persuasion then the line direction? <8Nov88smb>
			bsr		GetDirection				; <30May89smb>
			cmp.b	TESysJust,d1				; test if TESysJust = script direction <30May89smb>
			bne.s	@EOLClusterBoundary			; if not then on a EOL cluster boundary

; on a line end but the style run has the same direction as the line, so only one cursor.
			st		doneFlag(a6)				; modified <12/13/88smb>
			tst.b	d1							; <30May89smb>
			bne.s	@RLDirection
			
; LR direction
; if in previous style and LR script direction, then measure since at end of style run
; if in cursor style, width is 0 since at beginning of run, so have width to use <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne		@MeasureRun					; bra to measure if in prevStyle's run
			bra		@finis
			
@RLDirection
; if in cursor style and RL script direction then measure since at beginning of style run
; if in previous style and RL script direction AND
;	 if RL flow, width is 0 since at end of run so, have width to use  <7Nov88smb>
;	 if LR flow, then measure since at beginning of RL script run <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			beq		@MeasureRun					; bra to measure if in cursor's run
			tst.b	TESysJust
			beq		@MeasureRun					; LR flow but RL script
			bra		@finis
			
;***********

@EOLClusterBoundary	
; on a cluster boundary at a line end => script direction different from line direction.
; need split cursors
			tst.b	d1							; <30May89smb>
			beq.s	@LRdirection
; RL script direction
			cmp.w	2(a2),d3
			beq.s	@AtDisplayR					; bra if d3 = lineEnd
			bra.s	@AtDisplayL					; d3 = lineStart
			
@LRdirection
; LR script direction
			cmp.w	(a2),d3
			beq.s	@AtDisplayR					; bra if d3 = lineStart
;-----------------------------------------------------------------------------------------			
@AtDisplayL
; at left end of display line
; if in LR flow, RL script direction, at BOL, OR if in RL flow, LR script direction, at EOL then 
;	1st cursor at left edge of screen (high caret) and
;	2nd cursor at measured end of this style run (low caret)

			move.w	selRectL(a6),teSelRect+left(a3)		; 1st cursor at L. edge
			move.w	selRectL(a6),teSelRect+right(a3)
			
; measure style run for second cursor
			bsr		MeasureWholeRun
			add.w	d0,d5
			st		doneFlag(a6)
			st		lineEndFlag(a6)
; use half a line heighth for split cursors
			move.w	teSelRect+bottom(a3),d2
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance
	IF forLocalizability THEN					; <31a-YDS-8/27/91>
			asr.w	#1,d2						; 1/2 line height - fix Applink bug 
	ELSE
			lsr.w	#1,d2						; 1/2 line height
	ENDIF
			move.w	d2,teSelRect+bottom(a3)		; new bottom (raised by 1/2 the heighth) <12July89smb>
			
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
; The high cursor (T) goes with the line ending. the top edge is ok. Adjust the bottom. Can only
; set the top and bottom edges now.  May need to measure more style runs. <12/13/88smb>
			lea		ExpandMemRec.emCursor2Rect(a0),a0		;  top, left, bottom, right <12July89smb>
			move.w	teSelRect+bottom(a3),(a0)+	; top edge
			addq	#2,a0
			move.w	selRectB(a6),(a0)			; use original bottom
			bra.s	@finis
;-----------------------------------------------------------------------------------------
@AtDisplayR
; at right end of display line
; if in LR flow, RL script direction, at EOL, OR if in RL flow, LR script direction, at BOL then 
;	1st cursor at present measured width (low caret) and
;	2nd cursor at end of all style runs on the display line (high caret) (continue measuring till out of runs)

			add.w	d5,teSelRect+left(a3)				; 1st cursor at present measured width
			add.w	d5,teSelRect+right(a3)
			
; Setup two rectangles for the split cursors. The low cursor goes with this script run. So, 
; adjust the top edge of the rectangle. <12/13/88smb>

			st		lineEndFlag(a6)
; use half a line heighth for split cursors
			move.w	teSelRect+bottom(a3),d2
			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance
	IF forLocalizability THEN					; <31a-YDS-8/27/91>
			asr.w	#1,d2						; 1/2 line height - fix Applink bug 
	ELSE
			lsr.w	#1,d2						; 1/2 line height
	ENDIF
			move.w	d2,teSelRect+top(a3)		; new top (lower by 1/2 the heighth) <12July89smb>
			
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
			
; say high caret in Cursor2Rect space <21Dec88smb> - for TESelView
			ori.w	#$00FF,ExpandMemRec.emTwoCursorsFlag(a0)
			
; The high cursor (T) goes with the line ending. the top edge is ok. Adjust the bottom. Can only
; set the top and bottom edges now.  May need to measure more style runs. <12/13/88smb>
			lea		ExpandMemRec.emCursor2Rect(a0),a0		;  top, left, bottom, right <12July89smb>
			move.w	selRectT(a6),(a0)+			; use original top of line
			addq	#2,a0
			move.w	teSelRect+top(a3),(a0)		; bottom edge
			bra.s	@finis
@MeasureRun
			Bsr		MeasureWholeRun
			add.w	d0,d5
			add.w	d5,teSelRect+left(a3)		; left edge of rectangle
			add.w	d5,teSelRect+right(a3)		; right edge of rectangle
@finis
			rts
			endwith
			
;formFeed
;----------------------------------------------------------------------
;
;			CaretInsideRun
;			<12/13/88smb>
;
;			The cursor is in this style run and there's RL text in this 
;			teRecord. We may be on a block boundary for unstyled RL text.
;			The cursor is in the middle of a style run so, call C2P twice
;			(with the values smLeftCaret and smRightCaret). If the values
;			returned are different, then two cursors must be drawn, otherwise
;			only one.
;
;			Input
;				a0:	style run containing cursor
;				a3: pointer to TE record
;				d3:	absolute position of cursor
;				d5:	total pixelWidth of style runs thus far in the line
;			Uses
;----------------------------------------------------------------------
CaretInsideRun
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vCaretInsideRun(a1),a1
			jmp		(a1)
			
xCaretInsideRun

			with 	SharedFrame,TEFormatOrder
; cursor is in the middle of this run, so call C2P twice to see if split cursors necessary
			st		doneFlag(a6)
			move.w	#smRightCaret,d2			; second offset to measure
			swap	d2
			move.w	#smLeftCaret,d2				; first offset to measure
			
; parameters for PixelWidths routine (calls Char2Pixel twice)
			move.l	a0,a1						; save pointer to current style run
			move.w	d5,-(sp)					; save pixel width from MeasureAndHilite routine
			move.w	d3,d0
			sub.w	startChar(a1),d0			; cursor posn relative to start of style run
; pin to lineStart <5Dec88smb>
			move.w	(a2),d1						; lineStart <5Dec88smb>
			cmp.w	startChar(a1),d1			; <5Dec88smb>
			bls.s	@UseStyleStart				; <5Dec88smb> 			<26June89smb> made unsigned
			sub.w	startChar(a1),d1			; |beginning of line - beginning of style run| <5Dec88smb>
			sub.w	d1,d0						; pin to lineStart! <5Dec88smb>
; may be at lineStart
			bne.s	@UseStyleStart				; <6Dec89smb>
; if at offset 0 of this line then at the lineStart and may need to measure more style runs <6Dec89smb>
			sf		doneFlag(a6)				; <6Dec89smb>
			st		lineEndFlag(a6)				; <6Dec89smb>
@UseStyleStart
			move.w	d0,d1						; same posn just different direction
			bsr		PixelWidths					; returns pixelwidths in d5 (R block) & d6 (L block)

; <3May89smb> this is a special case that makes this UGLY! If LR text and RL line direction
; and (offset = SOL or EOL), then must setup teSelRect a little differently with the 
; results returned from C2P.
			tst.b	TESysJust
			beq.s	@LRdownstream
; RL line direction. a0 contains the current style.
			bsr		GetDirection				; returns script direction in d1
			cmp.b	TESysJust,d1
			beq.s	@RLdownstream				; RL line direction & RL script run
; Otherwise, RL line and LR script
			cmp.w	d5,d6
			beq.s	@RLdownstream
			tst.w	d5
			beq.s	@ZeroWidth
			exg		d5,d6						; want 0 width in d5: L&R edges are already set in teSelRect. 
@ZeroWidth
			add.w	(sp),d6
			bra.s	@SetUp2nd					; set up the second rectangle
			
; test line direction to determine where high caret and low caret should display. <12/13/88smb>
;;			tst.b	TESysJust
;;			bne.s	@RLdownstream
; <3May89smb> done with mods.

; L-R is the downstream direction. d6 is the L block's width. <12/13/88smb>
; Want downstream script's width in d5.  Simplifies set up for second rectangle.
@LRdownstream
			exg		d5,d6
@RLdownstream
; R-L is the downstream direction. d5 is the R block's width. <12/13/88smb>
			add.w	(sp),d5						; add pixel width of previous runs on line				
			add.w	d5,teSelRect+left(a3)
			add.w	d5,teSelRect+right(a3)
			add.w	(sp),d6
; test for one cursor
			cmp.w	d5,d6
			beq.w	@finis
			
; Setup two rectangles for the split cursors.
; The high cursor (T): the top edge is ok. Adjust the bottom. <12/13/88smb>
; use half a line heighth for split cursors
@SetUp2nd
			move.w	teSelRect+bottom(a3),d2

	IF NOT forLocalizability THEN				; <31a-YDS-8/27/91>
			bls.s	@ScrollDownBug				; scrolling down in hebrew applelink <1/15/90smb> <14>
	ENDIF

			add.w	teSelRect+top(a3),d2		; get line height <12July89smb> performance

	IF forLocalizability THEN					; <31a-YDS-8/27/91>
			asr.w	#1,d2						; 1/2 line height - fix Applink bug 
	ELSE
			lsr.w	#1,d2						; 1/2 line height
	ENDIF

			move.w	d2,teSelRect+bottom(a3)		; new bottom (raised by 1/2 the heighth) <12July89smb>
			
; need two cursors because have arabic/english in same run OR on a cluster boundary
			move.l	ExpandMem,a0				; <1Feb89smb> must save for processing at a higher level!
			st		ExpandMemRec.emTwoCursorsFlag(a0)
; <7July89smb> indicate that high caret is not stored in ExpandMem space.
			andi.w	#$FF00,ExpandMemRec.emTwoCursorsFlag(a0)

; set up low cursor (perpendicular symbol). <12/13/88smb>	
; top edge of rectangle
			lea		ExpandMemRec.emCursor2Rect(a0),a0	;  top, left, bottom, right <12July89smb>
			move.w	teSelRect+bottom(a3),(a0)+	; new top of line (same as other rect's bottom edge)
			add.w	selRectL(a6),d6				; add original L. edge
			move.w	d6,(a0)						; left
			sub.w	#1,(a0)+					; cursor posn
			move.w	selRectB(a6),(a0)+			; use original bottom of line
			move.w	d6,(a0)						; right (same as left)


	IF forLocalizability THEN					; <31c-YDS-8/27/91>
												;YS  - added to support single carret option 
												; handles unstyled text !!!! <3.3>
			clr.l	-(sp)						; make space for function result
			move	#smGenFlags,-(sp)			; put smSysScript verb to get the SMGR general flags
			_GetEnvirons						; now wh have the general flags
			Move.l	(sp)+, d5					; take return value.
			and.l	#(1<<smfDualCaret),d5		; leave only the right bit
			bne.w	@finis						; leave the split carret as is ?

			clr.l	-(sp)						; we will need a place on the stack anyway !
			Tst.b	teCarOn(A3)					; if caret on, we would like to calculate the same caret allways
			bne.s	@1							; carret is going on, calculate a new one 
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	lastScript(a0),d5 			; push script numberused to highligt (d5) to lastScript
			bra.s	@2
			
@1			move	#smKeyScript,-(sp)			; we will call _GetEnvirons to get the current active (keyboard) script.
			_GetEnvirons						; now we know who the active script
			Move.l	(sp), d5					; take return value (the script number (long !!!)), leave place for return value
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0
			move.b	d5, lastScript(a0)			; push script numberused to highligt (d5) to lastScript

@2			move.w	d5, -(sp)					; push the script (word !!!) for the next call we will need

			move	#smScriptRight,-(sp)		; is that script a right to left script  ?
			_GetScript							; we have smScriptRightflag the stack
			move.l	(sp)+, d0					; do = result
			move.l	ExpandMem,a0				; get the scplit cursor addres into A0
			lea		ExpandMemRec.emCursor2Rect(a0),a0
			cmp.b	TESysJust, d0
			beq.s	@UseTop
@UseBottom
			move.w	teSelRect+top(a3),top(a0)	; strech lower cursor
			move.w	teSelRect+top(a3),teSelRect+bottom(a3)	; make top = bottom in upper cursor
			bra.s	@finis
@UseTop	
			move.w	bottom(a0),teSelRect+bottom(a3) ; strech upper cursor
			move.w	bottom(a0),top(a0)			; make top = bottom in lower cursor
	ENDIF

@finis
			addq.l	#2,sp						; restore stack (d5 pushed)
			rts

	IF  NOT forLocalizability THEN				; <31a-YDS-8/27/91>
@ScrollDownBug
; when scrolling down the selRect top & bottom values are negative. this causes a large caret once divided
			move.l	ExpandMem,a0				; <1/15/90smb>
			sf		ExpandMemRec.emTwoCursorsFlag(a0)	; <1/15/90smb>
			addq.l	#2,sp						; restore stack (d5 pushed)
			rts
	ENDIF
			endwith
			
;formFeed
;----------------------------------------------------------------------
;
;			OneCursor
;			<12/13/88smb>
;
;			The cursor is on a script boundary but surrounded by runs of
;			the same script, therefore only one cursor is necessary.  This
;			routine sets up the selection rectangle at the position where
;			the cursor should be displayed.
;
;			Input
;				a0:	style run containing cursor
;				a3: pointer to TE record
;				d0: present style run's script id number
;				d3:	absolute position of cursor
;				d5:	total pixelWidth of style runs thus far in the line
;			Modifies d5 (appropriately), d0.
;----------------------------------------------------------------------
OneCursor
			with	SharedFrame,TEFormatOrder
			st		doneFlag(a6)				; only need one cursor since not a cluster boundary
			bsr.s	GetDirection				; <30May89smb> cc's set
			bne.s	@RLScript
; LR Script
; if in previous style and LR script direction then measure since at end of style run
; if in cursor style width is 0 since at beginning of run so, have width to use <7Nov88smb>
			tst.b	prevStyleFlag(a6)
			bne.s	@MeasureRun					; bra to measure if in prevStyle's run
			bra.s	@finis			
@RLScript
; if in cursor style and RL script direction then measure since at beginning of style run
; if in previous style and RL script direction AND
;	 if RL flow, width is 0 since at end of run so, have width to use  <7Nov88smb>
;	 if LR flow, then measure since at beginning of RL script run <8Nov88smb>
			tst.b	prevStyleFlag(a6)
			beq.s	@MeasureRun					; bra to measure if in cursor's run
			tst.b	TESysJust
			bne.s	@finis						; don't branch if LR flow but RL script
			
@MeasureRun
			Bsr		MeasureWholeRun
			add.w	d0,d5
			add.w	d5,teSelRect+left(a3)		; left edge of rectangle
			add.w	d5,teSelRect+right(a3)		; right edge of rectangle
@finis
			rts
			endwith

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE SetDirection
;			<30May89smb>
;
;			Sets the direction of the current font in the stFace word in the
;			StyleRecord by calling the Script Manager.
;
;			Input:
;				d1 = font number
;				a0 = pointer to face+1 byte where to set the direction
;
;			Output:
;				Destroys d1.
;				Preserves d0,d2,a0,a1.
;				High bit of high-order byte of stFace(a0) set to direction.
;----------------------------------------------------------------------
SetDirection
			movem.l		d0/d2/a0/a1,-(SP)		; GetScript destroys these
			move.l		ExpandMem,a0			; <28June89smb>
			move.l		ExpandMemRec.vSetDirection(a0),a0
			jmp			(a0)
			
xSetDirection

			sub.w		#6,sp					; allocate returns, 1 long, 1 int
			move.w		d1,-(sp)				; fontNumber param
			_Font2Script						; returns script
			move.w		#smScriptRight,-(sp)	; pass verb
			_GetScript
			move.l		(sp)+,d1				; get byte equal to line direction			
			movem.l		(SP)+,d0/d2/a0/a1		; restore
			bclr		#7,(a0)
			tst.b		d1						; right directional script?
			beq.s		@LeftDir				; bra if not
			bset		#7,(a0)
@LeftDir
			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			GetDirection
;			<30May89smb>
;
;			Gets the script direction for the current style run by getting 
;			it from the top bit of the high-order byte of the Face value
;			that corresponds to the style index of the current style run
;			(REMEMBER: the Face value is in different places for styled and
;			unstyled teRecords).
;
;			Input
;				a0: ptr to current style run (for styled text)
;				a3: ptr to teRecord (for unstyled text)
;			Output
;				d1.b: script direction (00 = LR/ $FF = RL)
;				cc's set, but not all calling routines take advantage of this
;			Preserves d0/a0.
;----------------------------------------------------------------------
GetDirection
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vGetDirection(a1),a1
			jmp		(a1)
			
xGetDirection

			movem.l	d0/a0,-(sp)
			tst.w	teSize(a3)					; <15June89smb>
			bpl.s	@Unstyled					; <15June89smb>
; styled text
			move.w	styleIndex(A0),D0			; fetch index into style table
			bsr		GetStyle					; returns ptr to associated style table entry in a0
			clr.w	d1
			move.b	stFace+1(a0),d1				; sets condition codes
			bra.s	@setRtn
@Unstyled
			move.b	teFace+1(a3),d1				; get from the teRecord not the styleRec
@setRtn
			beq.s	@done
			st		d1							; want the return value to be 00/FF <6June89smb>
@done
			movem.l	(sp)+,d0/a0
			rts
			
;formFeed
;-----------------------------------------------------------------------------------------
;
;			GetFormatOrdering
;			<8Mar89smb>
;
;			Created a routine that sets up format ordering information for styled and
;			unstyled text.
;-----------------------------------------------------------------------------------------
GetFormatOrdering

			with	SharedFrame,TEFormatOrder
			tst.w	teSize(a3)
			bmi.s	@GetStyles					; bra if styled edit record
			
; old-style record: one style for the whole record.  My code is expecting a0 to contain a ptr to 
; the startChar for the current style so must fake the setup.
			clr.l	firstStyleRun(a6)
			clr.l	secondStyleRun(a6)
			move.w	teLength(a3),secondStyleRun(a6)
			lea		firstStyleRun(a6),a0
			move.l	a0,a2StyleRun(a6)			; save style run of lineStart as a ptr 
			move.w	#1,d2
			move.w	d2,numberOfRuns(a6)			; save
			lea.l	fmtOrdering(a6),a1			; <18Jan89smb>
			move.l	a1,fmtOrderingPtr(a6)		; <18Jan89smb>
			clr.w	fmtOrderingIndex(a6)		; <18Jan89smb>
			clr.w	(a1)
			bra.s	@done						; <4Jan88smb>		
@GetStyles
			move.w	(a2),d0
			move.w	2(a2),d1
			bsr.s	teGetFormatOrder			; <4Jan88smb>
@done						
			rts
			endwith

;formFeed
;-------------------------------------------------------------------
;
;			GetStylesInOrder
;
;			This gets the ordering of format runs on a line and accesses 
;			the first display format order.
;										<10Nov88smb>
;			ENTRY
;				d0	start offset
;				d1	end offset
;				a6	DoText's local frame: TextFrame;
;
;			EXIT
;				d2	number of styles still to process
;				a0	ptr to next style for processing
;				a1	ptr to storage area for format orderings
; 				fmtOrdering(a6) contains a handle (if allocated) to a storage area 
;				fmtOrderingPtr(a6) contains a pointer to a storage area
;				condition codes set for evaluation
;
;-------------------------------------------------------------------
GetStylesInOrder
			move.l	ExpandMem,a0			; <28June89smb>
			move.l	ExpandMemRec.vGetStylesInOrder(a0),a0
			jmp		(a0)
			
xGetStylesInOrder

			with	SharedFrame,TEFormatOrder
			bsr.s	teGetFormatOrder			; <9Jan89smb>
; get next style in a0 using the results from getFormatOrder
			bsr		GetNextDisplayStyle			; <4Jan89smb>
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter			
			SubQ	#1,D2						; dec the style counter
			Rts
			endwith
			
;formFeed
;-------------------------------------------------------------------
;			
;			teGetFormatOrder
;			
;			This routine orders the text properly for DISPLAY of bidirectional
;			format runs on a line by calling the SMgr routine GetFormatOrder.
;			We won't come in here unless the teRecord is styled!
;
;										<10Nov88smb>
;			ENTRY
;				d0	start offset
;				d1	end offset
;				a3	dereferenced pointer to teRecord
;				a6	DoText's local frame: TextFrame
;			USES
;				a0,a1,d0-d2
;			EXIT
;				d2	number of styles still to process
;				a0	ptr to next style for processing
;				a1	ptr to storage area containing correct ordering of format runs for DISPLAY
; 				fmtOrdering(a6) contains a handle (if allocated) to a storage area 
;				fmtOrderingPtr(a6) contains a pointer to a storage area
;				condition codes set for evaluation
;-------------------------------------------------------------------
teGetFormatOrder
			move.l	ExpandMem,a0				; <28June89smb>
			move.l	ExpandMemRec.vteGetFormatOrder(a0),a0
			jmp		(a0)
			
xteGetFormatOrder

FormatOrderRegs		reg		d2-d4

			with	SharedFrame,TEFormatOrder
			moveq.l	#0,d2
			
			bsr		GetCurStyle
; Made a2StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!) Oh-Dopey-Me!
			move.l	teStylesH(a3),a1			; <5Aug89smb>
			move.l	(a1),a1						; deref <5Aug89smb>
			sub.l	a1,a0						; save posn as an offset <5Aug89smb>
			move.l	a0,a2StyleRun(a6)			; save offset to style run of lineStart
			
			add.l	a1,a0						; restore for GetNumStyles call!
			bsr		GetNumStyles				; number of runs on this line
			move.w	d0,d2
			move.w	d2,numberOfRuns(a6)			; save
			
			Bsr		GetStyleStorage				; <18Jan89smb> returns fmtOrdering array in a1
; Initialize fmtOrdering array with LR format ordering (0->d2) (aka: backin-store ordering)
			moveq	#0,d0
			bra.s	@CheckZero
@FillArray
			move.w	d0,(a1)+					; fill 'er up!
			addq.w	#1,d0						; next integer value for array
@CheckZero
			dbra	d2,@FillArray				; loop til d2 = -1
			move.w	numberOfRuns(a6),d2			; restore			
			
; determine if display order is different from backin-store order
			clr.w	fmtOrderingIndex(a6)
			tst.b	WordRedraw					; $FF if a R->L directional script installed
			bge.s	@finis
			
; call GetFormatOrder for correct display order for style runs
; test for only one style run <23June89smb>
			move.l	a0,-(sp)					; save
			Move.L	teStylesH(a3),a0			; handle to style info
			Move.L	(a0),a0						; dereference
			cmpi.w	#1,nRuns(a0)				; only one run?
			beq.s	@done						; yep, so done
			move.l	(sp)+,a0					; restore
			
			movem.l	FormatOrderRegs,-(sp)
; parameter setup
			move.l	fmtOrderingPtr(a6),-(sp)	; formatOrder array
			move.w	#0,-(sp)					; 1st format
			subq.w	#1,d0
			move.w	d0,-(sp)					; last format (1 less than num of runs)
			move.b	TESysJust,-(sp)				; lineRight
			pea		teDirectionProc
			
; parameter for direction procedure
			move.l	a0,startStyleRun(a6)		; dirParam is the ptr to first style run and
			move.l	a3,teRecPtr(a6)				; and the pointer to the teRecord
			pea.l	directionParam(a6)
			_GetFormatOrder						; returns display ordering in array

			movem.l	(sp)+,FormatOrderRegs
			bra.s	@finis
@done			
			move.l	(sp)+,a0
@finis
			rts									; return to sender!
			endwith
			
;formFeed			
;----------------------------------------------------------------------
;
;			GetNextDisplayStyle
;			<22Dec88smb>
;			Does exactly what it's name says it does!
;
;			On entry
;				a6 = the local stack frame
;			On exit
;				a0 = pointer to next style run
;				a1 = trashed
;				d0 = trashed
;----------------------------------------------------------------------
GetNextDisplayStyle

			with	SharedFrame,TEFormatOrder

			movea.l	a2StyleRun(a6),a0
; For styled is an offset to desired posn in style run array, otherwise is a ptr <5Aug89smb>
; Made a2StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!)
; Get to posn in styleRun array via the style handle and saved offset <5Aug89smb>
			tst.w	teSize(a3)					; <5Aug89smb>
			bpl.s	@Unstyled					; saved as a ptr for unstyled text! <5Aug89smb>
; styled teRec
			move.l	teStylesH(a3),a1			; <5Aug89smb>
			move.l	(a1),a1						; deref <5Aug89smb>
			add.l	a1,a0						; add to offset to get desired posn in the array <5Aug89smb>
@Unstyled
			move.w	fmtOrderingIndex(a6),d0		; index (0-d2) into array for next style run
			lsl.w	#1,d0						; index into fmtOrdering array <27June89smb>
			move.l	fmtOrderingPtr(a6),a1
			move.w	0(a1,d0.w),d0				; index of style run to process
			move.w	d0,styleRunIndex(a6)
			lsl.w	#lnStStartSize,d0			; offset in styleRun array <27June89smb>
			lea.l	0(a0,d0.w),a0				; pointer to next style run
			rts
			endwith
			
;formFeed
;----------------------------------------------------------------------
;
;			GetStyleStorage
;
;			This routine allocates a storage area for the ordering of 
;			style runs on this line in teGetFormatOrder.  It will be in the
;			local frame if the number of style runs on this line is small
;			enough (<= #numStyleRuns).  Otherwise, a handle is allocated
;			for storage.  It saves the handle in fmtOrdering(a6) and the 
;			pointer in fmtOrderingPtr(a6).
;			<14Nov88smb>
;
;	Entry:
;			d2:		number of style runs between the offsets in low word/ high word cleared
;			a0:		ptr to style run at first offset
;	Exit:
;			a0:		preserved
;			a1:		ptr to storage area for ordering of style runs
;			d2:		preserved
;			fmtOrderingPtr(a6):	pointer to space for format ordering array
;	Uses:
;			d0
;			Modifies fmtOrdering(a6) if a handle is allocated for storage
;----------------------------------------------------------------------
GetStyleStorage

StorageRegs		reg		d2/a0

			with	SharedFrame,TEFormatOrder
			movem.l	StorageRegs,-(sp)

; indicate a handle was NOT allocated
			move.l	ExpandMem,a0			; <1Feb89smb>
			sf		ExpandMemRec.emFmtOrderHFlag(a0)

; initialize a1 for teGetFormatOrder call: wants a pointer to the storage area
			lea.l	fmtOrdering(a6),a1		; may be replaced if too many style runs
			move.l	a1,fmtOrderingPtr(a6)
			
			cmpi.w	#numStyleRuns,d2
			bls.s	@done					; bra if fits ok		<26June89smb> made unsigned

			
; local frame too small, get a handle to hold all the style runs on this line		
			move.l	ExpandMem,a0			; <1Feb89smb> indicate a handle was allocated
			st		ExpandMemRec.emFmtOrderHFlag(a0)

			lsl.w	#1,d2					; mult number of style runs by 2 for byte cnt
			move.l	d2,d0
			_NewHandle ,CLEAR				; allocate and clear a block and return handle in a0
			bne.s	@sysErr					; exit if system error

			_HLock
			bne.s	@CleanUp

; dereference the handle and save
			move.l	(a0),a1					; for teGetFormatOrder
			move.l	a0,fmtOrdering(a6)		; save handle
			move.l	(a0),fmtOrderingPtr(a6)	; need pointer for processing style runs			
@done
			movem.l	(sp)+,StorageRegs			
			Rts
			

; OH NO!!!! can't get no memory!
@CleanUp
; deallocate handle in a0
			move.l	d0,-(sp)				; save initial error
			_DisposHandle
			move.l	(sp)+,d0				; restore initial error
@sysErr			
			_SysError						; go bye-bye with error in d0
			
			endwith

;formFeed
;-------------------------------------------------------------------
;
;			teDirectionProc
;			<29Sept88smb>
;
;			This routine returns the direction of a style run,
;			00 for Left and $FF for Right.  It is called from 
;			the Script Manager routine GetFormatOrder.
;
;			Function MyRLDirProc (theFormat:	Integer;
;									dirParam:	Ptr):	Boolean;
;				
;			Input:
;				sp.w:		theFormat
;				sp.l:		dirParam:
;							- ptr into the styleRun array at the 1st offset's style run
;							- pointer to the teRecord
;			Output:
;				a0 contains the return address at exit
;				00/$FF on the stack (sp.b) for direction
;			Register Usage:	
;				a3 = teRecord
;------------------------------------------------------------------
teDirectionProc

DirFrame	record	{a6Link},decr
result		ds.w	1					; MyDirProc boolean result
argTop		equ		*
format		ds.w	1					; theFormat parameter
dirParam	ds.l	1					; dirParam parameter
argBottom	equ		*
return		ds.l	1
a6Link		ds.l	1
DirFrameSz	equ		*
			EndR

DirProcRegs		reg		d0/d1/a1/a3
			
			with	DirFrame
			link	a6,#DirFrameSz
			movem.l	DirProcRegs,-(sp)
			
; get parameters: style run pointer and teRecord pointer
			move.l	dirParam(a6),a0
			move.l	(a0)+,a1			; pointer to style run array
			move.l	(a0),a3				; get to teRecord

			move.w	format(a6),d0
			lsl.w	#2,d0				; incr ptr into styleRun array
			move.l	a1,a0				; address of style run array
			add.w	d0,a0				; new pointer to current style run <10jan89smb>
			bsr		GetDirection		; <10jan89smb>
			move.b	d1,result(a6)		; 0 => Left to Right; otherwise Right to Left <10jan89smb>

			movem.l	(sp)+,DirProcRegs
			unlk	a6
			move.l	(sp)+,a0			; pop return
			addq.l	#(argTop-argBottom),sp
			jmp	(a0)
			rts
			endWith
			
;formFeed
;----------------------------------------------------------------------
;
;			FreeFmtOrderArray
;			<15Nov88smb>
; 			Determine if a handle for style runs needs to be deallocated
;			and if so, do it!
;
;----------------------------------------------------------------------

FreeFmtOrderArray
			
			with	SharedFrame,TEFormatOrder
			move.l	ExpandMem,a0				; <1Feb89smb>
			tst.b	ExpandMemRec.emFmtOrderHFlag(a0)
			beq.s	@NoHandle
; deallocate the handle that's saved in FmtOrdering(a6)
			sf		ExpandMemRec.emFmtOrderHFlag(a0)
			move.l	fmtOrdering(a6),a0
			_DisposHandle
@NoHandle
			rts

;formFeed
;----------------------------------------------------------------------
;
;			DoHilite
;
;			Modified to use SMgr HiliteText.
; ********* Be sure to notice the unusual use of link/unlk here	*******
; *********	due to multiple line highlighting! 					*******
; Entry
;			a3			pointer to locked edit record
;			a4			handle to teRecord													<27>
;			d3			position of first character to redraw
;			d4			position of last character to redraw
;			a6			DoText's local frame: TextFrame
;----------------------------------------------------------------------
DoHilite
			
; If a Roman system then use old DoHilite code: HyperCard expects to hilite a whole region not three! <3Oct89smb>
			move.l	ExpandMem,a0
			cmpi.b	#1,ExpandMemRec.emScriptsInstalled(a0)	; total number of installed scripts
			beq		RomanDoHilite			; use old DoHilite
			
; use this code for mixed directional text
			
			Bsr 	PinDisplay
			Bsr		Preamble				; set rLine to A2 line, d5 = d4
											; sets A2 to point to line containing d3
			Bsr		LineRect				; get top, bottom and just (from A2)

			move.l	a4,-(sp)				; need for OnSameLine vector <26June89smb>

			with	HiliteFrame
			link	a6,#HiLiteSz			; LineRect needs to access doText stack frame			

			movea.l	a2,a1					; save d3 lineStart
			cmp.w	d3,d4					; wrong order?
			beq		@unLinkFrame
			bhi.s	@Get2ndLine				; no, correct
			exg		d3,d4					; fix
			
; find out the first offset's line for Right to Left directional text
			move.w	d3,d0
			lea 	teLines(a3),a2			; point to line starts
			bsr		GetLine					; returns ptr to line in a2
			bra.s	@CompareLines
@Get2ndLine
; test if 2nd offset is at the end of the 1st offset's line <2Dec88smb>
			cmp.w	2(a2),d4				; <2Dec88smb>
			beq.s	@CompareLines			; <2Dec88smb>
			
; get the second offset's line. Already have lineStart for d3 in a1
			move.w	d4,d0
			bsr		GetLine 				; returns ptr to line in a2

@CompareLines
			exg		a1,a2
			cmpa.l	a1,a2
			bne.s	@MultipleLines			; over multiple lines

			bsr		xOnSameLine				; skip the vector code since it wipes out a4		<27>
			bra		@unLinkFrame

@MultipleLines
; [d3,d4] over multiple line
; set up for line containing d3
			move.l	a1,d4Line(a6)			; save lineStart for d4 for later
			move.l	a2,d3Line(a6)
			move.w	d4,savD4(a6)
			move.w	2(a2),d4				; end of d3 line
			bsr		xOnSameLine				; skip the vector code since it wipes out a4		<27>

; set up for line containing d4			

			move.w	savD4(a6),d4
			move.l	d4Line(a6),a2			; LineRect wants the current line in a2
			move.w	(a2),d3					; beginning of d3 line
			
; ********* Be sure to notice the unusual use of link/unlk here	*******
; *********	due to multiple line highlighting! 					*******
			move.l	d3Line(a6),a1			; temp for unlink 
			unlk	a6						; unlink HiliteFrame for LineRect *********
			move.w	teSelRect+bottom(a3),-(sp)	; save for middle rectangle's top edge
			move.l	a1,-(sp)				; save d3's line
			bsr		LineRect				; get top, bottom and just (from A2)
			bsr		xOnSameLine				; skip the vector code since it wipes out a4		<27>
			
			move.l	(sp)+,a1				; d3's line
; now hilite the middle rectangle, between the lines containing the offsets.
; a1 = ptr to line containing d3
; a2 = ptr to line containing d4			
	
; tests for lines inbetween 1st and last
			move.w	2(a1),d2				; end of 1st line				
			cmp.w	(a2),d2					; end of 1st rectangle = beginning of last rectangle
			beq.s	@noMidRect				; done: no middle rectangle

;-------------------------------------------													<16>
	IF hasInlineInput THEN					; 													<16>
; if inlineInput then don't want to hilite to edge of selRect, only to text boundaries			<16>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFInlineInput,d0		; is this Inline Input feature desired?
			beq.s	@HiliteMiddle			; no, so hilite middle rect as one!
; inline input so measure the middle rectangle of text
; a1 = ptr to line containing d3
; a2 = ptr to line containing d4
@AnotherLine
			move.w	d2,d3					; d2 contains the new d3
			add.w	#2,a1					; increment to pt to line containing new d3
			move.w	2(a1),d4
			movem.l	a1/a2,-(sp)				; save d3 & d4's line
			move.l	a1,a2					; LineRect wants the current line in a2
			bsr		LineRect				; get top, bottom & just (from a2)
			bsr		xOnSameLine				; skip the vector code since it wipes out a4		<27>
			movem.l	(sp)+,a1/a2
			move.w	2(a1),d2				; end of d3's line
			cmp.w	(a2),d2					; end of d3's line = beginning of last line?
			bne.s	@AnotherLine			; bra if another line to measure & hilite
			bra.s	@noMidRect				; otherwise done									<16>
	ENDIF									;													<16>
;-------------------------------------------													<16>

; set up selRect(a3)
@HiliteMiddle
			move.w	teSelRect+top(a3),teSelRect+bottom(a3)	; top of last rect = bottom of middle rect
			move.w	(sp)+,teSelRect+top(a3)		; bottom of 1st rect = top of middle rect
			Move.W	#UnboundLeft,teSelRect+left(a3) 	; far left
			Move.W	#UnboundRight,teSelRect+right(a3) 	; far right

			Move.L	teHiHook(a3),D0 		; do the inversion via hook if exists
			Bsr		InvertHook				; hilite it				
			bra.s	@finis
	
@noMidRect
			addq	#2,a7					; don't need saved pixelWidth for top edge
			bra.s	@finis
@unLinkFrame
; ********* Be sure to notice the unusual use of link/unlk here	*******
; *********	due to multiple line highlighting! 					*******
			unlk	a6						; unlink HiliteFrame
@finis
			move.l	(sp)+,a4				; restore handle <26June89smb>
			bra		doBye
			endWith
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RomanDoHilite
			Bsr 		PinDisplay
			Bsr			Preamble				; set rLine to A2 line

			Bsr			LineRect				; get top, bottom and just
			Bsr			PrepLine				; pin D4 at line end
			Bls.S		@done					; done...						<C971/RWW102887>NO

			Bsr			ChkBounds				; check far left and right		<C971/RWW102887>NO

			Move.L		teHiHook(A3),D0 		; do the inversion via hook if
			Bsr 		InvertHook				; there

			Cmp.W		2(A2),D5				; only 1 line?
			Bls.S		@done					; made this unsigned	** <C381/6nov86/MBK> **

			Bsr			PtrToLine				; get current line #
			Move.W		D0,D1					; save it
			Move.W		D5,D0					; offset to look for
			Bsr			GetLine					; get D5 line ptr
			Bsr			PtrToLine				; convert A2 ptr to line #
			AddQ		#1,D1
			Cmp.W		D0,D1					; get the difference
			Beq.S		@LastLine				; no lines inbetween

			Move.W		D0,-(SP)				; save line #
			Exg			D0,D1
			Move.W		teSelRect+bottom(A3),teSelRect+top(A3)
			Bsr			GetLineHites			; hites from 2nd to last lines
			Add.W		D0,teSelRect+bottom(A3)	; hite to last line
			Move.W		#UnboundLeft,teSelRect+left(A3) ; far left
			Move.W		#UnboundRight,teSelRect+right(A3) ; far right

			Move.L		teHiHook(A3),D0
			Bsr			InvertHook				; hilite it
			Move.W		(SP)+,D0				; restore line #

; hilite last line
@LastLine
			Bsr			NextLineRect			; get rectangle for last line	<C971/RWW102887>NO
			Move.W		(A2),D3					; for chkBounds
			Bsr			PrepLine				; get left and right
			Bls.S		@done					; done...

			Bsr			ChkBounds				; check far left and right		<C971/RWW102887>NO

			Move.L		teHiHook(A3),D0 		; do the inversion via hook if
			Bsr 		InvertHook				; there
@done
			Bra 		doBye

;formFeed
;----------------------------------------------------------------------
;
;			OnSameLine
;
;			<12Oct88smb>
;
;			Get the format ordering for the current line containing d3.
;			Hilite appropriately in the style runs containing character 
;			offsets d3 & d4.  Use the format ordering to hilite the 
; 			necessary runs in between the two runs.
;
;			Input:
;				d0 = initial L edge of selection rectangle
;				d1 = initial R edge of selection rectangle
;				d3 = 1st character position to redraw
;				d4 = 2nd character position to redraw
;				d5 = 0; cleared to accumulate widths of style runs
;
;				a0 = ptr to startChar for style of 1st character position
;				a1 = lineStart of current line containing d4
;				a2 = lineStart of current line containing d3
;
;			Output:
;				d5 = pixelWidth of the line, up to the 1st character position
;
;----------------------------------------------------------------------
OnSameLine
			move.l	ExpandMem,a4			; <28June89smb>
			move.l	ExpandMemRec.vOnSameLine(a4),a4
			jmp		(a4)

xOnSameLine

SameLineRegs	reg		d3/d4/d7/a0-a1

			with	SharedFrame,TEFormatOrder
			link	a6,#SharedFrameSz
			movem.l	SameLineRegs,-(sp)

; initialize
			moveq.l	#0,d5						; cleared to accumulate widths of style runs from MeasureWidth and PixelWidths
			moveq.l	#0,d2
			clr.w	totalWidth(a6)
			clr.w	hiliteInbetween(a6)			; set sameStyle and hiliteInbetween to F.
			sf		doneFlag(a6)
			clr.w	foundD4(a6)					; clear D3 and D4 index flag
			clr.l	d4FmtIndex(a6)				; clear D3 and D4 holders
			clr.l	hiliteREndFlag(a6)			; clear left and right end flags

			Move.w	teSelRect+left(A3),selRectL(a6)		; preserve initial L. edge
			Move.w	teSelRect+right(A3),selRectR(a6)	; preserve initial R. edge
			Move.w	selRectL(a6),anchorL(a6)			; initialize L. anchor
			Move.w	selRectR(a6),anchorR(a6)			; initialize R. anchor

; [d3,d4] are on the same line
			tst.w	teSize(a3)
			bpl		@oldStyle					; old style edit record
			
; get style runs for character offsets
			move.w	d3,d0
			bsr		GetCurStyle
; made d3StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!) Oh-Dopey-Me!
			move.l	a0,-(sp)					; save <19Aug89smb>
			move.l	teStylesH(a3),a1			; <19Aug89smb>
			move.l	(a1),a1						; deref <19Aug89smb>
			sub.l	a1,a0						; save posn as an offset <19Aug89smb>
			move.l	a0,d3StyleRun(a6)			; save offset to style run of lineStart
			move.l	(sp)+,a0					; restore for FixFormatEnd call<19Aug89smb>
			
			bsr		FixFormatEnd				; get real end position of run <6Mar89smb>
			cmp.w	d0,d4
			bhi.s	@GetD4Style
; in same style run as d3
; made d4StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!) Oh-Dopey-Me!
			move.l	teStylesH(a3),a1			; <19Aug89smb>
			move.l	(a1),a1						; deref <19Aug89smb>
			sub.l	a1,a0						; save posn as an offset <19Aug89smb>
			move.l	a0,d4StyleRun(a6)			; save as offset
			bra.s	@GetDisplayOrder
@GetD4Style			
			move.w	d4,d0
			bsr		GetCurStyle
			cmp.w	startChar(a0),d4			; is d4 the start of this run? <29June89smb>
			bne.s	@SaveD4StyleRun				; bra if not. the style is correct. <29June89smb>
; Otherwise, want the previous style run since d4 is on a boundary, and it indicates the rightmost
; end of the hilite rectangle. d4StyleRun in this case, should be a pointer to the style run which
; ends w/ d4, not begins w/ d4. GetCurStyle doesn't give us what we need, so fix it! <29June89smb>
			subq.l	#stStartSize,a0
@SaveD4StyleRun
; made d4StyleRun(a6) an offset - can't save the ptr! (the handle's not locked!) Oh-Dopey-Me!
			move.l	teStylesH(a3),a1			; <19Aug89smb>
			move.l	(a1),a1						; deref <19Aug89smb>
			sub.l	a1,a0						; save posn as an offset <19Aug89smb>
			move.l	a0,d4StyleRun(a6)			; save as offset
			
@GetDisplayOrder
			move.w	(a2),d0
			move.w	2(a2),d1
			Bsr		teGetFormatOrder			; <4Jan88smb>
			
; Made d3StyleRun(a6) & d4StyleRun(a6) an offset - can't save the ptr! (unlocked handle!) 
; Get to posn in styleRun array via the Style Handle and saved offset after moving memory
; in teGetFormatOrder <19Aug89smb>
			move.l	teStylesH(a3),a0			; <19Aug89smb>
			move.l	(a0),a0						; deref <19Aug89smb>
			move.l	a0,-(sp)					; <19Aug89smb>
			adda.l	d3StyleRun(a6),a0			; <19Aug89smb>
			move.l	a0,d3StyleRun(a6)			; add in offset to desired posn in the array <19Aug89smb>
			move.l	(sp)+,a0					; <19Aug89smb>
			adda.l	d4StyleRun(a6),a0			; <19Aug89smb>
			move.l	a0,d4StyleRun(a6)			; add in offset to desired posn in the array <19Aug89smb>

; get the format order indexes for the character offsets (could be the same)
@Loop4Indexes
			Bsr		GetNextDisplayStyle			; <22Dec88smb>
			addq	#1,fmtOrderingIndex(a6)		; incr the format ordering array counter			
			SubQ	#1,D2						; dec the style counter
			
; is this the same style run as one of the character offsets?
			cmpa.l	d3StyleRun(a6),a0
			bne.s	@testD4
			move.w	styleRunIndex(a6),d3FmtIndex(a6)
			tst.b	foundD4(a6)
			bne.s	@MeasureNow					; have both offsets' indeces in the fmt array
			st		foundD3(a6)
@testD4
			cmpa.l	d4StyleRun(a6),a0
			bne.s	@Loop4Indexes
			move.w	styleRunIndex(a6),d4FmtIndex(a6)
			tst.b	foundD3(a6)
			bne.s	@MeasureNow					; have both offsets' indeces in the fmt array
			st		foundD4(a6)
			bra.s	@Loop4Indexes

; measure by style runs and highlight where appropriate based on character offsets
; and display ordering of format runs!
@MeasureNow
			move.w	numberOfRuns(a6),d2
			clr.w	fmtOrderingIndex(a6)

; test if [d3,d4] in same style run
			move.w	d3FmtIndex(a6),d0
			cmp.w	d4FmtIndex(a6),d0
			bne.s	@MeasureLoop
			st		sameStyle(a6)
			
@MeasureLoop
			Bsr		GetNextDisplayStyle			; <22Dec88smb>
			Bsr		MeasureWidth
			tst.b	doneFlag(a6)
			bne.s	@hiliteMore
			addq	#1,fmtOrderingIndex(a6)		; incr the format ordering array counter			
			tst.b	WordRedraw					; <4Oct89smb>
			bge.s	@GetNext					; <4Oct89smb>
			SubQ	#1,D2						; dec the style counter
			beq.s	@hiliteMore
			bra.s	@MeasureLoop
			
@GetNext
			Addq.l	#stStartSize,a0				; get next style
			SubQ	#1,D2						; dec the style counter
			bne.s	@MeasureLoop				; must be more than 1 line
			bra.s	@hiliteMore
@oldStyle
; old-style record: one style for the whole record.  My code is expecting a0 to contain a ptr to 
; the startChar for the current style so must fake the setup.
			clr.l	firstStyleRun(a6)			; startChar and style index (both 0)
			clr.w	secondStyleRun(a6)			; startChar of second style run (EO array)
			move.w	teLength(a3),secondStyleRun(a6)
			lea		firstStyleRun(a6),a0
			Bsr		teHiliteText
			
@hiliteMore
; test if there's more to hilite: either more style runs or line ends
						
			tst.b	hiliteInbetween(a6)
			beq.s	@testEnds
			bsr		HiliteMiddle				; hilite any remaining runs inbetween offsets
			sf		hiliteInbetween(a6)
@testEnds			
			tst.b	hiliteLEndFlag(a6)
			beq.s	@testRightEnd
; hilite left end of display line
			move.w	selRectL(a6),teSelRect+right(a3)
			move.w	#UnboundLeft,teSelRect+left(a3)
; top and bottom edges should be the same
			move.l	a0,-(sp)					; <24Jan89smb> save for unstyled text
			Move.L	teHiHook(A3),D0 			; do the inversion via hook if exists
			Bsr		InvertHook					; hilite it
			sf		hiliteLEndFlag(a6)
			move.l	(sp)+,a0					; <24Jan89smb> need for hiliting on right end of unstyled text			
@testRightEnd
			tst.b	hiliteREndFlag(a6)
			beq.s	@finis
; hilite right end of display line
			tst.w	teSize(a3)					; <5Dec88smb>
			bmi.s	@UseAnchor
			bsr		MeasureWholeRun				; need length of line for unstyled <5Dec88smb>
			move.w	d0,teSelRect+left(a3)		; <5Dec88smb>
			bra.s	@addSelRect					; <5Dec88smb>
@UseAnchor
			move.w	anchorR(a6),teSelRect+left(a3) 		; <25Oct88smb>
@addSelRect			
			move.w	selRectL(a6),d0
			add.w	d0,teSelRect+left(a3) 		; <25Oct88smb>
			move.w	#UnboundRight,teSelRect+right(a3)
; top and bottom edges should be the same
			Move.L	teHiHook(A3),D0 		; do the inversion via hook if exists
			Bsr		InvertHook				; hilite it
			sf		hiliteREndFlag(a6)
			
@finis	
			bsr		FreeFmtOrderArray			; <18Jan89smb>	
			movem.l	(sp)+,SameLineRegs
			unlk	a6
			Rts
			endWith

;formFeed
;----------------------------------------------------------------------
;
;			MeasureWidth
;
;			<12Oct88smb>
;
;			Get the width of each style run and hilite when appropriate.
;			We never come in here if we have an old single style teRec!
;
;			Input:
;				d3 = 1st character position to redraw
;				d4 = 2nd character position to redraw
;
;				a0 = ptr to startChar for style of 1st character position
;				a2 = lineStart of current line containing d3
;
;			Output:
;				d5 = pixelWidth of the measured style runs
;
;----------------------------------------------------------------------
MeasureWidth
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vMeasureWidth(a1),a1
			jmp		(a1)

xMeasureWidth

			with	SharedFrame,TEFormatOrder

; is this d3's style run?
			move.w	styleRunIndex(a6),d0
			cmp.w	d3FmtIndex(a6),d0
			beq.s	@MeasureD3Run
			tst.b	sameStyle(a6)
			bne		@justMeasure				; bra if [d3,d4] in same style
			
; is this d4's style run?
			cmp.w	d4FmtIndex(a6),d0
			beq.s	@MeasureD4Run
			blt.s	@inBetween					; bra to check if inbetween d3 & d4 runs
			bra		@justMeasure				; not to be hilited: just measure
			
@MeasureD3Run
; measure [d3,end of style]
			move.w	d3,saveD3(a6)
			move.w	d4,saveD4(a6)
			tst.b	sameStyle(a6)
			bne.s	@TestDirection				; when in RL text may need to measure the rest of the line <25Oct88smb>
			bsr		FixFormatEnd				; <6Mar89smb>
			move.w	d0,d4						; <6Mar89smb>
			bra.s	@dontQuit
			
@MeasureD4Run
; measure [begin of style,d4]
			move.w	d3,saveD3(a6)
			move.w	d4,saveD4(a6)
			move.w	startChar(a0),d3
@TestDirection
			tst.b	teSysJust					; RL line direction (Roman, Kanji or Arabic)? <29Aug89smb>
			bne.s	@dontQuit					; yep, not done at this style run <29Aug89smb>
			tst.b	WordRedraw					; <4Oct89smb
			blt.s	@dontQuit					; <4Oct89smb
			st		doneFlag(a6)				; once hilited d4 
@dontQuit
			tst.b	hiliteInbetween(a6)
			beq.s	@HiliteOffsetRun			; nothing inbetween: just hilite the offset's run
			bsr		HiliteMiddle				; hilite runs prior to offset run, then the offset run
			bra.s	@HiliteOffsetRun
			
@inBetween
; test if style run in between d3 and d4's style runs!
			cmp.w	d3FmtIndex(a6),d0
			bhi.s	@hiliteRun					; bra to be hilited		<26June89smb> made unsigned
			
; not inbetween therefore, only measure. don't hilite
			bsr.s	MeasureWholeRun
			add.w	d0,totalWidth(a6)
			tst.b	hiliteInbetween(a6)
			beq.s	@exit
			bsr		HiliteMiddle				; hilite runs prior to non-hilited run
			move.w	totalWidth(a6),d0
			add.w	d0,anchorL(a6)				; new left anchor
			bra.s	@exit
			
@hiliteRun
; This run is between d3 and d4 and needs to be hilited at some later time.
; Test if this style run contains the lineStart or lineEnd and if so, then must extend the
; highlighting to the screen's edge!
			move.w	startChar(a0),d0			; get the beginning of the style run			
			move.w	stStartSize(a0),d1			; get the end of the style run
			Bsr		HiliteLineEnds				; test and set a flag
			
			tst.b	hiliteInbetween(a6)
			bne.s	@addToAnchor
; new run of runs inbetween d3 and d4 to be hilited
			st		hiliteInbetween(a6)
			move.w	totalWidth(a6),anchorL(a6)	; new left anchor
			move.w	totalWidth(a6),anchorR(a6)	; new right anchor
@addToAnchor			
			bsr.s	MeasureWholeRun
			add.w	d0,totalWidth(a6)			; accumulates the overall width
			add.w	d0,anchorR(a6)				; save for hiliting middle rectangle
			bra.s	@exit
			
@HiliteOffsetRun
; hilite the appropriate part of the offset's style run
			bsr		teHiliteText

			move.w	saveD3(a6),d3
			move.w	saveD4(a6),d4

; measure the length of the style run and add to overall line width 
@justMeasure
			bsr.s	MeasureWholeRun				; add width of style run to total width of line
			add.w	d0,totalWidth(a6)
			move.w	totalWidth(a6),anchorR(a6)	; possible new Left anchor for next hilite region

@exit
			Move.w	totalWidth(a6),d5
			rts
			endWith
			
;formFeed
;----------------------------------------------------------------------
;
;			MeasureWholeRun
;
;			Input:
;				a0:		current style run
;				a2:		lineStart
;				a3:		pointer to TERecord
;
;			Uses: a0/a1/d0/d1
;				a4:		textPtr for textWidth
;
;			Output:
;				d0:		width of style run
;----------------------------------------------------------------------
MeasureWholeRun
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vMeasureWholeRun(a1),a1
			jmp		(a1)

xMeasureWholeRun

WholeRunRegs		reg		d2/a0/a4
			
			movem.l	d2/a0,-(sp)					; 												<27>
			move.l	a4,-(sp)					; separate out so can restore teHandle to a4 before hook call	<27>
			Movea.l	a0,a1						; save beginning posn of current style			
			Move.L	teTextH(A3),A0				; get text handle
			Move.L	(A0),A0 					; dereference
			Add.w	(a1),a0						; add beginning of the style run to get to desired line
			move.l	a0,a4
			movea.l	a1,a0						; restore current style run
			
; If style run starts on previous line, then pin text pointer to start of current line
			moveq	#0,d1						; used to adjust length
			Move.w	(a2),d0						; beginning of line
			cmp.w	startChar(a0),d0
;;<21June89smb>			bcs.s	@getLength					; bra if lineStart is prior to the styleRun start
			bls.s	@getLength					; bra if lineStart is prior or equal to the styleRun start <21June89smb>
			
; Adjust text pointer and length for lineStart within styleRun
			sub.w	startChar(a0),d0			; difference from start of styleRun to lineStart
			add.w	d0,a4						; pin pointer to beginning of line
			move.w	d0,d1						; save for length adjustment below

; If style run ends on next line, then use the current line's end for determining length!
@getLength
			bsr		FixFormatEnd				; <6Mar89smb> returns end of style run in d0
			cmp.w	2(a2),d0					; inside the line's end?
			bls.s	@UseStyleEnd				; <26June89smb> made unsigned
			move.w	2(a2),d0					; use the line's end
@UseStyleEnd
			sub.w	startChar(a0),d0
			sub.w	d1,d0						; adjust for LineStart
			tst.w	teSize(a3)					; <1Dec88smb>
			bpl.s	@DontSet

			movem.l	d0/d1,-(sp)					; SetStyle mucks with this guy - not good!
			bsr		SetStyle					; set grafport style from current style in a0
			movem.l	(sp)+,d0/d1
			
@DontSet
;get PixelWidth of this style on this line
	IF hasTextWidthHook THEN					; 												<18>
			move.l	a4,a0						; wants text ptr here							<18>
			moveq	#0,d1						; wants offset here								<18>
			move.l	(sp)+,a4					; restore teHandle to a4						<27>
			bsr		TETextWidthHook				; hook out TextWidth							<18>
	ELSE										;												<18>
			subq.l	#2,sp						; room for result
			move.l	a4,-(sp)					; ptr on stack
			move.w	#0,-(sp)					; offset to first char
			move.w	d0,-(sp)					; length of block
			_TextWidth							; how wide is it?
			moveq	#0,d0
			move.w	(sp)+,d0					; width
	ENDIF										;												<18>
			movem.l	(sp)+,d2/a0					; already restored a4 before TETextWidthHook call	<27>
			rts
			endWith

;formFeed
;----------------------------------------------------------------------
;
;			HiliteMiddle
;
; 			Hilite measured runs between d3 and d4
;
;			Input:
;				a3:		pointer to teRec
;
;			Uses: d0 (preserved)
;
;----------------------------------------------------------------------
HiliteMiddle
			with 	SharedFrame,TEFormatOrder
			
			movem.l	d0/d2/a0,-(sp)
; do middle rectangle
			move.w	selRectL(a6), teSelRect+left(a3)		; left edge
			move.w	anchorL(a6),d0
			add.w	d0,teSelRect+left(a3)
			move.w	selRectR(a6), teSelRect+right(a3)		; right edge
			move.w	anchorR(a6),d0
			add.w	d0,teSelRect+right(a3)
; top and bottom edges should be the same
			move.l	teHiHook(a3),d0 		; do the inversion via hook if exists
			bsr		InvertHook				; hilite it
			sf		hiliteInbetween(a6)	
			
			movem.l	(sp)+,d0/d2/a0
			Rts
			endWith
			
;formFeed
;----------------------------------------------------------------------
;
;			HiliteLineEnds
;
;
;			This routine tests if the regions to be highlighted on a line
;			should include the visible screen at both ends of the line.
;
;			The visible left end of the displayed line should be hilited if:
;				2(a2) is in a hilited region and TESysJust = RL
;				(a2) is in a hilited region and TESysJust = LR
;			The visible right end of the displayed line should be hilited if:
;				2(a2) is in a hilited region and TESysJust = LR
;				(a2) is in a hilited region and TESysJust = RL
;
;			Input
;				a2 = ptr to lineStart of current line
;				d0 = beginning of region to be highlighted
;				d1 = end of region to be highlighted
;
;----------------------------------------------------------------------
HiliteLineEnds
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vHiliteLineEnds(a1),a1
			jmp		(a1)

xHiliteLineEnds

			with 	SharedFrame,TEFormatOrder
			
; test if ends of line should be highlighted
; test line start
			cmp.w		(a2),d0
			bhi.s		@testLineEnd			; bra if outside region to be highlighted	<26June89smb> made unsigned
			cmp.w		(a2),d1
			bcs.s		@testLineEnd			; bra if outside region to be highlighted
			tst.b		TESysJust				; beginning of line: hilite to display's edge	<26June89smb> made unsigned
			bne.s		@lineStartIn
			st			hiliteLEndFlag(a6)		; left rect should be highlighted for LR flow
			bra.s		@testLineEnd
@lineStartIn
			st			hiliteREndFlag(a6)		; right rect should be highlighted for RL flow
			
@testLineEnd
; test line end
			cmp.w		2(a2),d0
			bhi.s		@done					; <26June89smb> made unsigned
			cmp.w		2(a2),d1
			bcs.s		@done					; bra if outside region to be highlighted	<26June89smb> made unsigned
			tst.b		TESysJust
			bne.s		@lineEndIn
			st			hiliteREndFlag(a6)		; left rect should be highlighted for LR flow
			bra.s		@done
@lineEndIn
			st			hiliteLEndFlag(a6)		; right rect should be highlighted for RL flow

@done
			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			teHiliteText
;
;			<27Sept88smb>
;
; 			Setup for and call to HiliteText (which works on a single format
;			run). Returns offsets within a format run of character positions 
;			for highlighting.
;
;			Identify runs of characters for highlighting between d3 & d4.
;
;		Entry:
;			d3 = 1st char posn to measure from
;			d4 = 2nd char posn to measure to
;			a0 = ptr to current style
;			a2 = lineStart array
;		Use:
;			d0,d1 = scratch
;			a4 = ptr to offsetPairs address, to be returned from HiliteText
;		Exit:
;			registers preserved from entry but, the offsetPairs values (ptr in a4)
;			have been filled in.
;
;----------------------------------------------------------------------
teHiliteText

HiliteTxtRegs		reg		d2-d4/a0/a1	

			with	SharedFrame,TEFormatOrder
			tst.w	teSize(A3)				; check style flag
			bpl.S	@DontSet				; don't set style: old-style edit record
			bsr		SetStyle				; set grafport style from current style in a0
@DontSet
											; call HiliteText (which works on a single fmt run) on [d3,d4]
			move.l	a4,-(sp)				; preserve <22Dec88smb>
			Lea		offPairs(a6),a4
			Movem.L	HiliteTxtRegs,-(SP)

; the textPtr will be the beginning of the style run, and the offsets will be the distance from
; d3 and d4 to the start of the style run.
			Movea.l	a0,a1					; temp			
			Move.L	teTextH(A3),A0			; get text handle
			Move.L	(A0),A0 				; dereference
			Add.w	(a1),a0					; add beginning of the style run to get to desired line
			
; test if style run starts on previous line, and if so adjust textptr <5Dec88smb>
			moveq	#0,d1
			move.w	(a2),d0					; linestart
			cmp.w	startChar(a1),d0
			bls.s	@UseStyleStart			; <26June89smb> made unsigned
			
; pin to beginning of line <5Dec88smb>
			sub.w	startChar(a1),d0		; |beginning of line - beginning of style run|
			add.w	d0,a0					; fix text ptr
			move.w	d0,d1					; save difference for length and offset adjustments
@UseStyleStart
			move.l	a0,-(sp)				; push text ptr parameter for _HiliteText

; test if style run ends on next line, and if so pin to end of this line & adjust length <5Dec88smb>
			move.l	a0,-(sp)				; <6Mar89smb>
			move.l	a1,a0					; <6Mar89smb>
			bsr		FixFormatEnd			; <6Mar89smb> returns in d0
			move.l	(sp)+,a0				; <6Mar89smb>
			cmp.w	2(a2),d0
			bls.s	@UseStyleEnd			; <26June89smb> made unsigned
			move.w	2(a2),d0				; pin to line end
@UseStyleEnd
			sub.w	startChar(a1),d0 		; text length is overall style run length
			sub.w	d1,d0					; adjust for lineStart
			move.w	d0,-(sp)
						
			sub.w	startChar(a1),d3		; 1st offset within style run
			sub.w	d1,d3					; adjust for lineStart
			move.w	d3,-(sp)
			
			sub.w	startChar(a1),d4		; 2nd offset within style run
			sub.w	d1,d4					; adjust for lineStart
			move.w	d4,-(sp)

			move.l	a4,-(sp)				; var offsets record
			_HiliteText

			Movem.L	(sp)+,HiliteTxtRegs
			
; HiliteText returns 3 pairs of possibly disjoint char offsets within a style run for highlighting.

			moveq	#2,d7					; set up dbra:counter for OffsetTable pairs
@tblLoop
			move.w	(a4)+,d0				; get offset1 of pair
			move.w	(a4)+,d1				; get offset2 of pair
			cmp.w	d0,d1					; equal?
			beq.s	@nxtPair				; yes,skip: pair is empty

; process a pair from HiLiteText
			Move.l	a4,-(sp)				; preserve pairs counter and offset pairs
; want to restore a4 to contain the teHandle													<27>
			move.l	4(sp),a4				; teHandle on the stack								<27>
			Bsr.s	xInvrtRectangle			; skip the vector to avoid wiping out a4!			<27>
			Move.l	(sp)+,a4
			
@nxtPair
			dbra	d7,@tblLoop				; loop thru record
			move.l	(sp)+,a4				; restore original value <22Dec88smb>			
			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			InvrtRectangle
;			<21June88smb>
;
;			Calls Char2Pixel to get the pixel widths for the left and right
;			side of a rectangle needing highlighting, finishes setting
;			up the rectangle and inverts it. Makes Char2Pixel calls for each
;			element of pair.
;
;			Input
;				a0 = ptr to beginning of current style run
;				a2 = lineStart of current line
;
;				d0 = 1st offset position within current style run
;				d1 = 2nd offset position within current style run
;				d5 = pixel width from MeasureAndHilite routine
;
;			Register Usage:
;				d5 = pixel width of 1st character in pair
;				d6 = pixel width of 2nd character in pair
;
;			Output
;				a0,d0,d1,d2 preserved
;				d5 = incremented by last pixel width: total width of line so far
;
;----------------------------------------------------------------------
InvrtRectangle
			move.l		ExpandMem,a4			; <28June89smb> use it since already saved!
			move.l		ExpandMemRec.vInvrtRectangle(a4),a4
			jmp			(a4)

xInvrtRectangle

InvrtRectRegs		reg		d0/d1/a0/a1
			with SharedFrame,TEFormatOrder
			Move.w		d2,-(sp)			
;; moved below since saved in PixelWidths <5Dec89smb>			Movem.l		InvrtRectRegs,-(sp)
			Move.w		d5,-(sp)				; save pixel width from MeasureAndHilite routine
			
			move.w		#smHilite,d2			; 1st offset's direction param
			swap		d2
			move.w		#smHilite,d2			; 2nd offset's direction param
			Bsr.s		PixelWidths				; Calls Char2Pixel for each element of hilite pair
 												; returns pixelwidths of both elements in d5 & d6

; Check pixel widths for stroke direction.

			cmp.w		d5,d6					; which is true left/right edge of rectangle
			bcs.s		@rightLeft				; bra if right-left text

			add.w		selRectR(a6),d5			; need dest rect right edge added on		
			add.w		(sp),d5					; add pixel width of previous runs on line
			add.w		selRectR(a6),d6			; need dest rect right edge added on
			add.w		(sp),d6					; add pixel width of previous runs on line
			bra.s		@edgesOK
			
@rightLeft
; right to left
			add.w		selRectL(a6),d5			; need dest rect left edge added on
			add.w		(sp),d5					; add pixel width of previous runs on line
			add.w		selRectL(a6),d6			; need dest rect left edge added on
			add.w		(sp),d6					; add pixel width of previous runs on line
			exg			d5,d6					; swap for R-L text. 

@edgesOK										; call InvertRect on pair (set up selRect)
			Movem.l		InvrtRectRegs,-(sp)		; <5Dec89smb>
			move.w		d5,teSelRect+left(A3)	; left edge of rectangle
			move.w		d6,teSelRect+right(A3)	; right
			
			Move.L		teHiHook(A3),D0 		; do the inversion via hook if exists
			Bsr			InvertHook				; hilite it
			
			Movem.l		(sp)+,InvrtRectRegs
			Move.w		(sp)+,d5				; restore pixel width from MeasureAndHilite routine		

; Test whether should also hilite visible (screen) line start and end.  Must first determine 
; whether style run should be pinned to the start of the line.
			move.w		(a2),d2					; <22Dec88smb>
			cmp.w		startChar(a0),d2		; <22Dec88smb>
			bls.s		@UseStyleStart			; <22Dec88smb>		<26June89smb> made unsigned
; pin to lineStart to get buffer position of offsets
			add.w		d2,d0					; <22Dec88smb>
			add.w		d2,d1					; <22Dec88smb>
			bra.s		@TestEnds
@UseStyleStart
			add.w		startChar(a0),d0		; buffer position of 1st offset in line
			add.w		startChar(a0),d1		; buffer position of 2nd offset in line
@TestEnds
			cmp.w		d0,d1					; <5Dec89smb>
			bcc.s		@OffsetsOK				; <5Dec89smb>
			exg			d0,d1					; swap for R-L text <5Dec89smb>
@OffsetsOK
	IF hasInlineInput THEN						; 										<16>
; if inline input is on then don't hilite to the end of the selRect! 					<16>
			movem.l		a0/d2,-(sp)				; must preserve							<16>
			move.l		teDispatchH(a3),a0		;										<16>
			move.l		(a0),a0					;										<16>
			move.l		newTEFlags(a0),d2		; move into reg for modulo 32 bit ops	<16>
			btst		#teFInlineInput,d2		; is this Inline Input feature desired?	<16>
			movem.l		(sp)+,a0/d2				; restore now							<16>
			bne.s		@NoLineEnds				; yes, so don't hilite line ends!		<16>
	ENDIF										; 										<16>			
			Bsr			HiliteLineEnds
@NoLineEnds										;										<16>
			Move.w		(sp)+,d2
			
			Rts
			
;formFeed
;----------------------------------------------------------------------		
;
;			PixelWidths
;
;			Setup for and call to Char2Pixel
;
;			Input
;			a0 = ptr to beginning of current style run
;			a2 = LineStart of current line
;
;			d0 = offset of 1st element of hilite pair in style run
;			d1 = offset of 2nd element of hilite pair in style run
;			d2.l = direction params for C2P for both offsets (second offset/first offset: High/Low)
;
;			Output
;			d5 = pixel width from start of run to 1st element.
;			d6 = pixel width from start of run to 2nd element.
;
;			-------------------------------
; 			Need to set up...
; 			a0 = start of text to be measured
;			a4 = direction values and teHandle!												<27>
; 			d0 = overall style run length
; 			d1 = length from start of measured text to end
; 			d2 = slop & highlight
;			-------------------------------
;----------------------------------------------------------------------
PixelWidths
			move.l		ExpandMem,a1			; <28June89smb>
			move.l		ExpandMemRec.vPixelWidths(a1),a1
			jmp			(a1)
			
xPixelWidths

; remove a4 from these lists of registers													<27>
PixelWidthRegs		reg		d0-d4/a0-a2			;											<27>
C2Pparams			reg		d0/a0/a1			; length, direction, textPtr, styleRunPtr	<27>

			Movem.l		PixelWidthRegs,-(sp)
			move.l		a4,-(sp)				; save the teHandle							<27>
			move.l		ExpandMem,a4			; <1Feb89smb>
			move.l		d2,ExpandMemRec.emDirection(a4)		; <27Oct88smb> direction for both offsets passed in 

			Movea.l		a0,a1					; save beginning posn of current style			
			Move.L		teTextH(a3),a0			; get text handle
			Move.L		(a0),A0 				; dereference
			Add.w		(a1),a0					; add beginning of the style run to get to desired line

; 1st offset's width
			move.w		d1,-(sp)				; save 2nd offset
; test if style run starts on previous line, and if so adjust textptr & offset posn in run
			move.w		d0,d1					; Char2Pixel wants the start offset here

			moveq		#0,d4
			move.w		(a2),d0					; linestart
			cmp.w		startChar(a1),d0
			bls.s		@getLength				; bra if so => offset is ok		<26June89smb> made unsigned
			
; pin to beginning of this line			 
			sub.w		startChar(a1),d0		; |begin of line - begin of the style run|
			add.w		d0,a0					; fix text ptr
			move.w		d0,d4					; save difference for length adjustment
@getLength
; test if style run ends on next line, and if so pin to end of this line & adjust length
			move.l		a0,-(sp)				; <6Mar89smb>
			move.l		a1,a0					; <6Mar89smb>
			bsr			FixFormatEnd			; <6Mar89smb> returns in d0
			move.l		(sp)+,a0				; <6Mar89smb>
			move.w		teLength(a3),d2			; 								<11>
			cmp.w		(a2),d2					; at the end of the text?		<11>
			beq.s		@UseStyleEnd			; yes -> use style end			<11>
			cmp.w		2(a2),d0				; style contained in the line?
			bls.s		@UseStyleEnd			; yes -> use style end.
			move.w		2(a2),d0				; pin to end of line.
@UseStyleEnd
			sub.w		startChar(a1),d0 		; Char2Pixel wants the length here
			sub.w		d4,d0					; adjust for lineStart
			
			clr.l		d2						; <27Oct88smb>
			move.l		ExpandMem,a4			; <1Feb89smb>
			lea			ExpandMemRec.emDirection(a4),a4		; changed to lea <12July89smb>
			move.w		(a4)+,d2				; <27Oct88smb>
			swap		d2						; 1st offset's direction in high word; slop in low

			move.l		a4,-(sp)				; save direction values						<27>
			move.l		6(sp),a4				; restore teHandle to a4					<27>
			movem.l		C2Pparams,-(sp)			; save to be used again
			bsr			TEWidthHook
			move.w		d1,d5					; 1st element's pixel width
			
; 2nd offset's width
; restore params: length, direction, textPtr, styleRunPtr, direction locale
			movem.l		(sp)+,C2Pparams
			move.l		(sp)+,a4				; restore direction values					<27>
			move.w		(sp)+,d1				; restore offset2
									
			clr.l		d2						; <7Nov88smb>
			move.w		(a4),d2					; <27Oct88smb>
			swap		d2						; 2nd offset's direction in high word; slop in low
						
			move.l		(sp)+,a4				; restore teHandle							<27>
			bsr			TEWidthHook
			move.w		d1,d6					; 2nd element's pixel width

			movem.l		(sp)+,PixelWidthRegs
			Rts		

;formFeed
;----------------------------------------------------------------------
;
;			ChkBounds
;
;			** <C139/22Sep86/MBK> Added for International **
;
;			The left and right sides of the selection rectangle are
;			extended if the line start = the selection start and the
;			line end = the selection end, respectively.
;
;	Entry:
;			d3	start offset
;			d4	end offset
;			a2	ptr to the current line
;   Output
;			teSelRect
;
;----------------------------------------------------------------------

ChkBounds
			with		TextFrame,TEFormatOrder		; <16Nov88smb> for GetStyleInOrder call
			Move.W		(A2),D0					; start of line
			Move.W		2(A2),D1				; end of line
 useBounds:	equ	0
 IF useBounds THEN
; <7Dec89smb>			
			Tst.W		teSize(A3)				; record with style?
			Bpl.s		@TestLineStart			; skip ahead if not
			
			Tst.W		TESysJust				; reverse order?
			Beq.s		@TestLineStart			; this is easy if not
			
; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
			bge.s		@getStyleOld			; nope, only L->R directional text

; mixed directional text
			bsr			GetStylesInOrder 		; <15Nov88smb>
			beq.s		@OneStyle		 		; <15Nov88smb>

			Subq		#1,D2					; dec style count
			move.w		d2,fmtOrderingIndex(a6)	; set to next-to-last style
			move.l		a0,-(sp)				; save style ptr at start
			
; more than 1 style in mixed directional text, so get the first and next-to-last
; styles using the results from getFormatOrder			
			bsr			GetNextDisplayStyle		; <4Jan89smb>			
			Move.W		startChar(a0),D1		; start of next-to-last style
			move.l		(sp)+,a0				; restore style ptr at start
			bra.s		@CmpStarts

; only L->R text			
@getStyleOld
			Bsr			GetCurStyle				; get its style	<7Oct88smb>
			Bsr			GetNumStyles			; # of styles between offsets <7Oct88smb>
			SubQ		#1,D0					; look for end of last style
			Bne.S		@ManyStyles

; Reset start and end of line if only 1 style
@OneStyle
			Move.W		(A2),D0					; reset start of line
			Move.W		2(A2),D1				; end of line
			Bra.S		@TestLineStart

; more than 1 style in L->R directional text, so find actual start and end line offsets
@ManyStyles
			SubQ		#1,D0					; dec style count
			LsL.W		#2,D0					; * stStartSize				** <C381/6nov86/MBK> **
			Neg			D0						; negative for subtraction

			Move.W		startChar(A0,D0),D1		; start of next-to-last style
@CmpStarts
			Move.W		(A2),D0					; get start of line again
			Cmp.W		startChar(A0),D0		; compare to start of style
			Bhs.S		@TestLineStart			; made this unsigned	** <C381/6nov86/MBK> **

			Move.W		startChar(A0),D0		; else set to style start
 ENDIF
; if block begins at start of line, make left a large negative number
; <7Dec89smb>	Tried to fix boundaries for tesysjust conditions
@TestLineStart
			Cmp.W		D0,D3
			Bne.S		@TestLineEnd
			tst.w		teSysJust
			bne.s		@FixRightBoundAtStart
			Move.W		#UnboundLeft,teSelRect+left(A3)	; assume LR text
			bra.s		@TestLineEnd
@FixRightBoundAtStart
			Move.W		#UnboundRight,teSelRect+right(A3)
			
; if block ends at end of line, make right a large positive number
@TestLineEnd
			Cmp.W		D1,D4
			Bne.S		@EdgesSet
			tst.w		teSysJust
			bne.s		@FixLeftBoundAtEnd
			Move.W		#UnboundRight,teSelRect+right(A3)
			bra.s		@EdgesSet
@FixLeftBoundAtEnd
			Move.W		#UnboundLeft,teSelRect+left(A3)	; assume LR text
			
@EdgesSet
;;<7Dec89smb>			bsr			FreeFmtOrderArray			; <18Jan89smb>		
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			NextLineRect
;
;			** <C105/14aug86/MBK> Added to speed things up **
;
;			LineRect was being called from the line drawing loop in
;			DoDraw, and adding up line heights from the 1st line to the
;			current one.  That was fine for fixed line heights, but too
;			slow for variable ones.  Now I call NextLineRect from the
;			loop to simply set the top of this line from the bottom of
;			the previous one, and get the height of this line only to
;			Set the bottom.  NextLineRect also calls DoJust to set
;			the justification.
;
;	Entry:
;			D0:		Current line #
;	Exit:
;			A2:		Ptr to current line #
;
;----------------------------------------------------------------------

NextLineRect
			Move.W		teSelRect+bottom(A3),teSelRect+top(A3)
			Bsr			GetHite					; get height of this line
			Add.W		D1,teSelRect+bottom(A3)	; adjust bottom

; ** <C381/5nov86/MBK> ** Replaced call to LineToPtr with these 2 lines
;							since noone else called it
			Add.W		D0,D0					; double for word entries	** <C381/5nov86/MBK> **
			Lea			teLines(A3,D0),A2		; pt to line starts array	** <C381/5nov86/MBK> **

			Move.W		teDestRect+left(A3),teSelRect+left(A3)
			Bsr.S		DoJust					; set the justification			<C971/RWW102887>NO

			Rts


;----------------------------------------------------------------------
;
;			PtrToLine
;
;			** <C105/14aug86/MBK> **
;
;			Get the line # from the A2 value.
;
;	Entry:
;			A2:		Ptr to current line #
;	Exit:
;			D0:		Current line #
;
;----------------------------------------------------------------------

PtrToLine
			Lea			teLines(A3),A0			; pt to line starts array
			Move.L		A2,D0					; current line ptr
			Sub.L		A0,D0					; current line offset
			AsR.L		#1,D0					; current line number

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			LineRect
;
;			** Modified 6/18/86 by MBK **
;
;			Given the line start array in A2, this fills in the rLine(A6)
;			With the rectangle for that line except that right = left.
;			It adjusts the rect for the current format.
;
;----------------------------------------------------------------------

LineRect
			Bsr.S		PtrToLine				; line # from A2 returned in d0	<C971/RWW102887>NO

			Move.W		D0,D1					; save current line #
			MoveQ		#0,D0					; from 0 to this line	** MBK 6/18/86 **
			Bsr.S		GetLineHites			; total height from 0->d1 returned in d0<C971/RWW102887>NO

			Lea 		teDestRect+8(A3),A0 	; point past destRect
			Lea 		teSelRect+8(A3),A1		; and past stack rect
			Move.L		-(A0),-(A1)				; copying teDestRect to teSelRect
			Move.L		-(A0),-(A1)				; copying teDestRect to teSelRect
			Add 		D0,(A1) 				; add total height to top to get
												; top bound of line rect

			Move		top(A1),bottom(A1)		; temporarily the same
			Move.W		D1,D0					; current line			** MBK 6/18/86 **
			Bsr			GetHite					; height of this line returned in d1	** MBK 6/18/86 **
			Add 		D1,bottom(A1)			; add line height to get bottom bound of line rect

; now offset to right according to the format

; ** <C105/12aug86/MBK> ** Added the DoJust label for just doing justification
DoJust
; ** <C229/28oct86/MBK> ** Changed to save justification on stack instead of in D2
			Move.W		teJust(A3),-(SP)		; get justification		** <C105/12aug86/MBK> **
			Bne.S		@NotLeftJust			; go process if not left** <C105/12aug86/MBK> **

			Move.W		TESysJust,(SP)			; check text direction	** <C105/12aug86/MBK> **
			Beq.S		@LRFLow					; do nothing if left->right text direction

@NotLeftJust
			Cmp.W		#teForceLeft,(SP)
			Beq.S		@LRFLow

			Bsr			LineWidth				; get width of (A2) line in D0

			Move		teDestRect+right(A3),D1
			Sub 		teDestRect+left(A3),D1
			Sub 		D0,D1
			SubQ		#1,D1					; subtract one for caret

			Tst.W		(SP)					; see what format
			Bmi.S		@RLFlow					; bra if right->left text direction
			
			AsR 		#1,D1					; div by 2 for centering
@RLFlow
			Add 		D1,teSelRect+left(A3)	; bump rect over
@LRFLow
			AddQ		#1,teSelRect+left(A3)	; indent for caret
			Move		teSelRect+left(A3),teSelRect+right(A3)
			Move.W		teSelRect+left(A3),saveJust(A6)	; left just		** <C105/18aug86/MBK> **

			AddQ.L		#2,SP					; restore it			** <C105/12aug86/MBK> **

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetLineHites
;			** Added 6/3/86 by MBK **
;
;			Gets the line height of each line from start to end line and
;			returns the total of all the line heights.  If teLineHite
;			has a non-zero value, a fixed line height is used
;			for each line. Otherwise, GetLineHites gets the line height
;			for each line from the MaxHites array.
;
;	Entry:
;			D0 	starting line #
;			D1 	ending line #		(Preserved)
;
;	Exit:
;			D0 	total distance in pixels from top of start line to top of
;				End line
;
;----------------------------------------------------------------------
GetLineHites
			MoveM.L		D1-D2,-(SP)				; save stuff

; If this TERec has no style, just use the old teLineHite
			Sub.W		D0,D1					; get # of lines
			Beq.S		@0						; if none, skip this

			Move.W		teLineHite(A3),D2		; get default line hite
; If lineHite is positive, use it no matter what type of TERec.
			Bpl.S		@0

			Tst.W		teSize(A3)				; check style flag
			Bmi.S		@1						; if not, use TERec value

; somebody set the default, so use fixed line height for all lines
@0			MulU		D1,D2					; * fixed line height
			Bra.S		@3						; that was easy!				<C971/RWW102887>NO

; Get maximum height on this line from the array
@1			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; dereference
			Move.L		lhTab(A0),A0			; handle to max hites
			Move.L		(A0),A0					; dereference
			LsL.W		#2,D0					; multiply by 4
			AddA.W		D0,A0					; starting line
			MoveQ		#0,D2					; line height accumulator

@2			Move.W		(A0),D0					; get line height		** <C105/28aug86/MBK> **
			And.W		#$7FFF,D0				; mask out high bit		** <C105/28aug86/MBK> **
			Add.W		D0,D2					; accumulate heights
			AddQ		#4,A0					; point to next
			SubQ		#1,D1					; dec the counter
			Bne.S		@2						; keep accumulating

@3			Move.L		D2,D0					; answer in D0
			MoveM.L		(SP)+,D1-D2				; restore stuff

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetHite
;
;			** Added 6/16/86 by MBK **
;
;			Gets the line height of the given line.
;
;	Entry:
;			D0 	line number
;	Exit:
;			D1 	height of this line
;
;----------------------------------------------------------------------
GetHite
; If this TERec has no style, just use the old teLineHite
			Move.W		teLineHite(A3),D1		; get default line height
			Bpl.S		@0						; use it if set			** <C381/5nov86/MBK> **
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; if not, use TERec value

; Get maximum height on this line from the array
			Move.L		teStylesH(A3),A0		; handle to style info	** <C381/5nov86/MBK> **
			Move.L		(A0),A0					; dereference			** <C381/5nov86/MBK> **
			Move.L		lhTab(A0),A0			; handle to max hites	** <C381/5nov86/MBK> **
			Move.L		(A0),A0					; dereference
			Move.W		D0,D1					; preserve D0			** <C381/5nov86/MBK> **
			LsL.W		#2,D1					; for 2 word entries	** <C381/5nov86/MBK> **
			Move.W		0(A0,D1),D1				; get height			** <C381/5nov86/MBK> **
			And.W		#$7FFF,D1				; mask out high bit		** <C105/28aug86/MBK> **


@0			Rts

;formFeed
;----------------------------------------------------------------------
;
;			LineWidth
;
;			Measures the width of the line at (A2)..2(A2).  Trims break chars
;			from the right side.  Called from LineRect.
;
;	 Entry
;			A2 = ptr to lineStart array
;			A3 = dereferenced handle to TE object
;
;	 Exit
;			leaves the width in D0
;
;----------------------------------------------------------------------
LineWidth
			move	(a2),d6 				; get lineStart as anchor
			move	2(a2),d7				; get line end as the other anchor
			move.l	ExpandMem,a0			; <1Feb89smb>
			st		ExpandMemRec.emMeasureLine(a0)		; mark it for later measuring: measure whole line

MeasD6D7
			Move.l	TETrimMeasure,-(SP) 	; push trimMeasure routine			<EHB 01Oct85>
			Rts 							; and call it						<EHB 01Oct85>

XTrimMeasure
;----------------------------------------------------------------------
;;<2Aug89smb>			tst.b	WordRedraw				; <18Jan89smb>
;;<2Aug89smb>			bmi.s	MeasureIt				; <18Jan89smb> don't use for RL text
; If a Roman system then use old TrimMeasure code rather than SMgr VisibleLength <2Aug89smb>
;;<31Oct89smb>			tst.b	teSysJust
;;<31Oct89smb>			bne.s	@VisLen					; use VisibleLength for RL line direction
			
;----------------------------------------------------------------------
; added <1Nov89smb>
; We need to strip off trailing spaces IF they are trailing in display order (on the L. in a
; R-L line and on the R. in a L-R line.)
; if the line direction = teJust (corrected for teSysJust), then go directly to MeasureIt.
; if teJust = teJustCenter OR teJust = teJustLeft, skip

			cmp 	d6,d7					; nothing to measure? <31Oct89smb>
			bls		zeroExit				; <31Oct89smb>
			move.w	teJust(a3),d0			; <31Oct89smb>
			bge		MeasureIt				; <31Oct89smb>
; if teJust = teSysJust, skip
			cmp.w	teSysJust,d0			; <31Oct89smb>
			beq		MeasureIt				; <31Oct89smb> implies teSysJust = RL
; ow, the line direction = LR and teJust = right
; OR (!!!) teJust = force left (the line direction = RL/LR) (!!!!!) new comment <10/10/90smb>
			tst.b	WordRedraw				; test if Arabic installed w/ line direction LR
			beq		@RomanTrim				; bra for Roman

;----------------------------------------------------------------------
; added <1Nov89smb>
; Adding call to GetStylesInOrder in order to call VisibleLength for a line's style runs.
; We need to traverse the style runs in display order but backwards! This is because it's 
; possible to have style runs at the end of a line containing only blanks (silly but true!)
			with	TextFrame,TEFormatOrder
			move.l	d5,-(sp)
			clr.w	d5						; flag that signifies we are done w/ VisibleLength
			move.w	d6,-(sp)				; save original lineStart
			tst.w	teSize(a3)				; do something different for unstyled! <7Nov89smb>
			bmi.s	@GetStyles				; bra if styled edit record
			
; old-style record: one style for the whole record.  My code is expecting a0 to contain a ptr to 
; the startChar for the current style so must fake the setup.
			clr.l	firstStyleRun(a6)
			clr.l	secondStyleRun(a6)
			move.w	teLength(a3),secondStyleRun(a6)
			lea		firstStyleRun(a6),a0
			move.l	a0,a2StyleRun(a6)		; save style run of lineStart as a ptr 
;;<16Nov89smb>			move.w	#1,d2
;;<16Nov89smb>			move.w	d2,numberOfRuns(a6)		; save
; cleared since don't need to go thru initial @styleLoop code. <16Nov89smb>
			clr.w	d2						;<16Nov89smb>
			clr.w	numberOfRuns(a6)		;<16Nov89smb>

			lea.l	fmtOrdering(a6),a1
			move.l	a1,fmtOrderingPtr(a6)
;;<16Nov89smb>			move.w	#1,fmtOrderingIndex(a6)	; decrement below @styleLoop
			clr.w	fmtOrderingIndex(a6)	;<16Nov89smb>
			clr.w	(a1)
;;<16Nov89smb>			bra.s	@styleLoop	
			bra.s	@UnStyled				;<16Nov89smb>
			
@GetStyles
			move.w	d6,d0					; start of selection
			move.w	d7,d1					; end of selection
			bsr		teGetFormatOrder		

			move.w	numberOfRuns(a6),d2
			move.w	d2,fmtOrderingIndex(a6)	; start w/ the last style run
;----------------------------------------------------------------------
@styleLoop
			subq	#1,fmtOrderingIndex(a6)	; decr the style run counter			
			bsr		GetNextDisplayStyle		
			subq	#1,d2					; dec the style counter

;;<16Nov89smb>			tst.w	teSize(a3)				; record with style?
;;<16Nov89smb>			bpl.s	@UnStyled				; if not, go do it the old way
			bsr		SetStyle				; set current style
@UnStyled
; If we've already found the first (or visibly last) non-blank style run on the line, the flag
; will be set and we need to loop to determine if this is the greatest style run offset.
			tst.b	d5
			bne.s	@GetStyleEnd				; yep
; must be blanks on the line end
;----------------------------------------------------------------------
; call VisibleLength to correctly determine the text to measure
			movem.l	d2/a0/a2,-(sp)
; pin to style run boundaries
			move.w	startChar(a0),d6
			bsr		FixFormatEnd			; if last format run, must decrement end offset

			move.l	teTextH(a3),a0			; get text handle
			move.l	(a0),a0 				; dereference

			add.w	d6,a0					; set to LineStart
			sub.w	d6,d0	
			clr.l	-(sp)					; longint return
			move.l	a0,-(sp)				; textPtr
			swap	d0						; clear high word
			clr.w	d0
			swap	d0
			move.l	d0,-(sp)				; textLen
			_VisibleLength
			
			move.l	(sp)+,d7				; length of visible text
			movem.l	(sp)+,d2/a0/a2
			beq.s	@LoopExit				; if all blanks, keep looping
;----------------------------------------------------------------------
			add.w	d6,d7					; non-blank => done; get real position
; set flag in high word saying done w/ VisibleLength
			st		d5 
@GetStyleEnd
; Once we encounter a non-blank style run, we need to loop through all the previous style runs
; on the line, searching for the largest end offset that is larger then the VisibleLength offset.
; Get the maximum of the style run's end offset and the visibleLength offset.
; per Mark Davis. I'm a believer now! <6Dec89smb>
; d7 = visibleLength initially; is replaced by the end offset of a style run which is larger.
; a0 = ptr to current style run
			bsr		FixFormatEnd			; if last format run, must decrement end offset
			cmp.w	d0,d7
			bge.s	@LoopExit				; VisibleLength is the larger, keep looping
			move.w	d0,d7					; prev style run is max.
;----------------------------------------------------------------------
; if all blanks, keep looping
@LoopExit
			tst.w	d2						; more styles?<1Nov89smb>
			bne.s	@styleLoop				; yes, loop again
			move.w	(sp)+,d6				; restore original lineStart 
			move.l	(sp)+,d5
			bra.s	MeasureIt				; if all blanks on this line, will terminate in MeasureIt
;----------------------------------------------------------------------
; <2Aug89smb>	end of VisibleLength changes
@RomanTrim
			Cmp 	teLength(A3),D6 		; are we past last char?
			Beq.s	zeroExit				; escape quick					<C971/RWW102887>NO

			Cmp 	D6,D7					; is line empty?
			Bls.s	zeroExit				; if so, skip trimming(fast exit)<C971/RWW102887>NO

			Move.L	teTextH(A3),A0			; get text handle
			Move.L	(A0),A0 				; dereference

@TrimLoop
			SubQ	#1,D7					; look to left
			Cmp 	D6,D7
			Beq.S	@LoopXit				; assume done if = to left

			Cmp.B	#$20,0(A0,D7) 			; if last char <= space then...
			Bls.S	@TrimLoop				; it's a break

@LoopXit
			AddQ	#1,D7					; use next char

			; fall into MeasureIt			; get width in [D6 to D7)

;formFeed
;----------------------------------------------------------------------
;
;			MeasureIt
;
;			** Rewritten 6/20/86 by MBK **
;
;	 Entry
;			A3 = dereferenced handle to TE object
;			Does a TextWidth for teTextH(A3), [D6 to D7]
;	 Exit
;			leaves the width in D0
;
;----------------------------------------------------------------------
MeasureIt
	IF forLocalizability THEN					; <31l-YDS-8/27/91>
			tst.b		WordRedraw				; have L->R script ?
			blt.s		@1						; yes, allow measure of zero char strings (skip zeroExit)
	ENDIF
			Cmp 		D6,D7					; nothing to measure?
			Bls.S		zeroExit				;								<C971/RWW102887>NO

@1			MoveM.L		D2/D4/D6,-(SP)			; save stuff
			And.L		lo16,D6 				; longize it

; Skip all the new stuff if style is not set
			Tst.W		teSize(A3)				; record with style?
			Bmi.S		@Styled					; if not, go do it the old way
; unstyled text
			Move.W		D7,D0					; End offset
			Bsr.S		GetWidth				; Get string width				<C971/RWW102887>NO
			Move.W		D1,D0					; Return width in D0
			Bra.S		@done

@Styled
; Record does have style; get # of styles within selection
			MoveQ		#0,D4					; Clear accumulator
			Move.W		D6,D0					; start of selection
			Bsr			GetCurStyle				; get current style
			Move.W		D7,D1					; end of selection
			Bsr			GetNumStyles			; # of styles in selection
			Move.W		D0,D2					; save # of styles

@styleLoop
; Set the GrafPort to the current style
			Bsr			SetStyle				; set current style
			bsr			FixFormatEnd			; <19June89smb> if last format run, must decrement
			AddQ		#stStartSize,A0			; pt to next style

; Get the width of this selection  <27June88smb>
; At this point, d0 = start of next style run  <20June89smb>
@2			Move.W		D2,-(SP)				; save the count
			Bsr.S		GetWidth				; get string width				<C971/RWW102887>NO

; Accumulate total width of the selection
			Add.W		D1,D4					; accumulate width
			Move.W		(SP)+,D2				; restore the count
			Move.W		startChar(A0),D6		; start of next style
			SubQ		#1,D2					; dec the style counter
			Bne.S		@styleLoop				; more styles

			Move.W		D4,D0					; return width in D0

@done
			MoveM.L		(SP)+,D2/D4/D6			; restore stuff
; clear up the world
			move.l	ExpandMem,a1				; <1Feb89smb>
			sf		ExpandMemRec.emMeasureLine(a1)		; restore old flag
			Rts
zeroExit
			MoveQ		#0,D0					; nothing to measure
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			 GetWidth
;
; 	Input
;			a0	next style run
; 			d0	start of the text in the next style run
;			d6	start of the text 
;			d7	end of the text
;			a2	pointer to current lineStart
;
; 	Need to set up...  <27June88smb>
;			a0 = start of text to be measured
; 			d0 = overall style run length
; 			d1 = length from start of measured text to end
; 			d2 = slop & highlight
;
;----------------------------------------------------------------------
GetWidth
			move.l		ExpandMem,a1			; <28June89smb>
			move.l		ExpandMemRec.vGetWidth(a1),a1
			jmp			(a1)
			
xGetWidth

			tst.w		teSize(A3)				; record with style?
			bpl.s		@Unstyled				; if not, A0 is nothing
; styled text
			Move.L		teStylesH(a3),a1		; get style handle
			Move.L		(a1),a1					; dereference
			Sub.L		a1,a0					; save as offset
@Unstyled
			Move.L		a0,-(SP)				; save A0
			Move.L		teTextH(a3),a0			; get text handle
			Move.L		(a0),a0 				; dereference
			
; get start of text into a0, max(d7,d0)-d6 into d1   <27June88smb>
; possible bug with > 32K
			add.w		d6,a0					; point at real start of text
			move.w		d7,d1					; get the end
  			
; adjust the start of the next style run to max at the end of the line <22Sept88smb>
			cmp.w		2(a2),d0				; length > end of line
			bls.s		@GotStyleEnd			; ok
			move.w		2(a2),d0				; fix it.
@GotStyleEnd

; pick the min of the style run end and the text end <26Sept88smb>
			sub.w		d6,d0					; sub start of text from end
			sub.w		d6,d1					; sub start of text from offset
			blt.s		@FullStyleRun			; d1 outside of range <26Sept88smb>

			cmp.w		d0,d1					; d1 higher than range,
	IF forLocalizability THEN					; <31l-YDS-8/27/91>
			bgt.s		@FullStyleRun			; allow measure when equal too (for R->L)
	ELSE
			bcc.s		@FullStyleRun			; bail: want to bra on equal too. <19June89smb>	<26June89smb> made unsigned
	ENDIF

; if drawing, then try this out! use textWidth for draw and C2P for caret. <21Sept88smb>
			move.l		ExpandMem,a1			; <1Feb89smb> full line flag
			tst.b		ExpandMemRec.emMeasureLine(a1)		; line width flag set?
			beq.s		@UseChar2Pixel			; no, do real stuff <22Sept88smb>

; we are measuring the whole line, BUT we only want to measure up to visible length <6Nov89smb>
			cmp.w		d0,d1					; take the minimum <6Nov89smb>
			bhs.s		@FullStyleRun			; d0 < d1, so skip <6Nov89smb>
			move.w		d1,d0					; stuff the visibleLength <6Nov89smb>

@FullStyleRun
; don't test interior of style run

	IF hasTextWidthHook THEN					; 												<18>
			moveq		#0,d1					; wants offset here								<18>
			bsr			TETextWidthHook			; hook out TextWidth							<18>
	ELSE										;												<18>
			clr.w		-(sp)					; allocate return <21Sept88smb>
			move.l		a0,-(sp)				; pointer
			move.w		#0,-(sp)				; no first byte
			move.w		d0,-(sp)				; bytecount
			_TextWidth							; go for it
			move.w		(sp)+,d1				; got the width
	ENDIF										;												<18>
			bra			@Continue				; rejoin <21Sept88smb>
			
@UseChar2Pixel
			MoveQ		#smHilite,D2			; hilite flag <27June88smb>
			swap		d2						; hilite in high word; slop in low <27June88smb> ** <C139/22Sep86/MBK> **

			Bsr			TEWidthHook				; THIS LINE REPLACES C2P call	<C971/RWW110387>
@Continue
			Move.L		(SP)+,A0				; restore A0

			Tst.W		teSize(A3)				; record with style?
			Bpl.S		@done					; if not, A0 is nothing

			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1					; dereference
			Add.L		A1,A0					; restore as pointer
@done
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			OldChar2Pixel
;
;			Using if the old WidthHook is preferred over the nWidthHook.
;			Never come here for script systems; always use new Char2Pixel.
;			See ScriptChar2Pixel and TEWidthHook dispatch code. <2/8/90smb>
;			Also coming here as the default for TextWidthHook (see TETextWidthHook)	<18>
;
;	Entry:	a0		ptr to text
;			d0.w	length of text to be measured
;			d1.w	offset into text
;
;	Exit:	d1.w	width of measured text
;
;----------------------------------------------------------------------
OldChar2Pixel
			subq		#2,sp					; room for result
			move.l		a0,-(sp)				; pass pointer
			move.w		d1,-(sp)				; offset
			move.w		d0,-(sp)				; length
			_TextWidth							; get width
			move.w		(sp)+,d1				; resulting width

			rts

;formFeed
;----------------------------------------------------------------------
;
;			Char2Pixel
;
;			new <27June88smb>
;
;	Entry:	A0:		ptr to start of text to be measured
;			D0.W	length of text to be measured (TE version)
;					overall style run length (SMgr version)
;			D1.W	start offset into text(TE version);
;					length from start of measured text to end (SMgr version)
;					: our offset w/in the style run (pinned to the lineStart)
;			D2		slop (low word)
;					add caret or hilite flag (high word)
;			A2		pointer to current lineStart
;
;	Exit:	D1.W	width of measured text
;
;----------------------------------------------------------------------
Char2Pixel
			Move.L		JChar2Pixel,-(SP)		; call the Char2Pixel Routine 		<EHB 01Oct85>
			Rts
vChar2Pixel
 
; if LR text and RL line direction and (offset = SOL or EOL) then <4May89smb>
;		if direction = smLeftCaret (0) then
;			if offset = lineStart then
;				return textWidth
;			otherwise return 0		; offset = lineEnd
;		else						; direction = smRightCaret (-1)
;			if offset = lineStart then
;				return 0
;			otherwise return textWidth		; offset = lineEnd

			move.l	d3,-(sp)
			tst.b	TESysJust
			beq		@UseC2P
; RL line direction
			movem.l	d0/d2/a0/a1,-(sp)
			move.w	d1,-(sp)
			tst.b	teSize(a3)
			bpl.s	@noStyle
			move.L	teTextH(a3),a1				; source = text
			move.L	(a1),a1 					; dereference
			suba.l	a1,a0						; offset to beginning of text to be measured
			move.w	a0,d0						; length to beginning of style run
			add.w	(sp),d0						; add in length to offset
			move.w	d0,d3						; save
			bsr		GetCurStyle
			bsr		GetDirection				; <6June89smb>
			bra.s	@TestDir					; <6June89smb>
@noStyle
;; d3 must be an absolute position for comparing to line ends. <20June89smb>
			move.w	d1,d3						; offset w/in line <20June89smb>
			add.w	(a2),d3						; absolute position <20June89smb>
; get the script direction from the font in the grafport for unstyled text <6June89smb>				<11>
			bsr		GetDirection				; input is a3 - handle to teRec						<11>
;;			sub.w	#6,sp						; allocate return, 1 long, 1 int					<11>
;;			_FontScript							; returns script; leave on stack as param			<11>
;;			move.w	#smScriptRight,-(sp)		; pass verb											<11>
;;			_GetScript																				<11>
;;			move.l	(sp)+,d1					; get byte = line direction							<11>
@TestDir
			cmp.b	TESysJust,d1
			beq.s	@fixStack					; not equal=> LR script 
			
; RL line and LR script
; compare current position to line ends
;; <20June89smb>			Bsr		GetLine 					; returns ptr to line in a2
			move.w	(sp)+,d1
			movem.l	(sp)+,d0/d2/a0/a1
; test if called for R-to-L highlighting rather than hit-testing <31July89smb>
			move.l	d2,-(sp)					; save  <1Aug89smb>
			swap	d2							; direction in high word <31July89smb>
			cmp.w	#smHilite,d2				; bug fix for Arabic highlighting <31July89smb>
			movem.l	(sp)+,d2					; restore (w/o affecting CCs) <1Aug89smb>
			beq.s	@UseC2P						; using for hilighting! <31July89smb>		
;;<2/1/90smb>			bne.s	@Use4HitTest				; <31July89smb>
;;<2/1/90smb>			bra.s	@UseC2P						; using for hilighting! <31July89smb>
;;<2/1/90smb>@Use4HitTest
; use for hit testing
			cmp.w	(a2),d3						; same as lineStart?
			beq.s	@OnAnEnd
			cmp.w	2(a2),d3					; same as lineEnd?
			bne.s	@UseC2P
			
@OnAnEnd
; RL line and LR script and on a lineEnd so process w/o calling C2P.
			swap	d2							; direction in high word
			cmp.w	#smLeftCaret,d2
			bne.s	@RightCaret
			cmp.w	(a2),d3						; same as lineStart?
			beq.s	@TextWidth					; yep, start
			bra.s	@ZeroWidth					; nope, end
@RightCaret
			cmp.w	(a2),d3						; same as lineStart?
			beq.s	@ZeroWidth					; yep, start
			
@TextWidth
	IF hasTextWidthHook THEN					; 												<18>
			moveq	#0,d1						; wants offset here								<18>
			bsr		TETextWidthHook				; hook out TextWidth							<18>
	ELSE										; 												<18>
			subq.l	#2,sp						; room for result
			move.l	a0,-(sp)					; ptr on stack
;;<20June89smb>			move.w	d1,-(sp)					; offset to first char
			move.w	#0,-(sp)					; offset to first char <20June89smb>
			move.w	d0,-(sp)					; length of block
			_TextWidth							; how wide is it?
			clr.l	d1
			move.w	(sp)+,d1					; this wide
	ENDIF										;												<18>
			bra.s	@done
@ZeroWidth
			moveq	#0,d1
			bra.s	@done
;****************************
@fixStack
			move.w	(sp)+,d1
			movem.l	(sp)+,d0/d2/a0/a1
			
@UseC2P
; <4May89smb> end of additions

			clr.w	-(sp)						; room for Char2Pixel return
			move.l	a0,-(sp)					; pass text ptr to buffer
			move.w	d0,-(sp)					; pass text len
			move.w	d2,-(sp)					; here's the slop
			move.w	d1,-(sp)					; pass the offset
			swap	d2							; direction in high word
;;<22June89smb>			move.b	d2,-(sp)					; actually,in lower byte
			move.w	d2,-(sp)					; move word since AIS tests word not byte <22June89smb>
	
			_Char2Pixel
			move.w	(sp)+,d1					; returns the pixel width
@done		move.l	(sp)+,d3					; restore <4May89smb>
			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			RangeRect
;
;			Given the line rect in rLine(A6), this sets teSelRect to the
;			line rect with the left side at the given loc in D3 and the
;			right side at D4.  If D3 is the first char on the line, it ...???
;
;----------------------------------------------------------------------

RangeRect
			Cmp.W		(A2),D3					; same as line start?
			Bhi.S		@0						; made this unsigned	** <C381/6nov86/MBK> **

			Cmp.W		2(A2),D4				; same as line end?
			Blo.S		@0						; made this unsigned	** <C381/6nov86/MBK> **

; Must set D6 in this case (DoMeasure sets it but MeasureIt doesn't)
			Move.W		(A2),D6					; set D6 to beg of line ** <C454/21nov86/MBK> **

			Move.W		D4,D7					; just need 2nd measure
			Bsr			MeasureIt				; measure whole line
			Add.W		D0,teSelRect+right(A3)	; save right side
			Bra.S		@1						; done with measuring

@0			Move		D3,D7					; get measure right
			Bsr.S		DoMeasure				; measure from [D6..D7)			<C971/RWW102887>NO
			Add 		D0,teSelRect+left(A3) 	; set left

			Move		D4,D7					; get 2nd measure right
			Bsr.S		DoMeasure				; measure from [D6..D7)			<C971/RWW102887>NO
			Add 		D0,teSelRect+right(A3)	; save right side

@1			Lea			teSelRect(A3),A1
			Move.W		left(A1),saveLeft(A6)	; just need to save left

			Move		left(A1),TempRect		; compatibility shit
			Move.L		botRight(A1),-(SP)		; push pen loc for compatibility

; In the pre-Mac+ version Capps used pnLoc throughout DoText.  He added the
; MoveTo here to maintain compatibility with that, but unfortunately in the
; pre-Mac+ version the pnloc is less by line height minus ascent.
; This fixes bug LM-RM-107.  Don't worry about new style records since this
; is only for maintaining compatibility with old apps.

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; are we on a color system?	(as per Jerome) <C971/RWW112487>
			Bnz.S		@2						; Nope								<C971/RWW112487>
	EndIf

			Tst.W		teSize(A3)				; if it's a new style record
			Bmi.S		@2						;	don't have to worry about it
			Move.W		teLineHite(A3),D0		; else, get hite - ascent
			Sub.W		teAscent(A3),D0
			Sub.W		D0,(SP)					; subtract from pnloc.v
@2

			_MoveTo 							; compatibility shit

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			DoMeasure
;			** <C139/22Sep/86> MBK **
;
;			DoMeasure was added to handle reverse justification.
;			DoMeasure measures from the display start of the line
;			to the given offset.  MeasureIt is still called directly
;			when the distance between 2 offsets is desired.
;
;			Input
;				d7 = left or right side to measure
;				a2 = line start
;			Output
;				d0 = total width
;			Use:
;				d5 = accumulated width
;				d0 = end of style run
;				d3 = haven't found a style run containing d7 yet
;				d2 = number of style runs on the line
;----------------------------------------------------------------------
DoMeasure
			with		TextFrame,TEFormatOrder		; <16Nov88smb> added for GetStylesInOrder call
			MoveM.L		D3/D5-D6,-(SP)
			MoveQ		#0,D5					; width accumulator
			Move.W		(A2),D6					; line start
			sf			d3						; not found yet

			Cmp 		D6,D7					; nothing to measure?
			Blo			@MeasureDone			; made this unsigned	** <C381/6nov86/MBK> **
	IF forLocalizability THEN					; <31i-YDS-8/27/91> - see <31i-YDS-8/27/91> below>			
			Tst.b		WordRedraw				; reverse order? if <0 then RL script present
			Bge			@PlainMeasure			; just do normal roman measure if not
			Tst.W		teSize(A3)				; style record?
			Bpl			@LRPlainMeasure			; just do normal L->R measure if not
	ELSE
			Tst.W		teSize(A3)				; style record?
			Bpl			@PlainMeasure			; just do normal measure if not
			Tst.b		WordRedraw				; reverse order? if <0 then RL script present
			Bpl			@PlainMeasure			; just do normal measure if not
	ENDIF

			sf			useOldMethod(a6)		; flag for getting style runs <28Sept88smb>
			Move.W		(A2),D0					; start of line <12July8smb> moved up here
			Move.W		2(A2),D1				; end of line <12July8smb> moved up here
			
; determine if display order is different from backin-store order <28Sept88smb>
			tst.b		WordRedraw				; $FF if a R->L directional script installed
;;<17July89smb>			bge.s		@getStyleOld			; nope, only L->R directional text
			blt.s		@RLStyledLine			; RL text in record <17July89smb>
; moved next 4 lines here to cleanup branching <17July89smb>
			st			useOldMethod(a6)
			Bsr			GetCurStyle				; get its style	<7Oct88smb>
			Bsr			GetNumStyles			; # of styles between offsets <7Oct88smb>
			bra.s		@MeasureLoop			; <17July89smb>

@RLStyledLine
			bsr			GetStylesInOrder		; initialize style run array
; tests whether any styles to process
			bge.s		@MeasureLoop
			bra.w		@MeasureDone

@getStyleNew
; get next style using the results from getFormatOrder
			bsr			GetNextDisplayStyle		; <4Jan89smb>
			addq		#1,fmtOrderingIndex(a6)	; incr the style run counter			
			SubQ		#1,D2					; dec the style counter
			bge.s		@MeasureLoop
			bra.w		@MeasureDone			; done 

;; removed label <17July89smb> @getStyleOld
@MeasureLoop
; get the style run in d6,d0
			Move.W		startChar(A0),D6		; store actual start of line
			bsr			FixFormatEnd			; <6Mar89smb> returns end of style run in d0

; pin d6 (start of the style run) to start of the line

			Cmp.W		(A2),D6					; should not be greater than
			Bhi.S		@D6Pinned2Start			; made this unsigned	** <C381/6nov86/MBK> **
			Move.W		(A2),D6					; the selection start
@D6Pinned2Start

; pin d0 (end of style run) to the end of the line

			Cmp.W		2(A2),D0				; style start
			Bls.S		@D0Pinned2End			; made this unsigned	** <C381/6nov86/MBK> **
			Move.W		2(A2),D0				; line's end
@D0Pinned2End

; now have a valid style run, limited to the line we are on

; this checks for a boundary condition, where d7 is between style runs

			tst.b		d3						; found already?
			bne.s		@PlainMeasure			; exit and measure the last one

; if searchpoint not in current style run, then keep measuring

			Cmp.W		D6,D7					; if less than selection start
			Blo.S		@DontExit				; then searchPoint is not in this style
			Beq.S		@CheckDirection			; check for boundary condition
			Cmp.W		D0,D7					; if greater than selection end
			Bhi.S		@DontExit				; then searchPoint is not in this style
			Bne.S		@PlainMeasure			; exit & measure (firmly inbetween)

; at this point, on a boundary. Measure & Exit if style direction = TESysJust
@CheckDirection
			Bsr			GetDirection			; returns script dir in d1
			cmp.b		TESysJust,d1			; TESysJust = 0, -1, so top byte set
			beq.s		@PlainMeasure			; exit & measure this last run
			st			d3						; found at least one style run
			bra.s		@GetTheWidth			; already set style, so go for it.

; if searchPoint (d7) on boundary of previous style run and this style run must adjust it to 
; be at the end of the style run to get the full measure of the style run. Rather than adjust
; it we force GetWidth to use TextWidth by setting tempVar to true! <27Sept88smb>

@DontExit
			Move.W		D0,-(SP)				; SetStyle destroys this	** <C229/28oct86/MBK> **
			Bsr			SetStyle				; set the style
			Move.W		(SP)+,D0				; restore length to measure ** <C229/28oct86/MBK> **

@GetTheWidth
			move.l		ExpandMem,a1			; <1Feb89smb>
			st			ExpandMemRec.emMeasureLine(a1)		; full line flag: measure full style run <27Sept88smb>
			move.w		d2,-(sp)				; save style count
			Bsr			GetWidth				; get string width
			Add.W		D1,D5					; accumulate width
			move.w		(sp)+,d2				; restore style count
			tst.b		useOldMethod(a6)		; <28Sept88smb>
			beq.s		@getStyleNew			; use formatOrder array
			SubQ.L		#stStartSize,A0			; pt to prev style
			Bra.S		@MeasureLoop			; keep measuring

	IF forLocalizability THEN					; Fix to support correct mesure for unstyled L->R
@LRPlainMeasure									; text <31i-YDS-8/27/91>>
			MoveM.l		a0-a1/d0-d2, -(sp)		;  
			Move.l		teTextH(A3),A0			; get text handle
			Move.l		(a0),a0					; derefrence it 
			move.w		teLength(a3), d0		; take lext length to d0
			cmp.w		(a2),d0					; are we at the start of the empty last line ?
			beq.s		@1						; yes !!
			move.w		2(a2), d0				; take next line start to d0
@1			move.w		d7,d1					; offset		
			Tst.W		TESysJust				; check text direction, we want tha max rect !!!	
			bne			@3						; push direction
			move.w		#smRightCaret, d2		; we allways push the oposite direction
			bra.w		@4						; in that way we get tha max mesurement
@3			move.w		#smLeftCaret, d2		; in that way we get tha max mesurement
@4			swap		d2
			clr.w		d2						; slop = 0
			add.w		d6,a0					; point to beginning of current line	<46>
			sub.w		d6,d0					; want length from current line	start	<46>
			sub.w		d6,d1					; want offset on current line			<46>
;Need:
;	textPtr in a0.l, textLen in d0.w, offset in d1.w;
;	d2.l = slop (low word), hilite flag (high word)
			bsr			TEWidthHook
			move.w		d1,d5					; mesure result in d5
			MoveM.L		(sp)+,a0-a1/d0-d2
			bra.s		@MeasureDone
	ENDIF

@PlainMeasure
			move.l		ExpandMem,a1			; <1Feb89smb>
			sf			ExpandMemRec.emMeasureLine(a1)		; <27Sept88smb>
			Bsr			MeasureIt				; last measurement
			Add.W		D0,D5					; final width

@MeasureDone
			Move.W		D5,D0					; return width in D0
			bsr			FreeFmtOrderArray		; <18Jan89smb>		
			MoveM.L		(SP)+,D3/D5-D6

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PinDisplay
;
;			Pins D3 and D4 to the viewRect
;			Expects A3 the usual TE record
;			Alternate entry with rect already in A0
;
;		Trashes D0, A0
;----------------------------------------------------------------------
PinDisplay
			Lea 		teViewRect(A3),A0		; use viewRect
PinA0Rect
			Move		top(A0),D0				; load D0 w/top

			Bsr.S		PtToLine				; turn into a lineStart in d0
			Bge.S		@4						; escape if top gone
			Add 		D0,D0					; double for array ref.
			Blt.S		@1
			Cmp 		teLines(A3,D0),D3		; pin D3 to viewRect.top
			Bhs.S		@0
			Move		teLines(A3,D0),D3		; dispStart = lines[i]
@0
			Cmp 		teLines(A3,D0),D4		; pin D4 to viewRect.top
			Bhs.S		@1
			Move		teLines(A3,D0),D4		; dispEnd = lines[i]
@1
			Move		bottom(A0),D0			; get bottom in D0
			SubQ		#1,D0
			Bsr.S		PtToLine

			AddQ		#1,D0					; inc line #			** MBK 6/18/86 **
			Cmp			teNLines(A3),D0			; compare to max		** MBK 6/18/86 **
			Bhi.S		@3						; made this unsigned	** <C381/6nov86/MBK> **

			Add 		D0,D0
			Cmp 		teLines(A3,D0),D3		; pin D3 to viewRect.bottom
			Blo.S		@2
			Move		teLines(A3,D0),D3		; dispStart = lines[i]
@2
			Cmp 		teLines(A3,D0),D4		; pin D4 to viewRect.bottom
			Blo.S		@3
			Move		teLines(A3,D0),D4		; dispEnd = lines[i]
@3
			Rts
@4
			Move		D3,D4					; nothing in range
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PtToLine
; 			** Rewritten 6/13/86 by MBK **
;
;		Entry:
;			D0 contains a V coordinate of a point of which we want to find the
;				corresponding line index into lineStart array
;		Exit:
;			D0 contains line index(May be negative)
;			CC's set according to D0 vs teNLines
;
;----------------------------------------------------------------------

PtToLine
			MoveM.L		D2/D6-D7/A0,-(SP)

			Sub 		teDestRect+top(A3),D0	; origin to destRect
			Ext.L		D0						; extend to long
			Move.W		teNLines(A3),D7			; save total # of lines
			Beq.S		@4						; if none, quit now
			
; special check for negative, return negative! <1/30/90smb>
			tst.l		d0						; before start of rect? <1/30/90smb>
			blt.s		@4						; yes, return above top line <1/30/90smb>

			Move.W		teLineHite(A3),D1		; get default line height

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; if not, do it the old way

			Tst.W		D1						; was line height set?
			Bmi.S		@1						; wasn't set, so use array

@0			DivS		D1,D0					; else divide by line height
			Bra.S		@4						; you're done

@1			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; dereference
			Move.L		lhTab(A0),A0			; max heights per line
			Move.L		(A0),A0					; dereference

			MoveQ		#0,D1					; init line hite accumulator
			Move.W		D7,D2					; get # of lines

@2			Move.W		(A0),D6
			And.W		#$7FFF,D6				; mask out high bit		** <C105/28aug86/MBK> **
			Add.W		D6,D1					; get the height
			AddQ.W		#4,A0
			Cmp.W		D1,D0					; compare to point
			Blt.S		@3						; found it

			SubQ.W		#1,D2					; dec counter
			Bne.S		@2						; more lines to point

@3			Move.W		D7,D0					; total # of lines
			Sub.W		D2,D0					; get line index

@4			Cmp 		D7,D0 					; compare the max # lines

			MoveM.L		(SP)+,D2/D6-D7/A0

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			InvertHook
;
;			This calls the passed hook if there, but otherwise uses _InverRect.
;			Used for carets and selection.  The hook passed must remove the
;			rect from the stack
;
;		Entry:
;			D0 the hook proc in question
;			selRect(A3) set up for rectangle in question
;
;----------------------------------------------------------------------
;
InvertHook
; Clear HiliteMode bit to tell QuickDraw to use color highlighting.
; Only do this if a hook is not installed.
			Pea 		teSelRect(A3)			;	default selection method

	If NOT ForROM THEN							; <9Dec88smb>
			; we have to do this test, so we have to explicitly check D0.L again rather
			;	than count on the SR flags coming in being right as in the ROM versions
			BTst		#14,ROM85				; on a color system?				<C971/RWW112487>
			Bnz.S		@1						;									<C971/RWW112487>

			Tst.L		D0						; does a hook exist?
			Bne.S		@2						; yes, go do it
			Lea			HiliteMode,A0			;									<C971/RWW112487>
			BClr		#7,(A0)					;									<C971/RWW112487>
			Bra.S		defHilite				;									<C971/RWW112487>

@1			Tst.L		D0						; does a hook exist?				<C971/RWW112487>
			Beq.S		defHilite				; no								<C971/RWW112487>
@2
	ElseIf hasCQD THEN							; <9Dec88smb>
			Bne.S		@0
			Lea			HiliteMode,A0			; new memory location for hiliting
			BClr		#7,(A0)					; tell them we want color hiliting
			Bra.S		defHilite				; do the inversion
@0
	Else
			Beq.S		defHilite				; there, otherwise just invert

	EndIf

			Move.L		D0,A0
			Jmp 		(A0)
defHilite
			_InverRect
			Rts

; Color highlighting is not to be used on the caret, so I created this separate
; procedure just for caret highlighting.

	If hasCQD|(NOT ForROM) THEN					; <9Dec88smb>

CaretHook
			Pea 		teSelRect(A3)			; default selection method
			Tst.L		D0						; make absolutely sure!			<S487/RWW050288>
			Beq.S		defHilite				; there, otherwise just invert
			Move.L		D0,A0
			Jmp 		(A0)
	EndIf

;formFeed
;----------------------------------------------------------------------
;			StdEntry (or "entries" as it is!)
;
;			Standard Entry for procs, saves registers and pops handle
;			argument into A4 and dereferences it into A3.  Points A2 to
;			first parameter AFTER the handle.
;----------------------------------------------------------------------
TEKeyStdEntry
; Added new entry point for TEKey since need to save/clear textBuffering flag around this routine.<18Sept89smb>
			moveq		#0,d0					; not a style trap
			move.l		(sp)+,a0				; save return address
			move.l		(sp)+,a1				; save newTEFlags
			link		a6,#stdLink 			; stack frame
			movem.l 	d2-d7/a2-a4,-(SP)
			move.l		a1,-(sp)				; newTEFlags to restore
			move.l		a0,-(sp)				; push return address back on stack
			bra.s		NotStyleTrap
StdEntry
			MoveQ		#0,D0					; not a style trap		** <C105/28aug86/MBK **
StdEntry2
			Move.L		(SP)+,A0				; save return address
			Link		A6,#stdLink 			; stack frame
			MoveM.L 	D2-D7/A2-A4,-(SP)
			Move.L		A0,-(SP)				; push return address back on stack

			Tst.W		D0						; is it a style trap?	** <C105/28aug86/MBK **
			Beq.S		NotStyleTrap			; if not, skip this		** <C105/28aug86/MBK **

			Move.W		inHandle(A6),D0			; get the selector		** <C105/28aug86/MBK **
			Lea			AddrTable,A0			; table of addresses	** <C105/28aug86/MBK **
			Add.W		D0,D0					; each entry is 2 bytes	** <C381/5nov86/MBK **
			Move.W		0(A0,D0),D0				; get offset to the trap** <C381/5nov86/MBK **
			Lea			0(A0,D0),A0				; get trap's addr		** <C381/5nov86/MBK **
			Move.L		A0,D3					; save addr in D3		** <C381/5nov86/MBK **

			Move.L		inHandle+2(A6),A4		; get TEHandle			** <C105/28aug86/MBK **
			Bra.S		StyleTrap
NotStyleTrap
			MoveQ		#0,D3					; use D3 as a flag		** <C105/28aug86/MBK **
			Move.L		inHandle(A6),A4 		; Pop handle into A4

; Modified to use _HGetState ** <C105/5sep86/MBK> **
StyleTrap
			Move.L		A4,A0					; set up for GetState
			_HGetState							; get handle flags
			Move.B		D0,saveHandle(A6)		; save handle flags

			Pea 		savePort(A6)			; save incoming port
			_GetPort							;

			Move.L		A4,A0					; get the TEHandle
			_HLock

			Move.L		(A4),A3 				; Dereference into A3	** <C381/8nov86/MBK **

; Do all safety related entry stuff
			Move.L		teGrafPort(A3),A2		; save "thePort" for below
			Move.L		A2,-(SP)				; set to our port
			_SetPort

; Get clip from this port into rgn defined above
			SubQ		#4,SP					; make room for clip
			_NewRgn
			Move.L		(SP),saveClip(A6)		; save user's clip in frame
			Move.L		(SP),-(SP)				; stay on stack for sectrgn below
			_GetClip							;

			Pea 		teViewRect(A3)			; clip to viewRect
			_ClipRect

; First param on stack from above.  Do not pass go. Do not collect $200
			Move.L		clipRgn(A2),-(SP)
			Move.L		(SP),-(SP)				; destination
			_SectRgn

; Set up font, etc. AFTER saving the grafport information!										<20>
			move.l		teGrafPort(a3),a0		; pt to GrafPort
			move.w		txFont(a0),saveFont(a6)	; save current font
			bclr		#7,txFace+1(a0)			; in case direction set here <30May89smb>
			move.w		txFace(a0),saveFace(a6)	; save current face
			move.w		txSize(a0),saveSize(a6)	; save current size
			pea			saveColor(a6)			; place to save color	** <C182/60ct86/MBK> **

			tst.w		teSize(a3)				; check style flag
			bmi.s		DontSet					; don't set style		** MBK 6/20/86 **

			move.l		teFontStuff(A3),txFont(A0)		; set the font/face
			move.l		teFontStuff+4(A3),txFont+4(A0)	; set the mode/size

DontSet
		
			Move.W		teMode(A3),txMode(A0)	; do set the mode		** <C815/13feb87/MBK **
			_GetForeColor						; for Ikki				** <C182/6oct86/MBK> **

			Move.L		teTextH(A3),A0			; get handle size

			_HGetState							; get the text handle's tag
			Move.B		D0,saveTH(A6)			; and save the flags
			_HLock								; and lock it

			_GetHandleSize						; get its size
			Move		D0,teLength(A3) 		; stuff its length

; Clean up the selection (This must be the last guy because of alternate entry)

CleanUpSel
			Move		teLength(A3),D0 		; get the text length

			Move		teSelEnd(A3),D1 		; make sure selEnd is cool
			Sub 		D0,D1					; selEnd-length
			Bls.S		okSelEnd				; if >0 then bad selend
			Move		D0,teSelEnd(A3) 		; set to length if > length
okSelEnd

			Move		teSelStart(A3),D1		; make sure selStart is cool
			Sub 		teSelEnd(A3),D1 		; selStart-selend
			Bls.S		okSelStart				; if >0 then bad selStart
			Sub 		D1,teSelStart(A3)		; set to selend if > selend
okSelStart
			IF			&TYPE('&RWWDebug') = 'UNDEFINED' THEN
			Bsr.s		SelSort 				; I wish i could fall into it
			ELSE
			Bsr			SelSort 				; I wish i could fall into it
			ENDIF

			Tst.L		D3						; addr of style trap?	** <C105/28aug86/MBK **
			Beq.S		@2						; if not, skip this		** <C105/28aug86/MBK **

			Move.L		D3,A0					; return it in A0		** <C381/5nov86/MBK **
			Lea			inHandle+6(A6),A2		; pt to next param		** <C105/28aug86/MBK **
			Bra.S		endEntry				; that's it				** <C105/28aug86/MBK **

@2			Lea 		inHandle+4(A6),A2		; Point to next to last param
												; (1st on stack after handle)
endEntry
; dump text buffer before processing any calls <14Sept89smb>
			move.l		a0,-(sp)
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops <15Sept89smb>
			btst		#teFTextBuffering,d0	; <15Sept89smb>
			beq.s		@noBuffer
			bsr			DumpBuffer				; dump text from buffer
@noBuffer	
			move.l		(sp)+,a0
			
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEDispatch (...; hTE: TEHandle; teStyl: INTEGER );
;
;			** <C105/28aug86/MBK> **
;
;			All style procedure and function traps come here (except
;			TEStylNew) due to a shortage of traps.
;
;			** <C207/13oct86/MBK> **
;
;			Added special dispatch to StylTextBox.  Have to special case
;			it since it doesn't go through StdEntry.
;
;----------------------------------------------------------------------
TEDispatch
			MoveQ		#1,D0					; tells stdEntry it's a style trap
			Bsr 		StdEntry2				; get addr of procedure
			Jmp			(A0)					; go and never come back!

; ***************************************************************************
; ** <C971/RWW102387>	So I can find routines more easily...
	If &TYPE('&RWWDebug') <> 'UNDEFINED' Then

	Macro
			FindEntry	&rout
			DC.B		'&SUBSTR(&CONCAT(&rout,'............'),1,12)'
			DC.L		&rout-DispLocTable
	EndM

			Export		DispLocTable
DispLocTable
			FindEntry	vChar2Pixel						; see OS:DispTable.a
			FindEntry	vPixel2Char						; see OS:DispTable.a
			FindEntry	XTrimMeasure					; see OS:DispTable.a
			FindEntry	XFindWord						; see OS:DispTable.a
			FindEntry	XFindLine						; see OS:DispTable.a
			FindEntry	XEOLHook
			FindEntry	XDRAWHook
			FindEntry	iTEStylPaste
			FindEntry	iTESetStyle
			FindEntry	iTEReplaceStyle
			FindEntry	iTEGetStyle
			FindEntry	iGetStylHandle
			FindEntry	iSetStylHandle
			FindEntry	iGetStylScrap
			FindEntry	iTEStylInsert
			FindEntry	iTEGetPoint
			FindEntry	iTEGetHeight
			FindEntry	iTECustomHook
			FindEntry	iTEContinuousStyle
			FindEntry	iSetStylScrap
			FindEntry	iTENumStyles
			FindEntry	iTEFeatureFlag
			DC.L		-1
	EndIf
; ***************************************************************************


;formFeed
;----------------------------------------------------------------------
;
;			Sorts the selStart and selEnd
;
;		Entry:
;			A3 must contain a dereferenced TE object
;
;		Exit:
;			D0 contains a sorted selStart/End as a long
;			A2 contains a pointer to teSelStart
;
;----------------------------------------------------------------------

SelSort
			Lea 		teSelStart(A3),A2		; Point to selstart
			Move.L		(A2),D0 				; load start and end
			Cmp 		(A2),D0 				; see which is bigger
			Bhs.S		@0
			Swap		D0
			Move.L		D0,(A2) 				; swap and store back
@0			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TECopy( h: TEHandle );
;
;			** Modified 6/20/86 by MBK **
;
;----------------------------------------------------------------------
TECopy
			Bsr			StdEntry				;								<C971/RWW102887>NO

			Bsr.S		SelSort 				; D0 contains both (end in low order)
			Sub 		(A2),D0 				; A2 points to selStart(A3)
			Move		D0,TEScrpLength 		; scraplength=selEnd-selStart

			Move.L		teTextH(A3),A0			; source = text; already locked
			Move.L		(A0),A0 				; dereference
			MoveQ		#0,D0					; clear whole long
			Move		(A2),D0
			Add.L		D0,A0					; offset to selection(see above)
			Move.L		TEScrpHandle,A1 		; destination
			Move		TEScrpLength,D0 		; nBytes = scrapLength
			_PtrToXHand

; ** <C207/15oct86/MBK> ** Don't wipe out desk scrap for old TERecs in case applications
;						use it for Undo

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		goEpilog4				; no style, don't wipe out scrap

; Now copy directly to the desk scrap anyway
			SubQ		#4,SP					; room for result		** MBK 6/20/86 **
			_ZeroScrap							; clear the scrap		** MBK 6/20/86 **
			AddQ.L		#4,SP					; ignore result			** MBK 6/20/86 **

			Bsr.S		SelSort 				; D0 contains both (end in low order)
			Bsr.S		CopyStyle				; copy style info				<C971/RWW102887>NO

			Move.L		teTextH(A3),A0			; text handle			** MBK 6/20/86 **
			Move.L		(A0),A0					; deref					** MBK 6/20/86 **
			MoveQ		#0,D0					; clear long word		** MBK 6/20/86 **
; <16May89smb> Must set up A2 to point to selStart(a3) again, since it may be invalid if the 
; teRecord moved during a MyNewHandle call in CopyGuts.
			Lea 		teSelStart(A3),A2		; <16May89smb> point to selStart
			Move		(A2),D0					; start of selection	** MBK 6/20/86 **
			AddA.W		D0,A0					; offset to selection	** MBK 6/20/86 **
			SubQ		#4,SP					; room for result		** MBK 6/20/86 **
			Move.W		TEScrpLength,D0			; length of selection	** MBK 6/20/86 **
			Move.L		D0,-(SP)				; push length			** MBK 6/20/86 **
			Move.L		#'TEXT',-(SP)			; type 'TEXT'			** <C381/5nov86/MBK> **
			Move.L		A0,-(SP)				; ptr to selection		** MBK 6/20/86 **
			_PutScrap							; copy to desk scrap	** MBK 6/20/86 **
			AddQ.L		#4,SP					; ignore result			** MBK 6/20/86 **

goEpilog4
			Bra 		epilog4

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE CopyStyle
;
;			** Added 5/28/86 by MBK **
;
;			CopyStyle saves the styles corresponding to the current text
;			selection to the desk scrap.
;
;	Entry:
;			A3:			Pointer to TERec
;			D0:			selStart, selEnd
;
;----------------------------------------------------------------------
CopyStyle
			MoveM.L		D0/D2-D5/A2/A5,-(SP)	; save stuff

; get ptr to 1st style and # of styles
			Move.W		D0,D1					; save end
			Swap		D0						; selStart in low word
			Cmp.W		D0,D1					; is it an insertion pt?
			Beq.S		@2						; if so, no style to copy

			Bsr.S		CopyGuts				; do the copy

; Lock my scrap handle 'cause PutScrap might try to move it!
			Move.L		A4,A0					; my scrap handle
			_HLock								; lock it

; copy the styles to the desk scrap now
			SubQ.L		#4,SP					; room for result
			Move.L		D4,-(SP)				; size of scrap
			Move.L		#'styl',-(SP)			; scrap type			** <C381/5nov86/MBK> **
			Move.L		(A4),-(SP)				; scrap ptr
			_PutScrap							; copy to desk scrap
			AddQ.L		#4,SP					; remove result code

; don't need this handle anymore
			Move.L		A4,A0					; scrap handle
			_DisposHandle						; get rid of it

@2			MoveM.L		(SP)+,D0/D2-D5/A2/A5	; save stuff

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE CopyGuts
;
;			** Separated out from CopyStyle 1/22/87 by MBK **
;
;			CopyGuts is called by CopyStyle and GetStylScrap to save the
;			styles corresponding to the current text selection.
;
;	Entry:
;			A3:			Pointer to TERec
;			D0:			selStart
;			D1:			selEnd
;	Exit:
;			A4:			handle to style scrap
;	Modifies:
;			A0-A4,D0,D2,D4,D5
;
;----------------------------------------------------------------------
CopyGuts
			Move.W		D0,D5					; save 1st offset
			Bsr			GetCurStyle				; get style at current selection
			Bsr			GetNumStyles			; find # of styles in selection
			Move.W		D0,D2					; save # of styles

; get a temp handle to store the styles in before copying to desk scrap
			MulU		#scrpRecSize,D0			; * size of a scrap style rec
			AddQ.L		#2,D0					; total scrap size
			Move.L		D0,D4					; preserve scrap size
			Bsr			MyNewHandle				; temp handle for style scrap	** <C381/7nov86/MBK> **
			Move.L		A0,A4					; save scrap handle

			Move.L		(A0),A0					; deref
			Move.W		D2,scrpNStyles(A0)		; store # of styles in scrap
			Lea			scrpStyleTab(A0),A1		; pt to array of styles

; ** <C393/10nov86/MBK> ** style ptr may no longer be valid after memory allocation
			Move.W		D5,D0					; get 1st offset				** <C393/10nov86/MBK> **
			Bsr			GetCurStyle				; get style at current selection** <C393/10nov86/MBK> **
			Move.L		A0,A2					; store ptr to current style	** <C393/10nov86/MBK> **

; loop over styles in the selection, copying to temp location
@0			AddQ.L		#4,A1					; skip 1st entry				** <C207/13oct86/MBK> **
			Move.W		styleIndex(A2),D0		; style index
			Bsr			GetStyle				; get the style ptr
			AddQ.L		#2,A0					; skip 1st entry				** <C207/13oct86/MBK> **
			MoveQ		#stRecSize-2,D0			; size of a style rec-2			** <C381/6nov86/MBK> **
			_BlockMove							; copy style to scrap

			MoveQ		#0,D0					; it's a long word				** <C207/13oct86/MBK> **
			Move.W		startChar(A2),D0		; get start offset of this style
			Sub.W		D5,D0					; offset from start of text scrap
			Bhs.S		@1						; made this unsigned			** <C381/6nov86/MBK> **

			MoveQ		#0,D0

@1			Move.L		D0,-(A1)				; store scrap offset
			Add.L		#scrpRecSize,A1			; next position in style array
			AddQ.L		#stStartSize,A2			; next style
			SubQ		#1,D2					; dec the style counter
			Bne.S		@0						; loop if more styles

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TECut( h: TEHandle );
;
;----------------------------------------------------------------------
TECut
			Bsr			StdEntry				;								<C971/RWW102887>NO

			Move.L		A4,-(SP)				; duplicate handle twice
			_TECopy 							; copy it
			Move.L		A4,-(SP)
			_TEDelete							; delete it (A3 no good after)

			Bra			goEpilog4				; see you later					<C971/RWW102887>NO


;----------------------------------------------------------------------
;
;			PROCEDURE TEDelete( h: TEHandle );
;
;----------------------------------------------------------------------
TEDelete
			Bsr			StdEntry				;								<C971/RWW102887>NO

			Bsr 		HideCaret

			Bsr.S		DelGuts 				; delete the selection
			Bsr			RecalDraw				; recalibrate line starts

			Bsr 		ShowCaret

			Bsr 		SelView 				; insure selection is visible

			Bra			goEpilog4				;								<C971/RWW102887>NO

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE DelGuts
;
;			** Modified 6/18/86 by MBK **
;
;		Entry:
;			A3 contains dereferenced handle
;
;		Exit
;			Selstart and selEnd will be fixed up to point to the old selStart
;			D7 contains delta amount for delete portion
;
;----------------------------------------------------------------------
DelGuts
			Bsr			SelSort 				; sort selection				<C971/RWW102887>NO

			Move		D0,D7					; calc delta amount(selEnd in D0)
			Sub 		(A2),D7 				; ...for ReCalLines (A2 ^selStart)
			Beq.s		outGuts 				; skip if null selection

; ** <C971/RWW102987>	Inserted test to change the way backspacing/deleting works.
; If you backspace to the beginning of a style, that style is saved to the null scrap.
; This allows you to type a selection, backspace over it, and retype without
; TextEdit reverting to the previous style.
			Tst.W		teSize(A3)				; is this a styled record?			<C971/RWW102987>
			Bpl.S		@1						; oops, never mind					<C971/RWW102987>

			MoveM.L		D0/D7/A2,-(SP)			; we need D0 and A2 temporarily		<C971/RWW102987>
			Move.W		teSelStart(A3),D0		; find start of block to be yanked	<C971/RWW102987>
			Bsr			GetCurStyle				; find the associated style run		<C971/RWW102987>
			Move.W		teSelStart(A3),D0		; get start of block again			<C971/RWW102987>
			Cmp.W		startChar(A0),D0		; is it the beginning of a style?	<C971/RWW102987>
			Beq.S		@2						; yes, so continue					<C971/RWW102987>

			Bsr			ClearRsrved				; no null selection!				<C971/RWW102987>
			Bra.S		@3						;									<C971/RWW102987>

@2			Move.W		styleIndex(A0),D0		; fetch index into style table		<C971/RWW102987>
			Bsr			GetStyle				; find associated style table entry	<C971/RWW102987>
			Move.W		#doAll,-(SP)			; build fake frame for SetRsrved	<C971/RWW102987>
			Pea			stFont(A0)				; point at embedded textstyle		<C971/RWW102987>
			Clr.B		-(SP)					; need another word, can't hurt		<C971/RWW102987>
			Move.L		SP,A2					; point A2 at stacked parameters	<C971/RWW102987>
			Bsr			AltSetRsrved			; set null scrap style				<C971/RWW102987>
			AddQ.W		#8,SP					; fix up stack						<C971/RWW102987>

@3			MoveM.L		(SP)+,D0/D7/A2			; retrieve saved registers			<C971/RWW102987>
@1												;									<C971/RWW102987>

			Move.W		D0,D1					; selEnd				** MBK 6/18/86 **
			Swap		D0						; selStart				** MBK 6/18/86 **
			Bsr.S		DeleteStyle				; del associated styles			<C971/RWW102887>NO

			Bsr 		MungeSetup				; set up params for delete

			Move		D7,-(SP)				; length for delete
			Clr 		-(SP)					; fake long length
			Clr.L		-(SP)					; fake p2
			Clr.L		-(SP)					; fake l2
			_Munger 							; sloppy munger
			AddQ.L		#4,SP					; pop result

			Move.L		teTextH(A3),A0			; RecalDraw expects text to be locked
			_Hlock								; and relock it

			Sub 		D7,teLength(A3) 		; length:=length -(selEnd-selStart)
			Move		(A2)+,(A2)				; selEnd:=selStart
			tst.w		teSize(A3)				; is this a styled record? <24July89smb>
			bpl.S		outGuts					; if so, no need to concat - only 1 run <24July8smb>
			bsr			ConcatStyles			; <21July89smb>
			bsr			ConcatRuns				; <25June89smb>
outGuts
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE DeleteStyle
;
;			** Added 6/2/86 by MBK **
;
;			DeleteStyle checks to see if the TERec has style (txSize = -1),
;			And if so deletes the style(s) corresponding to the current text
;			selection.
;
;	Entry:
;			A3:			Ptr to TERec
;			D0:			selStart
;			D1:			selEnd
;
;----------------------------------------------------------------------
DeleteStyle
			MoveM.L		D0/D2-D6/A2,-(SP)		; save stuff

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@2						; no style so nothing to delete

			Move.W		D0,D5					; store selStart
			Sub.W		D1,D5					; neg length for delete
			Beq.S		@2						; quit if nothing to delete

			Move.W		D0,D3					; save selStart
			SubQ		#1,D0					; pre-decrement
			Bsr			GetCurStyle				; get style at current selection
			Move.L		A0,A2					; store ptr to current style
			Move.W		D0,D6					; save index
			AddQ		#1,D1					; include following style
			Bsr			GetNumStyles			; find # of styles in selection

			SubQ		#1,D0					; don't delete current style

			Move.W		D0,D2					; # of styles
			Add.W		D6,D0					; add index
			Move.W		D0,D6					; save index
			MoveQ		#0,D4					; clear long word			** <C381/6nov86/MBK> **
			Move.W		D2,D4
			LsL.L		#2,D4					; * stStartSize (4)			** <C381/6nov86/MBK> **
			Add.L		D4,A0					; pt to last style to be deleted

			Tst.W		D2						; see if any styles to delete
			Bne.S		@0						; if nothing to delete
			Bsr			RecalStStarts			; reset following style starts
			Bra.S		@2						; and go

@0			Move.W		D3,startChar(A0)		; selStart is new start of last style
			Bsr			RecalStStarts			; reset following style starts

			Cmp.W		startChar(A2),D3		; special case
			Beq.S		@1

			Add.L		#stStartSize,A2			; point to next style
			SubQ		#stStartSize,D4			; 1 less to delete
			SubQ		#1,D2					; don't delete last style
			Beq.S		@2						; nothing to delete

@1			Move.L		A2,A0					; ptr
			Move.W		D2,D0					; count
			Bsr.S		DecStylCount			; decrement style count			<C971/RWW102887>NO

; Delete the runs corresponding to deleted text
			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; dereference
			MoveQ		#0,D0					; clear long word			** <C381/6nov86/MBK> **
			Move.W		nRuns(A0),D0			; current # of styles
			AddQ		#1,D0					; plus 1
			Sub			D6,D0					; minus index
			LsL.L		#2,D0					; * stStartSize (4)			** <C381/6nov86/MBK> **
			Sub.W		D2,nRuns(A0)			; dec the # of styles

			Move.L		A2,A1					; destination of move
			Move.L		A2,A0
			Add.L		D4,A0					; source of move
			_BlockMove

@2			MoveM.L		(SP)+,D0/D2-D6/A2		; restore stuff

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE DecStylCount
;
;			** Added 6/2/86 by MBK **
;
;			DecStylCount decrements the style count by one after an instance
; 			of the style has been deleted.
;
;	Entry:
;			D0:			# of styles to check
;			A0:			Pointer to style from which to start
;			A3:			Ptr to TERec
;
;----------------------------------------------------------------------
DecStylCount
			Move.L		A0,A1					; save ptr to style start
			Move.W		D0,D1					; store # styles to check

; get the styleRec corresponding to the index
@0			Move.W		styleIndex(A1),D0		; get index to style
			Bsr			GetStyle				; get pointer to that style
			Tst.W		stCount(A0)				; is the count already 0?
			Beq.S		@1

			SubQ		#1,stCount(A0)			; if not, decrement the count

; see if there are more styles to delete
@1			Add.L		#stStartSize,A1			; point to next style
			SubQ		#1,D1					; dec the counter
			Bne.S		@0						; more to decrement


			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE RecalDraw
;
;			** Modified 6/18/86 by MBK **
;
;			Calls ReCalLines to recalibrates the line start array and then draws
;			the "new" part according to selStart
;
;		Entry
;			A4 points to handle
;			A3 points to dereferenced TE object
;			D7 contains delta change = oldLength-newLength
;
;			** <C207/16oct86/MBK> ** Added code to reset redraw boundaries if the
;			line height has changed on any line.
;
;			** <C381/8nov86/MBK> ** Moved code to decide where redraw must occur
;			to the routine SetLineHite.
;
;----------------------------------------------------------------------
RecalDraw

			MoveQ		#0,D0					; 1st line				** MBK 6/18/86 **
			Move.W		teNLines(A3),D1			; last line				** MBK 6/18/86 **
			Bsr			GetLineHites			; get total height		** MBK 6/18/86 **
			Move.W		D0,-(SP)				; save it				** MBK 6/18/86 **

			Bsr 		ReCalLines				; D2/D4 returned w/dispStart
			Move		D2,D3					; record dispStart

			MoveQ		#0,D0					; 1st line				** MBK 6/18/86 **
			Move.W		teNLines(A3),D1			; last line				** MBK 6/18/86 **
			Bsr			GetLineHites			; get new height		** MBK 6/18/86 **
			Move.W		(SP)+,D1				; get old height
			Cmp.W		D0,D1					; don't erase if same
			Blo.S		noErase					; nothing to erase

			Lea			teSelRect(A3),A0		; pt to selection rect
			Add 		teDestRect+top(A3),D1	; new bottom
			Move.W		D1,bottom(A0)

			Add 		teDestRect+top(A3),D0	; new top
			Move.W		D0,top(A0)

			Move.W		#UnboundLeft,left(A0) 	; large negative left
			Move		#UnboundRight,right(A0) ; VERY large right(Erase to end)
			
			Move.L		A0,-(SP)				; point to rect
			_EraseRect

noErase
			MoveQ		#teDraw,D7				; Redraw changed part
			Bra			DoText					; see you later					<C971/RWW102887>NO

;formFeed
;-------------------------------------------------------------------------------
; Function: GetCurScript // <DGO 881004>
;
; This function determines the "script run" (comprising one or more style runs)
;  that contains the character position contained on entry in register d0. Note
;  that this routine should only be called for styled TERecs.
;
; Inputs:
;
;	d0 = Absolute char position for which script run is to be found
;
; Outputs:
;
;	a0 = Address of the first style run in the script run
;	a1 = Index of the first style run in the script run
;	d0 = Total length (in chars) of all style runs comprising this script run
;	d1 = Script number of this script run
;
; General register usage (as usual, a6 is local frame pointer):
;
;	d4 = On-the-fly index into array of StyleRuns
;	d5 = Cumulative character length of runs
;	d6 = Offset into STElement array of the (a2) element
;	d7 = Script number for this run
;
;	a2 = On-the-fly address of StyleRuns array element
;	a4 = Base address of STElement[0]
;	a5 = Base address of TEStyleRec
;
; Assumptions made about input state:
;
;	a3 = Dereferenced pointer to TERecord
;
; CHANGE LOG
;
; <4-Oct-88 DGO>	Corrected bug whereby I was using the styleRun index rather than the
;					styleIndex for the styleRun **arrgghhh**
;
;-------------------------------------------------------------------------------
GetCurScript
			move.l		ExpandMem,a0			; <28June89smb>
			move.l		ExpandMemRec.vGetCurScript(a0),a0
			jmp			(a0)

xGetCurScript

; Initial housekeeping
;
			link		a6,#gcsLink
			movem.l		d2-d7/a2/a4/a5,-(sp)
;
; Since d0 is already set to the char position, we start the ball rolling by calling
;	GetCurStyle. This returns a pointer to the style run in a0, and the style run index
;	in d0.
;
			bsr			GetCurStyle
			movea.l		a0,a2
			move.w		d0,d4
;
; Set up our utility registers.
;
			movea.l		teStylesH(a3),a5
			movea.l		(a5),a5						; Pointer to TEStyleRec now in a5
			
			movea.l		styleTab(a5),a4
			movea.l		(a4),a4						; Pointer to STElement[0] now in a4
			
			moveq.l		#0,d5						; Zero cumulative script length counter
			
			moveq		#0,d6						; must clear for shift logic <29June89smb>
			move.w		styleIndex(a2),d6
;;			mulu		#stRecSize,d6				; Offset from a4 of STElement[d4]
			add.w		d6,d6						; replace mulu w/ shift logic <28June89smb>
			move.w		d6,d1						; save <28June89smb>
			lsl.w		#3,d6						; <28June89smb>
			add.w		d1,d6						; sum <28June89smb>
;
; Now determine to which script this style run belongs. The result will be the script value
;	that all other contiguous style runs must match in order to be added to this script run.
;
			clr.w		-(sp)
			move.w		stFont(a4,d6.l),-(sp)		; Font for this style run
			_Font2Script
			move.w		(sp)+,d7					; Script number for this script run in d7
;
; We now start traversing the style runs. We'll first traverse the earlier runs, and then
;	the later ones. Before we start the first traverse, we save the state of several of the
;	registers for restoration when starting the second traverse, below.
;
			movem.l		d4/a2,-(sp)
;
; Add the length of this style run to the cumulative length for the script run. Remember
;	that the length of a style run can be determined by adding the startChar of the
;	following style run and subtracting the startChar of this style run. (Note
;	that we fall into this code the first time through, which adds the length of the
;	initial style run). This is complicated by the following ugliness: If we're in the
;	last style run in the TERecord, we need to decrement the count by one, since the
;	dummy entry at the end of the StyleRun table has a startChar value that is one
;	*greater* than the total count of characters in the record. *Sigh*
;
@1			add.w		stStartSize(a2),d5				; Note that any overflows will
			sub.w		startChar(a2),d5				;	automagically sort themselves out...
			
			move.l		a2,gcsTemp(a6)					; Save earliest script start
			move.w		d4,gcsIndex(a6)					; 	and index of earliest start
			
			addq.w		#1,d4							; These 4 lines are the ugly code
			cmp.w		nRuns(a5),d4					;	that handle the case of the
			bne.s		@2								;	final style run's extra
			subq.w		#1,d5							;	count...
			
@2			subq.w		#1,d4							; Balance the addq in the above ugly code
			beq.s		@3								; If we just did 0th, first traverse is done
			
			subq.l		#stStartSize,a2					; Set pointer to previous styleRun
			subq.w		#1,d4							; Set index to previous styleRun
			moveq		#0,d6							; must clear for shift logic <29June89smb>
			move.w		styleIndex(a2),d6
;;			mulu		#stRecSize,d6					; Move to previous STElement
			add.w		d6,d6							; replace mulu w/ shift logic <28June89smb>
			move.w		d6,d1							; save <28June89smb>
			lsl			#3,d6							; <28June89smb>
			add.w		d1,d6							; sum <28June89smb>
			
			clr.w		-(sp)							; Convert font
			move.w		stFont(a4,d6.l),-(sp)			;	into script
			_Font2Script
			
			cmp.w		(sp)+,d7						; If this new script matches ours,
			beq.s		@1								;	continue with first traverse
;
; We're done with the earlier traverse. Restore the registers that were saved above,
;	and start essentially the same operation for the later traverse.
;
@3			movem.l		(sp)+,d4/a2						; Restore on-the-fly values
			addq.w		#1,d4							; Set index to next styleRun

@4			addq.l		#stStartSize,a2					; Set pointer to next styleRun
			moveq		#0,d6							; must clear for shift logic <29June89smb>
			move.w		styleIndex(a2),d6
;;			mulu		#stRecSize,d6					; Move to next STElement
			add.w		d6,d6							; replace mulu w/ shift logic <28June89smb>
			move.w		d6,d1							; save <28June89smb>
			lsl			#3,d6							; <28June89smb>
			add.w		d1,d6							; sum <28June89smb>
			
			cmp.w		nRuns(a5),d4					; If the new style run index is equal to
			beq.s		@5								;	the nRuns count, we're done!
			
			clr.w		-(sp)							; Convert font
			move.w		stFont(a4,d6.l),-(sp)			;	into script
			_Font2Script
			
			cmp.w		(sp)+,d7						; If this new script doesn't match ours,
			bne.s		@5								;	then we've found the script run's end
			
			add.w		stStartSize(a2),d5				; Note that any overflows will
			sub.w		startChar(a2),d5				;	automagically sort themselves out...
			
			addq.w		#1,d4							; These 4 lines are the ugly code
			cmp.w		nRuns(a5),d4					;	that handle the case of the
			bne.s		@4								;	final style run's extra
			subq.w		#1,d5							;	count...
;
; We're done! Set up the return values into their registers, restore state, and return.
;
@5			movea.l		gcsTemp(a6),a0
			movea.w		gcsIndex(a6),a1
			move.w		d5,d0
			move.w		d7,d1
			
			movem.l		(sp)+,d2-d7/a2/a4/a5
			unlk		a6
			rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE FindWord
;
;			Finds a word @ D0 and returns its start and end+1 index in D0,D1
;			respectively. Note cannot return selStart itself - must look to left
;
;			Entry
;						A3 - dereferenced handle
;						D0 - current position (i.e. selStart)
;						D2 - identifier of routine that called FindWord
;			Exit
;						D0 - word start
;						D1 - word end+1
;
;----------------------------------------------------------------------
FindWord
			Move.L		TEFindWord,-(SP)		; call the FindWord Routine 		<EHB 01Oct85>
			Rts

fwRegs		REG			d3-d5/a0-a2

XFindWord
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Look for an overriding FindWord routine.

;;			move.l		d0,-(sp)				; preserve
;;			move.l		teWordBreak(a3),d0
;;			_StripAddress						; does return in d0
;;			move.l		ExpandMem,a0
;;			cmp.l		ExpandMemRec.emCleanWordBrk(a0),d0	; same?
;;			beq.s		@NoOverride				; Branch around wordBreak cleanup stuff
;;			move.l		(sp)+,d0				; restore
;;			bra			WBOverid				; Handle via old logic if an override exists

; If we get here, there's no wordBreak override
;;@NoOverride
;;			move.l		(sp)+,d0				; restore <21Dec88smb>
; test if RomanFindLine calling; if so, use old FindWord. added new identifier (see d2). <8June89smb>
;;			cmpi.w		#teFromFind,d2			; only called by Roman FindLine.
;;			beq			WBOverid
; Roman line wrapping should use old FindWord <7Aug89smb>
;;			cmpi.w		#teFromRecal,d2			; is line wrapping desired? (recalLines)
;;			bne.s		UseSMgrFW
; If a Roman system then use old FindWord code <19July89smb>
;;			move.l		ExpandMem,a0							; <19July89smb>
;;			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)	; number of installed scripts <19July89smb>
;;			beq			WBOverid								; use old FindWord <19July89smb>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Redone to be compatible with applications using incorrect char breaking algorithms for Script Systems
; <1/16/90smb>
; If a non-Roman system then use new FindWord code
			move.l		ExpandMem,a0
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)	; number of installed scripts
			bne.s		UseSMgrFW				; use new FindWord

; Roman-only system
; test if line breaking calling; if so, use old FindWord.
			cmpi.w		#teFromFind,d2			; called by Roman FindLine or teRecal?
			bge			WBOverid				; changed to 'bge' instead of 'bgt' <1/23/90smb>
			
; Otherwise, look for an overriding FindWord routine.
			move.l		d0,-(sp)				; preserve
			move.l		teWordBreak(a3),d0
			_StripAddress						; does return in d0
			move.l		ExpandMem,a0
			cmp.l		ExpandMemRec.emCleanWordBrk(a0),d0	; same?
			beq.s		@NoOverride				; Branch around wordBreak cleanup stuff
			move.l		(sp)+,d0				; restore (and not earlier since StripAddress returns here!)
			bra			WBOverid				; Handle via old logic if an override exists
; If we get here, there's no wordBreak override
@NoOverride
			move.l		(sp)+,d0				; restore (and not earlier since StripAddress returns here!)

UseSMgrFW
			with		FindWordFrame
			link		a6,#fwLink				; This version uses the Script Manager // <DGO 880819>
			movem.l		fwRegs,-(sp)

; The value of fwLeadingEdge is determined by which routine called FindWord.
; If RecalLines called (teFromRecal (16)), we want to look back to determine the word so
; leadingEdge is False, implying we hit on the trailing edge of a character.
; If RomanFindLine called (teFromFind (12)), we want to move forward so, leadingEdge is True.
; If FindLine called (teFromFind (12)), leadingEdge is arbitrary since we're on a character
; break when FindWord is called. (so I set it to True for consistency).
; If ClickExpand called (teWordSelect (4) or teWordDrag (8)), leadingEdge can be taken from
; teLftClick in the teRecord. <23May89smb>

			clr.w		fwLeadingEdge(a6)		; initialize (for bra to @GetSelWrap) <26Oct89smb>
			cmpi.w		#teFromRecal,d2			; is it RecalLines calling? <28Aug89smb>
			beq.s		@GetSelWrap				; yep.
; if ClickExpand calling, get leadingEdge from teLftClick in teRecord. Use teLftClick rather than
; teLftCaret since DoSearch sets teLftClick. <28Aug89smb>
			move.b		teLftClick(a3),d1		

; if calling for WordDrag then simulate Kanji code. <25Aug89smb>
			cmpi.w		#teWordDrag,d2			; <25Aug89smb>
			bne.s		@StuffIt				; <25Aug89smb>
; at this point a2 is still equal to the Left Anchor for teClick so compare the offset to it <25Aug89smb>
			cmp.w		d0,a2					; compare L. anchor to char offset <25Aug89smb>
			scc			d1						; set leadingEdge flag accordingly <25Aug89smb>
@StuffIt
			ext.w		d1
			move.w		d1,fwLeadingEdge(a6)
@GetSelWrap
			moveq		#0,d1
			cmpi.w		#teFromRecal,d2			; <28Aug89smb>
			bne.s		@3						; bra if ClickExpand calling
			not.l		d1						; RecalLines calling
@3			move.l		d1,fwSelWrap(a6)
			swap		d2
			move.w		d0,d2
			move.l		d2,fwSavedD2(a6)
			move.w		d0,d5

			tst.w		teSize(a3)
			bpl.s		FWStyle2				; If unstyled, set values specially

; First, we determine the script run to which d0 belongs. On return, a0 contains the
;	address of the 1st style run in this script run, a1 contains the index of that style
;	run, d0 contains the total length of all style runs comprising the script run, and
;	d1 contains the script number of this script run.

FWStyle
			bsr			GetCurScript			; Remember copy of original d0 is in d5, which gets saved
			move.w		d5,d3					; Copy of absolute input offset
			sub.w		startChar(a0),d3		; Now d3 has script run offset
			
; If the script run offset is zero (i.e. we're at the very first character in the script run),
;	then we need to determine the previous script run as well, unless we're at the very start
;	of the whole TERec. <12June89smb>
			bne.s		SaveScriptVars
; ... at a script run boundary
			tst.w		d5
			beq.s		SaveScriptVars
; ... beyond the start of the teRec
			tst.w		fwLeadingEdge(a6)
			bne.s		SaveScriptVars
; ... and leading edge is False, so get the previous script run
			move.w		d5,d0					; Set d0 to be the absolute index of
			subq.w		#1,d0					;	the byte *before* the current one			
			bsr			GetCurScript			; Determine that byte's script run
			move.w		d5,d3					; Copy of absolute input offset
			sub.w		startChar(a0),d3		; Now d3 has script run offset	
			
SaveScriptVars
; Now determine the values of the script run local variables and store them in the local frame.
;<12June89smb> end of mods
			move.w		d3,fwSROffset(a6)		; Save script run offset
			move.w		d0,fwSRLength(a6)		; Save script run byte length
			movea.l		teTextH(a3),a2			; Handle to actual text
			movea.l		(a2),a2					; Pointer to actual text
			adda.w		startChar(a0),a2		; Pointer to first byte in the script run
			move.l		a2,fwSRTxtPtr(a6)		; Save pointer to start of script run text
			move.w		a1,fwSRIndx(a6)			; Save style run index
			move.w		startChar(a0),fwSRStrtCh(a6)	; Save abs posn of script run start

; Save the txFont in the current grafPort.
			move.w		styleIndex(a0),d0
			bsr			GetStyle
			move.w		stFont(a0),fwSRFont(a6)
			bra.s		FWDoIt

FWStyle2
; Set the variables for the unstyled , non-overridden case.
			clr.w		fwSRStrtCh(a6)
			move.w		d5,fwSROffset(a6)
			move.w		teLength(a3),fwSRLength(a6)
			movea.l		teTextH(a3),a2
			move.l		(a2),fwSRTxtPtr(a6)
			
; Save the txFont in the current grafPort for unstyled text. <1Dec88smb>
			movea.l		teGrafPort(a3),a0		; GrafPtr for current GrafPort
			move.w		txFont(a0),fwSRFont(a6)	; Save it for now
			
; Clear some of the local frame variables 

FWDoIt		movea.l		teGrafPort(a3),a0		; GrafPtr for current GrafPort
			move.l		fwSRTxtPtr(a6),-(sp)	; Start address of this script run
			move.w		fwSRLength(a6),-(sp)	; Length of this script run
			move.w		fwSROffset(a6),-(sp)	; Offset within this script run
			move.w		fwSRFont(a6),txFont(a0)	; Set the font for this script run
			move.w		fwLeadingEdge(a6),-(sp)	; Correctly determined leftSide value
			move.l		fwSelWrap(a6),-(sp)		; Set appropriate word selection/word wrap value
			pea			fwOffTab(a6)			; Output buffer
			_FindWord
			movea.l		teGrafPort(a3),a0		; GrafPtr for current GrafPort
			move.w		fwSRFont(a6),txFont(a0)	; Faster to always reset than to selectively reset
;
; Now unpack the return values and set up for our return.
;
			move.l		fwOffTab(a6),d0
			move.l		d0,d1
			swap		d1
			cmp.w		d0,d1
			bcc.s		@3
			exg			d0,d1
@3			add.w		fwSRStrtCh(a6),d0
			add.w		fwSRStrtCh(a6),d1
FWReturn	
			move.l		fwSavedD2(a6),d2
			movem.l		(sp)+,fwRegs
			unlk		a6
			rts
			
; forced here from RomanFindLine; mask off flag in low bit of d2 <8June89smb>
			
WBOverid										; here's our FindWord				<EHB 01Oct85>
			Swap		D2						; get constant into high word		<EHB 01Oct85>
			Move.W		D0,D2					; save position in low word 		<EHB 01Oct85>

			Move.W		D0,D1
			Beq.S		RightScan

			Bsr.S		LeftScan				; do left scan 1st

; Right scan, given a char code in D1, this returns the next word break >= D1

RightScan
			BClr		#17,D2					; clear bit 17 (right)				<EHB 01Oct85>
RS1
			Cmp 		teLength(A3),D1 		; see if @ right edge
			Bhs.S		@0						; assume found if at right edge
			Move		D1,A1					; pass index
			Bsr.S		CallBreak
			Bne.S		@0
			AddQ		#1,D1					; try next char
			Bra.S		RS1 					;									<EHB 01Oct85>
@0
			Rts

; Given a char location in D0, this routine returns a new word break to left of D0

LeftScan
			BSet		#17,D2					; set bit 1 (left)					<EHB 01Oct85>
LS1
			SubQ		#1,D0					; pre decrement
			Move		D0,A1					; pass index
			Bsr.S		CallBreak				; was it a break?
			Bne.S		@0						; if so, skip town

			Tst 		D0						; are we done?
			Beq.S		@1						; if so, skip town
			Bra.S		LS1 					; keep looking
@0
			AddQ		#1,D0					; try next char
@1
			Rts

CallBreak
			movem.l 	d0-d1/a0-a1,-(sp)		; save regs - also save d1! <4/17/90smb>
			move		a1,d0					; pass index in D0
			move.l		teTextH(a3),a0			; get handle
			move.l		(a0),a0
			move.l		teWordBreak(a3),a1		; get routine
			jsr 		(a1)					; call routine which sets CC's
			movem.l 	(sp)+,d0-d1/a0-a1		; restore regs - also restore d1! <4/17/90smb>
			rts

DefWordBrk
; lo16 is used by TE as a constant for clearing the high word of registers
lo16		Equ 		*+2
			And.L		#$0000FFFF,D0			; longize it
			Cmp.B		#$20,0(A0,D0.L) 		; see if <= $20
			Sls 		D0						; return if word break(SP)
			Tst.B		D0
			Rts
			endwith								; with FindWordFrame <23May89smb>

 if 0 then	; unneeded
; Measures the trimmed string in [D6..D7)

TrimMeasure
			MoveM.L 	D6-D7,-(SP) 			; save regs
			Bsr 		MeasD6D7
			MoveM.L 	(SP)+,D6-D7 			; restore regs
			Rts
 endif
			
;formFeed
;------------------------------------------------------------------
;			FindLine 			<18Nov88smb>
;
;			This routine breaks a line on a word boundary.  It uses the SMgr
;			version of StyledLineBreak. It returns whether the routine broke on a word or
;			character boundary, or the display width extended beyond the edge of the text.
;			If the width extends beyond the edge of the text and we have multi-formats 
;			then we must look for the line break within the next format run.
;
;			Function StyledLineBreak (textPtr:Ptr; textLen:LongInt; textStart:LongInt; textEnd:Longint;
;								flags:LongInt; Var textWidth:Fixed; Var textOffset:Longint)
;				:LineBreakCode;
;
;	Input:
;		a3: ptr to edit record
;		d6: lineStart of line containing selStart
;	Output:
;		d0: line end after d6
;	Register Usage:
;		a0: current style run
;		a1: nextStyleRun
;		a2: textPtr
;		d0,d1: scratch
;		d7: mult styles flag
;------------------------------------------------------------------
			
FindLine	Move.L		TEFindLine,-(SP)		; push current FindLine routine 	<EHB 01Oct85>
			Rts 								; and call it						<EHB 01Oct85>
XFindLine

FindLineRegs	reg		d1-d7/a0-a2
; left this test here rather than move to RecalLines since it would be duplicated 4x in RecalLines <12july89smb>
; If a Roman system then use old FindLine code: performance improvement <5May89smb>
			move.l	ExpandMem,a0			; <1Feb89smb>
			cmpi.b	#1,ExpandMemRec.emScriptsInstalled(a0)	; total number of installed scripts
			beq		NewRomanFindLine			; use new Roman FindLine								<20>
			Movem.l	FindLineRegs,-(sp)			; preserve whether use new or old FindLine
			with	LineBreakFrame
			link	a6,#localFrame
; initializations
			moveq	#0,d7						; flag multiple styles: init to single style
			move.w	d6,lineStart(a6)
			move.w	d6,EOLCharPosn(a6)			; start for new EOL position calculation
			clr.w	textPtrOffset(a6)

; set up textWidth: pixel width for displaying the text
			moveq	#0,d0
			move.w	teDestRect+right(a3),d0		; right edge
			sub.w	teDestRect+left(a3),d0
			swap	d0							; width is FIXED
			move.l	d0,width(a6)				; textWidth

; textLength: is necessary for CR test and unstyled text
			moveq	#0,d1						; longize
			move.w	teLength(a3),d1				; doc length
			sub.w	d6,d1						; adjusted to lineStart position
			move.l	d1,length(a6)

; textPtr: pointer to current lineStart position.
			movea.l	teTextH(a3),a2				; handle to start of text
			movea.l	(a2),a2						; dereference
			add.w	d6,a2						; begin search for CR here <17Nov88smb>
			
; if we are in CR only mode, just search for a CR
;;			addq.w	#1,d1						; incr for initial decr below in dbeq test <17Nov88smb>	<16>

			tst.b	teCROnly(a3)
			bge.s	@StyleCheck					; changed from beq to bge <2May89smb>
			; notice: CCs are set to not equal AT THIS POINT based on test of CROnly.
			bra.s	@CheckLength				; zero check
@CRLoop
			move.b	(a2)+,d0					; is it a CR? changed to byte <28Jan89smb>
			Bsr		TEEOLHook
@CheckLength
			dbeq	d1,@CRLoop
			beq.s	@GotCR
			move.w	teLength(a3),d0				; return end of text if CR not found
			bra		@finis						; <17Mar89smb>

@GotCR
			move.w	teLength(a3),d0				; doc length <15Mar89smb>
			sub.l	d1,d0						; - characters left
;;			addq	#1,d0						; go one beyond the CR <15Mar89smb>						<16>	
			bra		@finis						; <17Mar89smb>
; End of CR check

@StyleCheck
;;			subq.w	#1,d1						; decr from CR test above <17Nov88smb>					<16>
			move.l	a2,textPtr(a6)
			move.l	a2,initlTextPtr(a6)
			
; test for new style edit record
			tst.w	teSize(a3)					; check style flag
			bpl		@noStyle					; don't set style: old-style edit record
			
; test for single or multiple format runs in the text
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			cmpi.w	#1,nRuns(a1)
			beq.s	@OneStyle					; bra if one style
			
			moveq	#1,d7						; flag multiple styles to process
@OneStyle
			moveq	#0,d0
			move.w	d6,d0
			bsr		GetCurStyle					; a0: ptr to current style, d0: style index
			addq.w	#1,d0						; index returned is 0 based but nRuns isn't
			move.w	d0,styleIndex(a6)
; test for last style run <5Dec88smb>
			movea.l	teStylesH(a3),a1			; handle to teStyleRec <5Dec88smb>
			movea.l	(a1),a1						; <5Dec88smb>
			cmp.w	nRuns(a1),d0				; <5Dec88smb>
			bcs.s	@StyleLoop					; <5Dec88smb>	<26June89smb> made unsigned
			moveq	#0,d7						; on last style run <5Dec88smb>
			
; Only one run so set up real length of run. The last entry in the styleRun table has
; a startChar posn equal to teLength+1. Must subtract the extra 1 to get the real length
; of the run. <28Nov88smb>

@StyleLoop
			lea		stStartSize(a0),a1
			move.l	a0,currStyle(a6)			; save for StyledLineBreak result test
			move.l	a1,nextStyle(a6)
			Bsr		SetStyle					; set grafport style from current style in a0
			
; Set up textPtr & length to the beginning of the script run.  Call GetCurScript which returns
; the address of 1st style run in the script run in a0 and the length in d0 of all style runs
; comprising this script run.  The script run may begin prior to this lineStart so must
; adjust the textPtr and length accordingly.  Also use the script run to determine the offset
; value, on input, to StyledLineBreak.  This value tells the routine if this is the first script
; run on the line, which affects the returned result and offset.

			move.w	d6,d0
			bsr		GetCurScript
			; returns d0 = total length of script run, a0 = addr of first style run in script run
			move.l	#0,offset(a6)				; assume it's not the 1st script run <12June89smb>
			
; pin beginning of script run to beginning of line
			move.w	startChar(a0),d1			; 1st style run of script run
			cmp.w	lineStart(a6),d1
			blo.s	@AdjustLength				; bra if textPtr ok
			beq.s	@AdjustOffset
			sub.w	lineStart(a6),d1			; offset from lineStart to beginning of script run
			move.l	initlTextPtr(a6),a0			; initial ptr at beginning of line
			add.w	d1,a0						; adjust to beginning of script run <21Mar89smb>
			move.l	a0,textPtr(a6)
			move.w	d1,textPtrOffset(a6)		; need for adjusting textStart and End
			bra.s	@LengthOK

@AdjustLength
			move.w	lineStart(a6),d2
			sub.w	d1,d2						; distance from start of script run to lineStart
			sub.w	d2,d0						; adjust to current line start
@AdjustOffset
; Set the offset parameter to non-zero since this is the 1st script run on the line.
			move.l	#1,offset(a6)				; necc for corrections to SMgr routine <8June89smb>
@LengthOK
; not the last run yet so use real length of run
;; replaced next 3 lines <17July89smb>
;;			move.w	d0,-(sp)					; longize - (can't use 'ext' since SMgr expects 
;;			moveq	#0,d0						;  0s in the high word!)
;;			move.w	(sp)+,d0
			swap	d0							; <17July89smb>
			clr.w	d0							; clear high word for SMgr call <17July89smb>
			swap	d0							; restore <17July89smb>
			move.l	d0,length(a6)

; set up textStart (beginning of style run) and textEnd (end of style run) as offsets from textPtr
; get the textStart, offset from textPtr
			moveq	#0,d1						; longize
			move.l	currStyle(a6),a0
			move.w	startChar(a0),d1			; get start of this format run
			cmp.w	lineStart(a6),d1			; must pin to this LineStart!
						
			bhs.s	@UseStyleStart				; bra if should use start of style run
			move.w	d6,d1						; use beginning of line
			
@UseStyleStart
			move.l	d1,start(a6)
; offset start and end from current textPtr posn
			move.w	lineStart(a6),d0
			add.w	textPtrOffset(a6),d0
			sub.l	d0,start(a6)				; adjust textStart to textPtr's offset

; get the textEnd, offset from textPtr
			move.w	stStartSize(a0),d1			; end of style run
			sub.l	d0,d1
			move.l	d1,end(a6)					; adjust textEnd to end of format run
			tst.w	d7							; test for one or last style
			bne.s	@SetUp						; multiple styles so can use next style run for length
			sub.l	#1,end(a6)
			bra.s	@SetUp

@noStyle
			move.w	#0,currStyle(a6)			; needed for a termination test
; set up textStart and textEnd for non-styled text
			move.l	#0,start(a6)				; absolute posn from beginning of text		
			move.l	length(a6),end(a6)
; Set the offset parameter to non-zero since this is the 1st script run on the line (AND THE ONLY ONE!) <15Dec89smb>.
			move.l	#1,offset(a6)				; necc for corrections to SMgr routine <15Dec89smb>

; call StyledLineBreak
@SetUp
			move.w	#0,-(sp)					; allocate return
			move.l	textPtr(a6),-(sp)			; textPtr
			move.l	length(a6),-(sp)			; textLength
			move.l	start(a6),-(sp)				; textStart
			move.l	end(a6),-(sp)				; textEnd
			move.l	#0,-(sp)					; no slop
			pea		width(a6)					; var textWidth: pass @width
			pea		offset(a6)					; var textOffset: pass @offset
			_StyledLineBreak					; call SMgr

			clr.w	d1
			move.b	(sp)+,d1					; word, char, or overflow break?
			cmpi.w	#smBreakOverflow,d1
			beq.s	@noLineBreak				; overflow!
			bra.s	@FindLineDone				; broke on a char or word boundary in this fmt run (or 
												; possibly the previous one for word breaks)  
@noLineBreak
; if the routine returns an overflow break (the display rectangle width was > the text width)
;	then the text width is returned in width(a6).  If another style exists, call StyledLineBreak
;	again with the width returned.

			tst.w	d7							
			beq.s	@FindLineDone				; only one or last style to process

; test if we just processed the second to last format run
			movea.l	teStylesH(a3),a1			; handle to teStyleRec <24Nov88smb>
			movea.l	(a1),a1
			move.w	styleIndex(a6),d0
			addq.w	#1,d0						; for next style run
			move.w	d0,styleIndex(a6)			
			cmp.w	nRuns(a1),d0				; at last style run? <24Nov88smb>
			bne.s	@DoFmtRun
			
; last format run: last entry of style run table is a dummy entry = teLength + 1
			moveq	#0,d7						; flag no more runs after this one
; special test for case of dummy RUN of 1 char, which is 1 longer than the teLength, as found
; in KanjiTalk. <9June89smb> test here to save some other processing.			
			move.l	nextStyle(a6),a0
			move.w	stStartSize(a0),d6
			sub.w	startChar(a0),d6
			subq.w	#1,d6
			beq.s	@FindLineDone

@DoFmtRun			
; use the next format to continue searching for a line break position.
; accumulate style offsets on line for line end
			moveq	#0,d0
			move.w	offset+2(a6),d1
			sub.l	start(a6),d1				; get the offset relative to the text start
			add.w	d1,EOLCharPosn(a6)
			move.l	nextStyle(a6),a0
			lea		stStartSize(a0),a1
			move.w	startChar(a0),d6
			bra		@StyleLoop
			
@FindLineDone
; return d0 = length
			moveq	#0,d0
			move.w	offset+2(a6),d0				; offset mod 64K
			sub.l	start(a6),d0				; get the offset relative to the text start
			add.w	EOLCharPosn(a6),d0			; absolute position
@finis
			unlk	a6
			movem.l	(sp)+,FindLineRegs			; restore
			rts
			endWith
						
;formFeed
;----------------------------------------------------------------------
;			PROCEDURE NewRomanFindLine
;
;		Entry
;			d6	start of line search assumed to be at 1st word?
;			a3	dereferenced handle
;		Exits
;			d0 with line end after d6
;		Register usage
;			d4	width to measure
;			d7	flag to indicate multiple styles in record
;----------------------------------------------------------------------
NewRomanFindLine
			Movem.l	FindLineRegs,-(sp)			; preserve whether use new or old FindLine
			with	LineBreakFrame
			link	a6,#localFrame

; textLength: is necessary for CR test and unstyled text
			moveq	#0,d1						; longize
			move.w	teLength(a3),d1				; doc length
			sub.w	d6,d1						; adjusted to lineStart position
			move.l	d1,length(a6)

; textPtr: pointer to current lineStart position.
			movea.l	teTextH(a3),a2				; handle to start of text
			movea.l	(a2),a2						; dereference
			add.w	d6,a2						; begin search for CR here
			
			tst.b	teCROnly(a3)				; do we only want to break on CRs?
			bne		@CROnlyMode					; yup.

; more initializations
			move.l	a2,textPtr(a6)
			moveq	#0,d7						; flag multiple styles: init to single style
			move.w	d6,lineStart(a6)
			move.w	d6,EOLCharPosn(a6)			; start for new EOL position calculation

; set up textWidth: pixel width for displaying the text
			moveq	#0,d4
			move.w	teDestRect+right(a3),d4		; right edge
			sub.w	teDestRect+left(a3),d4
;;			subq	#1,d4						; reduce for caret indent						<28>
			move.l	d4,width(a6)				; textWidth
			
; test for new style edit record
			tst.w	teSize(a3)					; check style flag
			bpl		@CallP2C					; old-style edit record
			
; test for single or multiple format runs in the text
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			cmpi.w	#1,nRuns(a1)
			beq.s	@DoStyle					; bra if one style
			
			moveq	#1,d7						; flag multiple styles to process
@DoStyle
			moveq	#0,d0
			move.w	d6,d0
			bsr		GetCurStyle					; a0: ptr to current style, d0: style index
			addq.w	#1,d0						; index returned is 0 based but nRuns isn't
			move.w	d0,styleIndex(a6)
; test for last style run
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			cmp.w	nRuns(a1),d0				; is styleIndex < nRuns?
			bcs.s	@StyleLoop					; yes
			moveq	#0,d7						; on last style run
			
; only one run so set up real length of run. The last entry in the styleRun table has
; a startChar posn equal to teLength+1. Must subtract the extra 1 to get the real length
; of the run.

@StyleLoop
			move.l	a0,currStyle(a6)
			lea		stStartSize(a0),a1
			move.l	a1,nextStyle(a6)
			Bsr		SetStyle					; set grafport style from current style in a0
			
; set up textStart (beginning of style run) and pin to lineStart
			moveq	#0,d1						; longize
			move.l	currStyle(a6),a0
			move.w	startChar(a0),d1			; get start of this format run
			cmp.w	lineStart(a6),d1			; must pin to this LineStart!
			bhs.s	@GetLength					; bra if should use start of style run
			move.w	d6,d1						; use beginning of line
			
@GetLength
; get the length
			moveq	#0,d0						; longize
			move.w	stStartSize(a0),d0			; end of style run
			sub.w	d1,d0						; minus the style start
			move.l	d0,length(a6)
; test for one or last style to adjust length
			tst.w	d7							
			bne.s	@CallP2C					; multiple styles so can use next style run for length
			sub.l	#1,length(a6)
;-----------------------------------------------
@CallP2C
; call Pixel2Char
			move.l	textPtr(a6),a0				; textPtr
			move.w	length+2(a6),d0				; textLength (style run length)
			move.w	width+2(a6),d1				; width
			clr.l	d2							; no slop
			bsr		TEHitTestHook				; call Pixel2Char
			; returns:
			;	d0	(low word)	pixel width to character offset in block
			;		(high word)	boolean = TRUE (0001) if offset corresponding to
			;		 the given pixel width was found (ONLY when hook is used!)
			;	d1.w character offset
			;	d2.w flagged (0001) if hit on leading edge of char (but not used here)

			move.w	d1,d3						; save char offset until after CR test			
			sub.w	d0,d4						; update pixel width
			bls.s	@CRTest						; got a hit (width <= 0)

; if at the last style, and pixel width > 0, and the TEHitTestHook is replaced, then
; must check the high word of d0 to see if we REALLY got a hit! <2/16/90smb>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	HitTestHook(a0),a0
			pea		Pixel2Char
			cmpa.l	(sp)+,a0
			beq.s	@NotAHit
; we've been hooked out so test per the old interface specs for a hit.
			swap	d0
			tst.b	d0
			bne.s	@CRTest
;----------------------------------------------------------------------
@NotAHit
; test for CR
			move.l	textPtr(a6),a2
			move.w	length+2(a6),d1
			bsr		TestForCR
			tst.b	d0							; did we find a CR?
			beq.s	@NoCR						; no, just measure
; found a CR
			move.w	length+2(a6),d0				; style run length
			sub.l	d1,d0						; - characters left		(should make this .w)	<27>x
			add.w	EOLCharPosn(a6),d0			; new break posn
			bra		@finis
@NoCR
			move.l	d4,width(a6)				;  and save as long.
			add.w	d3,EOLCharPosn(a6)			; update char offset
			tst.w	d7							
			beq		@setResult					; only one style or last style to process

; test if we just processed the second to last format run
			movea.l	teStylesH(a3),a1			; handle to teStyleRec
			movea.l	(a1),a1
			move.w	styleIndex(a6),d0
			addq.w	#1,d0						; for next style run
			move.w	d0,styleIndex(a6)			
			cmp.w	nRuns(a1),d0				; at last style run?
			bne.s	@DoNextRun
			
; last format run: last entry of style run table is a dummy entry = teLength + 1
			moveq	#0,d7						; flag no more runs after this one
; special test for case of dummy RUN of 1 char, which is 1 longer than the teLength, as found
; in KanjiTalk. Test here to save some other processing.			
			move.l	nextStyle(a6),a0
			move.w	stStartSize(a0),d6
			sub.w	startChar(a0),d6
			subq.w	#1,d6
; MathCad creates a 0 length style run at the end of the StyleRun array of teLength->teLength,	<24>
; instead of teLength->teLength+1, so we're testing for their bug here!							<24>
			ble		@setResult					; problem of 0 length style run in MathCad		<24>
;;			beq		@setResult					;				change branching condition		<24>

@DoNextRun			
; use the next format to continue searching for a line break position.
; accumulate style offsets on line for line end

			move.l	nextStyle(a6),a0
			move.w	startChar(a0),d6
			moveq	#0,d0						; clear high word before add					<30>
			move.w	length+2(a6),d0
			add.l	d0,textPtr(a6)				; update textPtr to the next style run
			bra		@StyleLoop

;----------------------------------------------------------------------
; on the way out now…
;----------------------------------------------------------------------

@CRTest
; test for CR
			move.l	textPtr(a6),a2
			move.w	d3,d1						; offset of char hit is length to use when searching for CR
			bsr		TestForCR
			tst.b	d0							; did we find a CR?
			bne.s	@GotCR						; yes, done earlier than hit!

; no CR found, so use char offset but back up to word boundary
			add.w	d3,EOLCharPosn(a6)			; update char offset
			move.w	EOLCharPosn(a6),d0
; Must test if at a blank since FindWord will backup before testing if not @ posn. 0.			<23>
; the problem this introduces is that we will not use an appications hook to teWordBreak if
; there is a blank or non-graphic character in this position.
			tst.b	d0							; 												<23>
			beq.s	@CallFW						; 												<23>
@WrdBrkLoop
			move.w	d0,a1						; CallBreak wants offset here					<23>
			bsr		CallBreak					; calls Roman wordbreak hooked routine			<23>
			beq.s	@CallFW						; CCs set if char<=$20 & d0 = wordstart			<23>
; point past the break character and look for another break character until at EOD				<23>
			cmp.w	teLength(a3),d0				; is this break character at the EOD			<23>
			beq		@HaveWordSt					; yes, so done									<23>
; check if the break character is a CR! don't look ahead if so!									<26>
			movea.l	teTextH(a3),a2				; handle to start of text						<26>
			movea.l	(a2),a2						; dereference									<26>
			move.w	d0,-(sp)					; save wordStart								<26>
			addq.w	#1,(sp)						; incr beyond this break character				<26>
			move.b	0(a2,d0.w),d0				; fetch the char to test						<26>
			Bsr		TEEOLHook					;												<26>
			movem.w	(sp)+,d0					; don't change CCs								<26>
			; now bra based on result of TEEOLHook 												<26>
			beq.s	@finis						; found a CR so done							<26>
; is a break char but not a CR so, try again													<26>
;;			addq	#1,d0						; no, so look ahead for next break character	<23><26>
			bra.s	@WrdBrkLoop					;												<23>

@CallFW
			MoveQ	#teFromFind,d2				; say findLine is calling
			bsr		FindWord					; word start in d0, word end in d1
@HaveWordSt

; must pin word start to lineStart for the case that it breaks across a word
			cmp.w	lineStart(a6),d0			; d6 changes for styled so use actual lineStart	<23>
			bls		@setResult
; test for case of 0 returned if line has no blanks
; (XX) these two lines seem to be redundant!!! (XX)
			tst.w	d0							; non-zero word start is ok
			bne.s	@finis
			move.w	EOLCharPosn(a6),d0			; assume P2C result is less than word end found
			cmp.w	d1,d0						; use smaller of two
			bls		@finis						; use P2C result
; (XX) we should never come here! (XX)			
			move.w	d1,d0						; use word end found
			bra		@finis

@GotCR
			move.w	d3,d0						; style run length
			sub.l	d1,d0						; - characters left		(should make this .w)	<27>x
			add.w	EOLCharPosn(a6),d0			; new break posn
			bra		@finis

;-----------------------------------------------
@CROnlyMode			
; since we are in CR only mode, just search for a CR
			bsr		TestForCR
			tst.b	d0							; did we find a CR?
			bne.s	@FoundCR					; yes
			move.w	teLength(a3),d0				; no, return end of text
			bra		@finis
@FoundCR
			move.w	teLength(a3),d0				; doc length <15Mar89smb>
			sub.l	d1,d0						; - characters left
			bra		@finis
; End of CR check
;-----------------------------------------------
@setResult	move.w	EOLCharPosn(a6),d0			; want result in d0
@finis
			unlk	a6
			movem.l	(sp)+,FindLineRegs			; restore
			rts
			endWith

;----------------------------------------------------------------------
;			PROCEDURE TestForCR
;			Called by NewRomanFindLine to search for a carriage return.
;		Entry
;			d1.w = length to search
;			a2.l = text pointer
;		Exit
;			d0.b = TRUE (FF) if CR found
;			d1.w = characters left
;		Uses d0,d1
;----------------------------------------------------------------------
TestForCR
			tst.w	d1							; is the initial length 0?
			beq.s	NoCR
			; notice: CCs are set to NOT EQUAL at this point.
			bra.s	@TestLength
@CRLoop
			move.b	(a2)+,d0					; is it a CR? changed to byte
			Bsr		TEEOLHook
@TestLength
			dbeq	d1,@CRLoop
			beq.s	GotCR
			bra		NoCR						; no CR in this run, just measure
NoCR
			sf		d0							; return F
			rts
GotCR
			st		d0							; return T
			rts
;formfeed
;----------------------------------------------------------------------
;
;			PROCEDURE ReCalLines
;
;			** Modified 6/18/86 by MBK **
;
;			Recalibrates the line start array and sets dispStart/dispEnd to
;			correct redraw spot.  Starting with the selection, it figures out
;			which line the selection is on.  Then it recalibrates the line starts
;			from there until the delta in D7 is consumed (the word wrap has
;			petered out).  It returns D2 and D4 to the redraw start and end.
;			(It should return D3 instead of D2, but for compatibility it uses
;			D2).
;
;		Entry
;			A4 points to handle
;			A3 points to dereferenced TE object
;			D7 contains delta in change = oldLength-newLength
;			teLength(a3) reflects the new length (at least for deletion)
;		Exit
;			dispStart(D2) now set to redraw start
;			dispEnd(D4) set to redraw end
;		Uses
;			d2	redraw start position (aka savedD2)
;			d3	initialized to word boundary at selStart(a3)
;			d4	redraw end position	(aka savedD4)
;			d5	for handle size
;			a2	ptr to current lineStarts(a3) position
;----------------------------------------------------------------------
;
; ** <C105/3Sep86/MBK> ** Stages 2 and 3 of Recal were totally rewritten for
;							speed.  I decided the insert and delete cases were
;							different enough to justify handling them separately.
;
ReCalLines
			Move.L		TERecal,-(SP)
			Rts
XReCalLines
ReCalLinesRegs	reg		D3/D5-D6/A2
			Link		A6,#RecalLink
			movem.l 	ReCalLinesRegs,-(SP)	; save regs
			
; initialize
			Move.W		teNLines(A3),oldNLines(A6) ; save old # of lines		** <C229/28oct86/MBK> **
			Clr.W 		teNLines(A3)	 		; prime nLines:=0
			Clr.W		savedD2(A6)				; default redraw beginning
			Move		teLength(A3),savedD4(A6); default redraw end
			
			Tst.W		teLength(A3)			; any text?
			Beq			ClrLineSts				; <19Mar89smb> if not, nothing to recal			
;;			Beq.S		ReCalDone				; if not, nothing to recal		<C971/RWW102887>NO

			Lea			teLines(A3),A2			; point to line starts
			MoveQ		#teFromRecal,D2 		; say ReCalLines is calling 		<EHB 01Oct85>
			Move		teSelStart(A3),D0		; put start position in D0			<EHB 01Oct85>
			Bsr			FindWord				; get word around selstart for comparison <C971/RWW102887>NO
			Move		D0,D3					; returned word boundary

; D3 contains the start point to recal from, so find the line containing D3

InitLineStLoop
			Move		(A2)+,D6				; i(start):=lineStarts[line]
			Move		D6,savedD2(A6)			; save away as default redraw start

			Cmp 		(A2),D3 				; while selWord<lineStarts[line+1]
			Blo.S		FoundLineBounds			; if inclusive (d3 contained between savedD2 & a2)
			Beq.S		AtNextLineStart 		; if at next line start

			AddQ		#1,teNLines(A3) 		; one more line, keep looking for
			Bra.S		InitLineStLoop			; line containing selStart(D3)

; The redraw start is in savedD2, which reflects the lineStart of d3.
;------------------------------------------------
AtNextLineStart
; d3 is on the boundary of the next lineStart
			Bsr			FindLine				; get line end after D6				<C971/RWW102887>NO
			Cmp 		D0,D3					; did the line break change? (ie - different from current a2)
			Bne.S		DrawWholeLine			; if so, must redraw whole thing<C971/RWW102887>NO
			Move		D3,savedD2(A6)			; "next" line OK if at beginning
			Bra.S		TestRedraw				;								<C971/RWW102887>NO

;------------------------------------------------
FoundLineBounds
; d3 is contained between the lineStarts of this line
			Bsr			FindLine				; get line end after D6				<C971/RWW102887>NO
			Cmp 		D0,D3					; did the line break change? (is d3 beyond this line end?)
			Bhs.S		DrawWholeLine			; if so, must redraw whole thing
TestRedraw										;									<EHB 05-Nov-85>
			Tst.B		WordRedraw				; should we redraw the whole word?	<EHB 31-Oct-85>
			Bgt.S		DrawWholeLine			; => yes, app wants whole word		<EHB 31-Oct-85>
			Blt.S		DoRecal 				; => app wants whole line			<EHB 01-Nov-85>

; final determination of redraw start position
			Move		teSelStart(A3),D3		; reset d3 from word boundary to selStart
DrawWholeLine

	IF forLocalizability THEN					; <40-YDS-2/5/92>
			Cmp.w		#teForceLeft,teJust(A3)	; are we forcing left ?
			Beq.S		@1						; if so, skip the TESysJust test.
	ENDIF

			Tst.W		teJust(A3)				; see what format: for right or
			Bne.S		DoRecal 				; centered, must use linestart (not selStart)
	
			Tst.W		TESysJust				; check text direction	** <C105/14aug86/MBK> **
			Bne.S		DoRecal					; not left				** <C105/14aug86/MBK> **

; Special case: redraw line didn't work because FoundLineBounds jumped here w/o checking the redraw flag.
@1			Tst.B		WordRedraw				; should we redraw the whole word?	** <C454/21nov86/MBK> **
			Blt.S		DoRecal 				; => app wants whole line			** <C454/21nov86/MBK> **	<19>
; restored to original state																					<19>
;;			Bne.S		DoRecal 				; => app wants whole line for double-byte as well! <12/14/88smb><19>

; if here, then teJust = teSysJust = 0 AND wordRedraw = 0 or 1.
			Move		D3,savedD2(A6)			; return word start-1
			Beq.S		DoRecal
; must call DoubleByte here to backup to the correct position													<25>
			subq		#1,savedD2(a6)
			tst.b		wordRedraw				; if Roman then don't call DoubleByte							<25>
			beq.s		DoRecal					;																<25>
			movem.l		d0-d4/d6/d7/a2,-(sp)	; save regs across call	(better safe than sorry!)				<25>
			move.w		d3,d6					; DoubleByte wants offset here									<25>
			move.w		#-1,d3					; incremental direction to move									<25>
			bsr			DoubleByte				;																<25>
			move.w		d6,savedD2(a6)			;																<25>
			movem.l		(sp)+,d0-d4/d6/d7/a2	;																<25>
;;			Bra.S		DoRecal					<16> unnecessary

DoRecal
; d3 reflects the start position for the recalibration of the line
			Move.W		D0,D3					; save next line start in D3

;------------------------------------------------
	If &TYPE('&RWWDebug') <> 'UNDEFINED' Then
			Tst.W		D7						; insertion or deletion?
			Ble.S		@0

; If some characters on a line are replaced by (a fewer number of) CRs
; the deletion algorithm does not work correctly because it is not
; prepared to add new lines.  So now I just call the insertion algorithm
; except for this special case, when character(s) at the beginning of
; the line are being deleted (the insertion algoritm doesn't work
; in this case).  Maybe someday this whole recalibration thing will
; get rewritten!
; Changed this once again. Selstart will equal selEnd whenever TEDelete was called.
; Only call InsertRecal if this was an insertion that was shorter than the selection.

			Move.W		teSelStart(A3),D0
			Cmp.W		teSelEnd(A3),D0
			Bne.S		@0

			Bsr.S		DeleteRecal				; recal for deletions
			Bra.S		ReCalDone

	EndIf		; <PMAB381/RWW020488>
;------------------------------------------------

@0
			IF			&TYPE('&RWWDebug') = 'UNDEFINED' THEN
			Bsr.s		InsertRecal				; recal for insertions
			ELSE
			Bsr			InsertRecal				; recal for insertions
			ENDIF

			Bra.s		ReCalDone				; <19Mar89smb>
ClrLineSts										; <19Mar89smb> clear first two words of lineStarts array
			move.l		#0,teLines(a3)
;------------------------------------------------
			
ReCalDone	Bsr			SetLineHite				; reset line heights	** <C229/28oct86/MBK> **
			Move.W		savedD4(A6),D4			; return start and end	** MBK 6/18/86 **
			Move.W		savedD2(A6),D2			;						** MBK 6/18/86 **

; ** <C971/RWW102287>	Rudy D. memorial lineStarts hack.
;					Force TERecord to be proper length.
cutBackSlop	Equ			8

			Move.L		A4,A0					; How fat is TERecord now?			<C971/RWW102987>
			_GetHandleSize						;									<C971/RWW102987>
			Tst.L		D0						; check for error					<C971/RWW102987>
			Bpl.S		@2
			_SysError							; fly away if system error			<C971/RWW102987>

@2			Sub.L		#teRecSize,D0			; lose header						<C971/RWW102987>
			LsR.L		#1,D0					; account for word sized table		<C971/RWW102987>
			And.L		#$7FFF,D0				; gotta be fewer than 32K lines		<C971/RWW102987>
			Sub.W		teNLines(A3),D0			; blow off cutback					<C971/RWW102987>
			Bz.S		@1						; didn't change at all				<C971/RWW102987>
			Bmi.S		@1						; got larger.  Munger handled it	<C971/RWW102987>
			Cmp.W		#cutBackSlop,D0			; is difference less than slop		<C971/RWW102987>
			Blo.S		@1						; Yes, so don't bother memory mgr	<C971/RWW102987>

			MoveQ		#0,D0					; Gotta talk longs, here			<PMAB345/C990/RWW121687>
			Move.W		teNLines(A3),D0			; Fetch number of lines				<PMAB345/C990/RWW121687>

			LsL.L		#1,D0					; account for word offset			<C971/RWW102287>
			Add.L		#teRecSize,D0			; Add in rest of record				<C971/RWW102287>
			Move.L		A4,A0					; TEHandle is what we're resizing	<C971/RWW102287>
			Bsr			MySetHandleSize			; Go do it							<C971/RWW102287>
@1												;									<C971/RWW102287>

			MoveM.L 	(SP)+,ReCalLinesRegs	; restore regs
			Unlk		A6

			Rts 								; see you later
			
;formFeed
;------------------------------------------------------------------
;			PROCEDURE InsertRecal
;
;			Only called from ReCalLines.
;
;			Entry
;			d3	line start of next line
;			d6	lineStart(a3) of line containing savedD2(a6) (redraw start position)
;			d7	delta = oldLength-newLength
;			a2	line starts array
;			savedD2(a6)	redraw start position
;
;			Uses
;			d4	loop terminator for determining next line end; initialized to selEnd 
;			d5	lineStart counter
;			** <C105/3Sep86/MBK> ** Stages 2 and 3 for insertion only
;------------------------------------------------------------------
InsertRecal
			MoveM.L		D2/D4,-(SP)				; save stuff

			MoveQ		#0,D5					; size of temp line start array
			Move.W		teSelEnd(A3),D4

	If &TYPE('&RWWDebug') = 'UNDEFINED' Then
			Tst.W		D7						; Only do "subtraction" if negative		<PMAB381/RWW020488>
			Bpl.S		@PosDeltaLength			;										<PMAB381/RWW020488>
	EndIf

			Sub.W		D7,D4					; new terminator: selEnd + delta
@PosDeltaLength

; ** <C393/10nov86/MBK> ** MyNewHandle unlocks the TEHandle for memory allocation and
; resets the A3 ptr, so the A2 ptr must also be reset
			Sub.L		A3,A2					; save A2 as an offset			** <C393/10nov86/MBK> **
			Move.L		#defBufSize,D0			; don't want to reset too often	** <C381/6nov86/MBK> **
			Move.L		D0,D2					; save initial handle size
			Bsr			MyNewHandle				; temp handle for line starts	** <C381/7nov86/MBK> **
			_HLock								; play it safe
			Move.L		(A0),A1					; save ptr
			Move.L		A0,startHndl(A6)		; save handle

			Add.L		A3,A2					; restore A2 as a ptr			** <C393/10nov86/MBK> **
			Move.L		A2,savePtr(A6)			; current line start ptr

;------------------------------------------------
iLineLoop

; If the width of a single character > the width of the window, Recal keeps
; finding the same line (line 1) forever.  If this happens, don't keep trying
; to wrap, just advance to the next character.
			Cmp.W		D6,D3					; same as old value?		** <C440/18nov86/MBK> **
			Bne.S		@CharWidthOK			; ok if not					** <C440/18nov86/MBK> **
			AddQ		#1,D3					; else advance to next char	** <C440/18nov86/MBK> **
@CharWidthOK

			Cmp 		D4,D3 					; beyond selEnd?
			Bls.S		SaveLineSt				; if not, save lineStart and fetch next one

; have calculated all necessary lineStarts: proceed!
; test for CR
			Move.L		teTextH(A3),A0			; get text handle
			Move.L		(A0),A0					; deref
			Move.B		-1(A0,D3),D0			; THESE TWO LINES REPLACE PREVIOUS	<C971/RWW110387>
			Bsr			TEEOLHook				;									<C971/RWW110387>

			Bne.S		@3						; keep going if not CR

			Move.L		A2,A0					; set current ptr
			Move.W		D3,D0					; get line start
			Add.W		D7,D0					; minus delta (D7 is neg) <not always!>

; find the old value of this line start for moving down remaining line starts
@OldLineStLoop
			Cmp.W		(A0)+,D0
			Bhi.S		@OldLineStLoop			; made this unsigned	** <C381/6nov86/MBK> **

			SubQ		#2,A0					; got over-incremented
			Move.L		A0,savePtr(A6)			; save it
			Bra 		iStage3					; on to stage 3 		<SM7> CSS 

@3
; D5 (temp lineStart array) may be greater than the old number of lines, so skip the
; delta check if so.  This was a really obscure bug which only hurt us when
; D0 happened to be equal to D7.
			MoveQ		#0,D0					; clear entire register
			Move.W		oldNLines(A6),D0		; get old # of lines
			Add.W		D0,D0					; double for word entries
			Cmp.L		D0,D5					; have we exceeded the length of the array?
			Bhs.S		SaveLineSt				; skip delta check if so

			Move.W		0(A2,D5.L),D0			; get old start
			Sub 		D3,D0	 				; oldStart - newStart

			Cmp 		D0,D7 					; compare to delta
			Bne.S		SaveLineSt				; keep trying if not same

			Add.L		D5,savePtr(A6)			; set old start for move down
			Bra.S		iStage3
			
SaveLineSt
; increase sizes of temporary arrays if needed
			Cmp.L		D5,D2					; time to increase sizes?
			Bgt.S		@0

			Move.L		startHndl(A6),A0		; temp line starts handle
			_HUnlock
			Add.L		#defBufSize,D2			; inc size for line starts	** <C381/6nov86/MBK> **
			Move.L		D2,D0
			Sub.L		(A0),A1					; make ptr an offset
			Bsr			MySetHandleSize			; reset handle size			** <C381/7nov86/MBK> **
			_HLock
			Add.L		(A0),A1					; make the offset a ptr again

@0			Move		D3,(A1)+				; lines[nLines]:=i
			Move		D3,D6					; now start with the next line
			AddQ		#1,teNLines(A3) 		; increment # lines
			AddQ.L		#2,D5

			Cmp 		teLength(A3),D6 		; while i < length do
			Blo.S		@FindNextLine			; keep finding lines		** <C229/28oct86/MBK> **

			Move.W		oldNLines(A6),D0		; get old # of lines		** <C229/28oct86/MBK> **
			AddQ.W		#1,D0					; plus 1 to pt to end		** <C229/28oct86/MBK> **
			Add.W		D0,D0					; double for word entries	** <C229/28oct86/MBK> **
			Lea			teLines(A3,D0),A0		; plus base address			** <C229/28oct86/MBK> **
			Move.L		A0,savePtr(A6)			; save it for replace		** <C229/28oct86/MBK> **
			Bra.S		iStage3A				; go munge					** <C229/28oct86/MBK> **

@FindNextLine
			Bsr			FindLine				; get line after D6				<C971/RWW102887>NO
			Move		D0,D3					; findline returns in D0
			Bra			iLineLoop				;								<C971/RWW102887>NO

;------------------------------------------------
; Fill out following line offsets with delta and return in D4 the redraw end
iStage3
			Move		D3,savedD4(A6)			; found it, record in dispEnd

; Still need to munge if D5 is 0, in case something was inserted over a CR.
; Line which skipped munging if D5 = 0 was deleted.
			Move.L		savePtr(A6),D0
			Sub.L		A2,D0					; change in # of lines?
			Sub.L		D5,D0
			Beq.S		iStage3A

			Move.W		teLength(A3),D3			; if so, must display all

iStage3A	Move		D3,savedD4(A6)			; found it, record in dispEnd

			Move.L		A4,A0
			_HUnLock							; unlock TEHandle
			SubQ.L		#4,SP					; room for ret value
			Move.L		A4,-(SP)				; TEHandle
			Move.L		A2,D0
			Sub.L		A3,D0					; offset to line preceding insert
			Move.L		D0,-(SP)
			Move.L		#0,-(SP)				; Nil ptr

			Move.L		savePtr(A6),D0			; end of insertion
			Sub.L		A2,D0					; - beg of insertion
			Move.L		D0,-(SP)
			Move.L		startHndl(A6),A0
			Move.L		(A0),-(SP)				; ptr to new line starts
			Move.L		D5,-(SP)				; length of insertion
			Sub.L		A3,A2					; save as offset

			_Munger;(TEHandle, preInsertPoint, NIL, selectionLen, newLineStarts, insertLen);
			AddQ.L		#4,SP					; don't care
			Move.L		A4,A0
			_HLock								; relock TEHandle
			Move.L		(A4),A3					; deref
			Add.L		A3,A2					; restore as ptr

			Add.L		D5,A2					; adjust ptr for move down

sameLine	Move.L		startHndl(A6),A0		; get rid of line starts handle
			_DisposHandle

			Cmp 		teLength(A3),D6 		; if i >= length quit
			Bhs.S		endIRecal				;
iStage3B
; update the table with new start
			AddQ		#1,teNLines(A3) 		; increment # lines
			Sub 		D7,(A2)	 				; lines[nLines]:=lines[nLines]-delta

			Move		(A2)+,D6				; see if done
			Cmp 		teLength(A3),D6 		; while i < length do
			Blo.S		iStage3B

endIRecal	MoveM.L		(SP)+,D2/D4				; other stuff
			Rts

;formFeed
;------------------------------------------------
	If &TYPE('&RWWDebug') <> 'UNDEFINED' Then
;------------------------------------------------------------------
;			PROCEDURE DeleteRecal
;
;			Called only by ReCalLines, although it appears that
;			Russ has removed it from ever being used ever again....
;			hmmmm.....
;
;			** <C105/3Sep86/MBK> ** Stages 2 and 3 for deletion only
;------------------------------------------------------------------

DeleteRecal
			Move.L		teTextH(A3),A0			; text handle
			Move.L		(A0),A1					; deref into A1

dStage2
; If the width of a single character > the width of the window, Recal keeps
; finding the same line (line 1) forever.  If this happens, don't keep trying
; to wrap, just advance to the next character.

			Cmp.W		D6,D3					; same as old value?		** <C440/18nov86/MBK> **
			Bne.S		@0						; ok if not					** <C440/18nov86/MBK> **
			AddQ		#1,D3					; else advance to next char	** <C440/18nov86/MBK> **
@0
			Cmp 		teSelEnd(A3),D3 		; not ready for stage 3 if not yet
			Bls.S		dSkip3					; past selEnd

			Move.L		A2,savePtr(A6)			; save ptr for move up

			Move.W		(A2),D0					; old line start
			Sub 		D3,D0	 				; oldStart - newStart
			Cmp 		D0,D7 					; compare to delta
			Beq.S		dStage3

; ** <C971/RWW110387>	Added this code to support tabs
;			Cmp.B		#returnChar,-1(A1,D3)	; get the last char

			Move.B		-1(A1,D3),D0			; THESE TWO LINES REPLACE PREVIOUS	<C971/RWW110387>
			Bsr			TEEOLHook				;									<C971/RWW110387>

			Bne.S		dSkip3					; if CR stage 2 is over

; look for the old value of this line
			Move.L		A2,A0
			Move.W		D3,D0					; line start + delta
			Add.W		D7,D0

@1			Cmp.W		(A0)+,D0				; must be a match
			Bhi.S		@1						; made this unsigned	** <C381/6nov86/MBK> **

			SubQ		#2,A0					; got over-incremented
			Move.L		A0,savePtr(A6)			; save ptr for move up
			Bra.S		dStage3
dSkip3
; update the table with new start
			AddQ		#1,teNLines(A3)			; inc # of lines
			Move		D3,(A2)+				; lines[nLines]:=i
			Move		D3,D6					; now start with the next line

			Cmp 		teLength(A3),D6 		; while i < length do
			Bhs.S		endDRecal				;

			Bsr			FindLine				; get line after D6				<C971/RWW102887>NO
			Move		D0,D3					; findline returns in D0
			Bra.S		dStage2					; if so, never do background

; Fill out following line offsets with delta and return in D4 the redraw end
dStage3
			Move.L		A2,A0

			Move.L		savePtr(A6),A0			; source ptr
			Cmp.L		A2,A0					; same as dest ptr?
			Beq.S		@3						; if so, no lines deleted

			Move.W		teLength(A3),D3			; else, redraw everything

@3			Move		D3,savedD4(A6)			; found it, record in dispEnd

dStage3A
; update the table with new start
			AddQ		#1,teNLines(A3) 		; increment # lines
			Move.W		(A0)+,D0
			Sub 		D7,D0	 				; lines[nLines]:=lines[nLines]-delta

			Move.W		D0,(A2)
			Move		(A2)+,D6				; see if done
			Cmp 		teLength(A3),D6 		; while i < length do
			Blo.S		dStage3A

endDRecal	Rts

	EndIf		; <PMAB381/RWW020488>

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE SetLineHite
;
;			** Added 6/18/86 by MBK **
;
;			Called only by ReCalLines
;
;			SetLineHite takes the maximum height for the current line
;			(which was determined in FindLine) and stores it in the
;			array of maximum line heights.
;
;			** <C229/28oct86/MBK> ** Changed to reset all heights at end of recal
;
;		Entry:
;			A4 is pointing into array in which to insert line heights and
;				ascents
;			a6	stack frame of RecalLink
;----------------------------------------------------------------------
SetLineHite
			MoveM.L		D2-D6/A2/A4,-(SP)		; save registers

			Tst.W		teSize(A3)				; record with style?
			Bpl			endSetLH				; quit if not

			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; deref
			Move.L		lhTab(A0),A0			; line heights array
			_GetHandleSize						; get current size
			Move.W		D0,D3					; save size in D3
			AsR.W		#2,D3					; get # of lines

			MoveQ		#0,D0					; clear whole reg
			Move.W		teNLines(A3),D0			; get # of lines
			AddQ.L		#1,D0					; + 1 for last entry
			LsL.L		#2,D0					; for 2 integers
			Bsr			MySetHandleSize			; reset handle size				** <C381/7nov86/MBK> **

			Move.L		teStylesH(A3),A1		; handle to style info			** <C381/6nov86/MBK> **
			Move.L		(A1),A1					; deref							** <C381/6nov86/MBK> **
			Move.L		lhTab(A1),A4			; line heights array
			Move.L		(A4),A4					; deref

			Tst.W		teLength(A3)			; any text?
			Bne.S		@GetStyles				; no default needed if so		** <C381/6nov86/MBK> **

; If all text was deleted, set line height according to only remaining style.
			Move.W		runs+2(A1),D0			; style index to 1st style	(in runs array)	** <C440/19nov86/MBK> **
			Bsr			GetStyle				; get ptr to 1st style			** <C440/19nov86/MBK> **
			Move.W		stHeight(A0),(A4)+		; store line height				** <C440/19nov86/MBK> **
			Move.W		stAscent(A0),(A4)		; store the ascent				** <C440/19nov86/MBK> **
			Bra			endSetLH				; and quit						** <C440/19nov86/MBK> **

@GetStyles
			Move.L		styleTab(A1),A0			; styles array
			Move.L		(A0),A0					; deref
			Lea			runs(A1),A1				; pt to style runs
			Lea			teLines(A3),A2			; pt to line starts
			MoveQ		#0,D1					; set max
			MoveQ		#0,D2					; set starting line #
			Move.L		#-1,D4					; starting redraw line			** <C381/8nov86/MBK> **
			Move.W		(A4),D5					; save old value				** <C381/8nov86/MBK> **

setLoop		Move.W		styleIndex(A1),D0		; index to current style
			MulU		#stRecSize,D0			; multiply index by size of record
			Cmp.W		stHeight(A0,D0.L),D1	; compare to current max		** <C381/6nov86/MBK> ** made D0 long
			Bge.S		@CmpStarts				; already have max

			Move.W		stHeight(A0,D0.L),D1	; else save as new max			** <C381/6nov86/MBK> ** made D0 long
			Cmp.W		D2,D3					; is this a new entry?
			Ble.S		@SetEntry				; just set it if so

			Tst.W		(A4)					; else, see if it should be set
			Bmi.S		@CmpStarts				; if neg don't reset (high bit set indicates user set entry)

@SetEntry
			Move.W		D1,(A4)					; else set height
			Move.W		stAscent(A0,D0.L),2(A4)	; set ascent					** <C381/6nov86/MBK> ** made D0 long

@CmpStarts
			Move.W		2(A2),D0				; get next line start
			Cmp.W		stStartSize(A1),D0		; cmp to next style start
			Blo.S		@GetNxtLine				; multiple lines of a style; made this unsigned			** <C381/6nov86/MBK> **
			Beq.S		@GetNxtStyle			; next style (style end = line end)

			AddQ.L		#stStartSize,A1			; pt to next style (multiple styles on a line)
			Bra.S		setLoop					; keep checking this line

@GetNxtStyle
			AddQ.L		#stStartSize,A1			; pt to next style
@GetNxtLine
			AddQ.L		#2,A2					; pt to next line
			Tst.L		D4						; line to start redraw from		** <C381/8nov86/MBK> **
			Bpl.S		@4						; don't reset it				** <C381/8nov86/MBK> **

			Cmp.W		(A4),D5					; compare to old max			** <C381/8nov86/MBK> **
			Beq.S		@4						; ok if same					** <C381/8nov86/MBK> **

			MoveQ		#0,D4					; clear neg value in hi word	** <C381/8nov86/MBK> **
			Move.W		D2,D4					; store line # for redraw		** <C381/8nov86/MBK> **

@4			AddQ.L		#4,A4					; next line height entry
			Move.W		(A4),D5					; save old value				** <C381/8nov86/MBK> **
			MoveQ		#0,D1					; reset max
			AddQ		#1,D2					; inc counter
			Cmp.W		teNLines(A3),D2			; check counter
			Blo.S		setLoop					; loop if more lines			** <C381/6nov86/MBK> ** changed BNE to BCS

			Move.L		-4(A4),(A4)				; last dummy entry

			Tst.L		D4						; change in heights?			** <C381/8nov86/MBK> **
			Bmi.S		endSetLH				; quit if not					** <C381/8nov86/MBK> **

			Move.W		teLength(A3),savedD4(A6) ; must redraw to bottom		** <C381/8nov86/MBK> **
			Add.W		D4,D4					; double the line #				** <C381/8nov86/MBK> **
			Move.W		teLines(A3,D4),D0		; get start of line				** <C381/8nov86/MBK> **
			Cmp.W		savedD2(A6),D0			; don't reset if new start 		** <C381/8nov86/MBK> **
			Bhs.S		endSetLH				;	is greater than old start	** <C381/8nov86/MBK> **

			Move.W		D0,savedD2(A6) 			; store as new display start 	** <C381/8nov86/MBK> **

endSetLH	MoveM.L		(SP)+,D2-D6/A2/A4		; restore registers

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE ShowCaret
;			PROCEDURE HideCaret
;			PROCEDURE DrawCaret
;			PROCEDURE EraseCaret
;
;		Entry:
;			A3 contains dereferenced handle
;
;----------------------------------------------------------------------
ShowCaret
			Tst.B		teActive(A3)			; do nothing if not active
			Beq			noDrawIt				;								<C971/RWW102887>NO

			Move		teSelStart(A3),D0		; see if should be turned on
			Cmp 		teSelEnd(A3),D0
			Bne			noDrawIt				; if selection <> 0 then escape
			ST			teCarAct(A3)			; activate caret

DrawCaret
			Tst.B		teCarOn(A3) 			; see if caret is on
			Bne.S		noDrawIt				; don't draw it if so
			ST			teCarOn(A3) 			; caret marked on
ForceCaret
			Bra.S		DrawIt					; force a redraw

HideCaret
			Tst.B		teActive(A3)			; do nothing if not active
			Beq.S		noDrawIt				;								<C971/RWW102887>NO

			SF			teCarAct(A3)			; deactivate caret

EraseCaret
			Tst.B		teCarOn(A3) 			; see if caret is on
			Beq.S		noDrawIt				; don't draw it if so
			SF			teCarOn(A3) 			; caret marked on

;Must be called with sorted selStart and selEnd
DrawIt
			MoveM.L 	D0-D7,-(SP)

			Move		teSelStart(A3),D3		; dispStart:=selStart
			Move		D3,D4					; dispEnd:=same
			
			MoveQ		#teCaret,D7				; does nothing except moves pen
			Bsr 		DoText					; draw the caret
@Cursor2
			Move.L		teCarHook(A3),D0		; do the inversion via hook if there

; Call new procedure for caret highlighting, so that color highlighting
; won't be used.

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; color QD around?					<C971/RWW112487>
			Bnz.S		@1						; nope								<C971/RWW112487>
			Bsr			CaretHook				;									<C971/RWW112487>
			Bra.S		@2						;									<C971/RWW112487>
@1			Bsr			InvertHook				;									<C971/RWW112487>
@2
	ElseIf hasCQD THEN							; <9Dec88smb>
			Bsr			CaretHook				;								<C971/RWW102887>NO
	Else
			Bsr			InvertHook				;								<C971/RWW102887>NO
	EndIf
	
; test if a second cursor must be drawn <28Oct88smb>
			tst.w		teSize(a3)
			bmi.s		@Test4Cursor2			; bra if styled text
			tst.b		WordRedraw
;;			bpl.s		@done					; bra if Roman/double-byte old style edit record
			bmi.s		@Test4Cursor2			; <6July89smb>
			tst.b		teSysJust				; <6July89smb>
; bra if Roman/dbl-byte, unstyled and lineDir = LR <6July89smb>
			beq.s		@done					; <6July89smb>				

@Test4Cursor2
			move.l		ExpandMem,a0			; <1Feb89smb>
			tst.b		ExpandMemRec.emTwoCursorsFlag(a0)
			beq.s		@done
						
; draw a 2nd rectangle for split cursors:Top,Left,Bottom,Right
;;unnecc <26Nov89smb>			move.l		ExpandMem,a0			; <1Feb89smb>
			lea			ExpandMemRec.emCursor2Rect(a0),a0		;  top, left, bottom, right <12July89smb>
			move.l		(a0)+, teSelRect+top(a3)
			move.l		(a0), teSelRect+bottom(a3)
			move.l		ExpandMem,a0			; <1Feb89smb>
			sf			ExpandMemRec.emTwoCursorsFlag(a0)
;;???<26Nov89smb>			sf			(a0)
			bra.s		@Cursor2
@done
			MoveM.L 	(SP)+,D0-D7
noDrawIt
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEActivate( h: TEHandle )
;			PROCEDURE TEDeActivate( h: TEHandle )
;
;----------------------------------------------------------------------
TEActivate
			with	OutlineFrame
			bsr		StdEntry				;								<C971/RWW102887>NO
			link	a6,#OutlineFrameSz		; only link if outlining

			tst.b	teActive(A3)			; see if already active
			bne.s	goGoHome
			
; fix the selection when inactive
			bsr.s	InitOutline
			move	teSelStart(a3),d0		; Only enable the caret
			cmp 	teSelEnd(a3),d0
			bne.s	@notSelPt
			
			st		teCarAct(a3)			; activate caret
; hide the caret when outline highlight on <2Oct89smb>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq.s	@notSelPt				; no outlining desired
			bsr		DrawIt					; hide the caret
@notSelPt
			st		teActive(a3)			; flag as active

			bsr 	HiLite
			bra.s	DoneActivate			; rejoin flow of control

;----------------------------------------------------------------------
TEDeactivate
			with	OutlineFrame
			bsr		StdEntry				;								<C971/RWW102887>NO
			link	a6,#OutlineFrameSz		; only link if outlining

			tst.b	teActive(a3)
			beq.s	goGoHome
			
			move	teSelStart(a3),d0		; is this a selection point?
			cmp 	teSelEnd(a3),d0
			bne.s	@drawRegion				; fall through for caret processing

; is outlining desired?
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq.s	@drawRegion				; outline bit not on
; if caret on invert it
			tst.b	teCarOn(a3)
			beq.s	@noDraw
			bsr		DrawIt			
@noDraw
; turn on flag in case off - want to display an outlined caret
			st		teCarOn(a3)				; will be turned off in HideCaret
@drawRegion
			bsr.s	InitOutline
			bsr		HideCaret				; hide the caret
			bsr 	HiLite					; Remove old selection
			sf		teActive(A3)			; flag as inactive
			; drop through to common exit
;-----------------------------------------

DoneActivate
			bsr.s	TEOutlineHilite			; outline hilite now
goGoHome
			unlk	a6
			bra		goHome
			
;----------------------------------------------------------------------
;			PROCEDURE InitOutline
;			<20Sept89smb>
; Test for outline highlighting after setting up teRec
;----------------------------------------------------------------------
InitOutline
			with	OutlineFrame
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq.s	@RegHilite
			_OpenRgn
			move.l	teHiHook(a3),oldHighHook(a6)	; save
			move.l	teCarHook(a3),oldCaretHook(a6)	; save
			lea		FrameHook,a0					; just frame it
			move.l	a0,teHiHook(a3)					; stuff it!
			move.l	a0,teCarHook(a3)				; stuff it!
			st		paintFlag(a6)					; init to always paint region <16Oct89smb>
@RegHilite	
			rts
;-----------------------------------------
FrameHook
			_FrameRect
			Rts
;----------------------------------------------------------------------
;			PROCEDURE TEOutlineHilite
;			<20Sept89smb>
;----------------------------------------------------------------------
TEOutlineHilite			
			
			with	OutlineFrame
; do we need anything fancy
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFOutlineHilite,d0
			beq		@DoneTEOutlineHilite	; don't do fancy stuff!
			
; now do the outlining <20Sept89smb>
			move.l	a4,-(sp)				; save TE handle
			subq.l	#4,sp					; handle to outline region
			_NewRgn
; handle to outline region still on stack
			move.l	(sp),a2					; save outline region
			_CloseRgn			
			subq.l	#4,sp					; handle to view region
			_NewRgn
; handle to view region still on stack
			move.l	(sp),a4					; save view region
			pea		teViewRect(a3)			; view Rectangle
			_RectRgn
			move.l	a4,-(sp)				; view region
			move.l	a2,-(sp)				; outline region
			move.l	a2,-(sp)				; intersection of view and outline regions
			_SectRgn
			move.l	a4,-(sp)				; view region
			_DisposRgn

; set up for drawing
			pea		oldPenState(a6)
			_GetPenState
			move.w	#1,-(sp)
			move.w	#1,-(sp)
			_PenSize
			move.l	GrafGlobals(a5),a0		; get graf globals
			move.w	teSelStart(a3),d0
			cmp.w	teSelEnd(a3),d0
			bne.s	@NoCaret
; got a caret
			lea		gray(a0),a4				; modified a bit <2Oct89smb>
			move.w	#PatXOr,d2
			bra.s	@doPen			
@NoCaret
			lea		black(a0),a4			; @black pattern
; test if color QD available
			move.w	#PatXOr,d2				; assume no color QD
			move.l	#gestaltQuickdrawVersion,d0
			_Gestalt						; result returned in a0
			tst.w	d0						; OSErr result returned here
			bne		SysErr
			move.l	a0,d0					; test result in a0!
			beq.s	@doPen					; no color QD available
			move.w	#50,d2					; hilite
@doPen
			move.w	d2,-(sp)
			_PenMode
			move.l	a4,-(sp)
			_PenPat
; draw
			move.w	teSelStart(a3),d0
			cmp.w	teSelEnd(a3),d0
			beq.s	@Caret
; no caret so outline
			move.l	a2,-(sp)
			_FrameRgn
			tst.b	paintFlag(a6)			; don't paint for Updating <16Oct89smb>
			beq.s	@NoPaint
@Caret
			move.l	a2,-(sp)
			_PaintRgn
@NoPaint			
			move.l	a2,-(sp)
			_DisposRgn
			move.l	(sp)+,a4				; restore TE handle
			
			pea		oldPenState(a6)
			_SetPenState
			
			move.l	oldHighHook(a6),teHiHook(a3)	; restore
			move.l	oldCaretHook(a6),teCarHook(a3)	; restore
@DoneTEOutlineHilite
			rts
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEIdle( h: TEHandle )
;
;----------------------------------------------------------------------
TEIdle
			Bsr			StdEntry				;								<C971/RWW102887>NO

			Tst.B		teCarAct(A3)			; see if active
			Beq.S		goHome

			SubQ		#4,SP					; make room for result
			_TickCount							; Get current time
			Move.L		(SP)+,A0				; use A0 for auto extend

			Cmp.L		teCarTime(A3),A0		; see if done
			Blo.S		goHome

			Add.L		CaretTime,A0			; next time
			Move.L		A0,teCarTime(A3)

	IF forLocalizability THEN					; <31p-YDS-8/27/91>
			Not.B		teCarOn(A3) 			; flip the flag
			Bsr			DrawIt					; flip the caret
	ELSE
			Bsr			DrawIt					; flip the caret
			Not.B		teCarOn(A3) 			; flip the flag
	ENDIF

goHome
			Bra 		epilog4

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEPaste( h: TEHandle );
;
;----------------------------------------------------------------------
TEPaste
			Bsr 		StdEntry

			MoveQ		#0,D7					; flag says normal paste
			Bsr.S		DoPaste					;								<C971/RWW102887>NO

			Bra.S		goHome					; {epilog4}						<C971/RWW102887>NO


DoPaste

; ** <C207/15oct86/MBK> ** Don't wipe out desk scrap for old TERecs in case applications
;						use it for Undo
			Tst.W		teSize(A3)				; record with style?
			Bpl.S		@2						; paste from TEscrap if not

; allocate a new handle for the text scrap contents
			MoveQ		#0,D0					; min size 				** MBK 6/20/86 **
			Bsr			MyNewHandle				; get a temp handle		** <C381/7nov86/MBK> **
			Move.L		A0,D6					; save the handle		** MBK 6/20/86 **
			Move.L		A0,-(SP)				; push it				** MBK 6/20/86 **

; copy desk scrap to my temp scrap
			SubQ.L		#4,SP					; room for VAR			** MBK 6/20/86 **
			Move.L		SP,A1					; save this address		** MBK 6/20/86 **
			SubQ.L		#4,SP					; make room for result	** MBK 6/20/86 **
			Move.L		A0,-(SP)				; push new handle		** MBK 6/20/86 **
			Move.L		#'TEXT',-(SP)			; scrap type			** <C381/5nov86/MBK> **
			Move.L		A1,-(SP)				; push address			** MBK 6/20/86 **
			_GetScrap							; get desk scrap		** MBK 6/20/86 **
			Move.L		(SP)+,D0				; error code			** MBK 6/20/86 **
			AddQ.L		#4,SP					; don't care 			** MBK 6/20/86 **
			Tst.L		D0						; error?				** MBK 6/20/86 **
			Ble.S		@1						; no text scrap			** MBK 6/20/86 **

			Move.L		D0,D5					; length of scrap		** MBK 6/20/86 **
			Move.L		D6,A0					;						** MBK 6/20/86 **

			_HLock								; lock text scrap		** MBK 6/20/86 **
			Move.L		(A0),D6					; ptr to scrap			** MBK 6/20/86 **

			Bsr 		PasteGuts				; go paste the scrap	<C971/RWW102887>NO <SM7> CSS 

@1			Move.L		(SP)+,A0				; temp scrap handle		** MBK 6/20/86 **
			_DisposHandle						; get rid of it			** MBK 6/20/86 **
			Bra.S		@3

; ** <C207/15oct86/MBK> ** paste from old TEScrp, for old TERecs only
@2			Move.L		TEScrpHandle,A0 		; insertion = scrap
			_HLock								; lock it
			Move.L		(A0),D6 				; now dereference
			MoveQ		#0,D5					; clear whole reg
			Move		TEScrpLength,D5 		; insertion length

			Bsr.S		PasteGuts				; go paste the scrap

			Move.L		TEScrpHandle,A0 		; insertion = scrap
			_HUnLock							; unlock it

@3			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEStylPaste( h: TEHandle );
;
;			** Added 6/20/86 by MBK **
;
;			TEStylePaste pastes the 'styl' scrap as well as the 'TEXT'
;			scrap.  TEPaste, on the other hand, simply extends the current
;			style in the text to include the pasted text.  Both work
;			the old way for records without style.
;
;----------------------------------------------------------------------
;iTEStylePaste									; comment out for now						<45>
iTEStylPaste
			MoveQ		#1,D7					; flag says normal paste
			Bsr.S		DoPaste					;								<C971/RWW102887>NO

			MoveQ		#6,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE PstRsrved;
; 			** <C851/14Apr87/MBK> **
;
;			I changed teReserved to a handle to the following structure:
;				Record
;					newReserved : LONGINT;
;					nullScrap	: stScrpHandle;
;				End;
;			nullScrap is used to store a style which is set when the
;			selection is NIL in TESetStyle.  I store it in the scrap
;			format so that it can easily be inserted using PstStylGuts.
;			This procedure is called to paste the reserved style if there
;			is one, and otherwise just to extend the current style.
;----------------------------------------------------------------------

PstRsrved
			Move.L		teStylesH(A3),A0		; get style handle
			Move.L		(A0),A0					; deref
			Move.L		nullStyle(A0),A0		; get reserved handle
			Move.L		(A0),A0					; deref
			Move.L		nullScrap(A0),A1		; get handle to scrap for null selection

			Move.L		A1,-(SP)				; save for unlocking later

			Move.L		(A1),A0					; deref
			Tst.W		scrpNStyles(A0)			; is there a style?
			Beq.S		@0						; do extend if not
			MoveM.L		D3/A4,-(SP)
			Move.L		A1,A4					; put scrap handle in A4

; Gotta lock down null scrap!
			Move.L		A1,A0
			_HLock

			MoveQ		#0,D3					; clear whole register
			Move.W		teSelStart(A3),D3		; PstStylGuts wants this
			Bsr			PstStylGuts				; go paste it
			MoveM.L		(SP)+,D3/A4
			Bra.S		@1

@0			Bsr			ExtendStyle				; just extend
@1
; Unlock previously locked null scrap
			Move.L		(SP)+,A0
			_HUnlock

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE PasteGuts
;
;
;		Entry:
;			D7 = 0, if ExtendStyle should be used to update style table
;				 1, if PasteStyle should be used to update style table
;			D5 = insert length after the delete
;			D6 = pointer to text to insert
;
;----------------------------------------------------------------------

PasteGuts
; The following routines cannot trash D5/D6
			Move.W		D7,-(SP)				; save flag
			Bsr			HideCaret				;								<C971/RWW102887>NO
			Bsr			HiLite					; remove selection				<C971/RWW102887>NO

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@1						; no, skip style paste
			Tst.W		(SP)					; paste or extend?
			Beq.S		@0

			Bsr.S		PasteStyle				; paste associated style		<C971/RWW102887>NO
			Bra.S		@1						; no, skip style paste

@0			Bsr.S		PstRsrved				; get the style					<C971/RWW102887>NO

@1			Bsr			SelSort 				; sort select (A2 ^selStart/End)<C971/RWW102887>NO

			Move		D0,D7					; calc delta amount(selEnd in D0)
			Sub 		(A2),D7 				; ...for ReCalLines (A2 ^selStart)

			Bsr			MungeSetup				; setup for the paste replace

			Move		D7,-(SP)				; length for delete
			Clr 		-(SP)					; fake long length
			Move.L		D6,-(SP)				; pointer to insert = p2
			Move.L		D5,-(SP)				; length to insert = l2
			_Munger 							; use sloppy munger
			AddQ.L		#4,SP					; pop result

			Move.L		teTextH(A3),A0			; get text handle
			_Hlock								; and relock it

			Sub 		D7,teLength(A3) 		; length:=length -(selEnd-selStart)
			Add 		D5,teLength(A3) 		; adjust length by insert amount
			Sub 		D5,D7					; adjust delta amount for ReCalLines
			Bsr 		RecalDraw				; redo the line stuff

			Bsr			ConcatRuns				; <25June89smb>
			
			Lea 		teSelStart(A3),A0		; point to selStart
			Add 		D5,(A0) 				; selStart:=selstart + insert amount
			Move		(A0)+,(A0)				; selEnd:=selStart

			Bsr			ShowCaret				;								<C971/RWW102887>NO

			Bsr 		SelView 				; insure selection is visible

			AddQ.L		#2,SP					; remove flag from stack
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE PasteStyle
;
;			** Added 5/28/86 by MBK **
;
;			PasteStyle inserts the style scrap into the TERec style array
;			if txSize is set to -1 (otherwise this is considered a record
;			without style).
;
;		Entry:
;			D5:			length of pasted text
;			A3:			ptr to TERec
;
;
;----------------------------------------------------------------------
PasteStyle
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		EndPStyl				; only like stylish records		<C971/RWW102887>NO

			MoveM.L		D2-D6/A2/A4,-(SP)		; save stuff

			Bsr			SelSort					; get selStart, selEnd
			Move.W		D0,D4					; selEnd
			Swap		D0
			MoveQ		#0,D3					; make sure all clear		** <C207/13oct86/MBK> **
			Move.W		D0,D3					; selStart

; allocate a new handle for the styl scrap contents
			MoveQ		#0,D0					; min size
			Bsr			MyNewHandle				; get a temp handle			** <C381/7nov86/MBK> **
			Move.L		A0,A4					; store the handle for locking & call to PstStylGuts
			Move.L		A0,-(SP)				; save the handle for disposing later

; copy desk scrap to my temp scrap
			SubQ.L		#4,SP					; room for VAR
			Move.L		SP,A1					; save this address
			SubQ.L		#4,SP					; make room for result
			Move.L		A0,-(SP)				; push new handle
			Move.L		#'styl',-(SP)			; scrap type				** <C381/5nov86/MBK> **
			Move.L		A1,-(SP)				; don't care what this is
			_GetScrap							; get desk scrap
			Move.L		(SP)+,D0				; error code
			AddQ.L		#4,SP					; don't care
			Tst.L		D0						; style found?
			Bpl.S		@0						; there was a style in scrap!

			Bsr			PstRsrved				; get the style
			Bra.S		@4						; extend current style			<C971/RWW102887>NO

; 'styl' scrap was found, delete styles formerly associated with the selection
@0			Move.L		A4,A0
			_HLock								; lock scrap handle while deleting
			Move.W		D3,D0					; selStart
			Move.W		D4,D1					; selEnd
			Bsr			DeleteStyle				; delete associated styles

			
			Bsr.S		PstStylGuts				; do the paste

; get rid of temp scrap handle
@4			Move.L		(SP)+,A0				; temp scrap handle
			_DisposHandle						; get rid of it

			MoveM.L		(SP)+,D2-D6/A2/A4		; restore stuff

EndPStyl	Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE PstStylGuts
;
;			** Separated out from PasteStyle 23jan87 by MBK **
;
;			PstStylGuts inserts the style info pointed at by the A4
;			handle into the TERec style array.
;
;		Entry:
;			D3:			selStart (high word must be clear!)
;			D5:			length of pasted text
;			A3:			ptr to TERec
;			A4:			handle to style info
;
;
;----------------------------------------------------------------------

PstStylGuts
; set up ptr to where new styles will be inserted
			Move.W		D3,D0					; get selStart
			SubQ		#1,D0					; pre-decrement
			Bsr			GetCurStyle				; get current style

			Move.W		D0,D4					; index to current style
			Move.L		(A4),A4					; dereference
			Move.W		scrpNStyles(A4),D2		; get # of styles in scrap
			Lea			scrpStyleTab(A4),A4		; ptr to style array
			Move.W		D3,D0					; selStart

			Bne.S		@0						; dup if not 0
			Tst.W		D2						; make sure num styles <> 0
			Beq.S		@05
			SubQ		#1,D4					; adjust index for this style
			Bra.S		@05
@0
			Bsr			DupStyle				; make copy of style if needed
			Add.L		#stStartSize,A0			; pt to next style
@05
			Add.W		D2,D4					; save index to last style
			Bsr.S		MakeRoom				; make room in array			<C971/RWW102887>NO

			Move.L		A0,A2					; updated ptr
			Move.L		teStylesH(A3),A0		; lock handle because
			_HLock								; you'll be munging

; loop over styles in scrap, adding them to styles array if not there already
@1			Move.L		scrpStartChar(A4),D1	; get scrap start offset	** <C207/13oct86/MBK> **
			Add.L		D3,D1					; plus current offset		** <C207/13oct86/MBK> **

			Cmp.L		#$FFFF,D1				; offset cannot be > 64K	** <C381/6nov86/MBK> **
			Bhi.S		@3						; if it is don't add it		** <C207/13oct86/MBK> **

			Move.W		D1,-(SP)				; save offset				** <C207/13oct86/MBK> **
			Move.L		A4,A0					; ptr to stuff that counts

; The count is a longint in the scrap style table, so I should be adding
; 2 to point to where a regular style record would be pointing. Otherwise,
; FindStyle will not find this style in the table.
			AddQ.L		#2,A0

			Bsr			FindStyle				; look for it

			Tst.L		D0						; do we have it already?
			Bne.S		@2						; yes

			Move.L		A4,A0
			AddQ.L		#2,A0					; skip high word			** <C207/13oct86/MBK> **
			Bsr			AddStyle				; else, add it

			Move.W		#1,stCount(A1)			; A1 is still pointing to style entry

; in either case insert new style descriptor in runs array
@2			Move.W		(SP)+,D1				; restore offset
			Move.W		D1,(A2)+				; store style start
			Move.W		D0,(A2)+				; store style index

@3			Add.L		#scrpRecSize,A4			; pt to next scrap style
			SubQ.W		#1,D2					; dec style counter (make word len!)	<PMAB381/RWW020488>
			Bne.S		@1						; keep looping if more
			SubQ		#stStartSize,A2

; add size of pasted text to all following style starts
			Move.L		teStylesH(A3),A0		; handle to style info
			_HUnlock							; ok to unlock it now
			Move.L		A2,A0					; ptr to last style
			Move.W		D4,D0					; index to last style
			Bsr			RecalStStarts			; inc following style starts
			Bsr			ConcatStyles			; allow no duplications	** <C182/2oct86/MBK> **
			Bsr			ClearRsrved				; clear reserved handle

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE MakeRoom
;
;			** Added 6/19/86 by MBK **
;
;			MakeRoom moves down the contents of the runs array
;			to make room for new entries.
;
;		Entry:
;			D2:			# of new entries
;			A0:			ptr from which to move
;		Exit:
;			A0:			new ptr value (after resizing)
;
;----------------------------------------------------------------------
MakeRoom
			MoveM.L		D2-D3/A2,-(SP)

			Move.L		A0,A2					; ptr from which to move
			Move.L		teStylesH(A3),A0		; style runs
			_HUnlock							; do this before setting D0

			Move.L		(A0),A1
			MoveQ		#1,D0					; + 1 for dummy end			** <C381/6nov86/MBK> **
			Add.W		nRuns(A1),D0			; current # of style runs	** <C381/6nov86/MBK> **
			Add.W		D2,nRuns(A1)			; new # of styles
			LsL.L		#2,D0					; * stStartSize				** <C381/6nov86/MBK> **
			Move.L		D0,D3					; preserve size for block move
			Add.L		#stBaseSize,D0			; add rest of handle size	** <C381/7nov86/MBK> **

			Lea			runs(A1),A1				; pt to start of style runs
			Sub.L		A1,A2					; preserve ptr as an offset	** <C381/6nov86/MBK> **
			
			Sub.L		A2,D3					; amount to be moved down
			Ext.L		D2						; make it a long			** <C381/6nov86/MBK> **
			LsL.L		#2,D2					; * stStartSize				** <C381/6nov86/MBK> **
			Add.L		D2,D0					; new size of block
			Bsr			MySetHandleSize			; reset handle size			** <C381/7nov86/MBK> **

			Move.L		(A0),A1					; dereference
			Lea			runs(A1),A1				; pt to start of style runs
			Add.L		A2,A1					; source					** <C381/6nov86/MBK> **
			_HLock								; assume locked state		** <C381/7nov86/MBK> **
			Move.L		A1,A0
			Add.L		D2,A1					; destination
			Move.L		D3,D0					; length
			_StripAddress						; clean up high byte of length <5June89smb>
			_BlockMove							; make room


			MoveM.L		(SP)+,D2-D3/A2

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE DupStyle
;
;			** Added 6/11/86 by MBK **
;
;			DupStyle makes a duplicate copy of the current style ptr
;			if no new style starts at the current cursor position.
;			This is used when the style is about to be broken up by
;			newly inserted styles (such as from TEStylePaste).
;
;		Entry:
;			D0:			selStart
;			A0:			ptr to current style
;
;----------------------------------------------------------------------
DupStyle
			Move.L		D2,-(SP)

			Move.L		A0,A1

			Add.L		#stStartSize,A0			; pt to next
			move.w		d0,d2					; temp storage <5July89smb>
; if in the last style run in the record, the real end of the run is really one char back. <5July89smb>
			move.w		(a0),d0					; <5July89smb>
			cmp.w		teLength(a3),d0			; <5July89smb>
			bls.s		@NotLastRun				; <5July89smb>
			sub.w		#1,d0					; at the last run: fix the end <5July89smb>
;;<5July89smb>			Cmp.W		startChar(A0),D0		; does a new style start here?
@NotLastRun
			exg			d0,d2					; restore <5July89smb>
			cmp.w		d0,d2					; does a new style start here? <5July89smb>
			Beq.S		@0						; if so, no need to dup

			Move.W		D0,-(SP)
			MoveQ		#1,D2					; one style to insert
			Bsr.S		MakeRoom				; make room for it				<C971/RWW102887>NO
			Move.L		A0,A1					; copy it
			SubQ		#stStartSize,A1			; point to prev style
			Move.W		(SP)+,startChar(A0)		; get style start
			Move.W		styleIndex(A1),D0		; get style's index		** <C381/7nov86/MBK> **
			Move.W		D0,styleIndex(A0)		; copy style index		** <C381/7nov86/MBK> **

; ** <C381/7nov86/MBK> ** obscure bug found by Andy H.; DupStyle should inc the stCount
			Bsr			GetStyle				; get the style			** <C381/7nov86/MBK> **
			AddQ		#1,stCount(A0)			; and inc the count

@0			Move.L		(SP)+,D2
			Move.L		A1,A0

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE FindStyle
;
;			** Added 5/29/86 by MBK **
;
;			FindStyle looks for a style in the style array matching the
;			style pointed at by A0.
;
;	Entry:
;			A0:			ptr to style being sought
;			A3:			TEHandle
;	Exit:
;			D0(High):	1 if style was found, 0 otherwise
;			D0(Low):	style index if style is found, 0 otherwise
;			A0:			ptr to entry in style array if style is found,
;						No change otherwise
;
;----------------------------------------------------------------------
FindStyle
			Move.L		D2,-(SP)				; save stuff

; get ptr to 1st style in text
			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1					; dereference
			Move.W		nStyles(A1),D2			; get # of styles in text <24July89smb> changed to nStyles
			Move.L		styleTab(A1),A1			; handle to styles array
			Move.L		(A1),A1					; dereference
			Lea			stFont(A0),A0			; set ptr to relevent data
			Move.W		D2,D1					; init to # of styles

; loop over styles comparing to the one being sought
@0			Tst.W		stCount(A1)				; is this style being used?
			Beq.S		@1						; doesn't count if not

			Bsr.S		CompareStyles			; do the styles match?			<C971/RWW102887>NO
;			Tst.W		D0						; REDUNDANT!					<PMAB381/RWW020488>
			Beq.S		@2						; go if you have a match

@1			Add.L		#stRecSize,A1			; point to next style
			SubQ		#1,D1					; dec counter
			Bne.S		@0						; keep trying

			MoveQ		#0,D0					; clear flag to indicate not found
			Bra.S		@3

; a matching style was found, set flag and style index
@2			MoveQ		#1,D0					; indicates style found			** <C381/6nov86/MBK> **
			Swap		D0						; faster than MOVE.L #$10000,D0	** <C381/6nov86/MBK> **
			Sub.W		D1,D2					; get the difference
			Move.W		D2,D0					; return index in D0(Low)
			AddQ.W		#1,stCount(A1)			; inc the count
			Move.L		A1,A0					; return ptr in A0

@3			Move.L		(SP)+,D2				; restore stuff

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE CompareStyles
;
;			** Added 5/29/86 by MBK **
;
;			CompareStyles compares two styles byte by byte.
;
;	Entry:
;			A0:			ptr to one style
;			A1:			ptr to another style
;	Exit:
;			D0:			non-zero if styles don't match, 0 if they do
;
;----------------------------------------------------------------------
CompareStyles
			MoveM.L		A0-A1,-(SP)				; save ptrs

			Lea			stFont(A1),A1			; set ptr to relevent data
			Move.L		#styleSize,D0			; get size of style descriptor
@0			CmpM.B		(A0)+,(A1)+				; compare a byte
			Bne.S		@1						; quit if not equal
			SubQ		#1,D0					; else dec the counter
			Bne.S		@0						; keep comparing if not 0

@1			MoveM.L		(SP)+,A0-A1				; restore ptrs

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE AddStyle
;
;			** Added 5/30/86 by MBK **
;
;			AddStyle adds a new style to the styles array.
;
;	Entry:
;			A0:			ptr to style to be added
;			A3:			TEHandle
;	Exit:
;			D0:			style index
;
;----------------------------------------------------------------------
AddStyle
			MoveM.L		D2-D3/A2,-(SP)

; Get # of styles and handle to them
			Move.L		teStylesH(A3),A1		; get handle to style info
			Move.L		(A1),A2					; dereference
			Move.W		nStyles(A2),D0			; get # of styleRecs <24July89smb> changed to nStyles
			Move.W		D0,D3					; save it
			Move.L		styleTab(A2),A1			; handle to styleRecs
			Move.L		(A1),A1					; dereference

; If a style has a count of 0, its location may be reused by the new style
@0			Tst.W		stCount(A1)				; style being used?
			Beq.S		@1						; if not, it can be reused

			Add.L		#stRecSize,A1			; else, pt to next style rec
			SubQ		#1,D0					; dec the counter
			Bne.S		@0						; keep trying

; No empty slots found, so create room at the end
			Move.L		A0,-(SP)				; save ptr to new style
			AddQ		#1,nStyles(A2)			; inc # of styleRecs <24July89smb> changed to nStyles
			Move.L		styleTab(A2),A0			; handle to styleRecs
			_GetHandleSize						; how big is it?
			Move.L		D0,D2					; save size
			Add.L		#stRecSize,D0			; inc size by 1 record

; ** <C381/6nov86/MBK> ** didn't need to reset A0 again since GetHandleSize doesn't trash it
			Move.L		A0,A2					; handle to styleRecs		** <C381/6nov86/MBK> **
			Bsr			MySetHandleSize			; reset handle size			** <C381/7nov86/MBK> **
			Move.L		(SP)+,A0				; restore ptr to new style

			Move.L		(A2),A1					; dereference
			Add.L		D2,A1					; add record at end
			MoveQ		#0,D0					; will be using last slot

@1			Sub.W		D0,D3					; get the index
			Move.L		#stRecSize,D0			; size of record
			_BlockMove							; copy it to styleRec array

			Move.W		D3,D0					; return the index

			MoveM.L		(SP)+,D2-D3/A2

			Rts


; A3 the standard record w/selstart for the offset
; trashes A1
; leaves stack setup to l1

MungeSetup
			Move.L		(SP)+,A1				; get local RTS

			Move.L		teTextH(A3),A0			; get text handle
			_HUnlock

			SubQ.L		#4,SP					; room for result
			Move.L		A0,-(SP)				; push handle
			Move		teSelStart(A3),-(SP)	; start index for insert
			Clr 		-(SP)					; fake long for index
			Clr.L		-(SP)					; fake p1

			Jmp 		(A1)

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE InsRsrved;
;
; 			** <C851/14Apr87/MBK> **
;
;			I changed teReserved to a handle to the following structure:
;				Record
;					newReserved : LONGINT;
;					nullScrap	: stScrpHandle;
;				End;
;			nullScrap is used to store a style which is set when the
;			selection is NIL in TESetStyle.  I store it in the scrap
;			format so that it can easily be inserted using PstStylGuts.
;			This procedure is called to insert the reserved style if there
;			is one, and otherwise just to extend the current style.
;----------------------------------------------------------------------
InsRsrved
			Tst.W		D5						; anything being inserted?
			Beq.S		@1						; quit if not
			
			Move.L		teStylesH(A3),A0		; get style handle
			Move.L		(A0),A0					; deref
			Move.L		nullStyle(A0),A0		; get reserved handle
			Move.L		(A0),A0					; deref
			Move.L		nullScrap(A0),A1		; get handle to scrap for null selection
			Move.L		(A1),A0					; deref
			Tst.W		scrpNStyles(A0)			; is there a style?
			Beq.S		@0						; do extend if not
			
			movem.l		d3/a1/a4,-(SP)			; added a1 for unlocking later						<20>
			Move.L		A1,A4					; put scrap handle in A4
; Gotta lock down null scrap!																		<20>
			move.l		a1,a0					;													<20>
			_HLock								;													<20>
			MoveQ		#0,D3					; clear whole register
			Move.W		teSelStart(A3),D3		; PstStylGuts wants this
			Bsr			PstStylGuts				; go paste it
			movem.l		(sp)+,d3/a1/a4			; added a1 for unlocking							<20>
; Unlock previously locked null scrap																<20>
			move.l		a1,a0					;													<20>
			_HUnlock							;													<20>

			Bsr			ClearRsrved				; selection is different now
; text already inserted by InsGuts so okay to call ConcatRuns now
			bsr			ConcatRuns				; <25June89smb>
			Bra.S		@1

@0			Move.W		teSelStart(A3),D0		; get selStart
			SubQ		#1,D0					; pre-decrement
			Bsr			GetCurStyle				; get current style
			Bsr			RecalStStarts			; adjust start points

@1			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE InsGuts
;
;			** Modified 6/18/86 by MBK **
;
;			Takes the text pointed to by D6 of length D5 and inserts it
;			at selStart.  It then adjusts teLength by the inserted length.
;			It also adjusts D7, the delta accumulator for RecalLines.
;
;		Entry:
;			D5 length of text
;			D6 pointer to text
;			D7 pending delta amount for recalLines
;		Exit:
;			D7 Adjusted by insert amount
;
;----------------------------------------------------------------------
InsGuts
			Bsr.S		MungeSetup				; setup for the insert			<C971/RWW102887>NO

			Clr.L		-(SP)					; fake l1
			Move.L		D6,-(SP)				; pointer to insert = p2
			Move.L		D5,-(SP)				; length to insert = l2
			_Munger 							; use sloppy munger
			AddQ.L		#4,SP					; pop result

			Move.L		teTextH(A3),A0			; get text handle
			_Hlock								; and relock it

			Add 		D5,teLength(A3) 		; adjust length by insert amount
			Sub 		D5,D7					; adjust delta amount for ReCalLines

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; no, you're done		** MBK 6/18/86 **

			Bsr.S		InsRsrved				; insert the style				<C971/RWW102887>NO
@0
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEInsert( pText: PTR; l: LONGINT; h: TEHandle );
;
;			This inserts the passed text/length just before the selection
;			but doesn't touch the scrap.  The selection too is "untouched"
;			because it is offset by the inserted amount to point to the same
;			range.  Just after a TENew this can be used as a replacement for
;			the old TESetText because the selection and length are all zero.
;
;----------------------------------------------------------------------
TEInsert
			Bsr 		StdEntry

			Bsr			HideCaret				;								<C971/RWW102887>NO
			Bsr			HiLite					; remove selection				<C971/RWW102887>NO

			MoveQ		#0,D7					; delta = 0(No deletion)
			MoveM.L 	(A2)+,D5-D6 			; A2 points to l param
			Bsr.S		InsGuts 				; go insert the scrap

			Bsr 		RecalDraw				; redo the line stuff

			Add 		D5,teSelStart(A3)		; selStart:=selstart + insert amount
			Add 		D5,teSelEnd(A3) 		; selEnd:=selEnd + insert amount

			Bsr 		ShowCaret
			Bsr			HiLite					; restore selection				<C971/RWW102887>NO

epilog12	MoveQ		#12,D0
			Bra 		StdExit

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEKey( key: CHAR; h: TEHandle );
;
;			** Modified 6/18/86 by MBK **
;
;----------------------------------------------------------------------
TEKey
; turn off textBuffering bit before calling StdEntry since want to process below <17Sept89smb>
			move.l		4(sp),a1				; teHandle (before the return address)
			move.l		(a1),a1					; need the ptr to the teRec
			move.l		teDispatchH(a1),a1
			move.l		(a1),a1
			move.l		newTEFlags(a1),-(sp)
			move.l		#0,newTEFlags(a1)
			
			Bsr			TEKeyStdEntry
;;			Bsr			StdEntry				;								<C971/RWW102887>NO

; reset textBuffering bit <17Sept89smb>
			move.l		teDispatchH(a3),a1
			move.l		(a1),a1
			move.l		(sp)+,newTEFlags(a1)
					
			_ObscureCursor						; nice knowing you cursor

			Move.W		(A2),D1 				; store char away
			move.b		d1,d0					; get char for comparison
			MoveQ		#1,D2					; assume going down

; Cursor Key support - Added from 'Lonely Hearts' patch 14Jan86
; left: If selStart isn't 0 it decrements it and places the caret there
; right:		Increments selEnd and places caret there
; up:	simulates a click one line above current selStart point
; down: simulates a click one line below current selStart point

	IF 0 THEN									; bye bye for now										<29>
			cmp.b		#forwardDeleteChar,d0	; is this the extended keyboard function key?			<20>
			bne.s		@CursorKeys				;														<20>
			
			st			teLftCaret(A3)			; jam caret to left cause its nota cursor key			<20>
; be sure d6 is not used in any subroutines called from here!!!!
			st			d6						; tell backspace that we are going forward				<20>
			bra			backspace				; do common backspace code								<20>
@CursorKeys
	ENDIF										; 														<29>
			subi.b		#downArrowChar,d0
			Beq.S		downArrow
			bhi.s		normalChar				; optimize normal characters
			
			subi.b		#upArrowChar-downArrowChar,d0
			Beq.S		upArrow

			subi.b		#rightArrowChar-upArrowChar,d0
			Beq			rightArrow

			subi.b		#leftArrowChar-rightArrowChar,d0
			Beq			leftArrow

			st			teLftCaret(A3)			; jam caret to left, UNLESS a cursor key <7Aug89smb>
	IF 0 THEN									; bye bye for now										<29>
; be sure d6 is not used in any subroutines called from here!!!!
			sf			d6						; tell backspace that we are going backward				<20>
	ENDIF										; 														<29>

			subi.b		#backspaceChar-leftArrowChar,d0
			Beq			backSpace

normalChar			
; test if want text buffering <12June89smb>			
			st			teLftCaret(a3)			; jam caret to left, UNLESS a cursor key <7Aug89smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0
			btst		#teFTextBuffering,d0
			beq			PasteChar				; little mod <15June89smb>
			
;;			Bra.S		PasteChar				; => go paste in the character
			bsr			TEBufferText			; <30Jan89smb>
			bra			Epilog6					; <30Jan89smb>

upArrow
;; subtract 2 rather than 1 <1/25/90smb>			MoveQ		#-1,D2					; going up
			MoveQ		#-2,D2					; going up
downArrow
			Move		D2,-(SP)				; save D2
			
; dump text buffer before processing cursor key <14Sept89smb>
			Move.L		teDispatchH(a3),a0
			Move.L		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops <15Sept89smb>
			btst		#teFTextBuffering,d0	; <15Sept89smb>
			beq.s		@noBuffer
			bsr			DumpBuffer				; dump text from buffer
@noBuffer	
; Call HideCaret to fix problems with old and new teLftClick <1/25/90smb>
			bsr			HideCaret				; erase old caret <1/25/90smb>
			Move		teSelStart(A3),D3		; pass selStart=selEnd
			Move		D3,D4
			moveq		#teCaret,d7				; position pen to caret <03July89smb> 
			bsr 		DoText					; the port ret. in A0

			move		(sp)+,d2				; restore D2
			
;-------------------------------------------------------------------------------------
; In order to go down from a line end position to a line whose line height is less than the current
; line height, must back up one position to get the hite for the correct line (when FindLineHite
; calls GetLine and the current position is at the end of a line, it thinks it's at the 
; beginning of the next line so the wrong height is returned. <1/30/90smb>
			movem.l		a2/d3,-(sp)
			tst.b		teLftCaret(a3)
			bne.s		@OffsetOK
			move.w		d3,d0					; offset
			beq.s		@OffsetOK
			lea			teLines(a3),a2
			bsr			GetLine					; get line that d3 is on
			cmp.w		(a2),d3					; cmp offset position to line start found
			bne.s		@OffsetOK
			subq.w		#1,d3					; backup to get correct line in FindLineHite
@OffsetOK
			bsr			FindLineHite			; get current line hite in d1	** MBK 6/18/86 **
			movem.l		(sp)+,a2/d3
; end of changes <1/30/90smb>
;-------------------------------------------------------------------------------------

;; <1/25/90smb>			muls		d1,d2					; get delta -- a SIGNED 16-bit value<09Dec85 JTC>
; if we are going down (d2 = 1), then add linehite (d1) <1/25/90smb>
; if we are going up (d2 = -2), then subtract 2, just enough to get into the previous line's Rect <1/25/90smb>
			tst.w		d2						; up or down <1/25/90smb>
			blt.s		@DeltaOk				; up = -1 <1/25/90smb>
			move.w		d1,d2					; move in delta <1/25/90smb>
@DeltaOk

; assume whole caret or high caret in teSelRect <26Nov89smb>
			move.l		teSelRect(a3),teSelPoint(a3)	; pass caret point
;-------------------------------------------------------------------------------------
; set teSelPoint(a3) from the high caret position! <26Nov89smb>
			move.l		ExpandMem,a0			; <26Nov89smb>
			cmpi.w		#$FFFF,ExpandMemRec.emTwoCursorsFlag(a0)		; <26Nov89smb>
			bne.s		@UseSelRect				; bra if high caret loc in teSelRect <26Nov89smb>

; use rect stored in emCursor2Rect: this is the high caret location. <26Nov89smb>
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; <26Nov89smb>
			move.l		(a0),teSelPoint(a3)		; pass high caret point <26Nov89smb>
@UseSelRect
;-------------------------------------------------------------------------------------
			add 		d2,teSelPoint(a3)		; adjust v value
			bsr 		DoFind					; the port ret. in A0

;; <5Aug89smb> screws up DoCaret!			ST			teLftCaret(A3)			; force clean clicks
			move.b		teLftClick(a3),teLftCaret(a3)	; <10Aug89smb>
			Bra.w		leftRight				; setselect'll force autoscroll

rightArrow
			Move		teSelEnd(A3),D6 		; get start
			MoveQ		#1,d3					; if 2byte char, incr posn <27June88smb>
			bra.s		HorizArrows				; <6Mar89smb>
leftArrow
			Move		teSelStart(A3),D6		; get start
			beq.s		HorizArrows				; <13Mar89smb> special case at 0th position
			MoveQ		#-1,d3					; if 2byte char, decr posn <27June88smb>
HorizArrows

; dump text buffer before processing cursor key <14Sept89smb>
			Move.L		teDispatchH(a3),a0
			Move.L		(a0),a0
			move.l		newTEFlags(a0),d0		; move into reg for modulo 32 bit ops <15Sept89smb>
			btst		#teFTextBuffering,d0	; <15Sept89smb>
			beq.s		@noBuffer
			bsr			DumpBuffer				; dump text from buffer
@noBuffer	

			tst.b		WordRedraw				; <9Jan89smb>
			blt.s		@RLText					; <22June89smb> includes RL directional text
			tst.b		teSysJust				; <22June89smb>
			beq.s		@LRLineDir				; <22June89smb> LR text on a LR line
@RLText
; may be RL text on any directioned line OR LR text on a RL line
			bsr			CursorMovement			; <9Jan89smb>
												; <31k-YDS-8/27/91>
												; supports the single carret corect display
	IF forLocalizability THEN					; when on cluster boundry, syncronize allways to the
												; style with the that his just = teSysJust
			tst.b		WordRedraw				; have L->R script ?
			bge.s		leftRight				; no, do the old way
			tst.w		teSize(a3)				; if unstyled ?
			bpl.s		leftRight				; do the old way for unstyled
			move.w		d6,d0					; GetCurStyle needs offset in d0
			bsr			GetCurStyle				; get the current style
			cmp.w		startChar(a0),d6		; are we on a boundry ?
			bne.s		leftRight				; if not do it the old way	
			move.l		a0,-(sp)				; keep a0 (the style) from being trashed
			Bsr 		HideCaret				; hide caret
			Bsr 		HiLite					; unhilite
			Move		d6,teSelEnd(A3) 		; set set start
			Move		d6,teSelStart(A3)		; set sel end
			move.l		(sp)+,a0				; restore style ptr (in a0)
			bsr			GetDirection			; get style direction
			cmp.b 		TESysJust,d1			; same as TESysJust ? 
			beq			@setStyle				; yes ! set the style for it.
			move.w		d6,d0					; no ! get the prev style, put offset into d0
			sub.w		#1,d0					; be in prev
			bsr			GetCurStyle				; get this style
@setStyle	bsr			SetStyle				; set the font/style in the grafport
			move.w		d6,d0					; char offset in d0 needed by SetKeyboard2Font
			bsr			SetKeyboard2Font		; sync keyboard to font
 			Bsr 		HiLite					; Hilite
			Bsr 		SelView 				; insure selection is visible
			Bsr 		ShowCaret				; 
			Bra			epilog6
	ELSE
			bra.s		leftRight				; <9Jan89smb>
	ENDIF

@LRLineDir
			Bsr			DoubleByte				; middle of char? Fix starting point <27June88smb>
leftRight
			Ext.L		D6						; D6 comes back char loc
			Move.L		D6,-(SP)				; pass start
			Move.L		D6,-(SP)
			Move.L		A4,-(SP)
			_TESetSelect

			Bsr 		DrawCaret				; force caret ON
	IF 0 THEN									; bye bye for now								<29>
			Bra			epilog6					;												<29>
	ELSE										; 												<29>
			Bra.w		epilog6
	ENDIF										; 												<29>
			
PasteChar
; Go paste the character
			Move.L		A2,D6					; point to the character
			AddQ		#1,D6					; character in lower half
			MoveQ		#1,D5					; one long
			Bsr			BufferChar				; buffer if 2 byte character <27June88smb>
	IF 0 THEN									; bye bye for now								<29>
			blt			epilog6					; the result isn't unsigned! <31Aug89smb>		<29>
	ELSE										; 												<29>
			blt.w		epilog6					; the result isn't unsigned! <31Aug89smb>
	ENDIF										; 												<29>

			moveq		#0,D7					; want to call ExtendStyle
			bsr 		PasteGuts
;; <1/9/90smb>			move.l		ExpandMem,a0			; <1Feb89smb> finished w/ character
;;<6Nov89smb>		clr.w		ExpandMemRec.emBufferPtr(a0)	; empty buffer; temp use of space <2Feb89smb>
;; <1/9/90smb>			clr.w		ExpandMemRec.emBufferLen(a0)	; empty buffer <6Nov89smb>
			move.l		teDispatchH(a3),a0		; <1/9/90smb> finished w/ character so empty storage
			move.l		(a0),a0
	IF forLocalizability THEN					; <31b-YDS-8/27/91>
			move.w		#0,TwoByteCharBuffer(a0)
	ELSE
			move.l		#0,TwoByteCharBuffer(a0)
	ENDIF
			bra.w		epilog6

backSpace
; dump text buffer before backspacing <14Sept89smb>
			Move.L		teDispatchH(A3),A0
			Move.L		(A0),A0
			move.l		newTEFlags(a0),d0	
			btst		#teFTextBuffering,d0
			beq.s		@noBuffer
			bsr			DumpBuffer				; <30Jan89smb> dump text from buffer
@noBuffer	
			Move		teSelStart(A3),D0		; see if null selection
			Cmp 		teSelEnd(A3),D0
			Bne.S		cutit

;------------------------
	IF 0 THEN									; bye bye for now									<29>
; add support for the forward delete key												<7jan91 fjs><20>
			tst.b		d6						; is this forward delete ?							<20>
			beq.s		@normalBS				; if 0 do normal backspace work						<20>

; since there is no selection, eat characters to the right
; first, check if we are at the extreme right already
			cmp.w		teLength(a3),d0			; at extreme right of text?  (really, the end… think R-L)<20>
			bge.s		epilog6					; yes, skip this									<20>
			bsr 		HideCaret				; remove the caret									<20>

; check for double-byte characters and fix starting point
			move.w		teSelEnd(a3),d6			; current position									<20>
			moveq		#1,d3					; direction to move									<20>
			bsr			DoubleByte				; middle of char? Fix starting point.				<20>
			move.w		d6,teSelEnd(a3)			; adjust selection									<20>
			bra.s		cutit					; fall into the cut case				<7jan91 fjs><20>
@normalBS
	ENDIF										; 													<29>
;------------------------

; since there's no selection eat characters to the left.
			Tst 		D0						; see if at extreme left (really, the beginning… think R-L)
			Beq.w		epilog6 				; skip if so

			Bsr 		HideCaret				; remove the caret
;;			SubQ		#1,teSelStart(A3)		; adjust selection

; check for double-byte characters and fix starting point. <27June88smb>

			move.w		teSelStart(a3),d6		; current position <27June88smb>
			moveQ		#-1,d3					; direction to move <27June88smb>
			Bsr			DoubleByte				; middle of char? Fix starting point <27June88smb>
			move.w		d6,teSelStart(A3)		; adjust selection

cutit
; Need to synchronize keyboard to the font <2/28/90smb>; moved here from DelGuts.
; This must be done before the call to TEDelete in order to synchronize the kbd to
; the style that corresponds to the current selStart.
			tst.w		teSize(a3)				; if unstyled, try synch keyboard to font  anyway>
	IF forLocalizability THEN					; even if we dont have all info
			bpl.s		@syncUnStyled			; sync for unstyled  <31n-YDS-8/27/91>.
	ELSE
			bpl.s		@JustCut				; <2/28/90smb>
	ENDIF
			move.w		teSelStart(a3),d0		; use current offset position <2/28/90smb>
			bsr			GetCurStyle				; <2/28/90smb>
			bsr			SetStyle				; <2/28/90smb>
			bsr			SetKeyboard2Font		; synch keyboard to font <2/28/90smb>

	IF forLocalizability THEN					; synch for unstyled too <31n-YDS-8/27/91>
			bra			@JustCut				; go to the cut if didn't come with a bpl.s
@syncUnStyled
	IF 0 THEN									; now using 'itlb' flag	in CubeE						<45>
;;			tst.b		WordRedraw				; is it a R->L script ?									<34>
;;			bge.w		@JustCut				; don't synch.											<34>
; Really want to synchronize for unstyled text in ALL scripts. However, this will cause problems for 	<34>
; input methods, so we will skip this code in this case. (WordRedraw only indicates the 				<34>
; types of scripts installed and not the current one…)													<34>
			subq		#2,sp					; result space for Font2Script & GetScript				<34>
			move.w		teFont(a3),-(sp)		; app font id											<34>
			_Font2Script						; it's a non-roman char so get script font				<34>
			move.w		(sp)+,d0				;														<34>
			beq			@UseFont				; if Roman then always synchronize						<34>
			cmp.w		#smEastEurRoman,d0		; Extended Roman?										<38>
			beq			@JustCut				; If so, never synchronize								<38>
			subq		#4,sp					; result space											<34>
			move.w		d0,-(sp)				; script												<34>
			move.w		#smScriptRedraw,-(sp)	;														<34>
			_GetScript							;														<34>
			move.l		(sp)+,d1				;														<34><37>
			tst.b		d1						; leave in d1 for later									<34><37>
			bgt			@JustCut				; if double-byte script	don't synchronize				<34>
			; otherwise, we have a single-byte non-Roman font											<34>
;	IF SysVers > $610 THEN		
;			move.l		teDispatchH(a3),a0		; 
;			move.l		(a0),a0
;			move.l		newTEFlags(a0),d0		; move into reg the flags
;			btst		#teFInlineInput,d0		; are we in an inline input window ?
;			bne.w		@JustCut				; yes, don't synch keyboard.
;	ENDIF		

	ELSE										; now using 'itlb' flag	in CubeE						<45>
			; optimize for Roman-only: do not have to synch font & kbd									<50>
			with		smgrRecord				;														<50>
			GetSMgrCore a0						; load SMgr globals pointer.							<50>
			cmp.b		#1,smgrEnabled(a0)		; how many scripts enabled?								<50>
			beq			@JustCut				; skip synchronization for Roman-only system			<50>
			endwith								;														<50>
			
			subq		#6,sp					; result space for Font2Script & GetScript				<45>
			move.w		teFont(a3),-(sp)		; app font id											<45>
			_Font2Script						; get script font										<45>
			; script left on stack				;														<45>
			move.w		#smScriptFlags,-(sp)	; now get script-specific flags							<45>
			_GetScript							;														<45>
			move.l		(sp)+,d0				;														<45>
			and.l		#(1<<smsfSynchUnstyledTE),d0	; leave only the synchronize bit				<45>
			beq			@JustCut				; 0=> do not synchronize								<45>
			; otherwise synchronize
	ENDIF										; now using 'itlb' flag	in CubeE						<45>

			Move.w		teSelStart(a3), d6		; <33-YDS-10/1/91> d6 was set only for a one char delete, not for a selection delete
; Check char to determine how to synch
			move.l		teTextH(a3),a2			; handle to text										<37>
			move.l		(a2),a0					; ptr to text											<37>
			move.b		0(a0,d6.w),d0			; get character											<37>
			cmp.b		#$20,d0					; control char?											<37>
			blo.s		@JustCut				; if so, don't synch									<37>
			move.b		d1,-(sp)				; save scriptRedraw										<37>
			subq		#2,sp					; room for return
			move.l		a0,-(sp)				; push text ptr on stack								<37>
			move.w		d6,-(sp)				; offset on stack
			_CharType							; what char is it
			move.w		(sp)+,d0				; take result
			move.b		(sp)+,d1				; recover scriptRedraw									<37>

; Mask off what interested in: the Type ($000F) and the Direction ($2000)								<34>
; Want a char whose Direction is LR (smCharLeft, $0000) and whose Type is Roman							<34>
; which can be smCharAscii (1) or smCharEuro (7) or smCharPunct (0).									<34>
;
; New approach. Different behavior for bidi and non-bidi scripts, because of caret						<37>
; requirements for bidi scripts.																		<37>
			bne.s		@doBidi					; check scriptRedraw for bidi							<37>
; For non-bidirectional scripts, set keyboard to Roman for Roman letters,								<37>
; sync to font for script letters, dont sync for anything else.											<37>
			and.w		#smcTypeMask,d0			; isolate info we need									<37>
			cmp.w		#smCharPunct,d0			; non-letter?											<37>
			beq.s		@JustCut				; if so, don't synch keyboard							<37>
			cmp.w		#smCharAscii,d0			; low-ASCII Roman?										<37>
			beq.s		@isRoman				; if so, go set keyboard								<37>
			cmp.w		#smCharEuro,d0			; Extended ASCII Roman?									<37>
			beq.s		@isRoman				; if so, go set keyboard								<37>
			bra.s		@UseFont				; otherwise, sync keyboard to font						<37>
; For bidirectional scripts, don't synch control chars (stripped out above) or low-ASCII				<37>
; (L-R) digits; synch other L-R chars to Roman, and everything else to font script.						<37>
@doBidi											;														<37>
			and.w		#smcTypeMask+smcClassMask+smcRightMask,d0	; isolate info we need				<37>
			cmp.w		#smCharPunct+smPunctNumber+smCharLeft,d0	; is char a low-ASCII digit?		<37>
			beq.s		@JustCut				; if so, don't synch									<37>
			and.w		#smcRightMask,d0		; now just check direction								<37>
			beq.s		@isRoman				; if left-right, sync to Roman							<37>

; Otherwise, synch the font to the script of the character												<34>
@UseFont
			subq		#2,sp					; room for return
			move.w		teFont(a3),-(sp)		; app font id
			_Font2script						; it's a non-roman char so get app font
			; leave script on stack
			bra.s		@SetKbd

@isRoman	move.w		#smRoman,-(sp)			; we think it is roman
@SetKbd
			move.w		(sp), d0				; script param on the stack 
			move.l		teDispatchH(a3),a0		; get teDispatchH addres 
			move.l		(a0),a0					;
			move.b		d0, lastScript(a0)		; push script numberused to highligt (d0) to lastScript
			_KeyScript							; set keyboard
	ENDIF

@JustCut
			Move.L		A4,-(SP)				; pass the handle
			_TEDelete							; and cut it (A3 no good after)

epilog6 	MoveQ		#6,D0
			Bra 		StdExit
			
;formFeed
;----------------------------------------------------------------------
;
;			TEBufferText
;			<30Jan89smb>
; 			
;			Buffer input characters (graphic).  This is to help performance for 
;			Asian systems.
;
;			Input
;				(a2)	character (or half a character in the case of double-byte chars)
;						 to be buffered
;
;			Uses a0,a1,d0
;----------------------------------------------------------------------
TEBufferText
			move.l	ExpandMem,a0						; <28June89smb>
			move.l	ExpandMemRec.vTEBufferText(a0),a0
			jmp		(a0)

xTEBufferText

; does a pointer to a buffer already exist?	
			move.l	ExpandMem,a1						; <1Feb89smb>
;;			tst.w	ExpandMemRec.emBufferLen(a1)		; <14Sept89smb> test for zero len					<18>
			tst.l	ExpandMemRec.emBufferHandle(a1)		; test for no buffer (using handle now for consistency)	<18>
			bne.s	@HaveBuffer
@GetBuffer
			moveq	#BufferSize,d0						; longize											<18>
			bsr.s	GetHandle							; allocate handle for buffer; in a0
; dereference the handle and save
			move.l	ExpandMem,a1						; <1Feb89smb>
			move.l	a0,ExpandMemRec.emBufferHandle(a1)	; save handle
	
@HaveBuffer
; if keybd changes in the middle of buffering must dump the buffer and synch the font to the keybd. <1/26/90smb>
; must set d0 to the current position before calling SetFont2Keyboard<2/28/90smb>
			tst.w	teSize(a3)							; check style flag
			bpl.S	@DontSet							; don't set style
			move.w	teSelStart(a3),d0					; pass current position <2/28/90smb>
			beq.s	@SynchUp							; skip test if zero <2/28/90smb>
			sub.w	#1,d0								; backup one to get previous style <2/28/90smb>
@SynchUp
			bsr		SetFont2Keyboard					; <1/26/90smb>
	IF hasBufferingFix THEN								; 													<18>
			move.l	ExpandMem,a1						; reload ExpandMem ptr								<18>
; SetFont2Keyboard may have called DumpBuffer so test for a deallocated handle								<18>
			tst.l	ExpandMemRec.emBufferHandle(a1)		; is this zero?										<18>
			beq.s	@GetBuffer							; if so, then get another storage handle			<18>
	ENDIF												;													<18>

@DontSet
			move.l	ExpandMemRec.emBufferHandle(a1),a0	; get handle of storage space <13Nov89smb>
			move.l	(a0),a0								; get to storage space <13Nov89smb>
	IF hasBufferingFix THEN								; 													<18>
			moveq	#0,d0								; longize											<18>
	ENDIF												;													<18>
			move.w	ExpandMemRec.emBufferLen(a1),d0		; <1Feb89smb> length = number of bytes already in buffer
; have we maxed out on the buffer?
			cmpi.w	#BufferSize,d0
			bne.s	@MoreRoom
			bsr.s	DumpBuffer
	IF hasBufferingFix THEN								; 													<18>
			tst.l	ExpandMemRec.emBufferHandle(a1)		; the high byte of a char may be in the buffer		<18>
			beq.s	@GetBuffer							; if empty then ok to get another handle			<18>
	ELSE												;													<18>
			bra.s	@GetBuffer
	ENDIF												;													<18>
@MoreRoom
			move.b	1(a2),(a0,d0.l)						; char in lower byte
			addq.w	#1,ExpandMemRec.emBufferLen(a1)
			rts
			
;formFeed
;----------------------------------------------------------------------
;
;			GetHandle
;			<30Jan89smb>
; 			Allocate a handle.
;
;			Input
;				d0.l = number of bytes to allocate
;			Output
;				a0 = handle allocated
;			Used by TEBufferText and GetStyleStorage.
;----------------------------------------------------------------------
GetHandle
			_NewHandle ,SYS,CLEAR			; allocate and clear a block and return handle in a0	<21>
			bne.s	sysErr					; exit if system error

			_HLock
			bne.s	CleanUp

			rts
			
; OH NO!!!! can't get no memory!
CleanUp
; deallocate handle in a0
			move.l	d0,-(sp)				; save initial error
			_DisposHandle
			move.l	(sp)+,d0				; restore initial error
sysErr			
			_SysError						; go bye-bye with error in d0
			
;formFeed
;----------------------------------------------------------------------
;
;			DumpBuffer
;			<30Jan89smb>
;
;			Dump the text buffer.  Either it's full or we've
;			encountered a condition for dumping (teIdle, control char, etc.)
;----------------------------------------------------------------------
DumpBuffer
			move.l	ExpandMem,a0			; <28June89smb>
			move.l	ExpandMemRec.vDumpBuffer(a0),a0
			jmp		(a0)

xDumpBuffer

dumpRegs	reg		d0-d7/a1-a2				; don't save a3/a4! creating a dangling ptr w/ a3 <21>
			movem.l	dumpRegs,-(sp)
			moveq.l	#0,d3
			move.l	ExpandMem,a2			; <1Feb89smb> buffer is 0 -> n-1
			lea		ExpandMemRec.emBufferLen(a2),a2		; changed to lea <12July89smb>
			move.w	(a2),d2					; buffer length, n
; test if buffer is empty
			beq		@Empty					; nothing to dump
			
; test last (n-1) character in buffer to see if is double-byte char
			subq.w	#1,d2
			move.l	ExpandMem,a1			; <1Feb89smb> pointer to buffer of chars
			move.l	ExpandMemRec.emBufferHandle(a1),a1		; <13Nov89smb>
			move.l	(a1),a1					; deref for pointer <13Nov89smb>

; <12Sept89smb> we want the font of the last character in the buffer to be set in the grafport before calling CharByte. 
			movem.l	a1/d2,-(sp)				; preserve, for unstyled too!<17Nov89smb>
			tst.w	teSize(a3)				; if unstyled, can't synch font to keyboard <12Sept89smb>
			bpl.s	@NoSynch				; <12Sept89smb>
			move.w	teSelStart(a3),d0		; pass current position <12Sept89smb>
			beq.s	@ZeroOffset				; skip test if zero <12Sept89smb>
			sub.w	#1,d0					; backup one to get previous style <12Sept89smb>
@ZeroOffset
; just need to use the current position's font: no need to call SetFont2Keyboard! <1/29/90smb>
;; <1/29/90smb> 			bsr		SetFont2Keyboard		; <12Sept89smb>
			bsr		GetCurStyle				; <1/29/90smb>
			bsr		SetStyle				; <1/29/90smb>
			movem.l	(sp),a1/d2				; restore but don't pop yet <13Nov89smb>
@NoSynch
			clr.w	-(sp)					; room for return
			move.l	a1,-(sp)				; use a1 now not the contents of it! <13Nov89smb>
			move.w	d2,-(sp)				; offset in buffer
			_CharByte
			move.w	(sp)+,d7				; pop result
			movem.l	(sp)+,a1/d2				; restore <13Nov89smb>
			tst.w	d7						; high byte of character?
			bge.s	@GoDump					; no

; yep, gotta save it
			move.b	(a1,d2.w),d3			; changed to d2.w <7Dec89smb>
			subq.w	#1,(a2)					; new length to paste
			beq.s	@Only1Char				; short cut <13Nov89smb>
@GoDump			
; must turn off buffering bit since PasteGuts calls TEPinScroll which calls StdEntry.
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),-(sp)
			bclr	#teFTextBuffering,newTEFlags+3(a0)
			
; setUp for buffer dump
			move.l	a1,d6					; pointer to text to insert (for PasteGuts) <13Nov89smb>
			moveq	#0,d5					; need high word cleared (for PasteGuts) <14Sept89smb>
			move.w	(a2),d5					; length of text to insert

			movem.l	d3/a1/a2,-(sp)
			moveq	#0,d7					; want to call ExtendStyle
			bsr 	PasteGuts
			movem.l	(sp)+,d3/a1/a2

; restore buffering bit
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	(sp)+,newTEFlags(a0)

; test if need to rebuffer 1st byte of double-byte character.
			tst.b	d3						; place holder for character
			beq.s	@DeleteHandle
; last byte in buffer was 1st byte of a double-byte charaacter. Rebuffer it.
			move.b	d3,(a1)					; <13Nov89smb>
@Only1Char
			move.w	#1,(a2)					; incr length for byte
			bra.s	@Empty
			
@DeleteHandle			
; deallocate the handle
			move.l	ExpandMem,a0
			move.l	ExpandMemRec.emBufferHandle(a0),a0	; get to handle! <19Sept89smb>
			_DisposHandle
			bne		SysErr					; <19Sept89smb>
			move.w	#0,(a2)					; set buffer length to zero. Used as a flag.
	IF hasBufferingFix THEN					; 														<18>
			move.l	ExpandMem,a0			; length is initially zero so clear storage for handle	<18>
			clr.l	ExpandMemRec.emBufferHandle(a0)		; flags a disposed handle					<18>
	ENDIF									;														<18>
@Empty
			movem.l	(sp)+,dumpRegs
			rts
	
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE CursorMovement();
;			<10Jan89smb>
;
;			For mixed directional text, must do extensive testing to 
;			determine the next position for the cursor ( and to have the
;			high caret in the position corresponding to the cursor 
;			movement) based on the arrow key struck.  On entry we know that
;			the teRecord has mixed-directional text.
;
;		Entry
;			d1 = arrow key
;			d6 = teSelStart (current position of cursor)
;			a2 = pointer to arrow key
;			a3 = pointer to teRec
;		Exit
;			d6 = modified to reflect new character offset
;
; 		Register Usage
;			d0 = scratch
;			d1 = p, initially: m[p], where p = 0/1
;	 		  = r, finally: (previous) format run index
;			d2 = q: m[q], where q = 1/0 (opposite of p)
;				m[0] = 0: index to leftmost format on line (in fmtOrderingArray)
; 				m[1] = n: index to rightmost format on line (in fmtOrderingArray)
;			d3 = start = 0/1 (opposite of end)
;			d4 = end = 1/0 (opposite of start)
;			d5 = character delta = -1/1
;			d6 = character offset (input/output)
;			d7 = format index delta = -1/1
;
;		Assumptions for basis of conditions:
;			m[0] = 0: index to leftmost format on line (in fmtOrderingArray)
; 			m[1] = n: index to rightmost format on line (in fmtOrderingArray)
;			l[0] = lineStart
;			l[1] = lineEnd
;			f[i] = format run i
;			f[i,0] = start offset for format run i
;			f[i,1] = end offset for format run i
;			cd = cursor direction; ld = line direction, c = char offset (d6)
;----------------------------------------------------------------------
CursorMovement
			move.l	ExpandMem,a1			; <28June89smb>
			move.l	ExpandMemRec.vCursorMovement(a1),a1
			jmp		(a1)

xCursorMovement

CursorMoveRegs		reg		d2-d5/d7/a2		
			with	CursorFrame,TEFormatOrder
			link	a6,#CursorFrameSz
			movem.l	CursorMoveRegs,-(sp)

; Initializations
			sf		FormatEndFlag(a6)			; <17Jan89smb>
			
; ***** cd = left? *****
			cmpi.b	#leftArrowChar,d1			; left arrow? <2Aug89smb> cmp byte not word
			beq.s	@SetLeftCD
; right arrow
			move.b	#$FF,d0						; cursor direction = right
			move.w	#1,d7						; fmt run index delta (in cursor direction [R])
			move.b	#1,d2						; q: m[q] = m[1] = n = rightmost fmt index boundary
			moveq	#0,d1						; p: m[p] = m[0] = 0 = leftmost fmt index boundary

			bra.s	@GetLineDir
@SetLeftCD
			moveq	#0,d0						; cursor direction = left
			move.w	#-1,d7						; fmt run index delta (in cursor direction [L]) 
			moveq	#0,d2						; q: m[q] = m[0] = 0 = leftmost fmt index boundary
			move.b	#1,d1						; p: m[p] = m[1] = n = rightmost fmt index boundary

; ***** cd = ld? ***** 
@GetLineDir
; get line direction
			cmp.b	TESysJust,d0
			beq.s	@CDequalsLD
; CD <> LD: cursor direction <> line direction (left arrow, RL line dir; right arrow, LR line dir)
			move.w	#-1,d5						; character delta
			move.b	#1,d3						; start
			moveq	#0,d4						; end
			bra.s	@NeedLine
@CDequalsLD
; CD = LD: cursor direction = line direction (left arrow, LR line dir; right arrow, RL line dir)
			move.w	#$1,d5						; character delta
			moveq	#0,d3						; start
			move.b	#1,d4						; end
@NeedLine
; need to test line ends so get current line containing character offset
			move.w	d6,d0
			lea		teLines(a3),a2
			movea.l	a2,a0
			bsr		GetLine

; special case! if at end of document (test if on last line) and cd <> ld don't
; want to add charDelta<17Jan89smb>
			move.w	teNLines(a3),d0				; number of lines
			lsl.w	#1,d0
			add.w	d0,a0						; want end of last line
			cmpa.l	a0,a2						; on last line?
			bne.s	@OtherLineStuff
			tst.b	d5
			blt		@done						; at EOD, done.
			
@OtherLineStuff
; yet another special case!  If at the lineStart, and cd = ld, then want to be on
; previous line. <16Jan89smb>
			cmp.w	(a2),d6
			bne.s	@OnCorrectLine				; not at lineStart
			cmpi.w	#0,d6
			beq.s	@OnCorrectLine				; not beginning of text
			tst.b	d5
			blt.s	@OnCorrectLine				; cd <> ld
			subq	#2,a2						; previous line
@OnCorrectLine
			movem.w	d1/d2,-(sp)
			bsr		GetFormatOrdering			; <8Mar89smb>
			movem.w	(sp)+,d1/d2					; restore
			
; ***** if c = l[s] then c = c *****
; if s = 0, then l[s] = lineStart
; if s = 1, then l[s] = lineEnd
			move.b	d3,d0						; start
			bsr		TestLineEnds
			bne		@done						; c = c. done

; ***** if c = l[e] then r1 = m[p] *****
; if e = 0, then l[e] = lineStart
; if e = 1, then l[e] = lineEnd
			move.b	d4,d0						; end
			bsr		TestLineEnds
			beq.s	@FindRun
; ***** r1 = m[p] *****
; d1 = p as input
			bsr		SetRun						; returns d1.w = r1: leftmost or rightmost format
; ***** d(r1) = ld? *****
			bsr		TestRunDirection			; d1 = r1 (format index)
			bne		@CSubDelta					; True: equal
			bra		@OneCharacterTest
@FindRun			
; find r s.t. f[r,0]<c<f[r,1] OR
;	((f[r,0]=c or f[r,1]=c) AND IF on a cluster boundary then d(r)=ld
; 							   Else find r s.t. c = f[r,e])			
			bsr		FindStyleRun				; returns a0 pointing to style run of d6, d1 = r
			cmp.w	startChar(a0),d6
			beq.s	@OnBoundary
			bsr		FixFormatEnd				; <17Jan89smb> if last format run, must decrement
			cmp.w	d0,d6						; <17Jan89smb>
			bcs.s	@InMiddle					; <17Jan89smb>		<26June89smb> made unsigned
			st		FormatEndFlag(a6)			; <17Jan89smb> on end of style run
@OnBoundary
; on boundary: test for cluster boundary <17Jan89smb>
; get this style run's script direction
			movem.l	d1/d2,-(sp)					; save r (d1) and style
			bsr		GetDirection
			move.b	d1,d0
			movem.l	(sp)+,d1/d2					; <20Jan89smb>
			cmp.b	TESysJust,d0				; <20Jan89smb>
			beq		@TakeRightBranch			; <20Jan89smb>
			move.b	d0,RunDirection(a6)			; <20Jan89smb>
			
; get other boundary style run
			tst.b	FormatEndFlag(a6)			; test if at start or end of style run
			bne.s	@GetNextRun					; at end of this style run
; at start of this style run so get previous style run in backing-store order 
			subq.l	#stStartSize,a0
			bra.s	@GetScriptDir
@GetNextRun
; get next style run in backing-store since at end of this style run
			addq.l	#stStartSize,a0
@GetScriptDir
; get the other style run's script direction
			movem.l	d1/d2,-(sp)					; save r (d1) and style
			bsr		GetDirection
			move.b	d1,d0
			movem.l	(sp)+,d1/d2
; compare script directions to see if on a cluster boundary
			cmp.b	RunDirection(a6),d0
			bne.s	@ClusterBoundary
			
; On a style run boundary with both runs of the same script <17Jan89smb>
; ***** d(r) = ld? *****
; d(r) <> ld so find r s.t. c = f[r,e]
; get original boundary style again <25June89smb>
			tst.b	FormatEndFlag(a6)			; test if at start or end of style run
			bne.s	@GetPrevRun					; at end of this style run
; at start of this style run so get previous style run in backing-store order 
			add.l	#stStartSize,a0
			bra.s	@TestStylEnd	
@GetPrevRun
; get next style run in backing-store since at end of this style run
			subq.l	#stStartSize,a0
@TestStylEnd			
			move.w	d1,-(sp)					; save original r
			move.b	d4,d1						; end
			move.w	d6,d0						; save d6
			bsr		GetStyleEnd					; returns style start or end in d6
			move.w	(sp)+,d1					; restore r
			exg		d6,d0						; want original char offset in d6
			cmp.w	d0,d6						; does c = f[r,e]?
			beq.s	@GetNewIndex				; yep
			bsr		FindStyleRun				; d1 =  r s.t. c = f[r,e]

@GetNewIndex
; ***** r1 = r + fmtDelta *****
			add.w	d7,d1						; format delta
			bra.s	@NewFmtIndex				; <20Jan89smb> must check for 1 char in style run
			
@ClusterBoundary
; find r s.t. (f[r,0]=c or f[r,1]=c) AND d(r)=ld <17Jan89smb>
; Since the character is on a cluster boundary, we want the style run with it's 
; direction = the line direction (LD).
; ***** d(r) = ld? *****
			bsr		FindStyleRun				; find other boundary run with d(r) = ld; d1 = r
			bra.s	@TakeRightBranch			; True: d(r) = ld
	
@InMiddle
; firmly in the middle.  Test the line direction to determine the branch to take <17Jan89smb>
; ***** d(r) = ld? *****
			bsr		TestRunDirection			; does the direction of the run = line direction?
			bne.s	@TakeRightBranch			; True: d(r) = ld
; d(r) <> ld
; ***** c <> f[r,e] - charDelta? ***** are we one away from a style boundary?
			move.w	d1,-(sp)
			move.b	d4,d1						; end
			move.w	d6,d0						; save d6
			bsr		GetStyleEnd					; returns style start or end in d6
			move.w	(sp)+,d1
			
; must adjust for double-byte characters <2Sept89smb>
			movem.l	a0/d0-d3,-(sp)				; save <2Sept89smb>
			move.w	d5,d3						; <2Sept89smb>
			neg.w	d3							; <2Sept89smb>
; f[r,e] - charDelta (where the delta may be -2/2 rather than -1/1)
			Bsr		DoubleByte					; <2Sept89smb>
			movem.l	(sp)+,a0/d0-d3				; <2Sept89smb>
			exg		d6,d0						; want original char offset in d6
;;<2Sept89smb>			sub.w	d5,d0						; character delta
			cmp.w	d0,d6
;------------------------------------------------------------------------------------
; must pin to line end to get correct offset, so to truly be done: <22Nov89smb>
; c <> l[e] - charDelta
			beq.s	@TstFmtIndeces				; <22Nov89smb>
; if e = 0, then l[e] = lineStart
; if e = 1, then l[e] = lineEnd
			move.w	2(a2),d0					; assume e=1 so use lineEnd ; <22Nov89smb>
			cmpi.b	#0,d4						; end ; <22Nov89smb>
			beq.s	@IsLineStart				; <22Nov89smb>
			bra.s	@SubDelta					; <22Nov89smb>
@IsLineStart
			move.w	(a2),d0						; <22Nov89smb>
@SubDelta
			sub.w	d5,d0						; - charDelta <22Nov89smb>
			cmp.w	d6,d0						; <22Nov89smb>
			bne		@CAddDelta					; done
;-----------------------------------------------------------------------------------

@TstFmtIndeces
; ***** r = m[q]? *****
; in the leftmost or rightmost format? test format indeces
			move.w	d1,d0						; save r(n)
			move.b	d2,d1						; q
			bsr		SetRun						; returns m[q] in d1.w (0/n)
			cmp.w	d0,d1
			beq.s	@CUseLineSt					; yep, r = m[q]: c = l[s]
			
; ***** r1 = r + fmtDelta *****
			add.w	d7,d0						; format delta
			move.w	d0,d1						; want r1 in d1
; ***** d(r1) = ld? ***** 
@NewFmtIndex
			bsr		TestRunDirection			; does the direction of the run = line direction?
			beq.s	@CAddDelta					; False: d(r1) <> ld ; c = c + CharDelta												; True: d(r1) = ld
; ***** c = f[r1,e] *****
			move.b	d4,d1						; end
			bsr		GetStyleEnd					; returns new char offset in d6
			bra.s	@done

@TakeRightBranch
; (either on a boundary or firmly in the middle) AND d(r) = ld
; ***** c <> f[r,s]? *****
			tst.b	d3							; start
			bne.s	@EndOffset					; s = 1
; c <> f[r,0]? => start offset for format run r
			cmp.w	startChar(a0),d6
			bne.s	@CSubDelta
			bra.s	@TestFmtArrayEnds
@EndOffset
; c <> f[r,1]? => end offset for format run r
			bsr		FixFormatEnd				; <17Jan89smb> if last format run, must decrement
			cmp.w	d0,d6
			bne.s	@CSubDelta
		
@TestFmtArrayEnds
; ***** r = m[q]? *****
; in the leftmost or rightmost format? test format indeces
			move.w	d1,d0						; save r(n)
			move.b	d2,d1						; q
			bsr.s	SetRun						; returns m[q] in d1.w (0/n)
			cmp.w	d0,d1
			beq.s	@done						; yep, r = m[q]: c = c
; ***** r1 = r + fmtDelta *****
			add.w	d7,d0						; format delta
			move.w	d0,d1						; want r1 in d1
; ***** d(r1) = ld? ***** 
			bsr.s	TestRunDirection			; does the direction of the run = line direction?
			bne.s	@CSubDelta					; True: equal
			
@OneCharacterTest
; no, style run direction <> line direction
; ***** f[r1,1] - f[r1,0] <> 1? *****
; test if there is only one character in the run.
;			move.w	stStartSize(a0),d0			; <17Jan89smb>
			bsr		FixFormatEnd				; <17Jan89smb> if last format run, must decrement
			sub.w	startChar(a0),d0
			cmpi.w	#1,d0
			bhi.s	@CUseStartDelta				; c = f[r1,s] + charDelta	<26June89smb> made unsigned

; ***** r1 = m[q]? *****
; in the leftmost or rightmost format? test format indeces
			move.w	d1,d0						; save r(n)
			move.b	d2,d1						; q
			bsr.s	SetRun						; returns m[q] in d1.w (0/n)
			cmp.w	d0,d1
			beq.s	@CUseStart					; terminator is direction test
; ***** r2 = r1 + fmtDelta *****
			add.w	d7,d0						; format delta
			move.w	d0,d1						; want r1 in d1
; ***** d(r2) = ld? ***** 
			bsr.s	TestRunDirection			; does the direction of the run = line direction?
			beq.s	@CUseStartDelta				; d(r2) <> ld: c = f[r1,s] + charDelta
@CUseStart
; ***** c = f[r1,s] ******
			move.b	d3,d1						; start
			bsr		GetStyleEnd					; returns new char offset in d6
			bra.s	@done
			
@CUseStartDelta
;***** c = f[r1,s] + charDelta *****
			move.b	d3,d1						; start
			bsr.s	GetStyleEnd					; returns new char offset in d6
			bra.s	@CAddDelta

@CUseLineSt
; ***** c = l[s] *****
;			sf		teLftCaret(A3)				; set so will go to previous line in DoCaret
			move.b	d3,d1						; start
			tst.b	d1
			bne.s	@UseLineEnd
; c = l[0] = lineStart
			move.w	(a2),d6
			bra.s	@done			
@UseLineEnd
; c = l[1] = lineEnd
			move.w	2(a2),d6
			bra.s	@done
;;@CSubDelta
;;<2Sept89smb>			sub.w	d5,d6						; c = c-charDelta(a6)			
;;<2Sept89smb>			bra.s	@done
					
;;@CAddDelta
;;<2Sept89smb>			add.w	d5,d6						; c = c+charDelta(a6)

; if double-byte character fix the offset posn.<2Sept89smb>
@CSubDelta
			neg.w	d5							; <2Sept89smb>
@CAddDelta
			move.w	d5,d3						; DoubleByte wants charDelta here <2Sept89smb>
			Bsr		DoubleByte					; <2Sept89smb>
@done
			movem.l	(sp)+,CursorMoveRegs
			unlk	a6
			rts
			endWith
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TestLineEnds();
;			Test whether the character offset is the lineStart or lineEnd.
;			Entry
;				d0.b = start or end
;				a2 = line containing character offset (d6)
;			Exit
;				d0.b = T/F
;				condition codes set accordingly
;----------------------------------------------------------------------
TestLineEnds
; ***** test if c = l[s] or c = l[e] *****
			cmpi.b	#0,d0						; l[0] = lineStart; l[1] = lineEnd
			bne.s	@testEnd
; test lineStart now
			cmp.w	(a2),d6
			bne.s	@done
			st		d0
			bra.s	@done
@testEnd
			clr.b	d0
; test lineEnd now
			cmp.w	2(a2),d6
			bne.s	@done
			st		d0							; c = c. done.
@done
			tst.b	d0							; <6Mar89smb>
			rts			
			

;----------------------------------------------------------------------
;
;			PROCEDURE SetRun();
;			Set the format run index from the first or last format on the
;			line.
;			Entry
;				d1.b = format index boundary (0 = leftmost, 1 = rightmost)
;			Exit
;				d1.w = 0 or n, where n = number of runs
;----------------------------------------------------------------------
SetRun
; r = m[d1]
			tst.b	d1
			bne.s	@RightMost
; r = m[0] = 0 = first (leftmost) format
			moveq	#0,d1						; r1 = 0
			bra.s	@done
@RightMost
; r = m[1] = n = last (rightmost) format
			move.w	numberOfRuns(a6),d1			; r1 = n
			subq.w	#1,d1
@done
			rts
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TestRunDirection();
;			Determine if the direction of the style run is equal to the
;			direction of the line.
;			Entry
;				d1 = format index
;			Exit
;				d0.b = T/F
;				condition codes set accordingly
;----------------------------------------------------------------------
TestRunDirection
			move.l	ExpandMem,a1				; <28June89smb>
			move.l	ExpandMemRec.vTestRunDirection(a1),a1
			jmp		(a1)

xTestRunDirection

; ***** d(r) = ld? ***** 
			movem.w	d1/d2,-(sp)
			move.w	d1,fmtOrderingIndex(a6)		; d1 = r
			bsr		GetNextDisplayStyle			; r is index into FmtOrderingArray
; does the direction of this style run = line direction?
			clr.w	d0							; result register
			bsr		GetDirection
			cmp.b	TESysJust,d1
			bne.s	@done						; not equal
			st		d0							; T
@done
			movem.w	(sp)+,d1/d2					; restore
			tst.b	d0							; <6Mar89smb>
			rts
			
;----------------------------------------------------------------------
;
;			PROCEDURE GetStyleEnd();
;			Set the new character offset as the format's start or end
;			offset, depending on value in d0.
;
;			Entry
;				d1 = indicator for start or end position of format run
;				a0 = ptr to current style run
;			Exit
;				d6 = f[r1,d1]
;				d0 preserved
;----------------------------------------------------------------------
GetStyleEnd
			move.w	d0,-(sp)					; <17Jan89smb>
			tst.b	d1
			bne.s	@UseEnd
; f[r1,0] = start offset for format run at format index r1.
			move.w	startChar(a0),d6
; must pin style run to lineStart! <26Nov89smb>
			cmp.w	(a2),d6
			bhs.s	@done						; style start on this line <26Nov89smb>
			move.w	(a2),d6						; use lineStart <26Nov89smb>
			bra.s	@done		

@UseEnd
; f[r1,1] = end offset for format run at format index r1.
;			move.w	stStartSize(a0),d6			; new character offset
			bsr.s	FixFormatEnd				; <17Jan89smb> if last format run, must decrement
			move.w	d0,d6						; <17Jan89smb>

; must pin style run to line end if it breaks across the line! <26Nov89smb>
			cmp.w	2(a2),d6					; <26Nov89smb>
			bls.s	@done						; <26Nov89smb>
			move.w	2(a2),d6					; <26Nov89smb>
@done
			move.w	(sp)+,d0					; restore <17Jan89smb>
			rts
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE FixFormatEnd()
;				 <17Jan89smb>
; 			If in the last format run in the record want the real end
;			of the run, which is style end - 1.
;
; 			Input:
;				a0 = pointer to style run
;			 Output:
;				d0 = correct end to use
;----------------------------------------------------------------------
FixFormatEnd

			move.w	stStartSize(a0),d0			; check for last format run in record
			cmp.w	teLength(a3),d0	
			bls.s	@done						; not in last format run so use style end	<26June89smb> made unsigned
			move.w	teLength(a3),d0				; in last format: use real end of run
@done
			rts

;----------------------------------------------------------------------
;
;			PROCEDURE FindStyleRun();
;				<17Jan89smb>
;			Find r s.t. f[r,0] <= c <= f[r,1]
;
;			 Input
;				d6 = character offset
;			 Output
;				a0 = pointer to style run containing d6
;				d1 = r = fmtOrderingIndex(a6) - 1
;----------------------------------------------------------------------
FindStyleRun

			with	CursorFrame,TEFormatOrder
@RunLoop
			bsr		GetNextDisplayStyle
			move.w	fmtOrderingIndex(a6),d1
			addq	#1,fmtOrderingIndex(a6)		; incr the style run counter			
			cmp.w	startChar(a0),d6
			bhi.s	@CheckUpperBound			; in middle?	<26June89smb> made unsigned
			beq.s	@done
			bra.s	@RunLoop
@CheckUpperBound
			bsr.s	FixFormatEnd				; <17Jan89smb> if last format run, must decrement
			cmp.w	d0,d6						; <17Jan89smb>
			bhi.s	@RunLoop					; <26June89smb> made unsigned
@done
			rts
			endwith
						
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE BufferChar();
; 			Test if inputing a double-byte character; if so, buffer the first byte,
;			get the next byte, and then insert as a double-byte character
;
;				On input,
;					A2 points to word containing character (char in lower half)
;					D6 points to character to insert (differs from A2 by +1)
;					D5 contains the length of the character
;					If processing a double-byte char, TwoByteCharBuffer in TEDispatchRec
;						may contain the high byte of the character.
;				On output,
;					A2 unchanged
;					If processing a double-byte character,
;					   	 - and have the first byte, D5 and D6 unchanged
;						 - if the second byte,
;							D6 - points to the address of emBufferHandle
;							D5 - set to 2, length of character.
;					Condition codes set for test upon return.
;
;				A0, D0 used as scratch.
;					
;			** Created 3May88 by SMB **
;
;----------------------------------------------------------------------
BufferChar
			move.l		ExpandMem,a0			; <28June89smb>
			move.l		ExpandMemRec.vBufferChar(a0),a0
			jmp			(a0)

xBufferChar
;----------------------------------------------------------------------
; now buffering a double-byte character in the newTEFlags space off the dispatch record. <1/9/90smb>			move.l	teDispatchH(a3),a0
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			lea			TwoByteCharBuffer(a0),a0		; move into reg for modulo 32 bit ops
			tst.b		(a0)					; test for existance of first byte
			beq.s		Empty
; have 2nd byte now - paste!
			move.b		1(a2),1(a0)				; 2nd byte of double byte char
			move.l		a0,d6					; pointer to 2byte character (f. PasteGuts)
			add.w		#1,d5					; length = 2 bytes (f. PasteGuts), sets cc for rts
			bra.s		GoPaste
			
Empty											; possible first byte of 2 byte char
			move.b		1(a2),(a0)				; buffer character; 2 byte?
			tst.w		teSize(A3)				; check style flag
			bpl.S		@DontSet				; don't set style

			move.w		teSelStart(a3),d0		; pass current position
			beq.s		@1						; skip test if zero
			sub.w		#1,d0					; backup one to get previous style
@1
; On a Kanji script system when the styled teRec is created, the current grafport's font is
; the font in the initial style run of 0 characters.  If it's created with a Roman
; font and then the keyboard is switched to Japanese to enter Kanji, via the input window
; (different unstyled teRec), the font for the 0th posn is still Roman, rather than Kanji,
; when it's used here.  Hence must set the grafport via the SetFont2Keyboard code. <2Sept89smb>

			bsr.s		SetFont2Keyboard		; <2Sept89smb>
@DontSet
; now test with charbyte
			clr.w		-(sp)					; room for return
			move.l		d6,-(sp)				; pointer to character
			move.w		#0,-(sp)				; offset in buffer
			_CharByte
			tst.w		(sp)+					; high byte of character?
GoPaste
			rts 		
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE DoubleByte();
;				on input,
;					d3 	contains a value (1, -1) that represents the incremental
;						direction to move
;					d6	current position in selection range (teSelStart or teSelEnd) 
;
;			** Created 2May88 by SMB **
;
;----------------------------------------------------------------------

DoubleByte
; check for double-byte characters and fix starting point. <27June88smb>

; find the font!

			add.w		d3,d6 					; fix position
			tst.w		teSize(A3)				; check style flag
			bpl.S		@DontSet				; don't set style

			move.w		d6,d0					; pass current position
			bsr			GetCurStyle				; current style ptr in a0
			bsr			SetStyle				; set grafport style from current
@DontSet
; now test with charbyte

			clr.w		-(sp)					; room for return
			move.l		teTextH(a3),a0			; get handle
			move.l		(a0),-(sp)				; pointer to start of text
			move.w		d6,-(sp)				; offset in text
			_CharByte
			tst.w		(sp)+					; middle of character?
			ble.s		@Done					; no, continue
			add.w		d3,d6 					; fix position
@Done
			Rts 		

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE ExtendStyle
;
;			** Added 6/6/86 by MBK **
;
;			Handles deletion or extension of styles.
;
;	Entry:
;			D5 	length of text being inserted (preserved)
;
;----------------------------------------------------------------------
ExtendStyle
			Move.W		D5,-(SP)				; save length

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@1						; quit if not

; get selStart, selEnd and see if it's an insertion pt

			Bsr			SelSort					; sorts selStart, selEnd
			Move.W		D0,D1					; selEnd
			Swap		D0						; selStart in low byte now
			Cmp.W		D0,D1					; is it an insertion pt?
			Beq.S		@0						; no styles to delete if so

; If insertion is replacing a selection, you want to use the style of the
; first character of the selection (whereas if it's an insertion pt, you
; use the previous character's style).

			SubQ		#1,D5					; dec insertion length
			AddQ		#1,D0					; pt to next char

			Bsr			DeleteStyle				; else, delete excess styles from selStart+1 -> selEnd

@0			Tst.W		D5						; anything to insert?
			Beq.S		@1						; you're done if not

			SubQ		#1,D0					; pre-decrement
			Bsr			GetCurStyle				; else get current style
			Bsr			RecalStStarts			; update style starts
			
@1			Move.W		(SP)+,D5				; restore length

			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			SetFont2Keyboard
;
;			<5Sept89smb>
;
;			When get a key and keyboard is different from font @ teSelStart
;			change the font to match the keyboard.  Will never come here 
;			for an unstyled teRecord.
;
;		Entry:
;			d0 = teSelStart (or one posn before it)
;		Uses:
;			d0,d1,a0,a1. Preserves d4,a2
;----------------------------------------------------------------------
SetFont2Keyboard
			move.l	ExpandMem,a0			; <28June89smb>
			move.l	ExpandMemRec.vSetFont2Keyboard(a0),a0
			jmp		(a0)

xSetFont2Keyboard
			bsr		GetCurStyle
; if only 1 script installed none of this is necessary
			move.l	ExpandMem,a1			; <1Feb89smb>
			cmpi.b	#1,ExpandMemRec.emScriptsInstalled(a1)
			beq		@Done					; only one script => keyboard set just fine!

			movem.l	d4/a2,-(sp)				; save
; get the keyboard script						
			move.l	a0,a2					; save style ptr
			clr.l	-(sp)
			move.w	#smKeyScript,-(sp)		; verb
			_GetEnvirons
			move.l	(sp)+,d4				; actually only a word

;---------------------------------------------------------------------------------
; If have an unsynchronized font & keyboard, and the KeyScript is not Roman, then synchronize
; the font and keyboard. <3Dec89smb>
			move.l	ExpandMem,a0
			tst.b	ExpandMemRec.emUnsynchedFlag(a0)
			beq.s	@TstNullStyle			; bra if synched up
; we are unsynchronized but are the keyScripts different?
			sf		ExpandMemRec.emUnsynchedFlag(a0)	; assume will synch up
			cmp.w	#smRoman,d4				; if unsynchronized, the keyScript was Roman
			bne.s	@TstNullStyle			; bra if want to synch up ?

			st		ExpandMemRec.emUnsynchedFlag(a0)	; don't synch up
			move.w	styleIndex(a2),d0		; get index to styleRec
			bsr		GetStyle				; get the styleRec in a0
			move.l	a0,-(sp)				; temp save
			move.l	a2,a0					; restore current style ptr
			bsr		SetStyle				; set the grafport; preserves a0
			move.l	(sp)+,a0				; restore styleRec
			move.w	stFont(a0),d0			; want current font here when branch!
			bra.s	@SetFont				; bra if equ: want to stay unsynched
			
; the new keyScript is non-Roman and we're currently unsynchronized so synch up
@TstNullStyle			
;---------------------------------------------------------------------------------
	IF NOT hasBufferingFix THEN				; 														<18>
; before synchronizing dump the text buffer: could change the keyboard in the middle of buffering <1/26/90smb>
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d0	; move into reg for modulo 32 bit ops
			btst		#teFTextBuffering,d0
			beq.s		@noBuffer
			bsr			DumpBuffer			; dump text from buffer
@noBuffer	
	ENDIF									;														<18>

; if a null style exists and it's font corresponds to the keyScript, use it!
			bsr		AnyNullStyle			; returns a0 pointing to the null scrap record; cc's set
			beq.s	@styleLoop				; nope
			lea		scrpStyleTab(a0),a0		; point to start of table
			
; must test if font is of the same script before using it
			move.l	a0,-(sp)				; save scrpStyleTab
			sub.w	#2,sp					; allocate return, 1 int
			move.w	scrpFont(a0),-(sp)		; scrpFont 
			_Font2Script					; get script from font
			move.w	(sp)+,d1				; fontScript
			move.l	(sp)+,a0				; restore scrpStyleTab
			move.w	scrpFont(a0),d0			; want current font here when branch!
			
			cmp.w	d1,d4					; is the scrpFont's script = the keyscript?
			beq.s	@SetFont				; already rsrved but must write to grafport

	IF hasBufferingFix THEN					; 														<18>
; before synchronizing dump the text buffer: could change the keyboard in the middle of buffering <1/26/90smb>
; Dump here rather than inside the styleLoop below and after we are sure that things aren't synched.<18>
			move.l	teDispatchH(a3),a0
			move.l	(a0),a0
			move.l	newTEFlags(a0),d0		; move into reg for modulo 32 bit ops
			btst	#teFTextBuffering,d0
			beq.s	@noBuffer
			bsr		DumpBuffer				; dump text from buffer
@noBuffer	
	ENDIF									;														<18>

; no null style exists or bad font
; d4.b = the keyScript
; a2.l = the current style ptr.

; Test if the current font is the correct script If not, use the keyScript to determine
; a font to use. Will find the font by looking back in the styleRun array until we find
; a font whose script corresponds to the keyScript.  If none exist, we'll use the script
; system's default font.

@styleLoop
			move.w	styleIndex(a2),d0		; get index to styleRec
			bsr		GetStyle				; get the styleRec in a0
			move.l	a0,-(sp)				; temp save
			
; set the grafport now since in the case of a selection SetRsrved does nothing (must set for BufferChar). 
			move.l	a2,a0					; restore a0
			bsr		SetStyle				; preserves a0
			sub.w	#2,sp					; allocate return, 1 int
			_FontScript						; get script from font in grafport
			move.w	(sp)+,d1				; fontScript
			move.l	(sp)+,a0				; restore styleRec
			move.w	stFont(a0),d0			; want current font here when branch!
			
; test if the keyboard script is the same as the fontScript
			cmp.w	d1,d4					; is the font's script = the keyscript?
			beq.s	@SetFont				; yep, use it.

			cmpi.w	#0,startChar(a2)		; are we at the start of the styleRun array yet?
			beq.s	@UseKbdScript			; yes.
			subq	#stStartSize,a2			; no, next!
			bra.s	@styleLoop
			
@UseKbdScript
; no more styles to check, use script system's application font
			clr.l	-(sp)					; allocate return
			move.w	d4,-(sp)				; script
;;			move.w	#smScriptSysFond,-(sp)	; verb
			move.w	#smScriptAppFond,-(sp)	; verb: use application font <3Dec89smb>
			_GetScript
			move.l	(sp)+,d0				; font is only a word

@SetFont
; are we replacing a selection? <6Sept89smb>
			move.w	teSelStart(a3),d1		; get selection start
			cmp.w	teSelEnd(a3),d1			; same as selEnd?
			beq.s	@notSelection
; is a selection so delete selection and then set
			move.l	d0,d4					; save the font
			move.l	a4,-(sp)				; pass the handle
			_TEDelete
			move.l	d4,d0					; restore the font and set it!
@notSelection
; load new font as in textStyle.tsFont
; d0 = font to use
			move.l	ExpandMem,a0			; textStylePtr: actually only font attribute
			move.w	d0,ExpandMemRec.emNewFont(a0)
			move.l	a0,a2
			lea		ExpandMemRec.emNewStyle(a2),a2
			lea		ExpandMemRec.emNewFont(a0),a0
; redraw flag and mode already set at init time above
			move.l	a0,2(a2)				; only stuffed the font: need address of emNewFont
			bsr		SetRsrved				; call this routine, which TESetStyle calls
			movem.l	(sp)+,d4/a2
@Done
			Rts
			
;formFeed
;----------------------------------------------------------------------
;
;			ClickKeyboard2Font
;
;			<3Dec89smb>
;
;			When click in Roman text (whether as an insertion point or selection),
;			in a non-Roman font, set the keyboard to Roman.  This is the only
;			time we will allow an unsynchronized font and keyboard. Used by TEClick
;			and TESetSelect since for hit-down or cursor movement.
;			This is only used for styled text.
;
;			ENTRY
;				The font must have been set in the grafport upon entry
;				d0 = the current char offset or teSelStart
;			USES
;				a1,d0-d2
;				preserves a0/d3/d4
;----------------------------------------------------------------------
ClickKeyboard2Font
			
; if only 1 script installed none of this is necessary
			movem.l		a0/a2/d3/d4,-(sp)		; save style ptr								<34> added a2 for text ptr
			move.l		ExpandMem,a1			; <1Feb89smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a1)
			beq			@done					; only one script => keyboard set just fine!

			move.w		d0,d3					; char offset to use for synching <3Dec89smb>			
; get the script (the font must have been set in the grafport already)			
			sub.w		#2,sp					; allocate return, 1 int
			_FontScript							; get script from font in grafport
;---------------------------------------------------------------------
; Will now allow a Roman keyboard and a non-Roman font for hit-down; KanjiTalk wants
; to be able to input Roman text from a Kanji font <3Dec89smb>

; if we're in single-byte Roman text, and the font is non-Roman then 
; want keyboard to be Roman <3Dec89smb>
			move.l		ExpandMem,a0			; initialize to false <3Dec89smb>
			sf			ExpandMemRec.emUnsynchedFlag(a0)	; <3Dec89smb>			

; if the font script = Roman then synch keyboard to the font
			move.w		(sp)+,d4				; font script
			beq.s		@UseFont

; Always synchronize the keyboard & font unless a double-byte script. 							<34>
			subq		#4,sp					;												<34>
			move.w		d4,-(sp)				;												<34>
			move.w		#smScriptRedraw,-(sp)	;												<34>
			_GetScript							;												<34>
			move.l		(sp)+,d0				;												<34>
			tst.b		d0						; result is a byte								<34>
			ble			@UseFont				; 0 = single byte LR script, -1 = RL script, 1 = double-byte script	<34>
			
; If we're not in single-byte Roman text then synch keyboard to the font
; now test with CharByte to see if we're in Roman text
			subq		#2,sp					; room for return
			move.l		teTextH(a3),a2			; get handle
			move.l		(a2),a2					; save text ptr to re-use						<34>
			move.l		a2,-(sp)				; pointer to start of text						<34>
			move.w		d3,-(sp)				; offset in text
			_CharByte
			tst.w		(sp)+					; high byte of character?
			bne.s		@UseFont				; if not single byte text, synch to font script

; Is a single byte character…
; Is this Roman text?
			subq		#2,sp					; room for return
			move.l		a2,-(sp)				; pointer to start of text
			move.w		d3,-(sp)				; offset in text			
			_CharType
			move.w		(sp)+,d0				; now let's see what "type" of char we have!
			
; Mask off what interested in: the Type ($000F) and the Direction ($2000)
; Want a char whose Direction is LR (smCharLeft, $0000) and whose Type is Roman letter
; which can be smCharAscii (1) or smCharEuro (7). smCharPunct (0) should not synch to Roman.
			and.w		#smcTypeMask+smcRightMask,d0
;;			beq.s		@UseFont				; smCharPunct = 0
			cmp.w		#smCharAscii,d0
			beq.s		@Set2Roman
			cmp.w		#smCharEuro,d0			; not really necc f. 2-byte scripts…			<34>
			bne.s		@UseFont				; otherwise, must use the font script
@Set2Roman
; want the keyboard to be Roman rather than synchronized to the font script <3Dec89smb>
			move.w		#smRoman,d4
			move.l		ExpandMem,a0			; indicate that we have an anamoly now! <3Dec89smb>
			st			ExpandMemRec.emUnsynchedFlag(a0)	; <3Dec89smb>
@UseFont
			move.w		d4,-(sp)
;---------------------------------------------------------------------
; change the keyboard to match the current selection's script.

	IF forLocalizability THEN					; <31f-YDS-8/27/91>
			Move.w	(sp), d0					; script param on the stack from FontScript call !!!
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0						;
			move.b	d0, lastScript(a0)			; push script numberused to highligt (d0) to lastScript
	ENDIF

			_KeyScript							; script param on the stack from FontScript call
@done
			movem.l		(sp)+,a0/a2/d3/d4		; restore style ptr								<34> added a2
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			SetKeyboard2Font
;
;			<10Nov88smb>
;
;			When click in text (whether as an insertion point or selection),
;			synch keyboard to font.  Will never come here for an 
;			unstyled teRecord. <10Nov88smb>
;
;			ENTRY
;				The font must have been set in the grafport upon entry
;			USES
;				a1,d0-d2
;				preserves a0
;----------------------------------------------------------------------
SetKeyboard2Font
			move.l		ExpandMem,a1			; <28June89smb>
			move.l		ExpandMemRec.vSetKeyboard2Font(a1),a1
			jmp			(a1)
			
xSetKeyboard2Font

; if only 1 script installed none of this is necessary
			move.l		a0,-(sp)				; save style ptr
			move.l		ExpandMem,a1			; <1Feb89smb>
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a1)
			beq.s		@done					; only one script => keyboard set just fine!

; turn off the flag set when TE creates an unsynchronized font & keyboard situation <3Dec89smb>
			sf			ExpandMemRec.emUnsynchedFlag(a1)	; <3Dec89smb>
			
; get the script (the font must have been set in the grafport already)			
			sub.w		#2,sp					; allocate return, 1 int
			_FontScript							; get script from font in grafport

; change the keyboard to match the current selection's script.

	IF forLocalizability THEN					; <31f-YDS-8/27/91>
			Move.w	(sp), d0					; script param on the stack from FontScript call !!!
			move.l	teDispatchH(a3),a0			; get teDispatchH addres
			move.l	(a0),a0						;
			move.b	d0, lastScript(a0)			; push script numberused to highligt (d0) to lastScript
	ENDIF
			_KeyScript							; script param on the stack from FontScript call
@done
			move.l		(sp)+,a0				; restore style ptr
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE FindLineHite
;
;			** Added 6/16/86 by MBK **
;
;			Finds the given line and returns its line height.
;
;	Entry:
;			D3 	selStart
;	Exit:
;			D1 	height of this line
;
;----------------------------------------------------------------------
FindLineHite
			Move.L		A2,-(SP)				; save A2

			Lea			teLines(A3),A2			; pt to start of linestarts
			Move.W		D3,D0					; offset
			Bsr			GetLine					; get line that it's on
			Bsr			PtrToLine				; get line # from A2

; Get maximum height on this line from the array
			Bsr			GetHite					; get height of this line

			Move.L		(SP)+,A2				; restore A2

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TESetJust( just: INTEGER; h: TEHandle	);
;
;			Sets the justify mode. DOESN'T redraw.  Lovely code...
;
;----------------------------------------------------------------------
;TESetAlignment									; comment out for now			<45>
TESetJust
			Bsr.w 		StdEntry
			Move		(A2),teJust(A3) 		; set the style
			Bra.w		epilog6					;								<C971/RWW102887>NO


;----------------------------------------------------------------------
;
;			PROCEDURE Refresh
;
;			Redraws the lines intersected verticals top in D0, bottom in D1
;
;----------------------------------------------------------------------

Refresh
			MoveQ		#0,D3					; min/max redraw pins in DoDraw
			MoveQ		#-1,D4
			Bsr 		PinA0Rect				; pass A0 rect to Pin code

			MoveQ		#teDraw,D7				; drawit
			Bsr 		DoText

			Bsr 		HiLite					; reshow selection

			Tst.B		teCarOn(A3) 			; force a redraw if caret is on
			Beq.S		handyReturn 			; if off skip it
			Bra 		ForceCaret				; implied return

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEScroll( dh, dv: INTEGER; h: TEHandle )
;
;			Scrolls the dest rect "under" the view rect to give the caller
;			scrolling ability.  A call of ( 0, -lineheight, h) would scroll up
;			one line, because dest rect is offset by the passed (dh,dv).  The
;			resultant update region is redrawn
;
;----------------------------------------------------------------------
TEScroll
			Bsr 		StdEntry

			Bsr 		HideCaret

			Move.L		(A2)+,D3				; get dv,dh pair
			Bsr.S		Scroll
epilog8
			MoveQ		#8,D0
			Bra 		StdExit

; Amount to scroll in D3

Scroll
			Tst.L		D3						; escape if nothing there
			Beq.S		ActCaret				; fix errant HideCaret (and Rts…)	<C971/RWW110587>

			Pea 		teDestRect(A3)			; pass the dest rectangle
			Move.L		D3,-(SP)				; pass dh, dv
			_OffsetRect

			SubQ		#4,SP					; make room for temp region
			_NewRgn 							; get it
			Move.L		(SP)+,A2				; save its handle

			Pea 		teViewRect(A3)			; pass rect to scroll
			Move.L		D3,-(SP)				; pass dh, dv
			Move.L		A2,-(SP)				; pass the temp region
			_ScrollRect

			Bsr.S		ActCaret				; just activate, don't draw		<C971/RWW102887>NO

			Move.L		A2,-(SP)				; clip to it update rgn
			_SetClip

			Move.L		(A2),A0 				; point to region
			Lea 		rgnBBox(A0),A0
			Bsr.s		Refresh 				; and redraw those lines

			Move.L		A2,-(SP)				; get rid of temp region
			_DisposRgn
@0
handyReturn
			Rts


; ** <C207/14oct86/MBK> ** Don't draw caret yet, just activate it
ActCaret	Tst.B		teActive(A3)			; do nothing if not active
			Beq.S 		@0						;								<C971/RWW102887>NO

			Move		teSelStart(A3),D0		; see if should be turned on
			Cmp 		teSelEnd(A3),D0
			Bne.S		@0						; if selection <> 0 then escape
			ST			teCarAct(A3)			; replaced ShowCaret

@0			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEPinScroll( dh, dv: INTEGER; h: TEHandle )
;
;			** Modified 6/18/86 by MBK **
;
;			Scrolls the dest rect "under" the view rect to give the caller
;			scrolling ability.  A call of ( 0, -lineheight, h) would scroll up
;			one line, because dest rect is offset by the passed (dh,dv).  The
;			resultant update region is redrawn.  This version pins the scroll
;			amount to the destRect/nLines
;
;----------------------------------------------------------------------
TEPinScroll
			Bsr 		StdEntry

			Bsr 		HideCaret
; get vertical parameter
			Move		(A2),D0 				; get dV
			Bpl.S		@PinTop					; pin top

			Move.W		teNLines(A3),D1			; last line				** MBK 6/18/86 **
			Move.W		teLength(A3),D0			; last char				**<C207/14oct86/MBK> **
			Tst.W		D0						; anything in file?		**<C207/14oct86/MBK> **
			Beq.S		@0						; skip test if not		**<C207/14oct86/MBK> **

			Move.L		teTextH(A3),A0			; text handle			**<C207/14oct86/MBK> **
			Move.L		(A0),A0					; dereference			**<C207/14oct86/MBK> **
			Cmp.B		#returnChar,-1(A0,D0)	; file end with CR?		**<C207/14oct86/MBK> **
			Bne.S		@0						; end of file if not	**<C207/14oct86/MBK> **

			AddQ		#1,D1					; else 1 more line		**<C207/14oct86/MBK> **

@0			MoveQ		#0,D0					; 1st line				** MBK 6/18/86 **
			Bsr			GetLineHites			; compile max hites		** MBK 6/18/86 **
			Move.W		D0,D1					; hite from 1st to last	** MBK 6/18/86 **
			Move.W		(A2),D0					; restore D0			** MBK 6/18/86 **

			Add 		teDestRect+top(A3),D1	; get destRect.top

			Sub 		teViewRect+bottom(A3),D1; a diff. viewRect.bottom
			Ble.S		@2						; dest already gone...
			Add 		D1,D0					; see what delta does
			Bpl.S		pinH

			Bra.S		@2						; should be subtracted because it's negative

@PinTop
; scrolling down
			Move		teDestRect+top(A3),D1	; add destRect.top
			Sub 		teViewRect+top(A3),D1	; diff. viewRect.top
			Bpl.S		@2						; already bad

			Add 		D1,D0
			Bmi.S		pinH
@2
			Sub 		D0,(A2) 				; adjust scroll
pinH
			Move		2(A2),D0				; get dH
			Bpl.S		@1						; pin top
			Move		teDestRect+right(A3),D1 ; add destrect.right
			Sub 		teViewRect+right(A3),D1 ; a diff. viewRect.right
			Ble.S		@2						; already past, cancel scroll
			Add 		D1,D0
			Bpl.S		pinDone
;;			Add 		D0,2(A2)				; adjust scroll
			Sub			d0,2(a2)				; bug found in MacDTS <12/19/88smb> 
			Bra.S		pinDone
@1
			Move		teDestRect+left(A3),D1	; add destRect.left
			Sub 		teViewRect+left(A3),D1	; diff. viewRect.left
			Bpl.S		@2						; already past, cancel scroll
			Add 		D1,D0
			Bmi.S		pinDone
@2
			Sub 		D0,2(A2)				; adjust scroll
pinDone

			Move.L		(A2)+,D3				; get dv,dh pair
			Bsr 		Scroll					; and go scroll it

			Bsr			ActCaret				; just activate, don't draw	** <C207/14oct86/MBK> **
			Bra 		epilog8
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TESelView( hTe: TEHandle );
;
;			** Modified 6/18/86 by MBK **
;
;			Insures the selection is in view rect.  SelView is a local
;			copy of it
;
;----------------------------------------------------------------------

TESelView
			Bsr 		StdEntry				 ; doo dah...

			Bsr.S		SelView 				; go do it

			Bra 		epilog4

; local cover (A4/A3 pointing to usual record)
SelView
; <PMAB381/RWW020488>
;	Changed from teFlags to new whizzy position in TEDispatchRec
;			BTst		#tefAutoPos,teFlags(A3) ; scrolling allowed?
			Move.L		teDispatchH(A3),A0
			Move.L		(A0),A0
			Move.L		newTEFlags(A0),D0
			BTst		#teFAutoScr,D0
			Beq.s		@Exit					; if not, must skip
			
			Bsr 		SelSort 				; sort selection

			Move		teSelStart(A3),D3		; dispStart:=selStart
			Move		D3,D4					; dispEnd:=same

			MoveQ		#teCaret,D7				; does nothing except moves pen
			Bsr 		DoText					; position for the caret

; test for split caret: if exists, want the high caret in view. <21Dec88smb>
			move.l		ExpandMem,a0			; <1Feb89smb>
			cmpi.w		#$FFFF,ExpandMemRec.emTwoCursorsFlag(a0)		; <21Dec88smb>
			bne.s		@HighCaretRect			; <21Dec88smb>
; use rect stored in emCursor2Rect: this is the High caret location. <21Dec88smb>
			lea			ExpandMemRec.emCursor2Rect(a0),a0	; top, left, bottom, right <12July89smb>
			move.l		(a0),d7					; <21Dec88smb>
			bra.s		@Continue				; <21Dec88smb>
@HighCaretRect
			Move.L		teSelRect+topLeft(A3),D7 ; save penloc in D7
@Continue
			Lea 		TempRect+8,A2			; place for working rect
			Lea 		teViewRect+8(A3),A0 	; source
			Move.L		-(A0),-(A2)
			Move.L		-(A0),-(A2)

			Move		teSelStart(A3),D3		; dispStart:=selStart	** <C95/4aug86/MBK> **
			Bsr			FindLineHite			; get height of line	** <C95/4aug86/MBK> **
			Sub 		D1,bottom(A2)
			SubQ		#1,right(A2)			; room for caret

			SubQ		#2,SP
			Move.L		D7,-(SP)				; pass selStart location
			Move.L		A2,-(SP)				; pass adjust viewRect
			_PtInRect
			Tst.B		(SP)+
			Bne.S		@Exit						; if visible, then OK

			Move.L		(A2)+,-(SP) 			; get adjusted viewRect.topLeft

			Move.L		(A2),-(SP)				; get adjusted viewRect.botRight
			Move.L		-(A2),-(SP) 			; subtract adjusted topLeft
			Pea 		4(SP)
			_SubPt
			Pea 		4(SP)					; add top to delta
			_AddPt
			Move.L		D7,-(SP)				; subtract penloc
			Pea 		4(SP)					; to "center" pen if possible
			_SubPt
			Move.L		A4,-(SP)

			_TEPinScroll 						; s/b a trap		** <C381/6nov86/MBK> **

@Exit
			Rts 								; adios

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEAutoView( auto: BOOLEAN; hTe: TEHandle );
;
;			Sets the autoview bit according to the boolean
;
;----------------------------------------------------------------------

TEAutoView
			Bsr 		StdEntry				 ; doo dah...

			Move.L		teDispatchH(A3),A0		; <PMAB381/RWW020488>
			Move.L		(A0),A0					; <PMAB381/RWW020488>
			Move.L		newTEFlags(A0),D0		; <PMAB381/RWW020488>

			Tst.B		(A2)+					; was it true
			Beq.S		@0

;;			BSet		#tefAutoPos,teFlags(A3) ; allow scrolling
			BSet		#teFAutoScr,D0			; <PMAB381/RWW020488>
			Bra.S		@1
@0
;;			BClr		#tefAutoPos,teFlags(A3) ; allow scrolling
			BClr		#teFAutoScr,D0
@1
			Move.L		D0,newTEFlags(A0)
			Bra 		epilog6

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEFeatureFlag( verb: word; action: word; hTe: TEHandle ):word;
;			<30May89smb>
;
;			Sets the verb field <selector> bit according to the action,
;			but preserve the old value as the result.
;
;			Verb or bit definitions for newTEFlags
;				teFAutoScr			EQU		0				; (00000001b)
;				teFTextBuffering	EQU		1				; (00000010b)
;				teFOutlineHilite	EQU		2				; (00000100b)
;				teFInlineInput		EQU		3				; (00001000b)
;				teFUseTextServices	EQU		4				; (00010000b)
;
; 			Action for the new "bit (un)set" interface
;				TEBitClear		equ			0
;				TEBitSet		equ			1				; set the selector bit.
;				TEBitTest		equ			-1				; no change; just tell the present value
;
;----------------------------------------------------------------------
iTEFeatureFlag
			moveq		#0,d0
			moveq		#0,d1
			move.w		(a2)+,d0				; action
			move.w		(a2)+,d1				; verb bit (which feature to affect)
			
			move.l		teDispatchH(a3),a0
			move.l		(a0),a0
			move.l		newTEFlags(a0),d2		; move into reg for modulo 32 bit ops <15Sept89smb>
			clr.w		(a2)					; <6Oct89smb> necessary so the return result of 'clear' is correct.
			btst		d1,d2					; <15Sept89smb>
			sne			(a2)					; save result
			
			tst.w		d0						; whatcha wanna do?
			blt.s		@done					; action = testFlag; result already on stack
			beq.s		@clear
			bset		d1,d2					; action = setFlag <15Sept89smb>
			bra.s		@done
@clear
			bclr		d1,d2					; action = clearFlag <15Sept89smb>
@done
			move.l		d2,newTEFlags(a0)		; <15Sept89smb>
			tst.b		(a2)					; <13Sept89smb>
			beq.s		@OK
			move.w		#1,(a2)
@OK
			moveq		#10,d0					; # of bytes on stack (include selector!)
			bra			stdExit2
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE DefClikProc
;
;			Default click proc for scrolling - does a pinned autoscroll of
;			the destRect to match the viewrect.
;		Entry:
;			A3 pointing to the dereferenced text edit record
;			A6 pointing to the standard stack frame
;			thePort set, etc.
;		Exits:
;			CC's set <> 0
;
;----------------------------------------------------------------------
DefClikProc
			MoveM.L 	D0-D7/A0-A4,-(SP)		; save ALL regs

;			BTst		#tefAutoPos,teFlags(A3) ; scrolling allowed?
			Move.L		teDispatchH(A3),A0		; <PMAB381/RWW020488>
			Move.L		(A0),A0					; <PMAB381/RWW020488>
			Move.L		newTEFlags(A0),D0		; <PMAB381/RWW020488>
			BTst		#teFAutoScr,D0			; <PMAB381/RWW020488>
			
			Beq.S		doneAuto				; if not, must skip

			Lea 		teViewRect+8(A3),A0 	; point to view rect
			Lea 		TempRect+8,A2			; copy into TempRect
			Move.L		-(A0),-(A2)
			Move.L		-(A0),-(A2)

			SubQ		#4,SP					; room for pt
			Move.L		SP,-(SP)
			_GetMouse
			Move		(SP)+,D6				; get V coordinate
			Move		(SP)+,D7				; get H coordinate

			MoveQ		#0,D4					; horz scroll amt
			Move		teLineHite(A3),D1		; vert scroll amt
			Bpl.S		@1						; use if not negative				** <C207/13oct86/MBK> **

			Move.W		D6,D0					; find D6 line						** <C207/13oct86/MBK> **
			Cmp.W		teDestRect+bottom(A3),D0 ; pt below the rect?				** <C207/13oct86/MBK> **
			Ble.S		@0						; okay if less or same				** <C207/13oct86/MBK> **

			Move.W		teDestRect+bottom(A3),D0 ; else reset to bottom				** <C207/13oct86/MBK> **

@0			Bsr			PtToLine				; try to find its line #			** <C207/13oct86/MBK> **
			Bge.S		noAuto					; no scroll if line doesn't exist	** <C207/13oct86/MBK> **	<4>
			Bsr			GetHite					; else get its height

@1			Cmp 		(A2)+,D6				; subtract top of viewRect
			Blt.S		scrollUp				; scroll up

			Cmp 		(A2)+,D7				; subtract left of viewRect
			Blt.S		scrollLeft				; scroll left

			Cmp 		(A2)+,D6				; subtract bottom of viewRect
			Bgt.S		scrollDown				; scroll down

			Cmp 		(A2)+,D7				; subtract right of viewRect
			Bgt.S		scrollRight 			; scroll right

noAuto											;											<4>
			clr.l		teClikTime(a3)			; clear it out because we're not scrolling	<4>
doneAuto
			MoveQ		#1,D0					; cc's <> 0
			MoveM.L 	(SP)+,D0-D7/A0-A4		; restore ALL regs
			Rts

scrollDown
			Neg 		D1						; flip direction
scrollUp
			Bra.S		scrollEm

scrollRight
			Neg 		D1						; flip direction
scrollLeft
			Exg 		D4,D1					; switch axes
scrollEm

; Finally do the scroll
			lea			-10(sp), sp				; reserve space for call to ScrollDelay		<4>
			move.w		#1,-(sp)				; itemsVisible = smallest possible (1)		<4>
			move		d4,-(sp)				; pass dh
			move		d1,-(sp)				; pass dv

			movea.l		a3, a0					; Grab Text Edit pointer from A3			<sm9>
			_RecoverHandle						; Recover the tehandle						<sm9>
			move.l		a0,-(sp)				; slam tehandle onto stack					<sm9>

			subq.l		#4,sp					;											<4>
			_TickCount							; Get a time stamp.							<4>
			move.l		(sp)+,d1				; Copy it into D1.							<4>
			move.l		d1,10(sp)				; And put it on the stack for ScrollDelay.	<4>

; Note:	teClikTime is a state variable in the TERecord which is used by TEClick.
;		Fortunately, TEClick does not use it at all within its body; it only checks its
;		value on entry and sets it on exit.  This code relies on it also being set on
;		entry, just after it has been tested.  Of course, this restricts its use to
;		click procs, but that's okay.

			move.l		teClikTime(a3),d0		; See if it's a new scroll					<4>
			bne.s		@gotTime				; Skip if not								<4>
			move.l		d1,teClikTime(a3)		; Otherwise, put in a new stamp				<4>
			move.l		d1,d0					; in D0 too									<4>

@gotTime
			move.l		d0,14(sp)				; D0 is startTicks for ScrollDelay			<4>
	
			_TEPinScroll 						;_TEPinScroll		** <C381/6nov86/MBK> **

			_ScrollDelay						;											<4>
			AddQ.L		#2,SP					; Toss the result							<4>
	
			Bra.S		doneAuto				;								<C971/RWW102887>NO

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetCurStyle
;
;			** Added 6/5/86 by MBK **
;
;			Gets the current style; in other words, it finds the 1st style
;			descriptor preceding the current selection.
;
;	Entry:
;			D0 	selection start (whose style we wish to find)
;
;	Exit:
;			D0 	index into runs array of current style
;			A0	ptr into runs array to current style
;
;----------------------------------------------------------------------
GetCurStyle
			MoveM.L		D1-D4,-(SP)

; get low and high indeces, and ptr to array for binary search
			AddQ		#1,D0					; don't get preceding style
			Move.W		D0,D2					; save the key (sel start)
			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; deref
			Move.W		nRuns(A0),D1			; high index
			Lea			runs(A0),A0				; pt to runs array
			MoveQ		#0,D0					; low index

; start of binary search loop
@0			Cmp.W		D0,D1					; are indeces the same?
			Beq.S		@3						; we're done if so

			Move.W		D1,D3
			Add.W		D0,D3					; low + high
			LsR.W		#1,D3					; divide by 2
			MoveQ		#0,D4					; clear the long word	** <C381/6nov86/MBK> **
			Move.W		D3,D4					; middle
			LsL.L		#2,D4					; mult by stStartSize	** <C381/6nov86/MBK> **
			Cmp.W		0(A0,D4),D2				; do we have a match?
			Beq.S		@2						; we're done if so
			Bls.S		@1						; range is low to mid

; no change in high; low gets middle + 1
			Move.W		D3,D0					; low := middle + 1
			AddQ		#1,D0
			Bra.S		@0						; try again

; no change in low; high gets middle
@1			Move.W		D3,D1					; else high := middle
			Bra.S		@0						; try again

@2			Move.W		D3,D0					; store answer in D0

; return ptr into runs array and index to the styleRec
@3			Tst.W		D0
			Beq.S		@4						; special case of 1st style

			SubQ		#1,D0					; point to prev style

@4			MoveQ		#0,D1					; clear the long word	** <C381/6nov86/MBK> **
			Move.W		D0,D1
			LsL.L		#2,D1					; mult by stStartSize	** <C381/6nov86/MBK> **
			Add.L		D1,A0					; ptr to style start

			MoveM.L		(SP)+,D1-D4

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetNumStyles
;
;			** Added 5/28/86 by MBK **
;
;			GetNumStyles counts the number of styles in the current
;			selection range in the text.
;
;	Entry:
;			D1:			selEnd
;			A0:			ptr to current style in runs array
;
;	Exit:
;			D0:			# of styles within current selection
;			a0:			preserved
;----------------------------------------------------------------------
GetNumStyles
			Move.L		A0,-(SP)				; save ptr

			Move.L		teStylesH(A3),A1		; handle to style info
			Move.L		(A1),A1					; dereference
			MoveQ		#0,D0					; clear whole register		** <C381/6nov86/MBK> **
			Move.W		nRuns(A1),D0			; # of style starts
			Lea			runs(A1),A1				; pt to style starts
			LsL.L		#2,D0					; * stStartSize				** <C381/6nov86/MBK> **
			Add.L		D0,A1					; pt to last style start
			MoveQ		#0,D0					; init the counter

; keep checking style starts till one is >= selEnd (eventually it MUST be)
@0			Add.L		#stStartSize,A0			; point to next style record
			AddQ		#1,D0					; at least 1 style

			Cmp.L		A0,A1					; reached the end?
			Beq.S		@1						; quit if so

			Cmp.W		startChar(A0),D1		; is style within selection?
			Bhi.S		@0						; made this unsigned	** <C381/6nov86/MBK> **

@1			Move.L		(SP)+,A0

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE GetStyle
;
;			** Added 5/29/86 by MBK **
;
;			GetStyle returns a pointer to the style found at the given
;			index into the style array.
;
;	Entry:
;			D0:			style index
;			A3:			Ptr to TERec
;	Exit:
;			A0:			style pointer
;
;----------------------------------------------------------------------
GetStyle
			MulU		#stRecSize,D0			; multiply index by size of record
			Move.L		teStylesH(A3),A0		; get style handle
			Move.L		(A0),A0					; dereference
			Move.L		styleTab(A0),A0			; handle to styles array
			Move.L		(A0),A0					; dereference
			Add.L		D0,A0					; point to style descriptor

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE RecalStStarts
;
;			** Added 5/23/86 by MBK **
;
;			Recomputes the starting offsets of each style in the text
;			following the current one.  It adds the length of the newly
;			inserted text to each offset following the insertion point.
;
;		Entry:
;			D0 index to current style in runs array
;			D5 length of inserted text
;			A0 pointer to the current style in runs array
;
;----------------------------------------------------------------------
RecalStStarts
			Move.L		teStylesH(A3),A1		; get handle to style info
			Move.L		(A1),A1					; deref
			Move.W		nRuns(A1),D1			; get # of style starts
			Sub.W		D0,D1					; subtract current index
			Bls.S		@1						; made this unsigned	** <C381/6nov86/MBK> **

; add length of inserted text to all following style starts
@0			Add.L		#stStartSize,A0			; point to next style record
			Add.W		D5,startChar(A0)		; add length to starting offset
			SubQ		#1,D1					; dec the counter
			Bne.S		@0

@1
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE SetRsrved;
;
; 			** <C851/14Apr87/MBK> **
;
;			I changed teReserved to a handle to the following structure:
;				Record
;					newReserved : LONGINT;
;					nullScrap	: stScrpHandle;
;				End;
;			nullScrap is used to store a style which is set when the
;				selection is NIL in TESetStyle.  I store it in the scrap
;				format so that it can easily be inserted using PstStylGuts.
;				This procedure is called to set the style to whatever the user
;				has input to TESetStyle.
;
;			On entry, SetRsrved expects A2 to be pointing to something
;				that looks like this:
;					flag.B TextStylePtr.L mode.W
;				The flag is not accessed and can just be a hole if desired.
;----------------------------------------------------------------------
SetRsrved
			Move.W		teSelStart(A3),D0		; get selection start
			Cmp.W		teSelEnd(A3),D0			; same as selEnd?
			Bne			lvSetRsrved				; quit if not

AltSetRsrved									;									<C971/RWW102987>
			Move.L		teStylesH(A3),A1		; get style handle
			Move.L		(A1),A1					; deref
			Move.L		nullStyle(A1),A1		; get reserved handle
			Move.L		(A1),A1					; deref
			Move.L		nullScrap(A1),A1		; get handle to scrap for null selection
			Move.L		A1,-(SP)				; save handle for later
			Move.L		(A1),A1					; deref
			Tst.W		scrpNStyles(A1)			; stored already?
			Beq.S		@0						; reset if not
			Lea			scrpStyleTab(A1),A1		; point to start of tableev style if so
			Bra.S		@1						; go use new settings

; First get current style settings
@0			SubQ		#1,D0					; in case sel is on a run boundary
			Bsr			GetCurStyle				; get current style run
			Move.W		styleIndex(A0),D0		; get style index
			Bsr.S		GetStyle				; get the style in A0			<C971/RWW102887>NO
			Move.W		#1,scrpNStyles(A1)		; indicate 1 style
			Lea			scrpStyleTab(A1),A1		; point to start of table
			Move.L		#0,scrpStartChar(A1)	; store start offset
			Lea			stFont(A0),A0
			Move.L		(A0)+,scrpFont(A1)		; font, face
			Move.L		(A0)+,scrpSize(A1)		; size, color
			Move.L		(A0)+,scrpColor+2(A1)	; color

; now adjust according to new settings
@1			Move.W		6(A2),D2				; get the mode
			Move.L		2(A2),A0				; get style ptr
			BTst		#fontBit,D2				; set font?
			Beq.S		@2						; no
			Move.W		tsFont(A0),scrpFont(A1)	; else, set it
; set the direction of the font in the high bit of the high-order byte <30May89smb>
			move.l		a0,-(sp)
			move.w		tsFont(a0),d1
			lea			scrpFace+1(a1),a0
			Bsr			SetDirection
			move.l		(sp)+,a0

@2			BTst		#faceBit,D2				; set face?
			Beq.S		@4						; no

; ** <C971/RWW102987>	Added code to support doToggle mode.
; An insertion point is by definition continuous, so all we have to do is
; calculate unique set elements
			Move.B		tsFace(A0),D0			; fetch given face					<C971/RWW102987>

			BTst		#toglBit,D2				; toggling?							<C971/RWW102987>
			Bz.S		@3						; no, go set						<C971/RWW102987>

			Eor.B		D0,scrpFace(A1)			;									<C971/RWW111187>
			Bra.S		@4						;									<C971/RWW102987>

@3			Tst.B		D0						; if new face is plain…				<C971/RWW102987>
			Bnz.S		@35						;									<C971/RWW102987>
			Clr.B		scrpFace(A1)			; …wipe out old attributes			<C971/RWW102987>
@35			Or.B		D0,scrpFace(A1)			; union in new attributes			<C971/RWW102987>

@4			BTst		#sizeBit,D2				; set size only?
			Beq.S		@5						; no
			BTst		#addSizeBit,D2			; is addSize also set?
			Bne.S		@5						; it has precedence
			Move.W		tsSize(A0),scrpSize(A1)	; else, get size

@5			BTst		#clrBit,D2				; set color only?
			Beq.S		@6						; no
			Move.L		tsColor(A0),scrpColor(A1)	; store the new value there
			Move.W		tsColor+4(A0),scrpColor+4(A1)	; store color ,hi

@6			BTst		#addSizeBit,D2			; is it addSize?
			Beq.S		@9
			Move.W		scrpSize(A1),D0			; get current size
			Bne.S		@7						; => not 0
			Move.B		FMDefaultSize,D0		; get default size as byte value** <C440/19nov86/MBK> **

@7			Add.W		tsSize(A0),D0			; add increment to size
			Bgt.S		@8						; size <-1 if it's 0 or negative
			Move.W		#1,D0					; minimum allowable

@8			Move.W		D0,scrpSize(A1)			; now store it

@9			Move.L		teGrafPort(A3),A0		; the port
			Move.W		scrpFont(A1),txFont(A0)	; set font
			Move.W		scrpFace(A1),txFace(A0)	; set face
			bclr		#7,txFace+1(a0)			; want direction in scrp but not grafport <30May89smb>
			Move.W		scrpSize(A1),txSize(A0)	; set size
			Bsr			GetSize					; get ascent & hite
			Move.L		(SP)+,A0				; get back scrap handle
			Move.L		(A0),A0					; deref
			Lea			scrpStyleTab(A0),A0		; pt to start of scrap table
			Move.W		D0,scrpAscent(A0)		; save in ascent
			Move.W		D1,scrpHeight(A0)		; save in line height

lvSetRsrved
			Rts

;formFeed
;----------------------------------------------------------------------
;
;	PROCEDURE TESetStyle( SetMode: INTEGER; Styl: StylPtr; redraw: BOOLEAN;
;						 hTE: TEHandle );
;
;	Sets the style of the selected text (replacing all other styles).
;
;	Supports the following modes:
;	1	doFont:		Set Font only
;	2	doFace:		Set Face only
;	4	doSize:		Set Size only
;	8	doColor:	Set Color only
;	15	doAll:		Set all modes
;	16	addSize:	Add Size integer to each size in selection
;	32	doToggle:	Set each face attribute if not continuous, reset otherwise		<C971/RWW102987>
;
;----------------------------------------------------------------------

iTESetStyle
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@DontSet				; if not, sorry, can't set it

			Bsr			SetRsrved				; save the style in the grafport
			
; mode may be an additive combination so must test the font bit <3Dec89smb>
			move.w		6(a2),d0				; <3Dec89smb>
			btst		#fontBit,d0				; is mode = doFont? <3Dec89smb>
			beq.s		@KeybdOK				; <3Dec89smb>
;;			cmpi.w		#doFont,6(a2)			; is mode = doFont? <12July89smb>
;;			bne.s		@KeybdOK				; <12July89smb>
			bsr			SetKeyboard2Font		; synch keyboard to new font <10Nov88smb>
@KeybdOK

; ** <C381/6nov86/MBK> ** boolean value is in bit 1 of high byte
			Move.W		(A2)+,D0				; get redraw value			** <C381/6nov86/MBK> **
			And			#$FF00,D0				; check redraw value		** <C381/6nov86/MBK> **
			Bne.S		@0						; must redraw if set

			Bsr.S		SetGuts					; else just add styles
			Bra.S		@DontSet

@0			Move.L		A2,-(SP)				; save ptr to parameters

			Bsr			HideCaret
			Bsr			HiLite					; remove selection

			Move.L		(SP)+,A2				; restore ptr to parameters

			Bsr.S		SetGuts					; do style munging

			MoveQ		#0,D7					; length is 0

			Bsr			RecalDraw				; redo the line stuff

			Bsr			ShowCaret
			Bsr			HiLite					; restore selection

			Bsr			SelView					; ensure selection is visible

@DontSet
			MoveQ		#14,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------

SetGuts
			MoveM.L		D2-D7/A2/A4/A6,-(SP)	; save registers
			Move.L		(A2)+,A4				; style ptr
			Move.W		(A2)+,D7				; save mode here
			Sub.L		A6,A6					; not used by SetStyle

; ** <C971/RWW102987>	Added code to support doToggle.
; I changed the next statement to a mask from the original, which punted if
; it saw bits it didn't like.

												; <31j-YDS-8/27/91>
												; if/when will add this should define those:
												; doAll4			EQU			$7F				
												; doFontSmart		EQU			$41	
;	IF forLocalizability THEN					; <31j-YDS-8/27/91> - minor, has another one marked>
;			And.W		#doAll4,D7				; only lower 7 bits make sense		<C971/RWW102987>
;	ELSE
			And.W		#doAll3,D7				; only lower 6 bits make sense		<C971/RWW102987>
;	ENDIF

			Move.W		D7,D0					;									<C971/RWW102987>
			And.W		#doFace+doToggle,D0		; are we toggling?					<C971/RWW102987>
			Cmp.W		#doFace+doToggle,D0		; (both bits have to be on, dummy!)	<C971/RWW102987>
			Bne.S		@05						;									<C971/RWW102987>

			SubQ.W		#1,A6					; -1 to signal toggle mode			<C971/RWW102987>
			Move.W		#doFace,-(SP)			; prepare fake frame for call		<C971/RWW102987>

	; SP => doFace/2																<C971/RWW102987>
			Sub.W		#styleSize+2,SP			; make room for result & TextStyle	<C971/RWW102987>

	; SP => VAR/2  VAR/styleSize  doFace/2											<C971/RWW102987>
			Pea			styleSize+2(SP)			; push pointer to doFace			<C971/RWW102987>

	; SP => ^doFace/4  VAR/2  VAR/styleSize  doFace/2								<C971/RWW102987>
			Pea			4+2(SP)					; push pointer to TextStyle hole	<C971/RWW102987>

	; SP => ^VAR/4  ^doFace/4  VAR/2  VAR/styleSize  doFace/2						<C971/RWW102987>
			Move.L		SP,A2					; point A2 at stacked parameters	<C971/RWW102987>

			Bsr			ContGuts				; coalesce continuous styles		<C971/RWW102987>

			Add.W		#10,SP					; pop stack back to TextStyle		<C971/RWW102987>
			Move.B		tsFace(SP),D5			; save continuous face attributes	<C971/RWW102987>
			Swap		D5						; we'll need low word later			<C971/RWW102987>
			Add.W		#styleSize+2,SP			; now remove TextStyle & doFace		<C971/RWW102987>
@05												;									<C971/RWW102987>
			Bsr.S		StyleGuts				; do style munging

@0			MoveM.L		(SP)+,D2-D7/A2/A4/A6	; restore registers
			Rts

;formFeed
;----------------------------------------------------------------------
StyleGuts
			move.l		ExpandMem,a0			; <28June89smb>
			move.l		ExpandMemRec.vStyleGuts(a0),a0
			jmp			(a0)

xStyleGuts

			Tst.W		D7						; check mode
			Beq			EndStyle				; 0 is invalid mode

			Bsr			SelSort					; sort selStart, selEnd
			Move.W		D0,D1					; save selEnd						<C971/RWW102987>
			Move.W		D0,D4
			Swap		D0
			Move.W		D0,D3					; save selStart
			Sub.W		D3,D1					; save selection length				<C971/RWW102987>
			Beq			EndStyle				; if len = 0, nothing to do

; store the input style information temporarily
			Sub.L		#stRecSize,SP			; make room on stack
			Move.L		SP,A2					; save ptr in A2

;			Move.W		D3,D0					; selStart REDUNDANT!				<PMAB381/RWW020488>
			Bsr			GetCurStyle				; get current style
			Move.W		D4,D1					; selEnd
			Bsr			GetNumStyles			; get # of styles within selection
			Move.W		D0,D2					; preserve # of styles
			Swap		D3						; selStart in upper word
			Move.W		D4,D3					; selEnd in lower word

; ** <C971/RWW102787>	Faces are byte length…
			Move.B		tsFace(A4),D4			; save face							<C971/RWW102787>
			Swap		D4						; put face in upper word
			Move.W		tsFont(A4),D4			; font in lower word
			Move.W		tsSize(A4),D5			; save size
			Move.L		tsColor(A4),D6		 	; save color
			Swap		D7						; running out of reg's	** <C182/6oct86/MBK> **
			Move.W		tsColor+4(A4),D7		; store color in D7,hi	** <C182/6oct86/MBK> **
			Swap		D7						; keep mode in D7,low	** <C182/6oct86/MBK> **
			Move.L		A2,A4					; temp style handle

			Move.L		A0,A2					; preserve ptr

			Move.L		teStylesH(A3),A0		; handle to style info	** <C381/6nov86/MBK> **
			_HLock								; keep it locked		** <C381/6nov86/MBK> **

; By this point, the world looks like this:
;			D2.W	=	number of styles in current selection (used as counter)
;			D3.L	=	selStart/selEnd (high word/low word)
;			D4.L	=	Face/Font
;			D5.L	=	Toggle face info/Size
;			D6.L	=	Color Red/Green
;			D7.L	=	Color Blue/set mode
;			A2.L	=>	StyleRun array, first associated element
;			A4.L	=>	working STElement on stack

styleLoop	Move.W		styleIndex(A2),D0		; else, index to style
			Bsr			GetStyle				; find it
			Bsr			CheckMatch				; must match for replacement
			Tst.W		D0						; check return flag
			Beq			NoMatch					; if false, don't replace

			Move.L		#stRecSize,D0			; length of a styleRec
			Move.L		A4,A1					; ptr to temp storage
			_BlockMove							; copy to temp location for mod

			Move.L		A2,A0					; current style
			Move.L		D3,D0					; selStart, selEnd
			Swap		D0						; selStart in low word
			Cmp.W		startChar(A2),D0		; compare to style start
			Bls.S		@0						; made this unsigned	** <C381/6nov86/MBK> **

			Bsr			DupStyle				; else dup it
			AddQ		#stStartSize,A0			; new style replaces this
			Move.L		A0,A2

@0			Cmp.W		#1,D2					; last style?
			Bne.S		@1						; not yet

			AddQ		#stStartSize,A0
			Cmp.W		startChar(A0),D3		; compare to style end
			Beq.S		@1						; ok if same as selEnd

			Move.W		D3,D0					; selEnd
			Move.L		A2,A0					; current style
			Bsr			DupStyle				; dup it
			Move.L		A0,A2					; ptr updated in A0

; ** <C381/7nov86/MBK> ** dupstyle was fixed to inc the style count, so it's
;							ok to dec it in all cases now
@1			MoveQ		#1,D0					; # of styles to (possibly) delete
			Move.L		A2,A0					; ptr to style start
			Bsr			DecStylCount			; style used 1 less time

			BTst		#fontBit,D7				; set font?
			Beq.S		@3						; no


;  <31j-YDS-8/27/91>												
;; here we will add a test to let you force a change  that we do not allow, we still check it so
;; all this code will be hidden after debugging after we will decide what to do !!!!
;
;	IF forLocalizability THEN					; <31j-YDS-8/27/91> Don't let me change fonts not from the same script 
;			BTst		#doFontSmart,D7			; check for matching script ?
;			Beq.S		@ignoreScript			; no
;
;
;			MoveM.L		D0-D2/A0-A1,-(SP)		; save registers, we call the toolbox
;			Clr.W		-(SP)					; space for return value of function
;			Move.W		stFont(A4),-(SP)		; move font to stack
;			_Font2Script						; get the font script
;			Clr.W		-(SP)					; space for return value of function
;			Move.W		D4,-(SP)				; move font to stack
;			_Font2Script						; get the font script
;			Move.W		(SP)+, D0				; into d0
;			Move.W		(SP)+, D1				; into d1
;			Cmp.W		D0,D1					; is it the same script ?
;			MoveM.L		(SP)+, D0-D2/A0-A1		; restore registers. (won't change cc)
;			Bne.S		@3						; no , don't awitch.
;	ENDIF
;			
;@ignoreScript	


			Move.W		D4,stFont(A4)			; else, put in temp rec
; set the direction of the font in the high bit of the high-order byte <30May89smb>
			move.l		a0,-(sp)
			move.w		d4,d1
			lea			stFace+1(a4),a0			; store direction here
			bsr			SetDirection
			move.l		(sp)+,a0

@3			BTst		#faceBit,D7				; set face?
			Beq.S		@5						; no

; ** <C971/RWW102987>	This new code supports the doToggle mode
			Move.L		D4,D0					; fetch face information			<C971/RWW102987>
			Swap		D0						; move face to low byte				<C971/RWW102987>

			Move.L		A6,D1					; are we just setting?				<C971/RWW102987>
			Bz.S		@41						;									<C971/RWW102987>

			AddQ.L		#1,D1					; are we toggling? (was it just -1?)<C971/RWW102987>
			Beq.S		@42						; yes, go handle					<C971/RWW102987>

	; Replacing…																	<C971/RWW102987>
			Move.B		D0,stFace(A4)			; we must be replacing, then		<C971/RWW102987>
			Bra.S		@5						;									<C971/RWW102987>

	; Toggling… (algorithm also works for plain, so we don't have to special case)	<C971/RWW102987>
@42			Move.L		D5,D1					; fetch toggle info					<C971/RWW102987>
			Swap		D1						; move continuous face to low byte	<C971/RWW102987>
			And.B		D0,D1					; intersect faces for XOR mask		<C971/RWW102987>
			Eor.B		D1,D0					; difference from desired is OR mask<C971/RWW102987>
			Or.B		D0,stFace(A4)			; union in new style attributes		<C971/RWW102987>
			Eor.B		D1,stFace(A4)			; remove already set attributes		<C971/RWW102987>
			Bra.S		@5						;									<C971/RWW102987>

	; Merging…																		<C971/RWW102987>
@41			Tst.B		D0						; is it plain?						<C971/RWW102987>
			Bnz.S		@43						; no, merge in attributes			<C971/RWW102987>
			Clr.B		stFace(A4)				; remove all styles if plain		<C971/RWW102987>
@43			Or.B		D0,stFace(A4)			; union sets						<C971/RWW102987>

@5			BTst		#sizeBit,D7				; set size only?
			Beq.S		@6						; no

			BTst		#addSizeBit,D7			; is addSize also set?	** <C139/10Sep86/MBK> **
			Bne.S		@6						; it has precedence		** <C139/10Sep86/MBK> **

			Move.W		D5,stSize(A4)			; else, get size

@6			BTst		#clrBit,D7				; set color only?
			Beq.S		@7						; no

			Move.L		D6,stColor(A4)			; store the new value there
			Swap		D7						; running out of reg's	** <C182/6oct86/MBK> **
			Move.W		D7,stColor+4(A4)		; store color in D7,hi	** <C182/6oct86/MBK> **
			Swap		D7						; keep mode in D7,low	** <C182/6oct86/MBK> **

@7			BTst		#addSizeBit,D7			; is it addSize?		** <C139/10Sep86/MBK> **
			Beq.S		@9

			Move.W		stSize(A4),D0			; get current size
			Bne.S		@8						; => not 0

;I assumed FMDefaultSize was a word constant, but actually it points to a byte value.
			Move.B		FMDefaultSize,D0		; get default size as byte value** <C440/19nov86/MBK> **
			Move.W		D0,stSize(A4) 			; store as word value			** <C440/19nov86/MBK> **

@8
; Don't allow the size to become 0 or be negative.
			Add.W		D5,D0					; add increment to size
			Bgt.S		@81						; size <-1 if it's 0 or negative

			Move.W		#1,D0					; minimum allowable

@81			Move.W		D0,stSize(A4)			; now store it

@9			Move.L		A4,A0					; point to relevent stuff
			Bsr			FindStyle				; look for this style
			Tst.L		D0						; do we have it already?
			Bne.S		@10						; guess so

			Move.L		A4,A0					; get ptr to new style
			Bsr.S		SetHiteAscent			; set line height and font ascent<C971/RWW102887>NO
			Move.W		#1,stCount(A0)			; will be used once to start
			Bsr			AddStyle				; and add it

@10			Move.W		D0,styleIndex(A2)		; store new style index

NoMatch		AddQ		#stStartSize,A2			; point to next style
			SubQ.W		#1,D2					; dec style counter
			Bne			styleLoop				; keep looping if not 0

			Move.L		teStylesH(A3),A0		; handle to style info
			_HUnlock

			Bsr			ConcatStyles			; watch out for adjoining styles
			Add.L		#stRecSize,SP			; restore stack

EndStyle	Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE SetHiteAscent
;
;			Added 5/30/86 by MBK
;
;			SetHiteAscent sets the line height and the font ascent based
;			On the given style.
;
;	Entry:
;			A0:			ptr to style (preserved)
;			A3:			TEHandle
;
;----------------------------------------------------------------------
SetHiteAscent
			Move.L		D2,-(SP)				; save registers

; set my style just to get the info I need
			Move.L		teGrafPort(A3),A1		; the port
			Move.W		stFont(A0),txFont(A1)	; set font
			Move.W		stFace(A0),txFace(A1)	; set face
			bclr		#7,txFace+1(a1)			; clear direction <30May89smb>
			Move.W		stSize(A0),txSize(A1)	; set size

; get the line height and font ascent
			Bsr			GetSize					; get ascent & hite		** <C207/10oct86/MBK> **

			Move.W		D0,stAscent(A0)		 	; save in ascent		** <C207/10oct86/MBK> **
			Move.W		D1,stHeight(A0)			; save in line height	** <C207/10oct86/MBK> **

			Move.L		(SP)+,D2				; restore registers

			Rts

;formFeed
;----------------------------------------------------------------------
;
;	AnyNullStyle
;	<C971/RWW102387>
;
;	Returns TRUE if a null style exists
;
;	ENTRY:
;			A3.L	=	TEPtr
;
;	EXIT:
;			A0.L	=>	null scrap record (hTE^^.nullStyle^^.nullScrap^)
;
;	USES:
;			A0.L
;
;----------------------------------------------------------------------
AnyNullStyle
			Move.L		teStylesH(A3),A0		; => style record
			Move.L		(A0),A0
			Move.L		nullStyle(A0),A0		; => null style record
			Move.L		(A0),A0
			Move.L		nullScrap(A0),A0		; => null scrap record
			Move.L		(A0),A0
			Tst.W		scrpNStyles(A0)			; Assure null style exists
			Rts


;----------------------------------------------------------------------
;
;	GetTrueStyle
;	<C971/RWW102387>
;
;	Returns the style at the specified offset, whether from null style or
;		inferred from current style.  Made subroutine because I needed
;		similar result for GetStylScrap.
;
;	ENTRY:
;			D0.W	=	offset into text record
;			A3.L	=	TEPtr
;
;	EXIT:
;			A0.L	=>	STElement representing style
;
;	USES:
;			D0.W, A0.L
;
;----------------------------------------------------------------------
GetTrueStyle
			Cmp.W		teSelStart(A3),D0		; start = offset, and…
			Bne.S		GetOneStyle
			Cmp.W		teSelEnd(A3),D0			; end = start?
			Bne.S		GetOneStyle

			Bsr.S		AnyNullStyle
			Bz.S		GetOneStyle				; None exists. Punt.

			; Yeah, this looks strange.  ScrpSTElements and STElements are _almost_
			;   the same, except that the first field of ScrpSTElement is a long instead
			;	of a word.  Fake it as though A0 => STElement
			Lea			scrpStyleTab+2(A0),A0
			Rts

;formFeed
;----------------------------------------------------------------------
;
;	GetOneStyle
;	<C971/RWW102387>
;
;	Returns the style at the specified offset
;
;----------------------------------------------------------------------
GetOneStyle
			Bsr			GetCurStyle				; get current style
			Move.W		styleIndex(A0),D0		; get style index
			Bsr			GetStyle				; now you have it

			Rts

;formFeed
;----------------------------------------------------------------------
;
;	PROCEDURE TEGetStyle( offset: INTEGER; VAR Styl: StylePtr;
;							VAR lineHite:INTEGER; VAR fontAscent:INTEGER;
;							hTE: TEHandle );
;
;	Returns the style _OF_THE_CHARACTER_ at the specified offset
;
;----------------------------------------------------------------------

iTEGetStyle
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; if not, sorry, can't get it

			Move.L		(A2)+,-(SP)				; save ptr to font ascent
			Move.L		(A2)+,-(SP)				; save ptr to line height
			Move.L		(A2)+,-(SP)				; save style ptr

			Move.W		(A2),D0					; offset

			Bsr.S		GetOneStyle				; fetch inferred style				<C971/RWW102687>

			Move.L		(SP)+,A1				; point to styleRec

			Move.W		stFont(A0),(A1)+		; copy font
			Move.W		stFace(A0),(A1)+		; copy face
			clr.b		-1(a1)					; clr direction <30May89smb>
			Move.W		stSize(A0),(A1)+		; copy size
			Move.L		A0,A2					; save ptr					** <C182/6oct86/MBK> **
			Lea			stColor(A0),A0			; pt to color				** <C182/6oct86/MBK> **
			Move.W		(A0)+,(A1)+				; copy red					** <C182/6oct86/MBK> **
			Move.W		(A0)+,(A1)+				; copy green				** <C182/6oct86/MBK> **
			Move.W		(A0),(A1)				; copy blue					** <C182/6oct86/MBK> **

			Move.L		(SP)+,A1				; ptr to line height
			Move.W		stHeight(A2),(A1)		; store line height

			Move.L		(SP)+,A1				; ptr to font ascent
			Move.W		stAscent(A2),(A1)		; store font ascent
			Bra.S		@1

; ** <C139/10Sep86/MBK> ** Added this code to return GrafPort info for records without style.
@0			Bsr			GetSize					; get ascent & hite		** <C207/10oct86/MBK> **
			Move.L		(A2)+,A0				; ptr to ascent			** <C207/10oct86/MBK> **
			Move		D0,(A0)			 		; save in ascent		** <C207/10oct86/MBK> **
			Move.L		(A2)+,A0				; ptr to line height	** <C207/10oct86/MBK> **
			Move		D1,(A0)					; save in line height	** <C207/10oct86/MBK> **

			Move.L		(A2),A0					; ptr to style record
			Move.L		teGrafPort(A3),A1
			Move.W		txFont(A1),(A0)+		; copy font
			Move.W		txFace(A1),(A0)+
			Move.W		txSize(A1),(A0)+		; copy size
			Pea			0(A0)					; ptr to forecolor

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; color QD around?					<C971/RWW112487>
			Bnz.S		@05						; nope								<C971/RWW112487>
			_GetForeColor						;									<C971/RWW112487>
			Bra.S		@07						;									<C971/RWW112487>
@05			Bsr			GetForeColor			;									<C971/RWW112487>
@07
	ElseIf hasCQD THEN							; <9Dec88smb>
			_GetForeColor						; for Ikki
	Else
			Bsr			GetForeColor			; for Alladin
	EndIf

@1			MoveQ		#20,D0
			Bra			StdExit2

;formFeed
;------------------------------------------------
; SetStyle - sets the style pointed to by A0
;
;	Entry:	A0	Pointer to styleStart (Preserved)
;
;------------------------------------------------
SetStyle
			Move.L		A0,-(SP)

			Move.W		styleIndex(A0),D0		; get index to styleRec
			Bsr			GetStyle				; get the styleRec

			Move.L		teGrafPort(A3),A1		; get the Port

			Move.W		stFont(A0),txFont(A1)	; set font
			Move.W		stFace(A0),txFace(A1)	; set face
			bclr		#7,txFace+1(a1)			; clr direction <30May89smb>
			Move.W		stSize(A0),txSize(A1)	; set size

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; Becks or better?					<C971/RWW112487>
			Bnz.S		@1						; nope								<C971/RWW112487>
	EndIf

	If hasCQD|(NOT ForROM) THEN					; <9Dec88smb>
		; Save D2 because the RGBForeColor trap destroys it.
		; Save the style ptr as an offset, since _RGBForeColor may shift memory.
			Move.L		teStylesH(A3),A1		; style handle			** <C717/28jan87/MBK> **
			Move.L		(A1),D0					; dereference			** <C717/28jan87/MBK> **
			Sub.L		D0,(SP)					; save as offset		** <C717/28jan87/MBK> **
			Move.W		D2,-(SP)				; save D2 for everybody	** <C574/30dec86/MBK> **
	EndIf

@1
			Pea			stColor(A0)				; point to fgColor		** <C182/6oct86/MBK> **

	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; Becks or better?					<C971/RWW112487>
			Bnz.S		@2						; nope								<C971/RWW112487>
			_RGBForeColor						;									<C971/RWW112487>
			Move.W		(SP)+,D2				;									<C971/RWW112487>
			Move.L		teStylesH(A3),A1		;									<C971/RWW112487>
			Move.L		(A1),D0					;									<C971/RWW112487>
			Add.L		D0,(SP)					;									<C971/RWW112487>
			Bra.S		@3						;									<C971/RWW112487>
@2			Bsr			RGBForeColor			;									<C971/RWW112487>
@3
	ElseIf hasCQD THEN							; <9Dec88smb>
			_RGBForeColor						; for Ikki				** <C182/06oct86/MBK> **
			Move.W		(SP)+,D2				; restore D2			** <C574/30dec86/MBK> **

			Move.L		teStylesH(A3),A1		; style handle			** <C717/28jan87/MBK> **
			Move.L		(A1),D0					; dereference			** <C717/28jan87/MBK> **
			Add.L		D0,(SP)					; restore as ptr		** <C717/28jan87/MBK> **
	Else
			Bsr			RGBForeColor			; for Alladin			** <C182/6oct86/MBK> **
	EndIf

			Move.L		(SP)+,A0

			Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE ConcatStyles
;
;			Added 6/12/86 by MBK
;
;			ConcatStyles checks the entire runs array for adjoining
;			identical styles, and concatenates any it finds.
;
;----------------------------------------------------------------------
ConcatStyles
			MoveM.L		D2/d3/A2,-(SP)			; save registers			** <C381/7nov86/MBK> **

			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A0					; dereference
			Move.L		styleTab(A0),A2			; handle to distinct styles	** <C381/7nov86/MBK> **
			Move.L		(A2),A2					; dereference				** <C381/7nov86/MBK> **
			Move.W		nRuns(A0),D0			; get # of style starts
			AddQ		#1,D0					; + dummy end index
			Lea			runs(A0),A0				; ptr to stStarts array
			Move.L		A0,A1					; copy it
			MoveQ		#0,D2					; repetition counter		** <C381/7nov86/MBK> **
			Move.W		styleIndex(A0),D1		; current index				** <C381/7nov86/MBK> **

; loop thru styles removing repetitious ones
@0			SubQ.W		#1,D0					; dec the count
			Beq.S		@2						; done, get out

			AddQ		#1,D2					; inc repetition counter	** <C381/7nov86/MBK> **
			AddQ.L		#stStartSize,A1			; point to next style
			Cmp.W		styleIndex(A1),D1		; are they the same?
			Beq.S		@0						; don't change ptrs if so

			SubQ		#1,D2					; dec repetition counter	** <C381/7nov86/MBK> **
			Beq.S		@1						; no repetitions			** <C381/7nov86/MBK> **

; ** <C381/7nov86/MBK> ** if any runs are merged, the stCount for that style must also be adjusted
			MulU		#stRecSize,D1			; * size of record			** <C381/7nov86/MBK> **
			Sub.W		D2,stCount(A2,D1.L)		; dec count					** <C381/7nov86/MBK> **
			MoveQ		#0,D2					; repetition counter		** <C381/7nov86/MBK> **

@1			AddQ.L		#stStartSize,A0			; now pt to next
			Move.L		startChar(A1),startChar(A0)	; move start and index
			Move.W		styleIndex(A0),D1		; current index				** <C381/7nov86/MBK> **
			Bra.S		@0

; shrink the handle to the style info
@2			Sub.L		A0,A1					; get amount that's redundant as an offset
			Move.L		A1,D0
			Move.L		teStylesH(A3),A0		; handle to style info
			Move.L		(A0),A1					; dereference
			AsR.L		#2,D0					; divide diff by 4
			Sub.W		D0,nRuns(A1)			; store new # of style starts

			MoveM.L		(SP)+,D2/d3/A2			; restore registers			** <C381/7nov86/MBK> **
			Rts									; bye

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE ConcatRuns
;
;			Added 24Nov88 by SMB (taken from DrawIITE.a)
;
;			ConcatRuns checks for a null style run preceding the dummy run
;			at the end of the style runs, and deletes it if it finds it.
;
;			Uses a0,a2,d0,d1. Preserves a2.
;
;----------------------------------------------------------------------
ConcatRuns
			move.l		ExpandMem,a0			; <28June89smb>
			move.l		ExpandMemRec.vConcatRuns(a0),a0
			jmp			(a0)

xConcatRuns

			tst.w		teSize(a3)				; don't want to be in here if unstyled! <1Dec88smb>
			bpl.s		@NoRuns
; Don't allow any runs to have offset = text length

			MOVE.L		A2,-(SP)
			MOVE.L		teStylesH(A3),A0		; handle to style info
			MOVE.L		(A0),A0					; dereference		
			MOVE.L		styleTab(A0),A2			; handle to distinct styles
			MOVE.L		(A2),A2					; dereference				
			MOVE.W		nRuns(A0),D0			; get # of style starts
			BEQ.S		@endConcat				; exit if none
			
			SUBQ		#1,D0					; point to 1 less than end
			BEQ.S		@endConcat				; exit if 1 only
			
;;			MULU		#stStartSize,D0			; * size of record	
			lsl.w		#lnStStartSize,d0		; replace mulu w/ shift <28June89smb>
			LEA			runs(A0,D0.w),A0		; ptr to last run before dummy
			MOVE.W		teLength(A3),D0			; text length
			CMP.W		startChar(A0),D0		; same as run start?
			BGT.S		@endConcat				; okay if less
			
			MOVEQ		#0,D1
			MOVE.W		styleIndex(A0),D1		; the style	
			MULU		#stRecSize,D1			; * size of record

			SUB.W		#1,stCount(A2,D1.L)		; dec count	
			ADDQ		#1,D0					; length + 1
			MOVE.W		D0,startChar(A0)		; store dummy run here
			MOVE.W		#$FFFF,styleIndex(A0)	; last style index
			
			MOVE.L		teStylesH(A3),A0		; handle to style info
			MOVE.L		(A0),A0					; dereference
			SUB.W		#1,nRuns(A0)			; store new # of style starts
			
@endConcat	MOVE.L		(SP)+,A2
@NoRuns
			RTS
; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE CheckMatch
;
;			** Added 7/19/86 by MBK **
;
;			CheckMatch checks to see if the input style record matches
;			the style being sought by TEReplaceStyle.  If so, a True flag
;			is returned.  If the call was from TESetStyle, True is auto-
;			matically returned since the record does not have to match
;			anything.
;
;	Entry:
;			A0:		ptr to style record
;			A6:		ptr to style being searched for (0 if from TESetStyle, except
;					in toggle mode)
;			D7:		replace mode
;
;	Exit:
;			D0:		flag = 1 if this style may be replaced
;
;----------------------------------------------------------------------
CheckMatch
			MoveQ		#1,D0					; assume okay
			Cmp.L		#0,A6					; call from TESetStyle?
			Beq.S		@exit					; quit with true if so

; ** <C971/RWW102987>	Added code to support doToggle mode
; Specifically, A6 = -1 is used as a flag in TESetStyle
			Cmp.L		#-1,A6					; ignore toggle mode, too			<C971/RWW102987>
			Beq.S		@exit						;									<C971/RWW102987>

			BTst		#fontBit,D7				; find font?
			Beq.S		@1

			Move.W		tsFont(A6),D1
			Cmp.W		stFont(A0),D1			; same as this style?
			Bne.S		@noMatch				; stop comparing if not

@1			BTst		#faceBit,D7				; find face?
			Beq.S		@2

; ** <C971/RWW102787>	Faces are byte length…
			Move.B		tsFace(A6),D1			;									<C971/RWW102787>
			Cmp.B		stFace(A0),D1			; same as this style?				<C971/RWW102787>
			Bne.S		@noMatch				; stop comparing if not

@2			BTst		#sizeBit,D7				; find size?
			Beq.S		@3

			Move.W		tsSize(A6),D1
			Cmp.W		stSize(A0),D1			; same as this style?
			Bne.S		@noMatch				; stop comparing if not

@3			BTst		#clrBit,D7				; find color?
			Beq.S		@exit					; must have a match if still here

			Move.L		tsColor(A6),D1
			Cmp.L		stColor(A0),D1			; same as this style?
			Bne.S		@noMatch				; red and green not same	** <C182/6oct86/MBK> **

			Move.W		tsColor+4(A6),D1		; get blue					** <C182/6oct86/MBK> **
			Cmp.W		stColor+4(A0),D1		; blues the same?			** <C182/6oct86/MBK> **
			Beq.S		@exit

@noMatch
			MoveQ		#0,D0					; not a match

@exit		Rts

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEReplaceStyle( ReplaceMode: INTEGER; Style1: STHandle;
;									Style2: STHandle; redraw: BOOLEAN;
;									hTE: TEHandle );
;
;			** <C94/29jul86/MBK> **
;
;			Replaces Style1 by Style2. If the mode is not doAll, the given
;			characteristic will be replaced within all styles in which it's found.
;
;			Supports the following modes:
;			1	doFace:		replace Face only
;			2	doSize:		replace Size only
;			4	doFont:		replace Font only
;			8	doColor:	replace Color only
;			15	doAll:		replace all modes
;
;----------------------------------------------------------------------

iTEReplaceStyle

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@1						; if not, sorry, can't set it

; ** <C381/6nov86/MBK> ** boolean value is in bit 1 of high byte
			Move.W		(A2)+,D0				; get redraw value			** <C381/6nov86/MBK> **
			And			#$FF00,D0				; check redraw value		** <C381/6nov86/MBK> **
			Bne.S		@0						; must redraw if set

			Bsr.S		ReplaceGuts				; else just add styles
			Bra.S		@1

@0			Move.L		A2,-(SP)				; save ptr to parameters

			Bsr			HideCaret
			Bsr			HiLite					; remove selection

			Move.L		(SP)+,A2				; restore ptr to parameters

			Bsr.S		ReplaceGuts				; do style munging

			MoveQ		#0,D7					; length is 0

			Bsr			RecalDraw				; redo the line stuff

			Bsr			ShowCaret
			Bsr			HiLite					; restore selection

			Bsr			SelView					; ensure selection is visible

@1			MoveQ		#18,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------

ReplaceGuts
			MoveM.L		D2-D7/A2/A4/A6,-(SP)	; save registers
			Move.L		(A2)+,A4				; replace style ptr
			Move.L		(A2)+,A6				; find style ptr
			Move.W		(A2)+,D7				; save mode here

			And.W		#doAll2,D7				; only the lower 5 bits make sense	<C971/RWW102987>

			Bsr			StyleGuts				; do style munging				<C971/RWW102887>NO

@0			MoveM.L		(SP)+,D2-D7/A2/A4/A6	; restore registers
			Rts

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION TEGetOffset( pt: Point; hTE: TEHandle): INTEGER;
;
;			** <C94/29jul86/MBK> **
;
;			Returns the offset into the text corresponding to the given point.
;
;----------------------------------------------------------------------

TEGetOffset
			Bsr			StdEntry
			Move.L		teSelPoint(A3),-(SP)	; save selPoint

; Find the point and get char index of it in D6

			Move.L		(A2)+,teSelPoint(A3)	; pass selPoint
			Bsr			DoFind					; juggle dispStart/End and do find
			Move.W		D6,(A2)					; dispStart

			Move.L		(SP)+,teSelPoint(A3)	; restore selPoint
			Bra			epilog8

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION	GetStylHandle( hTE: TEHandle	): TEStylHandle;
;
;			** <C94/29jul86/MBK> **
;
;			Returns the style handle.
;
;----------------------------------------------------------------------
;iTEGetStyleHandle								; comment out for now							<45>
;iGetStyleHandle								; comment out for now							<45>
iGetStylHandle
			Clr.L		(A2)					; init value to Nil

			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; if not, sorry, can't set it

			Move.L		teStylesH(A3),(A2)		; return the style handle

@0			MoveQ		#6,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE SetStylHandle (hST: TEStylHandle; hTE: TEHandle);
;
;			** <C105/8aug86/MBK> **
;
;			Sets the style handle.
;
;----------------------------------------------------------------------
;iTESetStyleHandle								; comment out for now							<45>
;iSetStyleHandle								; comment out for now							<45>
iSetStylHandle
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; if not, sorry, can't set it

; Dispose of old handle before replacing.
			Move.L		teStylesH(A3),A0		; get old handle
			_DisposHandle						; get rid of it

			Move.L		(A2),teStylesH(A3)		; set the style handle

@0			MoveQ		#10,D0
			Bra			StdExit2


	If (NOT hasCQD)|(NOT ForROM) THEN			; <9Dec88smb>
	
		;
		; procedure RGBForeColor (Color : RGBColor);
		;
		;	This routine takes an RGB triple and sets the current Graf- or CGrafPort
		;	fields so that drawing will take place with the best match of the
		;	requested color, using the current GDevice's color matching rules.  The
		;	appropriate fields are set depending on portType
		;

RGBForeColor
			Move.L		4(SP),A1				; point at the RGB color

	; convert RGB to old-style index value
	; use high bit of each component to select RGB off (0) or on (1)
			MoveQ		#0,D1					; clear out D1
			Move		(A1)+,D1				; get red
			LsL.L		#1,D1					; get high bit
			Move		(A1)+,D1				; get green
			LsL.L		#1,D1					; get high bit
			Move		(A1)+,D1				; get blue
			LsL.L		#1,D1					; get high bit
			Swap		D1						; get RGB index

			Lea			mapTbl,A0				; get translate table
			MoveQ		#0,D0					; clear out high word
			LsL.W		#1,D1					; word index
			Move		0(A0,D1),D0				; convert to planar value

			Move.L		GrafGlobals(A5),A0		; get the QuickDraw globals pointer
			Move.L		thePort(A0),A0			; point at the port
			Move.L		D0,fgColor(A0)			; and set the index field
			Move.L		(SP)+,A0				; get the return address
			AddQ		#4,SP					; get rid of the parameter
			Jmp			(A0)					; and return

	; TABLE TO MAP FROM 3 BIT RGB TO OLD-STYLE COLOR INDICES
MapTBL		DC.W		$21						; RBG = 0,0,0 -> black
			DC.W		$199					; RBG = 0,0,1 -> blue
			DC.W		$155					; RBG = 0,1,0 -> green
			DC.W		$111					; RBG = 0,1,1 -> cyan
			DC.W		$CD						; RBG = 1,0,0 -> red
			DC.W		$89						; RBG = 1,0,1 -> magenta
			DC.W		$45						; RBG = 1,1,0 -> yellow
			DC.W		$1E						; RBG = 1,1,1 -> white

		;
		; PROCEDURE GetForeColor (VAR Color: RGBColor);
		;
		; Return the RGB components of the current foreground color
		; Works for old and new ports.

GetForeColor
			Move.L		4(SP),A1				; point at the RGB color
			Move.L		GrafGlobals(A5),A0		; get the QuickDraw globals pointer
			Move.L		thePort(A0),A0			; point at the port

; Use CMYB bits in color to derive proper RGB components

			Move.L		fgColor(A0),D0			; get planar color from port
			BTst		#5,D0					; test black bit
			Beq.S		notBlack				; => color isn't not black
			Or.W		#$01C0,D0				; else set CMY = 111 for black
notBlack	LsR.W		#1,D0					; xxxC MYBR GBwb -> CMYx xxxx

			MoveQ		#2,D1					; process 3 bits
nxtBit		Clr.W		(A1)					; assume component is 0
			LsL.B		#1,D0					; check next component
			Blo.S		cmpOK					; => if bit set, component clear
			Not.W		(A1)					; else component = $FFFF
cmpOK		AddQ		#2,A1					; advance to next component
			DBra		D1,nxtBit				; repeat for all components

			Move.L		(SP)+,A0				; get the return address
			AddQ		#4,SP					; get rid of the parameter
			Jmp			(A0)					; and return

	EndIf

;formFeed
;----------------------------------------------------------------------
;
;	FUNCTION TEGetPoint( offset: INTEGER; hTE: TEHandle): Point;
;
;	** <23jan87/MBK> **
;
;	Returns the point corresponding to the given offset into the text.
;
;----------------------------------------------------------------------

iTEGetPoint
			move.w		(a2)+,d0				; get the offset
			move.l		a2,-(sp)				; preserve parameter ptr
			move.w		d0,-(sp)				; preserve offset
			cmp.w		teLength(a3),d0			; pin it to the length
			blo.s		@LengthOK				; ok if less or same
			
;----------------------------------------------------------------------
; special case of 0 length and any offset: set the point to the DestRect's left/right edge and use
; the lineHeight + the DestRect's top. <1/8/90smb>
			cmpi.w		#0,teLength(a3)			; is it a 0 length record? <1/8/90smb>
			bne.s		@OffsetGELength			; bra if length <> 0 => offset >= length
; set up return point to be valid (or at least more correct than it was!)
			lea 		teDestRect+8(a3),a0 	; point past destRect
			lea 		teSelRect+8(a3),a1		; and past stack rect
			move.l		-(a0),-(a1)				; copying teDestRect to teSelRect
			move.l		-(a0),-(a1)				; copying teDestRect to teSelRect

			move		top(a1),bottom(a1)		; temporarily the same
			moveq		#0,d0					; current line
			bsr			GetHite					; height of this line returned in d1
			add 		d1,bottom(a1)			; add line height to get bottom bound of line rect
			addq		#1,teSelRect+left(A3)	; indent for caret in case L just
			adda.l		#2,sp					; pop offset
			bra.s		@AssumeLeftJust
; finished w/ changes <1/8/90smb>			
;----------------------------------------------------------------------

@OffsetGELength
			Move.W		teLength(A3),D0			; else pin to end
			Move.W		D0,(SP)					; replace offset
			SubQ		#1,D0					; just for GetLine

@LengthOK
			Lea			teLines(A3),A2			; pt to start of array
			Bsr			GetLine					; get ptr to line it's on

; LineRect expects to be called from RecalLines, which has its own frame.  It saves
; a value off of A6, which in this case destroys the savePort value on the stdEntry frame.
; So save and restore the value that will be overwritten.

			with		TextFrame,TEFormatOrder	; <1Nov89smb>
			link		a6,#TextFrameSz			; for LineRect: calls FormatOrder code <1Nov89smb>
;; <1Nov89smb>			Move.W		saveJust(A6),-(SP)		; LineRect will write something here
			Bsr			LineRect				; sets up selRect from destRect and justification
;; <1Nov89smb>			Move.W		(SP)+,saveJust(A6)		; restore port
			unlk		a6						; <1Nov89smb>
			Move.W		(A2),D6					; start of line
			Move.W		(SP)+,D7				; offset to measure to

; If the last char is a CR, the h coord should be at the beginning of the next line after the CR
; (the v coord was correct, but the h was at the point preceding the CR on the previous line).
			Cmp.W		teLength(A3),D7			; is offset = text length?
			Bne.S		@DoEndOfLine			; skip CR test if not
			Move.L		teTextH(A3),A0
			Move.L		(A0),A0
			Cmp.B		#returnChar,-1(A0,D7)	; if last char = CR then...
			Bne.S		@DoEndOfLine

@AssumeLeftJust
; assume left justification
			move.w		teSelRect+left(a3),d0
			move.w		teJust(a3),d1
			bne.s		@DoNonLeftJust
			move.w		TESysJust,d1
			beq.s		@DoTheJustThing
;; <7Dec89smb>			Cmp.W		#teForceLeft,D1
;; <7Dec89smb>			Beq.S		@DoTheJustThing

@DoNonLeftJust
; <7Dec89smb> move test to teForceLeft to where it's useful!
			cmp.w		#teForceLeft,d1			; <7Dec89smb>
			beq.s		@DoTheJustThing			; <7Dec89smb>
; right or center justification
			move.w		teDestRect+right(A3),d0	; assume right justification
			subq		#1,d0
			tst.w		d1
			bmi.s		@DoTheJustThing			; branch if right

; center justification (divide width by 2)
			sub.w		teDestRect+left(A3),d0
			asr			#1,d0
			add.w		teDestRect+left(A3),d0
			bra.s		@DoTheJustThing
@DoEndOfLine

	IF forLocalizability THEN					; fix for TEGetPoint Bug <31h-YDS-8/27/91>
			move.l		ExpandMem,a0			; do we have more then the roman script
			cmpi.b		#1,ExpandMemRec.emScriptsInstalled(a0)
			beq.s		@romanMeas				; use MeasureIt
			link		a6,#TextFrameSz			; DoMeasure uses a stack frame 
			bsr			DoMeasure				; measure with LR styles
			unlk		a6
			bra.s		@1
	ENDIF
@romanMeas	bsr			MeasureIt				; measure with style
@1			add.w		teSelRect+left(A3),d0	; add in justification

@DoTheJustThing
			move.l		(SP)+,a2				; restore parameter ptr
			move.w		teSelRect+bottom(a3),(a2)+	; return v coord
			move.w		d0,(a2)					; return h coord

			moveq		#8,d0
			bra			StdExit2

;formFeed
;----------------------------------------------------------------------
;
;	FUNCTION GetStylScrap( hTE: TEHandle): StScrpHandle;
;
;	** <23jan87/MBK> **
;
;	Gets the style information corresponding to the current selection and
;	returns a handle to it, stored in the same format as the 'styl' block.
;
;----------------------------------------------------------------------

;iTEGetStyleScrapHandle							; comment out for now				<45>
;iGetStyleScrap									; comment out for now				<45>
iGetStylScrap
			Clr.L		(A2)					; init value to Nil
			Tst.W		teSize(A3)				; is it a new TERec?
			Bpl.S		EndGet					; quit if not

			Move.W 		teSelStart(A3),D0		; get selstart, selEnd
			Move.W		teSelEnd(A3),D1			; selEnd in D1
			Cmp.W		D0,D1					; compare start to end

; Return true style at selection, whether inferred or stated in NullStRec
			Bne.S		@05						; selection - get it				<C971/RWW102387>

			Move.L		#scrpRecSize+2,D0		; size of total scrap style rec		<C971/RWW102387>
			Bsr			MyNewHandle				; temp handle for style scrap		<C971/RWW102387>
			Move.L		A0,(A2)					; report back with scrap handle		<C971/RWW102387>
			Move.L		(A0),A1					; save as destptr					<C971/RWW102387>
			Move.W		#1,(A1)+				; one style total					<C971/RWW102387>
			Clr.L		(A1)+					; scrpStartChar := 0				<C971/RWW102387>

			Move.W		teSelStart(A3),D0		; get offset						<C971/RWW102387>
			Bsr			GetTrueStyle			; Get style record					<C971/RWW102387>
			Lea			2(A0),A0				; skip over stCount to stHeight		<C971/RWW102387>

			Move.L		#scrpRecSize-4,D0		; amount to copy					<C971/RWW102387>
			_BlockMove							; from NullStRec to StScrpRec		<C971/RWW102387>
			Bra.S		EndGet					; we're outta here					<C971/RWW102387>
@05												;									<C971/RWW102387>

			Bhs.S		@0						; ok if end >= start
			Exg			D0,D1					; else swap start and end

@0			MoveM.L		D2-D5/A2/A5,-(SP)		; save stuff
			Bsr			CopyGuts				; go to create 'styl' handle
			MoveM.L		(SP)+,D2-D5/A2/A5		; restore stuff
			Move.L		A4,(A2)					; return 'styl' handle

EndGet		MoveQ		#6,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE SetStylScrap(rangeStart, rangeEnd: LONGINT; newStyles: StScrpHandle;
;									redraw: BOOLEAN; hTE: TEHandle);
;			** <C971/RWW102887> **
;
;			This procedure is the logical opposite of GetStylScrap.  It
;				takes a handle to a style scrap record and applies it
;				over the given range.  SetStylScrap does not affect the
;				range of the current selection.  If newStyles is NIL or
;				if the edit record was not created with TEStylNew, this
;				procedure has no effect.
;			It is easily possible for the range to be out of sync with
;				with the scrap record.  In either case, as soon as a
;				boundary is reached, this procedure is terminated without
;				a specific error condition.
;
;----------------------------------------------------------------------
;iTEUseStyleScrap								; comment out for now				<45>
;iSetStyleScrap									; comment out for now				<45>
iSetStylScrap
			Tst.W		teSize(A3)				; don't do anything if not styled
			Bpl			@xit
; per documentation, must test for a NIL StScrpHandle handle (newStyles)							<20>
			tst.l		2(a2)					; is the scrap handle NIL							<20>
			beq			@xit					; yep, don't do nuttin!								<20>
			Move.W		(A2)+,D5				; get redraw byte					<C971/RWW111787>
			And.W		#$FF00,D5				; boolean is bit 1 of high byte		<C971/RWW111787>
			Sne			D5						; D5 non-zero if we want to redraw	<C971/RWW111787>
			Beq.S		@03						; we don't, so skip hiliting		<C971/RWW111787>

			Bsr			HideCaret				; remove hiliting
			Bsr			HiLite

@03
			Move.L		(A2)+,A1				; fetch scrap handle
; <17May89smb> must lock the handle before using it
			move.l		a1,-(sp)				; save for restoring flags <17May89smb>
			Move.l		a1,a0					; handle to style scrap <17May89smb>
			_HGetState
			move.b		d0,-(sp)				; save state flags for handle <17May89smb>
			move.l		a1,a0					; get handle again for lock <17May89smb>
			_HLock								; <17May89smb>
			Move.L		(A1),A1					; point at scrap record proper
			Move.L		(A2)+,D7				; fetch end
			Move.L		(A2),D6					; fetch start

			Cmp.L		D6,D7					; sort start/end
			Bhs.S		@05						; end is higher or same, so okay

			Exg			D6,D7					; we want start in D6

@05			MoveQ		#0,D0					; make long for comparisons
			Move.W		teLength(A3),D0
			Cmp.L		D0,D6					; pin start to end of record
			Bls.S		@07

			Move.L		D0,D6

@07			Cmp.L		D0,D7					; pin end to end of record
			Bls.S		@09

			Move.L		D0,D7

@09			Move.L		D6,D3					; make a working copy

			Move.L		teSelStart(A3),-(SP)	; save original start/end

			Move.W		(A1)+,D4				; number of styles to do
			Bra.S		@loop


@1			Cmp.L		D3,D7					; break out if start >= range end
			Bls.S		@done

			Move.W		D3,teSelStart(A3)		; save end as new start
			Tst.W		D4						; is this the last scrap entry?
			Bnz.S		@2						; no, calc end from table

			Move.L		D7,D0					; ran off end of table, so force end
			Bra.S		@3

@2			Move.L		D6,D0					; calc end of selection
			Add.L		scrpRecSize+scrpStartChar(A1),D0
			Cmp.L		D7,D0					; pin end to range end
			Bls.S		@4

@3			Move.L		D7,D0

@4			Move.W		D0,teSelEnd(A3)			; and save as new end
			Move.L		D0,D3					; (save end as next new start)

			MoveM.L		D3-D7/A1/A4/A6,-(SP)	;									<C971/RWW111787>

			Move.W		teSelStart(A3),D0		; fetch start of style				<C971/RWW111787>
			Bsr			GetOneStyle				; point at style to copy over		<C971/RWW111787>
			Lea			stFont(A0),A6			; TEReplaceStyle expects it in A6	<C971/RWW111787>
			Lea			scrpFont(A1),A4			; point at style to set				<C971/RWW111787>
			Move.W		#doAll,D7				; replace everything				<C971/RWW111787>
			Bsr			StyleGuts				; go replace it						<C971/RWW111787>

			MoveM.L		(SP)+,D3-D7/A1/A4/A6	;									<C971/RWW111787>

			Add			#scrpRecSize,A1			; bump pointer to next scrap entry	<C971/RWW111787>

@loop		DBra		D4,@1


@done			
			Move.L		(SP)+,teSelStart(A3)	; restore previous select/end
			move.b		(sp)+,d0				; state flags for style scrap handle <17May89smb>
			move.l		(sp)+,a0				; handle to reset <17May89smb>
			_HSetState							; <17May89smb>

			Tst.B		D5						; are we redrawing?					<C971/RWW111787>
			Beq.S		@xit					; nope, dump out					<C971/RWW111787>

			MoveQ		#0,D7					; no change in lineStarts array
			Bsr			RecalDraw
			Bsr			ShowCaret
			Bsr			HiLite
			Bsr			SelView					; ensure selection is visible		<C971/RWW111787>

@xit		MoveQ		#20,D0
			Bra			StdExit2
			
;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TEStylInsert( pText: Ptr; l: LONGINT; hST: StScrpHandle;
;									hTE: TEHandle );
;
;			This inserts the passed text/length and the associated styles
;			specified in the StScrpHandle just before the selection
;			but doesn't touch the scrap.  The selection too is "untouched"
;			because it is offset by the inserted amount to point to the same
;			range.  Just after a TEStylNew this can be used as a replacement
;			for the old TESetText because the selection and length are all zero.
;
;			** <C734/30jan87/MBK> ** Replaced PutStylScrap by TEStylInsert.
;			TEStylInsert is exactly the same as TEInsert if the TERec is not
;			a style record, or if a NIL style handle is passed in.  Otherwise,
;			TEStylInsert inserts the input style information along with the
;			text.
;
; 			** <C788/11feb87/mbk> ** A2 points to the style handle when we
;			1st enter here.   Before I was getting it after the text and length.
;----------------------------------------------------------------------
;iTEStyleInsert									; comment out for now				<45>
iTEStylInsert
; ** <C766/10feb87/MBK> ** Removed call to StdEntry because TEDispatch does it.
			Bsr			HideCaret				;								<C971/RWW102887>NO
			Bsr			HiLite					; remove selection				<C971/RWW102887>NO

			Move.L		(A2)+,D0				; get style handle			** <C788/11feb87/mbk> **
			MoveQ		#0,D7					; delta = 0(No deletion)
			MoveM.L 	(A2)+,D5-D6 			; A2 points to length & pointer params

; ** <C971/RWW101987>	If length is 0, punt
			Tst.L		D5						; length?							<C971/RWW101987>
			Bz.S		@15						; Nope, so leave					<C971/RWW101987>

			Tst.L		D0						; check if handle is NIL	** <C788/11feb87/mbk> **
			Beq.S		@0						; can't insert styles if NIL

			Move.L		D0,A2					; save style handle in A2	** <C788/11feb87/mbk> **
			Tst.W		teSize(A3)				; check style flag
			Bpl.S		@0						; just insert text if not a style record

			Bsr 		MungeSetup				; setup for the insert
			Clr.L		-(SP)					; fake l1
			Move.L		D6,-(SP)				; pointer to insert = p2
			Move.L		D5,-(SP)				; length to insert = l2
			_Munger 							; use sloppy munger
			AddQ.L		#4,SP					; pop result
			Add 		D5,teLength(A3) 		; adjust length by insert amount

			Move.L		teTextH(A3),A0			; get text handle
			_Hlock								; and relock it

			Move.L		A2,A0					; get style handle			** <C788/11feb87/mbk> **
			_HGetState							; get the style handle's tag
			Move.B		D0,-(SP)				; and save the flags
			_HLock								; and lock it

			MoveM.L		D2-D6/A2/A4,-(SP)		; save stuff
			Move.L		A2,A4					; style handle in A4		** <C788/11feb87/mbk> **

; ** <C851/23Apr87/MBK> ** High word of D3 must be clear for PstStylGuts
			MoveQ		#0,D3					; clear whole register

			Move.W		teSelStart(A3),D3		; selection start
			Bsr			PstStylGuts				; go do the style paste
			MoveM.L		(SP)+,D2-D6/A2/A4		; restore stuff

			Move.B		(SP)+,D0				; get the flags
			Move.L		A2,A0					; get style handle			** <C788/11feb87/mbk> **
			_HSetState							; set the style handle's tag
; only call ConcatRuns when styles are pasted, hence moved here. Text inserted now so
; okay to call.
			Bsr			ConcatRuns				; <24Nov88smb> don't leave any null style runs

			Sub 		D5,D7					; adjust delta amount for ReCalLines
			Bra.S		@1						; go recal

@0			Bsr			InsGuts 				; no styles to insert, only text!	<C971/RWW102887>NO

@1			Bsr 		RecalDraw				; redo the line stuff
			Add 		D5,teSelStart(A3)		; selStart:=selstart + insert amount
			Add 		D5,teSelEnd(A3) 		; selEnd:=selEnd + insert amount

@15												;									<C971/RWW101987>
			Bsr 		ShowCaret
			Bsr			HiLite					; restore selection				<C971/RWW102887>NO
			MoveQ		#18,D0					; # of bytes on stack
			Bra 		StdExit2				;	to be removed before exit

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION TEGetHeight (endLine, startLine : LONGINT; hTE: TEHandle): LONGINT;
;
;			** Rewritten <C971/RWW102387>  **
;
;			Gets the total line height of the document.
;			Now properly sorts endLine and startLine so doesn't need special glue.
;
;----------------------------------------------------------------------
iTEGetHeight
			MoveM.L		(A2)+,D0-D1				; 1st line
			Cmp.L		D0,D1					; Which is larger?
			Bhs.S		@05						; D1 is, so okay
			Exg.L		D0,D1					; Assure endLine in D1
@05
			Tst.L		D0						; is it 0?
			Bnz.S		@0
			MoveQ		#1,D0					; minimum line #
@0
			SubQ.L		#1,D0					; make it 0-based
			Tst.L		D1						; is it 0?
			Bnz.S		@1
			MoveQ		#1,D1					; minimum line #
@1
			MoveQ		#0,D2					; clear D2 long
			Move.W		teNLines(A3),D2			; last line
			Bne.S		@15						; At least one line!			<S443/RWW032588>
			MoveQ		#1,D2					;								<S443/RWW032588>
@15												;								<S443/RWW032588>
			Cmp.L		D2,D0					; pin to last line
			Bls.S		@2						; okay if less or same
			Move.L		D2,D0					; else set to max line
@2
			Cmp.L		D2,D1					; pin to last line
			Bls.S		@3						; okay if less or same
			Move.L		D2,D1					; else set to max line
@3
			Bsr			GetLineHites			; get total height
			Move.L		D0,(A2)					; return total height

			MoveQ		#14,D0					; # of bytes on stack
			Bra			StdExit2				;	to be removed before exit

;formFeed
;----------------------------------------------------------------------
;
;			PROCEDURE TECustomHook(which: TEHook; VAR addr: ProcPtr;
;									hTE: TEHandle);
;			** <C971/RWW110487> **
;
;			This procedure sets the various internal dispatch table
;				addresses, returning the previous contents in addr.
;
;----------------------------------------------------------------------
iTECustomHook
			Move.L		(A2)+,A1				; fetch pointer to new address
			Move.W		(A2),D0					; fetch selector
			LsL.W		#2,D0					; * 4 for long offset
			Move.L		teDispatchH(A3),A0		; get handle to hooks
			Move.L		(A0),A0					; point at table
;;			Add.L		D0,A0					; add in offset <2May89smb>
			Add.w		D0,A0					; add in offset <2May89smb>: changed to word op.
			Move.L		(A0),D0					; fetch old vector
			Move.L		(A1),(A0)				; and store away the new one
			Move.L		D0,(A1)

@xit		MoveQ		#12,D0					; # of bytes on stack
			Bra			StdExit2				;	to be removed before exit

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION  TENumStyles(rangeStart, rangeEnd: LONGINT;
;									 hTE: TEHandle): LONGINT;
;			** <C971/RWW111887> **
;
;			This function returns the number of style changes across
;				a given range.
;
;----------------------------------------------------------------------
iTENumStyles
			Move.L		(A2)+,D1				; get end of range
			Move.L		(A2)+,D0				; get start of range

			Cmp.L		D0,D1					; Which is larger?
			Bhi.S		@1						; D1 is, so okay
			Beq.S		@3						; (special case when both same)

			Exg.L		D0,D1					; Assure endLine in D1

@1			Tst.W		teSize(A3)				; if it is an old TERec
			Bmi.S		@2

@3			MoveQ		#1,D0					; signify one style exists
			Bra.S		@xit

@2			Clr.L		D2						; pin rangeEnd to selEnd			<C971/RWW111987>
			Move.W		teSelEnd(A3),D2			;									<C971/RWW111987>
			Cmp.L		D2,D1					;									<C971/RWW111987>
			Bls.S		@4						;									<C971/RWW111987>

			Move.L		D2,D1					; rangeEnd was larger, force selEnd	<C971/RWW111987>

@4			Bsr			GetCurStyle
			Bsr			GetNumStyles

@xit		Move.L		D0,(A2)					; store away result
			MoveQ		#14,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------
;
;			FUNCTION  TEContinuousStyle(VAR mode: INTEGER; VAR aStyle: TextStyle;
;										hTE: TEHandle): BOOLEAN;
;			** <C971/RWW102687> **
;
;			This function gives you information about the continuity of
;				various aspects of the current selection.  The result
;				returned is TRUE if the given style exists across the
;				entire selection range.  The style attributes to check
;				are specified by the mode parameter, which takes the
;				same values as in TESetStyle.  Attributes which are
;				continuous across the current selection range are
;				returned in aStyle, with the appropriate bits set in
;				mode.  If the selection range is an insertion point,
;				this call duplicates TEGetStyle, except that the returned
;				style reflects the style of the _next_character_typed_.
;			The attribute bits of aStyle.tsFace are individually
;				checked across the selection range, and are returned set
;				to 1 if that attribute is indeed continuous.
;
;----------------------------------------------------------------------
iTEContinuousStyle
			Tst.W		teSize(A3)				; is it a new TERec?
			Bmi.S		@1						; yes it is, continue

			Move.L		(A2),A0
			Move.L		teGrafPort(A3),A1
			Move.L		txFont(A1),(A0)+		; copy font/face
			Move.W		txSize(A1),(A0)+		; copy size
			Pea			0(A0)					; ptr to forecolor
	If NOT ForROM THEN							; <9Dec88smb>
			BTst		#14,ROM85				; Becks or better?					<C971/RWW112487>
			Bnz.S		@2						; nope								<C971/RWW112487>
			_GetForeColor						;									<C971/RWW112487>
			Bra.S		@3						;									<C971/RWW112487>
@2			Bsr			GetForeColor			;									<C971/RWW112487>
@3
	ElseIf hasCQD THEN							; <9Dec88smb>
			_GetForeColor						; for Mac II
	Else
			Bsr			GetForeColor			; for all others
	EndIf
			ST			8(A2)					; only one style, so everything's continuous
			Bra.S		@xit
@1
			Bsr.S		ContGuts
@xit
			MoveQ		#14,D0
			Bra			StdExit2

;formFeed
;----------------------------------------------------------------------
;
;	ContGuts
;	<C971/RWW102687>
;	<S425/RWW031688>	Rewrote according to suggestions from DTS.  Now no face information
;					needs to be passed in.  If ANY face information is continuous across
;					the selection, doFace is returned TRUE if it was requested.
;					Seems this is a more required case than the original allowed for,
;					(and besides, it is a helluva lot easier case to code for)
;
;	Does actual work of TEContinuousStyle
;
;----------------------------------------------------------------------
contArgs	Record		0
contStyle	Ds.L		1
contMode	Ds.L		1
contResult	Ds.B		1
			EndR

ContGuts
			With		contArgs

			MoveM.L		D3-D7/A4,-(SP)			; save working registers

			Move.W		teSelStart(A3),D0		; insertion point gets handled differently
			Cmp.W		teSelEnd(A3),D0
			Seq			D5						; show as an insertion point
			Bne.S		@1

			Bsr			AnyNullStyle			; use null style if available
			Bnz.S		@1

			Tst.W		D0						; otherwise, we want style of character…
			Bz.S		@1						; …just _before_ insert point

			SubQ.W		#1,D0					; (exception is top of record, obviously)

@1			Bsr			GetTrueStyle

			Move.L		contStyle(A2),A1		; point at receiving record

			Move.L		stFont(A0),tsFont(A1)	; move TextStyle
			Move.L		stSize(A0),tsSize(A1)
			Move.L		stColor+2(A0),tsColor+2(A1)

; aStyle is primed with the style of the selection start.  Find the StyleRun that
;	determines the selection start and walk through the style changes, noting differences

			Move.B		stFace(A0),D7			; save start face for compare later	<S425/RWW031688>
			Move.B		D7,D6					; make a working copy

			Move.L		contMode(A2),A0			; point at mode
			Move.W		(A0),D0					; save mode for comparison later
			And.W		#$000F,D0				; only low 4 bits make any sense
			Move.W		D0,D4					; D4 = working register				<S425/RWW031688>
			Move.W		D0,D3					; D3 = original request				<S425/RWW031688>

			Tst.B		D5						; insertion point?
			Bnz			@goodxit				; yes, so no need to consult style entries <S425/RWW031688>

			Move.W		teSelStart(A3),D0		; get selection start
			Bsr			GetCurStyle				; get the current StyleRun
			Move.L		A0,A4					; (we don't need the TEHandle…)

@loop		AddQ		#stStartSize,A4			; actually, we want the next one

			Tst.W		D4						; if we've reset all bits…
			Bz.S		@2						; …it's senseless to go on

			Move.W		startChar(A4),D0		; if negative, we're off end of table
			Bmi.S		@2

			Cmp.W		teSelEnd(A3),D0			; if past end of selection, we're done
			Bhs.S		@2

			Move.W		styleIndex(A4),D0		; get index into style table
			Bsr			GetStyle				; go get it

; In order for this to work, neither GetCurStyle nor GetStyle can mess with A1!!!!!…
			BTst		#fontBit,D4				; check font?
			Bz.S		@3

			Move.W		tsFont(A1),D0
			Cmp.W		stFont(A0),D0			; do fonts match?
			Beq.S		@3						; yes, go on

			BClr		#fontBit,D4				; don't need to check it anymore

@3			BTst		#sizeBit,D4				; check size?
			Bz.S		@4

			Move.W		tsSize(A1),D0
			Cmp.W		stSize(A0),D0			; do sizes match?
			Beq.S		@4						; yes, go on

			BClr		#sizeBit,D4				; don't need to check it anymore

@4			BTst		#clrBit,D4				; check color?
			Bz.S		@5

			Move.L		tsColor(A1),D0
			Cmp.L		stColor(A0),D0			; do red/green match?
			Bne.S		@6						; no, reset bit
			Move.W		tsColor+4(A1),D0
			Cmp.W		stColor+4(A0),D0		; does blue match?
			Beq.S		@5

@6			BClr		#clrBit,D4				; don't need to check it anymore

; Comparing faces is a bit tricky.  If we started out plain, merge in style bits.
;	Otherwise, calculate intersection of bit sets
@5			BTst		#faceBit,D4				; check face?
			Bz.S		@loop

			Tst.B		D7						; did we start out with plain style?
			Bnz.S		@8

			Or.B		stFace(A0),D6			; Don't fall through anymore		<S488/RWW050388>
			Bra.S		@loop					;									<S488/RWW050388>

@8			And.B		stFace(A0),D6
			Bra.S		@loop



; We come here when we're done perusing the selection range.
; 	Now, we have to resolve the doFace bit.  This is all complicated by the fact that
;	“plain” isn't a style attribute, but rather a lack of other styles.
@2			BTst		#faceBit,D4				; check face?
			Bz.S		@xit					; nope, skip resolution

; <S425/RWW031688>	All this is new, for new handling of face information
			Tst.B		D7						; did we start out with plain?		<S425/RWW031688>
			Bnz.S		@notPlain				; nope, go on						<S425/RWW031688>
			
			Tst.B		D6						; if ended with plain, hunky dory	<S425/RWW031688>
			Bz.S		@goodxit				; save result and exit				<S425/RWW031688>
			
@badxit		BClr		#faceBit,D4				; no good.  reset bit				<S425/RWW031688>
			Bra.S		@xit					; …and leave						<S425/RWW031688>

@notPlain	Tst.B		D6						; end with any intersection?		<S425/RWW031688>
			Bz.S		@badxit					; nope, so nothing was continuous	<S425/RWW031688>

@goodxit	Move.B		D6,tsFace(A1)			; save intersection to aStyle		<S425/RWW031688>

@xit		Move.L		contMode(A2),A0			; Point at mode
			Move.W		D4,(A0)					; save intersection back to mode

			Cmp.W		D4,D3					; Was everything continuous?		<S425/RWW031688>

			Seq			D0						; TRUE if everything was equal		<S425/RWW031688>
			Neg.B		D0						; Blaise wants false=0 and true=1	<C971/RWW111687>
			Move.B		D0,contResult(A2)		; Blaise wants false=0 and true=1	<C971/RWW111687>
			MoveM.L		(SP)+,D3-D7/A4			; Retrieve working registers
			Rts

			EndWith		;contArgs


; *************************************************************************************************
; *************************************************************************************************
; *************************************************************************************************

; TextEdit end
