;EASE$$$ READ ONLY COPY of file “QuickerDraw.a”
; 1.2	CCH 01/16/1989 Merged 6.0.3 final sources into 7.0.
;•1.1	CCH 11/16/1988 Updated to newest version.

			PRINT		ON

; File QuickLoops.a
;-----------------------------------------------------------------------------
;  
;   High performance Mac II Color QuickDraw Inner Loops (for 8-bit mode)
;
;	  written by Andy Hertzfeld  December 22, 1987
;
;   This INIT patches out some of the Color QuickDraw inner loop traps 
;   to improve 8-bit performance by a factor of 2 to 3 (or even more!)
;
;   Modification History:
;
;        AJH  11-Jan-88   1st Beta release, version .9
;        AJH  13-Jan-88   made fills work in modes other than 8-bit (.91)
;        AJH  14-Jan-88   fixed bug in unclipped pattern fill (.92)
;        AJH  16-Jan-88   fixed seek region bug in mapped copyBits (.93)
;        AJH  17-Jan-88   fixed scaling rejection bug in mapped copyBits
;        AJH  18-Jan-88   implemented fast 8 to 1 copyBits; fixed 1-8 seekRgn bug (.94)
;        AJH  20-Jan-88   region counting for clipped blit
;        AJH  22-Jan-88   fixed OR mode fill, added $335 for MacDraw Plus
;        AJH  23-Jan-88   fixed bug when region is a mask (CB1to8 from CopyMask)
;        AJH  24-Jan-88   broke LogoPict into separate resource; separate 1-bit logo (.95)
;        AJH  25-Jan-88   region counting for InvertClip
;        AJH  26-Jan-88   significantly improved oval/rrects when unclipped 
;        AJH  26-Jan-88   added oval/rrects in OR mode  
;        AJH  27-Jan-88   OR mode fills (simple and complex patterns) (.96)
;        AJH  28-Jan-88   INIT wasn't locked bug  (.97)
;        AJH  28-Jan-88   check if already installed; if so, display logo
;        AJH  29-Jan-88   removed OR mode complex fills; fixed OR mode simple fills
;        AJH  29-Jan-88   reject patterns > 8 pixels wide
;        AJH  29-Jan-88   added oval/rrects with complex patterns   
;        AJH  30-Jan-88   added arithmetic transfer mode fills for rrects/ovals
;        AJH  31-Jan-88   added arithmetic transfer mode fills for unclipped rects
;        AJH  01-Feb-88   added arithmetic transfer mode fills for clipped rects (.98)
;        AJH  02-Feb-88   added blend mode; fixed arithmetic copyBits bug
;        AJH  03-Feb-88   removed hilite by invert hack (.985)
;        AJH  03-Feb-88   further optimized hilite, 1 to 8 copybits
;        AJH  04-Feb-88   added transparent modes
;        AJH  04-Feb-88   fixed arithmetic mode bug with type 0 patterns (-$68, not -68!) (.987)
;	 	 AJH  05-Feb-88   converted to cdev
;        AJH  07-Feb-88   added configuration code at startup time (.99)
;        AJH  18-Feb-88   fixed bug in transparent mode fill (LSR instead of ASR)
;        AJH  18-Feb-88   fixed bug in unclipped, less than 5 wide arithmetic modes
;        AJH  21-Feb-88   fixed bug in arithmetic mode cache initialization
;        AJH  21-Feb-88   fixed wrong reg (A4 -> A2) bump bug in oval handler (MacDraw crash) (1.0)
;        AJH  22-Feb-88   fixed bug in 8-1 copybits (can't assume map is 0 or 1 only)
;        AJH  23-Feb-88   fixed arithmetic mode cache initialization (add and sub modes) (1.1)
;
;---- A New Life at Apple --------------------
;	
; PB415	 DAF/BAL	01Mar88		QuickerDraw integrated into system patch files
; PB427	 BAL		17Mar88		Corrected some edge masking bugs in arithmetic modes.
;								Return to ROM if arithmetic mode copybits from left to right.
; PB428	 DAF		18Mar88		Fixed QuickerDraw to be A/UX friendly.
; PB433	 DAF		22Mar88		Improved dispatches to ROM (saved a couple of bytes and cycles)
; 		 BAL		25Mar88		Converted to use symbolic stack frame references
; PB446	 DBG		29Mar88		Fixed up missed JMPs into ROM in QuickerDraw.a, which cause certain
;								CopyBits cases to crash.
; PB448  DBG		30Mar88		Fixed erroneous references to HBUMP to be to SRCBUMP
; PB452	 BAL		01Apr88		Fixed bug in DrawSlab OR mode handler ($381) to preserve fgColor
; PB471	 BAL		18Apr88		Fixed 1 to 8 bit expansion to first insure CLUT is B/W.
; PB473	 DAF		19Apr88		Modified PB471 to allow more cases to be accelerated.
; PB471	 BAL/DVB	13Jun88		Fixed 1 to 8 bit expansion to first insure src = scalebuf
;								(i.e. dest not before pixmap's baseAddr).
; PBnnn  d√b		12Jul88		Fixed error in 8 to 1 when white doesn't map to white.
;
;--------------------------------------------------------------------------------------------------


		
		MACHINE	MC68020		

; for reference, here are the patched traps

	IF 0 THEN

		InstToolTp	CopyScanLine1,$330
		InstToolTp	PatClipScanLine,$362
		InstToolTp	PatFillScanLine,$338
		InstToolTp	CBClipLine,$35A
		InstToolTp	InvertClip,$360
		InstToolTp	InvertHiliteClip,$372
		InstToolTp	CB1To8Clip,$373
		InstToolTp	FillClipScanLine,$380	
		InstToolTp	FillClipOrLine,$381				; Removed typo ` <PB446 DBG>
		InstToolTp	PatClipVar2,$35E
		InstToolTp	FillClipXLine,$384
	
		InstToolTp	AddOverFillO,$38A
		InstToolTp	SubOverFillO,$38E
		InstToolTp	AddPinFillO,$389
		InstToolTp	SubPinFillO,$38B
		InstToolTp	AddMaxFillO,$38D
		InstToolTp	AddMinFillO,$38F
		InstToolTp	BlendFillO,$388
		InstToolTp	TransFillO,$38C
	
		InstToolTp	AddOverFillR,$368
		InstToolTp	SubOverFillR,$36C
		InstToolTp	AddPinFillR,$367
		InstToolTp	SubPinFillR,$369
		InstToolTp	AddMaxFillR,$36B
		InstToolTp	AddMinFillR,$36D
		InstToolTp	BlendFillR,$366
		InstToolTp	TransFillR,$36A
	
		InstToolTp	AddOverUnClip,$352
		InstToolTp	SubOverUnClip,$356
		InstToolTp	AddPinUnClip,$351
		InstToolTp	SubPinUnClip,$353
		InstToolTp	AddMaxUnClip,$355
		InstToolTp	AddMinUnClip,$357
		InstToolTp	BlendUnClip,$350
		InstToolTp	TransUnClip,$354

	ENDIF
		
;******************************************************************************************

;
; to make scoping for upcoming equates happier, we force the end of the previous procedure here
;

QuickerDraw		PROC		EXPORT


				EXPORT		CopyScanLine1		
				EXPORT		PatClipScanLine		
				EXPORT		PatClipVar2			
				EXPORT		PatFillScanLine		
				EXPORT		CBClipLine			
				EXPORT		InvertClip
				EXPORT		InvertHiliteClip
				EXPORT		CB1To8Clip
				EXPORT		FillClipScanLine
				EXPORT		FillClipOrLine
				EXPORT		FillClipXLine
				EXPORT		AddOverFillO
				EXPORT		SubOverFillO
				EXPORT		AddPinFillO
				EXPORT		SubPinFillO
				EXPORT		AddMaxFillO
				EXPORT		AddMinFillO
				EXPORT		BlendFillO
				EXPORT		AddOverFillR
				EXPORT		SubOverFillR
				EXPORT		AddPinFillR
				EXPORT		SubPinFillR
				EXPORT		AddMaxFillR
				EXPORT		AddMinFillR
				EXPORT		BlendFillR
				EXPORT		AddOverUnClip
				EXPORT		SubOverUnclip
				EXPORT		AddPinUnclip
				EXPORT		SubPinUnclip
				EXPORT		AddMaxUnclip
				EXPORT		AddMinUnclip
				EXPORT		BlendUnclip
				EXPORT		TransFillO
				EXPORT		TransFillR
				EXPORT		TransUnClip
		
; now patch the inner loop traps; so far we handle:

Old330		EQU		$1B8F8	; bMain0-- copyBits, no clip, copy mode

Old338		EQU		$1BB7A	; bXMain8-- pattern fill, complex pattern, copy mode, no clipping

Old350		EQU		$1BF24	; bAvg-- blend fill, unclipped rects
Old351		EQU		$1BC6A	; bAddPin-- addPin fill, unclipped rects
Old352		EQU		$1BBF4	; bAddOver-- addOver fill, unclipped rects (and bitmaps)
Old353		EQU		$1BD7C	; bSubPin-- subPin fill, unclipped rects
Old354		EQU		$1C0B0	; bTransparent-- transparent fill, unclipped rects
Old355		EQU		$1BE18	; bMax-- addMax fill, unclipped rects
Old356		EQU		$1BD06	; bSubOver-- subOver fill, unclipped rects
Old357		EQU		$1BE9E	; bMin-- addMin fill, unclipped rects

Old35A		EQU		$1CBF8	; rMASK0-- copyBits, copy mode, region clipped

Old35E		EQU		$1CCCC	; rMASK8-- one-reg region clipped fill

Old360		EQU		$1CCFA	; rMASK10-- invert, region clipped, pattern black

Old362		EQU		$1CD20	; rXMASK8-- pattern fill, region clipped

Old366		EQU		$1CF94	; rAvg-- blend fill, clipped rects
Old367		EQU		$1CDE8	; rAddPin-- addPin fill, clipped rects
Old368		EQU		$1CD9C	; rAddOver-- addOver fill, clipped rects  (and bitmaps)
Old369		EQU		$1CE88	; rSubPin-- subPin fill, clipped rects
Old36A		EQU		$1D094	; rTransparent-- transparent fill, clipped rects
Old36B		EQU		$1CEDC	; rMax-- addMax fill, clipped rects
Old36C		EQU		$1CE3C	; rSubOver-- subOver fill, clipped rects
Old36D		EQU		$1CF38	; rMin-- addMin fill, clipped rects

Old372		EQU		$1D000	; rHilite-- clipped hilite invert
Old373		EQU		$227EC	; stMASK0-- 1 to 8 clipped copyBits

Old380		EQU		$1DD7E	; slMASK8-- oval/rrect copy mode scan line handler
Old381		EQU		$1DD9A	; slMASK9-- oval/rrect OR mode scan line handler

Old384		EQU		$1DDCE	; slXMask8-- oval/rrect complex fill, copy mode

Old388		EQU		$1E1BE	; slAvg-- blend fill, ovals
Old389		EQU		$1DF50	; slAddPin-- addPin fill, ovals
Old38A		EQU		$1DEBA	; slAddOver-- addOver fill, ovals
Old38B		EQU		$1E042	; slSubPin-- subPin fill, ovals
Old38C		EQU		$1E2CE	; slTransparent-- transparent fill, ovals
Old38D		EQU		$1E0CE	; slMax-- AddMax fill, ovals
Old38E		EQU		$1DFDA	; slSubOver-- subOver fill, ovals
Old38F		EQU		$1E146	; slMin-- AddMin fill, ovals

;******************************************************************************************

		
;--------------------------------------------------------------
;
;  PROCEDURE StretchBits(srcBits,maskBits,dstBits: BitMap;
;			 srcRect,maskRect,dstRect: Rect;
;			 mode: INTEGER; pat: Pattern;
;			 rgnA,rgnB,rgnC:  RgnHandle);
;
;  Transfer a rectangle of bits from srcBits to dstBits,
;  stretching or compressing according to srcRect and dstRect.
;  The transfer is clipped to the intersection of rgnA, rgnB, and rgnC.
;  It is also clipped to the specified mask.  If MaskBits is NIL, then
;  no masking is done.
;
;  Restrictions:
;
;	  transfer mode 0..7 only.
;	  if numer <> denom, then src and dst bitmaps do not overlap.
;
;
;  COPYRIGHT APPLE COMPUTER INC.
;  DESIGNED AND WRITTEN BY BILL ATKINSON
;


;----------------------------------------------------
;
;  A6 OFFSETS OF PARAMETERS AFTER LINK:
;
PARAMSIZE		EQU 	44					;SIZE OF PARAMETERS
SRCBITS 		EQU 	PARAMSIZE+8-4		;LONG, ADDR OF BITMAP
MASKBITS 		EQU 	SRCBITS-4			;LONG, ADDR OF BITMAP
DSTBITS 		EQU 	MASKBITS-4			;LONG, ADDR OF BITMAP
SRCRECT 		EQU 	DSTBITS-4			;LONG, ADDR OF RECT
MASKRECT 		EQU 	SRCRECT-4			;LONG, ADDR OF RECT
DSTRECT 		EQU 	MASKRECT-4			;LONG, ADDR OF RECT
MODE			EQU 	DSTRECT-2			;WORD
PAT 			EQU 	MODE-4				;LONG, ADDR OF PATTERN
RGNA			EQU 	PAT-4				;LONG, RGNHANDLE
RGNB			EQU 	RGNA-4				;LONG, RGNHANDLE
RGNC			EQU 	RGNB-4				;LONG, RGNHANDLE
multColor		EQU		RGNC-2				;byte, set if source contains nonblack/white colors

;-------------------------------------------------
;
;  A6 OFFSETS OF LOCAL VARIABLES AFTER LINK:
;
;  STACK FRAME VARS USED BY SEEKMASK (CALLED BY STRETCHBITS, RGNBLT, DRAWARC, DRAWLINE)
;
RECTFLAG		EQU 	-2					;WORD
VERT			EQU		RECTFLAG-2			;WORD
RGNBUF 			EQU 	VERT-4				;LONG
BUFLEFT 		EQU 	RGNBUF-2			;WORD
BUFSIZE			EQU		BUFLEFT-2			;WORD
EXRTN			EQU		BUFSIZE-4			;LONG
SEEKMASK		EQU		EXRTN-4				;LONG
DSTMASKBUF		EQU		SEEKMASK-4			;LONG
DSTMASKALIGN	EQU		DSTMASKBUF-4		;LONG
STATEA			EQU 	DSTMASKALIGN-RGNREC	;RGN STATE RECORD
STATEB			EQU 	STATEA-RGNREC		;RGN STATE RECORD
STATEC			EQU 	STATEB-RGNREC		;RGN STATE RECORD

;  STACK FRAME VARS USED BY PATEXPAND, COLORMAP, DRAWSLAB
;  CALLED BY STRETCHBITS, RGNBLT, BITBLT, DRAWARC, DRAWLINE

;													 SET UP FOR BITBLT AND RGNBLT
EXPAT			EQU		STATEC-4			;LONG				YES
PATVMASK		EQU		EXPAT-2				;WORD (must follow expat)
PATHMASK		EQU		PATVMASK-2			;WORD (must follow PATVMASK)
PATROW			EQU		PATHMASK-2			;WORD (must follow PATHMASK)
PATHPOS			EQU		PATROW-2			;WORD				YES
PATVPOS			EQU		PATHPOS-2			;WORD				YES
LOCMODE			EQU		PATVPOS-2			;WORD				YES
PIXSRC			EQU		LOCMODE-1			;BYTE				YES
NEWPAT			EQU		LOCMODE-2			;BYTE				YES
LOCPAT			EQU		NEWPAT-4			;LONG				YES
FCOLOR			EQU		LOCPAT-4			;LONG				YES
BCOLOR			EQU		FCOLOR-4			;LONG				YES
DSTPIX			EQU		BCOLOR-(PMREC+CTREC+20)	;PIXMAP+COLOR TABLE	   YES
DSTSHIFT		EQU		DSTPIX-2			;WORD				YES

; these shared stack frame vars are set up and used by the arithmetic drawing modes

weight			EQU		DSTSHIFT-6			;RGB  weight for averaging
pin				EQU		weight				;RGB  used by max, min
notWeight		EQU		weight-6			;RGB  complement of weight (for average)
multiColor		EQU		notWeight-2			;byte	set if source contains nonblack/white colors
colorTable		EQU		multiColor-4		;long	pointer to color table
invColor		EQU		colorTable-4		;long	pointer to inverse color table
invSize			EQU		invColor-2			;word 	resolution of inverse color table
rtShift			EQU		invSize-2			;Word	used by average how far to shift
transColor		EQU		rtShift-4			;long	copy of backcolor for transparent
hilitColor		EQU		transColor-4		;long	hilite color pixels

;  MORE SHARED STACK FRAME VARS (STRETCHBITS, RGNBLT, BITBLT)

SRCPIX			EQU		hilitColor-(PMREC+CTREC+20)	;PIXMAP				YES
MASKPIX			EQU		SRCPIX-(PMREC+CTREC+20)		;PIXMAP				YES
SRCROW			EQU 	MASKPIX-4			;LONG				YES
MASKROW			EQU 	SRCROW-4			;LONG				YES
DSTROW			EQU 	MASKROW-4			;LONG				YES
SRCSHIFT		EQU		DSTROW-2			;WORD				YES
MASKSHIFT		EQU		SRCSHIFT-2			;WORD				YES
MINRECT 		EQU 	MASKSHIFT-8			;RECT				YES
INVERT			EQU		MINRECT-4			;LONG				YES
SAVESTK 		EQU 	INVERT-4			;LONG				YES
SAVEA5	 		EQU 	SAVESTK-4			;LONG				YES

SRCBUF			EQU 	SAVEA5-4			;LONG
DSTBUF			EQU 	SRCBUF-4			;LONG
SCALEBUF		EQU		DSTBUF-4			;LONG
SRCMASKBUF		EQU		SCALEBUF-4			;LONG
SRCLONGS		EQU 	SRCMASKBUF-2		;WORD
SRCMASKLONGS	EQU		SRCLONGS-2			;WORD
DSTMASKLONGS	EQU		SRCMASKLONGS-2		;WORD
DSTLONGS		EQU 	DSTMASKLONGS-2		;WORD
SCALELONGS		EQU		DSTLONGS-2			;WORD
SRCADDR 		EQU 	SCALELONGS-4		;LONG
MASKADDR		EQU		SRCADDR-4			;LONG
DSTADDR 		EQU 	MASKADDR-4			;LONG
SRCLIMIT		EQU 	DSTADDR-4			;LONG
NUMER			EQU 	SRCLIMIT-4			;POINT
DENOM			EQU 	NUMER-4 			;POINT
MASKNUMER		EQU 	DENOM-4				;POINT
MASKDENOM		EQU 	MASKNUMER-4 		;POINT
MODECASE		EQU 	MASKDENOM-4			;LONG

;  STACK FRAME VARS USED BY STRETCHBITS ONLY

STACKFREE		EQU		MODECASE-4			;LONG
VERROR			EQU 	STACKFREE-2 		;INTEGER
RATIOCASE		EQU 	VERROR-4			;LONG
MASKCASE		EQU		RATIOCASE-4			;LONG
FRACTION		EQU 	MASKCASE-2 			;WORD
MASKFRACT		EQU		FRACTION-2			;WORD
SCALECASE		EQU		MASKFRACT-4			;LONG
SRCSCANS		EQU		SCALECASE-2			;WORD
SRCPIXCNT		EQU		SRCSCANS-2			;WORD
SRCALIGN		EQU		SRCPIXCNT-4			;LONG
DSTALIGN		EQU		SRCALIGN-4			;LONG
MASKALIGN		EQU		DSTALIGN-4			;LONG
ScaleTbl		EQU		MASKALIGN-4			;LONG
CRSRFLAG		EQU		ScaleTbl-2			;WORD
REALBOUNDS		EQU		CRSRFLAG-4			;LONG

;  STACK FRAME VARS USED BY RGNBLT ONLY

FIRSTV			EQU 	REALBOUNDS-2		;WORD
LASTV			EQU 	FIRSTV-2			;WORD
VBUMP			EQU 	LASTV-2 			;WORD, MUST BE ABOVE HBUMP
HBUMP			EQU 	VBUMP-2 			;WORD
RGNADDR			EQU 	HBUMP-4				;LONG
SRCSIZE 		EQU		RGNADDR-2			;WORD
SAVESTK2		EQU		SRCSIZE-4			;LONG

;  STACK FRAME VARS USED BY BITBLT ONLY

SRCV			EQU 	SAVESTK2-2 			;WORD
DSTV			EQU 	SRCV-2				;WORD
SRCBUMP 		EQU 	DSTV-2				;WORD
HEIGHT			EQU 	SRCBUMP-2			;WORD
LONGCNT 		EQU 	HEIGHT-2			;WORD
SRCRECT2		EQU 	LONGCNT-8 			;RECT
FIRSTMASK		EQU		SRCRECT2-4			;LONG

doneMid			EQU		FIRSTMASK-1			;Byte  two flags used to control loop
endSwitch		EQU		doneMid-1			;Byte  three-way switch chooses from src, pat, bigpat
lastMask		EQU		endSwitch-4			;Long  mask for last long blitted on line
midCount		EQU		lastMask-2			;Word  # of pixels on line less mask longs - 1
pixInLong		EQU		midCount-2			;Word   > # of pixels in a long - 1
patPos			EQU		pixInLong-2			;Word  pattern vertical offset
patOffset		EQU		patPos-4			;Long  pattern horizontal initial offset	
destPixOffset	EQU		patOffset-2			;Word  destination pixel offset
pixInLong1		EQU		destPixOffset-2		;Word  same as pixInLong, 1 based (for transparent)
VARSIZE 		EQU 	pixInLong1			;SIZE OF LOCAL VARIABLES

;-----------------------------------------------------
; Here's where we handle the case of copyBits copy mode without region clipping ($330)

UseOld330
		LEARom	Old330,A1		;must use A1 to avoid re-entry
		JMP	(A1)

CopyScanLine1	

		CMP.W	#8,SRCPIX+PIXELSIZE(A6)		;8 bits/pixel?
		BNE.S 	UseOld330		;if not, don't handle

		TST.L	D7			;toggling source?
		BNE.S	UseOld330		;if so, don't handle
		
; it's 8 bit mode, so handle it. Calculate the address adjustments in D7 from the
; bit offset in D6 and mask in D1.  First decode the mask, casing out on the direction
; in A0


		MOVE.L	D1,D3			;get mask
		MOVEQ	#0,D1			;assume minimum
		
		MOVE.W	D6,D0
		ASR	#3,D0			;turn into byte number

		MOVE.W	A0,D5			;remember direction
		BPL.S	@0			;if positive, we're cool
		
		NOT.L	D3			;invert the mask for other direction
@0		
		TST.L	D3
		BMI.S	Got1stOffset		;if on, we're done
		
		ADDQ	#1,D1		
		LSL.L	#8,D3
		BMI.S	Got1stOffset		;if on, we're done
		
		ADDQ	#1,D1		
		LSL.L	#8,D3
		BMI.S	Got1stOffset		;if on, we're done

		ADDQ	#1,D1		

; we got the mask offset in D1 and the byte offset in D0, so compute the bump factors

Got1stOffset	
		ADD.W	D1,D0			;compute byte offset
		
		MOVE.W	D0,D7			;remember offset
		SWAP	D7
		MOVE.W	D1,D7			;use mask offset for dest	
		
; here's the top of the outer loop where we adjust the addresses by the offsets in D7

SL1Loop
		ADD.W	D7,A5
		SWAP	D7
		ADD.W	D7,A4

; get the byte count and blast the scan line

SL1Blast
		MOVE.W	MINRECT+RIGHT(A6),D0
		SUB.W	MINRECT+LEFT(A6),D0		;compute pixel count
		EXT.L	D0
		MOVE.L	A4,A0
		MOVE.L	A5,A1		
		BSR	BlockMove		;blast those bytes!
		
; done with this scan line, so bump to the next scan line and loop until done

		SUB.W	D7,A4			;undo source offset
		SWAP	D7
		SUB.W	D7,A5			;undo dest offset
	
		MOVEQ	#0,D0
		MOVE.W	LONGCNT(A6),D0		;get long count
		ADDQ	#1,D0
		ASL	#2,D0			;turn into byte count
	
		TST.W	D5
		BPL.S	@0			;if positive, skip
		
		NEG.L	D0			;negate it
@0		
		ADD.L	D0,A4
		ADD.L	D0,A5
		
		ADD.W	SRCBUMP(A6),A4		;bump source		; <PB448 DBG>
		ADD.W	A3,A5			;bump destination

		SUBQ.W	#1,HEIGHT(A6)		;decrement scan line count
		BNE.S	SL1Loop			;if more, go do it
		
		RTS

;******************************************************************************************


; Here's where we handle the case of 8-bit pattern fill with region clipping  (trap $362)
; this is used for the more complex patterns that require 2 registers per scan line

; this routine uses "region counting" to keep track of the last scan line's region runs
; for ultra-fast plotting when the region mask hasn't changed.  This requires a few different
; loops to keep track of measuring state implicitly, without performance degradation.

UseOld362
		LEARom	Old362,A1		;must use A1 to avoid re-entry
		JMP	(A1)

PatClipScanLine	

		CMP.W	#4,D7			;is pattern too complex?
		BGT.S	UseOld362		;if so, can't handle
		
		LEA	PatClipOuter,A0
		MOVE.L	A0,MODECASE(A6)		;skip initial testing on return

		MOVEQ	#0,D7			;no runs yet
		SUB.L	A2,A2			;runs not valid

; Handle pattern fill with region clipping.  Fetch the pattern raster into D3 and D4.

PatClipOuter
		ADD.W	D6,A3
		SWAP	D6			;bump to next raster
		
		MOVE.L	0(A3,D6),D3		;get 1st 4 pixels
		EOR.W	#4,D6
		MOVE.L	0(A3,D6),D4		;get next 4 pixels
		
		MOVEQ	#-1,D5			;mask for comparing
		
; first handle the left edge outside of the inner loop so we don't count it in the runs

		MOVE.L	(A4)+,D1		;fetch region mask
		MOVE.L	D3,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		EXG.L	D3,D4
		SUBQ	#1,D2
		BMI.S	DonePCV1Line

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

		MOVE.L	A2,D0			;is it valid?
		BNE	V1PlotRgnRuns		;if so, go super fast
		
		ADDQ	#1,A2			;validate it for next time
		MOVEQ	#0,D7			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ 	V1FirstZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE	V1StartSecondRun	;if not, skip
		
		BRA.S	V1FirstOnes1
		
; here's the loop that counts and plots the first run of all ones

V1FirstOnes
		MOVE.L	(A4)+,D1
			
		CMP.L	D5,D1			;is it still all ones?
		BNE 	V1StartSecondRun	;if not, end the run
V1FirstOnes1	
		ADDQ.W	#1,D7			;bump the run count
		
		MOVE.L	D3,(A5)+
		EXG.L	D3,D4		
		
		DBRA	D2,V1FirstOnes		;loop until we're done

; done with this scan line, so bump to the next

DonePCV1Line
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line of destination

; bump pattern index

		MOVE.W	PATHPOS(A6),D6
		SWAP	D6
		ADD.W	PATROW(A6),D6
		AND.W	PATVMASK(A6),D6		;wrap around

; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADDQ	#1,D0
		MOVE.W	D0,VERT(A6)

		CMP.W	MINRECT+BOTTOM(A6),D0		;all done?
		BEQ 	DonePatClip		;if so, use common exit

; create the region mask for the new scan line, and maintain the all one's flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	V1NewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	V1NewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	V1NewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	V1NewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	V1NewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BLT.S	V1NewRgn		;if so, go do it
							
		TST.L	DSTMASKBUF(A6)			;can we skip it?
		BEQ.S	V1SkipRgn		;if so, skip
V1NewRgn
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		

		SUB.L	A2,A2			;invalidate region counts
		
; set up registers and go handle the next line

V1SkipRgn
		MOVE.L	SRCADDR(A6),A3
		MOVE.L	RGNBUF(A6),A4
		MOVE.L	DSTADDR(A6),A5
		MOVE.W	BUFSIZE(A6),D2

		BRA	PatClipOuter

; here's the loop that counts and plots the first run of all zeros

V1FirstZero
		MOVE.L	(A4)+,D1
		BNE.S	V1StartSecondRun
V1FirstZero0		
		SUBQ.W	#1,D7			;decrement run count for zeros
		
		ADDQ	#4,A5
		EXG.L	D3,D4
		DBRA	D2,V1FirstZero

		BRA.S	DonePCV1Line	

; the region mask is heterogenous, so plot the word and start the second run.

V1StartSecondRun	
		SWAP	D7
		
		MOVE.L	D3,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		EXG.L	D3,D4
		SUBQ	#1,D2
		BMI.S	DoneV1SecondRun

; sample the region and case out for the 2nd time

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ.S	V1stZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE.S	V1StartLastRun		;if not, skip
	
		BRA.S	V1stOnes1
		
; here's the loop that counts and plots the second run of all ones

V1stOnes
		MOVE.L	(A4)+,D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE.S	V1StartLastRun		;if not, end the run
V1stOnes1	
		ADDQ.W	#1,D7			;bump the run count
		
		MOVE.L	D3,(A5)+
		EXG.L	D3,D4
		DBRA	D2,V1stOnes		;loop until we're done
DoneV1SecondRun
		SWAP	D7
		BRA	DonePCV1Line		;all done
		
; here's the loop that counts the 2nd run of zeros

V1stZero
		MOVE.L	(A4)+,D1
		BNE.S	V1StartLastRun
V1stZero0		
		SUBQ.W	#1,D7
		ADDQ	#4,A5			;bump dest reg
		EXG.L	D3,D4
		DBRA	D2,V1stZero		;loop until it changes

		BRA.S	DoneV1SecondRun

; OK, we've accumulated two runs, so finish up the line without counting

V1StartLastRun
		SWAP	D7

		TST.L	D1	
		BEQ.S	V1LastZero
		BRA.S	V1LastLoopA
V1LastLoop
		MOVE.L	(A4)+,D1		;get region		
		BEQ.S	V1LastZero
V1LastLoopA		
		CMP.L	D5,D1
		BNE.S	V1LastHard
		
		MOVE.L	D3,(A5)+		;plot it
		EXG.L	D3,D4
		DBRA	D2,V1LastLoop
		
		BRA	DonePCV1Line
V1LastZero
		ADDQ	#4,A5
		EXG.L	D3,D4
		DBRA	D2,V1LastLoop
		BRA	DonePCV1Line
V1LastHard
		MOVE.L	D3,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		EXG.L	D3,D4
		
		DBRA	D2,V1LastLoop
		BRA	DonePCV1Line
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D7.

V1PlotRgnRuns
		TST.W	D7			;which type of run?
		BPL.S	V1BlastPat1		;if ones, go blast it
		BEQ 	V1PlotRHard1		;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D7,D0
		
		NEG.W	D0			;turn into longword count
		
		BTST	#0,D0			;is the run odd?
		BEQ.S	@0			;if not, skip
		
		EXG.L	D3,D4
@0
		LSL.W	#2,D0			;times 4
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		ADD.W	D7,D2			;decrement count
		BMI	DonePCV1Line		;if done, skip
		
; now handle the second run

V1PRRun2
		LEA	@0,A0			;plot the break longword
		BRA 	V1PlotHardCommon	
@0
		MOVE.L	D7,D0			;which type of run?
 		BPL.S	V1BlastPat2		;if ones, go blast it
		BEQ 	V1PlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		
		BTST	#0,D0			;is the run odd?
		BEQ.S	@1			;if not, skip
		
		EXG.L	D3,D4
@1		
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		TST.W	D2	
		BMI	DonePCV1Line		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA	V1LastLoop

; Handle blasting out the first run

V1BlastPat1
		MOVE.W	D7,D0			;get the size
		LEA	V1PRRun2,A0
		BRA.S	V1BlastPat
		
; Blast out the second run

V1BlastPat2
		SWAP	D0			;use high word for 2nd run
		LEA	V1LastLoop,A0
			
; Here's the unwound loop to blast the # of longwords in D0 out.

V1BlastPat
		CMP.W	#8,D0			;8 left to do?
		BLT.S	V1BlastFinishUp
		
		MOVE.W	D0,D1
		LSR	#3,D1
		SUBQ	#1,D1
V1BlastLoop
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+	
		
		DBRA	D1,V1BlastLoop
V1BlastFinishUp
		MOVE.W	D0,D1
		AND	#7,D1
		EOR	#7,D1
		
		BTST	#0,D1
		BEQ.S	@0
		
		EXG.L	D3,D4
@0
		JMP	V1FinishTable(D1.W*2)
V1FinishTable
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+		;15 total to finish up	

		EXG.L	D3,D4

; all done with plotting so adjust the region pointer and count, then return

@0
		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A4			;bump region ptr
		
		SUB.W	D0,D2
		BMI	DonePCV1Line
V1BlastDone		
		JMP	(A0)

; handle the heterogenous plots between runs

V1PlotRHard1
		LEA	V1PRRun2,A0
		BRA.S	V1PlotHardCommon	
V1PlotRHard2
		LEA	V1LastLoop,A0
V1PlotHardCommon
		MOVE.L	(A4)+,D1
		
		MOVE.L	D3,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		EXG.L	D3,D4
		
		SUBQ	#1,D2			;count it
		BMI	DonePCV1Line	
		
		JMP	(A0)
		
;******************************************************************************************


; Here's where we handle a case of 8-bit pattern fill with region clipping (trap $35E)
; where there's only 4 pixel repeating pattern so it fits in a single register.

; this routine uses "region counting" to keep track of the last scan line's region runs
; for ultra-fast plotting when the region mask hasn't changed.  This requires 5 different
; loops to keep track of measuring state implicitly, without performance degradation.

; D3 has 2 runs in its two words; negative numbers are runs of zeros, positive numbers ones
; D4 has the "scan line valid" flag; if it's non-zero, it's valid.

; this routine works for any bits/pixel

UseOld35E
		LEARom	Old35E,A1		;must use A1 to avoid re-entry	<PB446 DBG>
		JMP	(A1)

PatClipVar2	
		
		LEA	PatClipV2Outer,A0
		MOVE.L	A0,MODECASE(A6)		;skip initial testing on return

		MOVEQ	#0,D3			;zero run counts
		MOVEQ	#0,D4			;runs are currently invalid
		
; Handle pattern fill with region clipping.  Fetch the pattern raster into D3 and D4.

PatClipV2Outer
		MOVEQ	#-1,D5			;mask for comparing
	
; first handle the left edge outside of the inner loop so we don't count it in the runs

		MOVE.L	(A4)+,D1		;fetch region mask
		MOVE.L	D6,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		SUBQ	#1,D2
		BMI.S	DonePCV2Line

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

		TST.W	D4			;is it valid?
		BNE	V2PlotRgnRuns		;if so, go super fast
		
		MOVEQ	#-1,D4			;validate it for next time
		MOVEQ	#0,D3			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ 	V2FirstZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE	V2StartSecondRun	;if not, skip
		
		BRA.S	V2FirstOnes1
		
; here's the loop that counts and plots the first run of all ones

V2FirstOnes
		MOVE.L	(A4)+,D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE 	V2StartSecondRun	;if not, end the run
V2FirstOnes1	
		ADDQ.W	#1,D3			;bump the run count
		
		MOVE.L	D6,(A5)+
		DBRA	D2,V2FirstOnes		;loop until we're done

; done with this scan line, so bump to the next

DonePCV2Line
		ADDQ	#1,D7
		AND.W	#15,D7
		MOVE.L	([EXPAT,A6],D7.W*4),D6	;bump the pattern
		
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line of destination
		
; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADDQ	#1,D0
		MOVE.W	D0,VERT(A6)

		CMP.W	MINRECT+BOTTOM(A6),D0		;all done?
		BEQ 	DonePatClip		;if so, use common exit

; create the region mask for the new scan line, and maintain the all one's flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	V2NewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	V2NewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	V2NewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	V2NewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	V2NewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BLT.S	V2NewRgn		;if so, go do it
							
		TST.L	DSTMASKBUF(A6)			;can we skip it?
		BEQ.S	V2SkipRgn		;if so, skip
V2NewRgn
		MOVEQ	#0,D4			;invalidate region counts
		
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		

; set up registers and go handle the next line

V2SkipRgn
		MOVE.L	RGNBUF(A6),A4
		MOVE.L	DSTADDR(A6),A5
		MOVE.W	BUFSIZE(A6),D2

		BRA	PatClipV2Outer

; here's the loop that counts and plots the first run of all zeros

V2FirstZero
		MOVE.L	(A4)+,D1
		BNE.S	V2StartSecondRun
V2FirstZero0		
		SUBQ.W	#1,D3			;decrement run count for zeros
		
		ADDQ	#4,A5
		DBRA	D2,V2FirstZero

		BRA.S	DonePCV2Line	

; the region mask is heterogenous, so plot the word and start the second run.

V2StartSecondRun	
		SWAP	D3
		
		MOVE.L	D6,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		SUBQ	#1,D2
		BMI.S	DoneSecondRun

; sample the region and case out for the 2nd time

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ.S	V2ndZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE.S	V2StartLastRun		;if not, skip
	
		BRA.S	V2ndOnes1
		
; here's the loop that counts and plots the second run of all ones

V2ndOnes
		MOVE.L	(A4)+,D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE.S	V2StartLastRun		;if not, end the run
V2ndOnes1	
		ADDQ.W	#1,D3			;bump the run count
		
		MOVE.L	D6,(A5)+
		DBRA	D2,V2ndOnes		;loop until we're done
DoneSecondRun
		SWAP	D3
		BRA	DonePCV2Line		;all done
		
; here's the loop that counts the 2nd run of zeros

V2ndZero
		MOVE.L	(A4)+,D1
		BNE.S	V2StartLastRun
V2ndZero0		
		SUBQ.W	#1,D3
		ADDQ	#4,A5			;bump dest reg
		DBRA	D2,V2ndZero		;loop until it changes

		BRA.S	DoneSecondRun

; OK, we've accumulated two runs, so finish up the line without counting

V2StartLastRun
		SWAP	D3

		TST.L	D1	
		BEQ.S	V2LastZero
		BRA.S	V2LastLoopA
V2LastLoop
		MOVE.L	(A4)+,D1		;get region		
		BEQ.S	V2LastZero
V2LastLoopA		
		CMP.L	D5,D1
		BNE.S	V2LastHard
		
		MOVE.L	D6,(A5)+		;plot it
		DBRA	D2,V2LastLoop
		
		BRA	DonePCV2Line
V2LastZero
		ADDQ	#4,A5
		DBRA	D2,V2LastLoop
		BRA	DonePCV2Line
V2LastHard
		MOVE.L	D6,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		DBRA	D2,V2LastLoop
		BRA	DonePCV2Line
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D3.

V2PlotRgnRuns
		TST.W	D3			;which type of run?
		BPL.S	V2BlastPat1		;if ones, go blast it
		BEQ 	V2PlotRHard1		;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D3,D0
		
		NEG.W	D0			;turn into longword count
		LSL.W	#2,D0			;times 4
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		ADD.W	D3,D2			;decrement count
		BMI	DonePCV2Line		;if done, skip
		
; now handle the second run

V2PRRun2
		LEA	@0,A0			;plot the break longword
		BRA 	V2PlotHardCommon	
@0
		MOVE.L	D3,D0			;which type of run?
 		BPL.S	V2BlastPat2		;if ones, go blast it
		BEQ.S 	V2PlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		TST.W	D2	
		BMI	DonePCV2Line		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA.S	V2LastLoop

; Handle blasting out the first run

V2BlastPat1
		MOVE.W	D3,D0			;get the size
		LEA	V2PRRun2,A0
		BRA.S	V2BlastPat
		
; Blast out the second run

V2BlastPat2
		SWAP	D0			;use high word for 2nd run
		LEA	V2LastLoop,A0
			
; Here's the unwound loop to blast the # of longwords in D0 out.

V2BlastPat
		CMP.W	#8,D0			;8 left to do?
		BLT.S	V2BlastFinishUp
		
		MOVE.W	D0,D1
		LSR	#3,D1
		SUBQ	#1,D1
V2BlastLoop
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+	
		
		DBRA	D1,V2BlastLoop
V2BlastFinishUp
		MOVE.W	D0,D1
		AND	#7,D1
		EOR	#7,D1
		JMP	V2FinishTable(D1.W*2)
V2FinishTable
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+
		MOVE.L	D6,(A5)+		;15 total to finish up	

; all done with plotting so adjust the region pointer and count, then return

		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A4			;bump region ptr
		
		SUB.W	D0,D2
		BMI	DonePCV2Line
		
		JMP	(A0)

; handle the heterogenous plots between runs

V2PlotRHard1
		LEA	V2PRRun2,A0
		BRA.S	V2PlotHardCommon	
V2PlotRHard2
		LEA	V2LastLoop,A0
V2PlotHardCommon
		MOVE.L	(A4)+,D1
		
		MOVE.L	D6,D0			;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		SUBQ	#1,D2			;count it
		BMI	DonePCV2Line	
		
		JMP	(A0)

;******************************************************************************************

; Here's where we handle the case of 8-bit pattern fill with no clipping  (trap $338)
; (with complex pattern, copy mode)

UseOld338
		LEARom	Old338,A1		;must use A1 to avoid re-entry
		JMP	(A1)

PatFillScanLine	

		CMP.W	#4,D7			;is pattern too complex?
		BGT.S	UseOld338		;if so, can't handle
		
; Handle pattern fill with no clipping.  Fetch the pattern raster into D3 and D4. The
; basic strategy is to do the edge in the general (masking) way, then blast away for
; the middle, finally handling the right edge generally.

PatFillOuter
		MOVE.L	0(A4,D6),D3		;get left pattern
		EOR.W	#4,D6
		MOVE.L	0(A4,D6),D4		;get right pattern
		
; first special case the left edge before falling into the loop

		MOVE.L	D1,D0			;get left mask
		AND.L	D3,D0			;use left pattern
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;get dest
		OR.L	D1,D0			;combine with source
		MOVE.L	D0,(A5)+		;stuff it

; now blast away for the bulk of it

		MOVE.W	D2,D0
		BEQ.S	NextPFillLine	

		CMP.W	#4,D2			;near the end?
		BLE.S	PatFillFinish		;if so, go handle
		
		SUBQ	#1,D0			;do last one with mask
		LSR	#2,D0			;divide by 4 for unwound loop
		SUBQ	#1,D0			;bias for DBRA
PatFillInner
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+		;store 32 pixels worth real fast
		
		DBRA	D0,PatFillInner
		
; finish up the last few pixels
		
PatFillFinish
		MOVE.L	D4,D0
		
		MOVE.W	D2,D1
		AND	#3,D1
		JMP	PatFinTable(D1.W*2)
Finish4
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
Finish2
		MOVE.L	D4,(A5)+
		MOVE.L	D3,D0
		BRA.S	Finish1
PatFinTable
		BRA.S	Finish4
		BRA.S	Finish1
		BRA.S	Finish2
		BRA.S	Finish3
Finish3
		MOVE.L	D4,(A5)+
		MOVE.L	D3,(A5)+
Finish1
		MOVE.L	D5,D1			;get mask
		AND.L	D1,D0			;mask pattern in D0
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;get dest
		OR.L	D1,D0			;combine with source
		MOVE.L	D0,(A5)+		;stuff it
NextPFillLine
		SWAP	D6
		SUB.W	D6,A4

		ADD.W	PATROW(A6),D6
		AND.W	PATVMASK(A6),D6		;wrap around
		ADD.W	D6,A4
		SWAP	D6

		MOVE.W	PATHPOS(A6),D6
		ADD.W	A3,A5		
	
		MOVE.L	FIRSTMASK(A6),D1
		MOVE.W	LONGCNT(A6),D2
		
		SUBQ.W	#1,HEIGHT(A6)		;decrement scan line count
		BNE	PatFillOuter

		RTS


;******************************************************************************************

		
; Handle copyBits, copy mode, with region clipping. Use the region clipping technique
; for fast plotting

UseOld35A
		LEARom	Old35A,A1				; <PB446 DBG>
		JMP	(A1)
		
CBClipLine	

		CMP.W	#8,SRCPIX+PIXELSIZE(A6)		;8 bits/pixel?
		BNE.S 	UseOld35A		;if not, don't handle

		TST.L	D7			;toggling source?
		BNE.S	UseOld35A		;if so, don't handle

		LEA	CBClipCommon,A0
		MOVE.L	A0,MODECASE(A6)		;skip initial testing on return

		MOVEQ	#0,D4			;count invalid 1st time through
CBClipCommon		
		MOVEQ	#-1,D5			;get all ones for comparing
CBClipOuter		
		MOVE.W	D6,D0			;get bit index
		ASR.W	#3,D0			;convert to byte index
		ADD.W	D0,A3			;factor in the byte offset
		
		TST.W	D3			;forwards or backwards?
		BMI	CBClipNeg		;if backwards, handle specially

; the first set of loops is for the plotting forward case (moving towards the left)

; first handle the left edge outside of the inner loop so we don't count it in the runs

CBClipLoop
		MOVE.L	(A4)+,D1		;fetch region mask
		MOVE.L	(A3)+,D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		SUBQ	#1,D2
		BMI.S	DoneCBCLine

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

		TST.W	D4			;is it valid?
		BNE	CBCPlotRgnRuns		;if so, go super fast
		
		MOVEQ	#-1,D4			;validate it for next time
		MOVEQ	#0,D7			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ 	CBCFirstZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE	CBCStartSecondRun	;if not, skip
		
		BRA.S	CBCFirstOnes1
		
; here's the loop that counts and plots the first run of all ones

CBCFirstOnes
		MOVE.L	(A4)+,D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE 	CBCStartSecondRun	;if not, end the run
CBCFirstOnes1	
		ADDQ.W	#1,D7			;bump the run count
		
		MOVE.L	(A3)+,(A5)+
		DBRA	D2,CBCFirstOnes		;loop until we're done

; all done with the scan line so bump the pointers, generate a new region mask if
; necessary, and loop until we're done

DoneCBCLine
		MOVE.L	SRCROW(A6),D0
		ADD.L	D0,SRCADDR(A6)
		
; now bump the output scan line pointer

		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line
		
; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADD.W	VBUMP(A6),D0
		MOVE.W	D0,VERT(A6)

		CMP.W	LASTV(A6),D0		;all done?
		BEQ.S	DonePatClip		;if not, skip

; create the region mask for the new scan line, and maintain the all one's flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CBCNewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	CBCNewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CBCNewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	CBCNewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CBCNewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BLT.S	CBCNewRgn		;if so, go do it
							
		TST.L	DSTMASKBUF(A6)			;can we skip it?
		BEQ.S	CBCSkipRgn		;if so, skip
CBCNewRgn
		MOVEQ	#0,D4			;invalidate region counts
		
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		

; set up registers and go handle the next line

CBCSkipRgn
		MOVE.L	SRCADDR(A6),A3
		MOVE.L	RGNADDR(A6),A4
		MOVE.L	DSTADDR(A6),A5
		MOVE.W	BUFSIZE(A6),D2
		
		MOVE.L	MODECASE(A6),A2
		JMP	(A2)
		
; all done so strip stack and return

DonePatClip		
		MOVE.L	SAVESTK2(A6),A7
DonePClipRTS		
		RTS

; here's the loop that counts and plots the first run of all zeros

CBCFirstZero
		MOVE.L	(A4)+,D1
		BNE.S	CBCStartSecondRun
CBCFirstZero0		
		SUBQ.W	#1,D7			;decrement run count for zeros
	
		ADDQ	#4,A3
		ADDQ	#4,A5
		DBRA	D2,CBCFirstZero

		BRA.S	DoneCBCLine	

; the region mask is heterogenous, so plot the word and start the second run.

CBCStartSecondRun	
		SWAP	D7
		
		MOVE.L	(A3)+,D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		SUBQ	#1,D2
		BMI.S	DoneCBCSecondRun

; sample the region and case out for the 2nd time

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ.S	CBCndZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE.S	CBCStartLastRun	;if not, skip
	
		BRA.S	CBCndOnes1
		
; here's the loop that counts and plots the second run of all ones

CBCndOnes
		MOVE.L	(A4)+,D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE.S	CBCStartLastRun		;if not, end the run
CBCndOnes1	
		ADDQ.W	#1,D7			;bump the run count
		
		MOVE.L	(A3)+,(A5)+
		DBRA	D2,CBCndOnes		;loop until we're done
DoneCBCSecondRun
		SWAP	D7
		BRA	DoneCBCLine		;all done
		
; here's the loop that counts the 2nd run of zeros

CBCndZero
		MOVE.L	(A4)+,D1
		BNE.S	CBCStartLastRun
CBCndZero0		
		SUBQ.W	#1,D7
	
		ADDQ	#4,A3
		ADDQ	#4,A5			;bump dest reg
		DBRA	D2,CBCndZero		;loop until it changes

		BRA.S	DoneCBCSecondRun

; OK, we've accumulated two runs, so finish up the line without counting

CBCStartLastRun
		SWAP	D7

		TST.L	D1	
		BEQ.S	CBCLastZero
		BRA.S	CBCLastLoopA
CBCLastLoop
		MOVE.L	(A4)+,D1		;get region		
		BEQ.S	CBCLastZero
CBCLastLoopA		
		CMP.L	D5,D1
		BNE.S	CBCLastHard
		
		MOVE.L	(A3)+,(A5)+		;plot it
		DBRA	D2,CBCLastLoop
		
		BRA	DoneCBCLine
CBCLastZero
		ADDQ	#4,A3
		ADDQ	#4,A5
		DBRA	D2,CBCLastLoop
		BRA	DoneCBCLine
CBCLastHard
		MOVE.L	(A3)+,D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		DBRA	D2,CBCLastLoop
		BRA	DoneCBCLine
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D7.

CBCPlotRgnRuns
		TST.W	D7			;which type of run?
		BPL.S	CBCBlastPat1		;if ones, go blast it
		BEQ 	CBCPlotRHard1		;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D7,D0
		
		NEG.W	D0			;turn into longword count
		LSL.W	#2,D0			;times 4
		
		ADD.W	D0,A3		
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		ADD.W	D7,D2			;decrement count
		BMI	DoneCBCLine		;if done, skip
		
; now handle the second run

CBCPRRun2
		LEA	@0,A0			;plot the break longword
		BRA 	CBCPlotHardCommon	
@0
		MOVE.L	D7,D0			;which type of run?
 		BPL.S	CBCBlastPat2		;if ones, go blast it
		BEQ.S 	CBCPlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		
		ADD.W	D0,A3
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		TST.W	D2	
		BMI	DoneCBCLine		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA.S	CBCLastLoop

; Handle blasting out the first run

CBCBlastPat1
		MOVE.W	D7,D0			;get the size
		LEA	CBCPRRun2,A0
		BRA.S	CBCBlastPat
		
; Blast out the second run

CBCBlastPat2
		SWAP	D0			;use high word for 2nd run
		LEA	CBCLastLoop,A0
			
; Here's the unwound loop to blast the # of longwords in D0 out.

CBCBlastPat
		CMP.W	#8,D0			;8 left to do?
		BLT.S	CBCBlastFinishUp
		
		MOVE.W	D0,D1
		LSR	#3,D1
		SUBQ	#1,D1
CBCBlastLoop
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+	
		
		DBRA	D1,CBCBlastLoop
CBCBlastFinishUp
		MOVE.W	D0,D1
		AND	#7,D1
		EOR	#7,D1
		JMP	CBCFinishTable(D1.W*2)
CBCFinishTable
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+
		MOVE.L	(A3)+,(A5)+		;15 total to finish up	

; all done with plotting so adjust the region pointer and count, then return

		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A4			;bump region ptr
		
		SUB.W	D0,D2
		BMI	DoneCBCLine
		
		JMP	(A0)

; handle the heterogenous plots between runs

CBCPlotRHard1
		LEA	CBCPRRun2,A0
		BRA.S	CBCPlotHardCommon	
CBCPlotRHard2
		LEA	CBCLastLoop,A0
CBCPlotHardCommon
		MOVE.L	(A4)+,D1
		
		MOVE.L	(A3)+,D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A5),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)+		;deposit it

		SUBQ	#1,D2			;count it
		BMI	DoneCBCLine	
		
		JMP	(A0)

; here's a whole different set of loops for the backwards case

CBClipNeg
		ADDQ	#4,A3			;ditto for source
		ADDQ	#4,A4			;bias region ptr
		ADDQ	#4,A5			;and dest
CBClipNegLoop
		MOVE.L	-(A4),D1		;fetch region mask
		MOVE.L	-(A3),D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	-(A5),D1		;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)			;deposit it

		SUBQ	#1,D2
		BMI 	DoneCBCLine

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

		TST.W	D4			;is it valid?
		BNE	CBCNegPlotRgnRuns	;if so, go super fast
		
		MOVEQ	#-1,D4			;validate it for next time
		MOVEQ	#0,D7			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	-(A4),D1		;fetch next word of region mask
		BEQ.S 	CBCNegFirstZero0	;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE.S	CBCNegStartSecondRun	;if not, skip
		
		BRA.S	CBCNegFirstOnes1
		
; here's the loop that counts and plots the first run of all ones

CBCNegFirstOnes
		MOVE.L	-(A4),D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE.S 	CBCNegStartSecondRun	;if not, end the run
CBCNegFirstOnes1	
		ADDQ.W	#1,D7			;bump the run count
		
		MOVE.L	-(A3),-(A5)
		DBRA	D2,CBCNegFirstOnes	;loop until we're done

		BRA	DoneCBCLine

; here's the loop that counts and plots the first run of all zeros

CBCNegFirstZero
		MOVE.L	-(A4),D1
		BNE.S	CBCNegStartSecondRun
CBCNegFirstZero0		
		SUBQ.W	#1,D7			;decrement run count for zeros
	
		SUBQ	#4,A3
		SUBQ	#4,A5
		DBRA	D2,CBCNegFirstZero

		BRA	DoneCBCLine	

; the region mask is heterogenous, so plot the word and start the second run.

CBCNegStartSecondRun	
		SWAP	D7
		
		MOVE.L	-(A3),D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	-(A5),D1		;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)			;deposit it

		SUBQ	#1,D2
		BMI.S	DoneCBCNegSecondRun

; sample the region and case out for the 2nd time

		MOVE.L	-(A4),D1		;fetch next word of region mask
		BEQ.S	CBCNegndZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE.S	CBCNegStartLastRun		;if not, skip
	
		BRA.S	CBCNegndOnes1
		
; here's the loop that counts and plots the second run of all ones

CBCNegndOnes
		MOVE.L	-(A4),D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE.S	CBCNegStartLastRun	;if not, end the run
CBCNegndOnes1	
		ADDQ.W	#1,D7			;bump the run count
		
		MOVE.L	-(A3),-(A5)
		DBRA	D2,CBCNegndOnes		;loop until we're done
DoneCBCNegSecondRun
		SWAP	D7
		BRA	DoneCBCLine		;all done
		
; here's the loop that counts the 2nd run of zeros

CBCNegndZero
		MOVE.L	-(A4),D1
		BNE.S	CBCNegStartLastRun
CBCNegndZero0		
		SUBQ.W	#1,D7
	
		SUBQ	#4,A3
		SUBQ	#4,A5			;bump dest reg
		DBRA	D2,CBCNegndZero		;loop until it changes

		BRA.S	DoneCBCNegSecondRun

; OK, we've accumulated two runs, so finish up the line without counting

CBCNegStartLastRun
		SWAP	D7

		TST.L	D1	
		BEQ.S	CBCNegLastZero
		BRA.S	CBCNegLastLoopA
CBCNegLastLoop
		MOVE.L	-(A4),D1		;get region		
		BEQ.S	CBCNegLastZero
CBCNegLastLoopA		
		CMP.L	D5,D1
		BNE.S	CBCNegLastHard
		
		MOVE.L	-(A3),-(A5)		;plot it
		DBRA	D2,CBCNegLastLoop
		
		BRA	DoneCBCLine
CBCNegLastZero
		SUBQ	#4,A3
		SUBQ	#4,A5
		DBRA	D2,CBCNegLastLoop
		BRA	DoneCBCLine
CBCNegLastHard
		MOVE.L	-(A3),D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	-(A5),D1		;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)			;deposit it

		DBRA	D2,CBCNegLastLoop
		BRA	DoneCBCLine
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D7.

CBCNegPlotRgnRuns
		TST.W	D7			;which type of run?
		BPL.S	CBCNegBlastPat1		;if ones, go blast it
		BEQ 	CBCNegPlotRHard1	;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D7,D0
		
		NEG.W	D0			;turn into longword count
		LSL.W	#2,D0			;times 4
		
		SUB.W	D0,A3		
		SUB.W	D0,A4			;skip over region
		SUB.W	D0,A5			;skip over destination

		ADD.W	D7,D2			;decrement count
		BMI	DoneCBCLine		;if done, skip
		
; now handle the second run

CBCNegPRRun2
		LEA	@0,A0			;plot the break longword
		BRA 	CBCNegPlotHardCommon	
@0
		MOVE.L	D7,D0			;which type of run?
 		BPL.S	CBCNegBlastPat2		;if ones, go blast it
		BEQ.S 	CBCNegPlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		
		SUB.W	D0,A3
		SUB.W	D0,A4			;skip over region
		SUB.W	D0,A5			;skip over destination

		TST.W	D2	
		BMI	DoneCBCLine		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA.S	CBCNegLastLoop

; Handle blasting out the first run

CBCNegBlastPat1
		MOVE.W	D7,D0			;get the size
		LEA	CBCNegPRRun2,A0
		BRA.S	CBCNegBlastPat
		
; Blast out the second run

CBCNegBlastPat2
		SWAP	D0			;use high word for 2nd run
		LEA	CBCNegLastLoop,A0
			
; Here's the unwound loop to blast the # of longwords in D0 out.

CBCNegBlastPat
		CMP.W	#8,D0			;8 left to do?
		BLT.S	CBCNegBlastFinishUp
		
		MOVE.W	D0,D1
		LSR	#3,D1
		SUBQ	#1,D1
CBCNegBlastLoop
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)	
		
		DBRA	D1,CBCNegBlastLoop
CBCNegBlastFinishUp
		MOVE.W	D0,D1
		AND	#7,D1
		EOR	#7,D1
		JMP	CBCNegFinishTable(D1.W*2)
CBCNegFinishTable
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)
		MOVE.L	-(A3),-(A5)		;15 total to finish up	

; all done with plotting so adjust the region pointer and count, then return

		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		SUB.W	D1,A4			;bump region ptr
		
		SUB.W	D0,D2
		BMI	DoneCBCLine
		
		JMP	(A0)

; handle the heterogenous plots between runs

CBCNegPlotRHard1
		LEA	CBCNegPRRun2,A0
		BRA.S	CBCNegPlotHardCommon	
CBCNegPlotRHard2
		LEA	CBCNegLastLoop,A0
CBCNegPlotHardCommon
		MOVE.L	-(A4),D1
		
		MOVE.L	-(A3),D0		;get  pattern
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	-(A5),D1		;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A5)			;deposit it

		SUBQ	#1,D2			;count it
		BMI	DoneCBCLine	
		
		JMP	(A0)


;******************************************************************************************
		
; InvertRgn case ($360) -- ie, invert clipped to region.  Use the standard region
; counting stuff

UseOld360
		LEARom	Old360,A1
		JMP	(A1)
		
InvertClip	
GoInvertClip	
		LEA	Inv1ClipOuter,A0
		MOVE.L	A0,MODECASE(A6)		;skip initial testing on return

		MOVEQ	#0,D4			;no runs yet
		SUB.L	A2,A2			;runs not valid
		
		MOVEQ	#-1,D5			;mask for comparing
Inv1ClipOuter
		
; first handle the left edge outside of the inner loop so we don't count it in the runs

		MOVE.L	D6,D0
		AND.L	(A4)+,D0
		EOR.L	D0,(A5)+

		SUBQ	#1,D2
		BMI.S	DoneInv1Line

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

		MOVE.L	A2,D0			;is it valid?
		BNE	Inv1PlotRgnRuns		;if so, go super fast
		
		ADDQ	#1,A2			;validate it for next time
		MOVEQ	#0,D4			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ 	Inv1FirstZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE	Inv1StartSecondRun	;if not, skip
		
		BRA.S	Inv1FirstOnes1
		
; here's the loop that counts and plots the first run of all ones

Inv1FirstOnes
		MOVE.L	(A4)+,D1
			
		CMP.L	D5,D1			;is it still all ones?
		BNE 	Inv1StartSecondRun	;if not, end the run
Inv1FirstOnes1	
		ADDQ.W	#1,D4			;bump the run count
		
		EOR.L	D6,(A5)+
		
		DBRA	D2,Inv1FirstOnes	;loop until we're done

; done with this scan line, so bump to the next

DoneInv1Line
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line of destination

; bump pattern index

		ADDQ	#1,D7
		AND.W	#15,D7
		MOVE.L	([EXPAT,A6],D7.W*4),D6	;bump the pattern

; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADD.W	VBUMP(A6),D0
		MOVE.W	D0,VERT(A6)

		CMP.W	LASTV(A6),D0		;all done?
		BEQ 	DonePatClip		;if so, use common exit

; create the region mask for the new scan line, and maintain the all one's flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	Inv1NewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	Inv1NewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	Inv1NewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	Inv1NewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	Inv1NewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BLT.S	Inv1NewRgn		;if so, go do it
							
		TST.L	DSTMASKBUF(A6)			;can we skip it?
		BEQ.S	Inv1SkipRgn		;if so, skip
Inv1NewRgn
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		

		SUB.L	A2,A2			;invalidate region counts
		
; set up registers and go handle the next line

Inv1SkipRgn
		MOVE.L	RGNBUF(A6),A4
		MOVE.L	DSTADDR(A6),A5
		MOVE.W	BUFSIZE(A6),D2

		BRA	Inv1ClipOuter

; here's the loop that counts and plots the first run of all zeros

Inv1FirstZero
		MOVE.L	(A4)+,D1
		BNE.S	Inv1StartSecondRun
Inv1FirstZero0		
		SUBQ.W	#1,D4			;decrement run count for zeros
		
		ADDQ	#4,A5
		DBRA	D2,Inv1FirstZero

		BRA.S	DoneInv1Line	

; the region mask is heterogenous, so plot the word and start the second run.

Inv1StartSecondRun	
		SWAP	D4
		
		AND.L	D6,D1			;mask it
		EOR.L	D1,(A5)+		;deposit it

		SUBQ	#1,D2
		BMI.S	DoneInv1SecondRun

; sample the region and case out for the 2nd time

		MOVE.L	(A4)+,D1		;fetch next word of region mask
		BEQ.S	Inv1stZero0		;if zero, go handle
		
		CMP.L	D5,D1			;all one's?
		BNE.S	Inv1StartLastRun	;if not, skip
	
		BRA.S	Inv1stOnes1
		
; here's the loop that counts and plots the second run of all ones

Inv1stOnes
		MOVE.L	(A4)+,D1
		
		CMP.L	D5,D1			;is it still all ones?
		BNE.S	Inv1StartLastRun	;if not, end the run
Inv1stOnes1	
		ADDQ.W	#1,D4			;bump the run count
		
		EOR.L	D6,(A5)+
		DBRA	D2,Inv1stOnes		;loop until we're done
DoneInv1SecondRun
		SWAP	D4
		BRA	DoneInv1Line		;all done
		
; here's the loop that counts the 2nd run of zeros

Inv1stZero
		MOVE.L	(A4)+,D1
		BNE.S	Inv1StartLastRun
Inv1stZero0		
		SUBQ.W	#1,D4
		ADDQ	#4,A5			;bump dest reg
		DBRA	D2,Inv1stZero		;loop until it changes

		BRA.S	DoneInv1SecondRun

; OK, we've accumulated two runs, so finish up the line without counting

Inv1StartLastRun
		SWAP	D4

		TST.L	D1	
		BEQ.S	Inv1LastZero
		BRA.S	Inv1LastLoopA
Inv1LastLoop
		MOVE.L	(A4)+,D1		;get region		
		BEQ.S	Inv1LastZero
Inv1LastLoopA		
		CMP.L	D5,D1
		BNE.S	Inv1LastHard
		
		EOR.L	D6,(A5)+		;plot it
		DBRA	D2,Inv1LastLoop
		
		BRA	DoneInv1Line
Inv1LastZero
		ADDQ	#4,A5
		DBRA	D2,Inv1LastLoop
		BRA	DoneInv1Line
Inv1LastHard
		AND.L	D6,D1
		EOR.L	D1,(A5)+		;deposit it

		DBRA	D2,Inv1LastLoop
		BRA	DoneInv1Line
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D4.

Inv1PlotRgnRuns
		TST.W	D4			;which type of run?
		BPL.S	Inv1BlastPat1		;if ones, go blast it
		BEQ 	Inv1PlotRHard1		;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D4,D0
		
		NEG.W	D0			;turn into longword count
		
		LSL.W	#2,D0			;times 4
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		ADD.W	D4,D2			;decrement count
		BMI	DoneInv1Line		;if done, skip
		
; now handle the second run

Inv1PRRun2
		LEA	@0,A0			;plot the break longword
		BRA 	Inv1PlotHardCommon	
@0
		MOVE.L	D4,D0			;which type of run?
 		BPL.S	Inv1BlastPat2		;if ones, go blast it
		BEQ.S 	Inv1PlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		ADD.W	D0,A4			;skip over region
		ADD.W	D0,A5			;skip over destination

		TST.W	D2	
		BMI	DoneInv1Line		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA.S	Inv1LastLoop

; Handle blasting out the first run

Inv1BlastPat1
		MOVE.W	D4,D0			;get the size
		LEA	Inv1PRRun2,A0
		BRA.S	Inv1BlastPat
		
; Blast out the second run

Inv1BlastPat2
		SWAP	D0			;use high word for 2nd run
		LEA	Inv1LastLoop,A0
			
; Here's the unwound loop to blast the # of longwords in D0 out.

Inv1BlastPat
		CMP.W	#8,D0			;8 left to do?
		BLT.S	Inv1BlastFinishUp
		
		MOVE.W	D0,D1
		LSR	#3,D1
		SUBQ	#1,D1
Inv1BlastLoop
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		
		DBRA	D1,Inv1BlastLoop
Inv1BlastFinishUp
		MOVE.W	D0,D1
		AND	#7,D1
		EOR	#7,D1
		
		JMP	Inv1FinishTable(D1.W*2)
Inv1FinishTable
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+
		EOR.L	D6,(A5)+

; all done with plotting so adjust the region pointer and count, then return

@0
		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A4			;bump region ptr
		
		SUB.W	D0,D2
		BMI	DoneInv1Line
Inv1BlastDone		
		JMP	(A0)

; handle the heterogenous plots between runs

Inv1PlotRHard1
		LEA	Inv1PRRun2,A0
		BRA.S	Inv1PlotHardCommon	
Inv1PlotRHard2
		LEA	Inv1LastLoop,A0
Inv1PlotHardCommon
		MOVE.L	D6,D1		
		AND.L	(A4)+,D1		
		EOR.L	D1,(A5)+		;deposit it

		SUBQ	#1,D2			;count it
		BMI	DoneInv1Line	
		
		JMP	(A0)		


;******************************************************************************************
		
		
; InvertHiliteClip ($372) speeds up region clipped hiliting; no more invert hack

UseOld372
		LEARom	Old372,A1
		JMP	(A1)
		
InvertHiliteClip	

		CMP.W	#8,SRCPIX+PIXELSIZE(A6)	;8 bits/pixel?
		BNE.S 	UseOld372		;if not, don't handle

		LEA	InvertHiOuter,A0
		MOVE.L	A0,MODECASE(A6)		;come back here
		
; if the background/hilite colors are black and white, we can expedite matters significantly

InvertHiOuter
		MOVE.L	D4,D7			;get hilite
		EOR.L	D5,D7			;compute toggle mask

; OK, here's the inner loop.  If the whole longword at the destination is background or
; hilite color, toggle it with the hilite mask.  Otherwise, we have to process it a
; byte at a time

InvertHInner
		MOVE.L	(A4)+,D1		;get the region mask
		BEQ.S	InvertEmpty		;if empty, skip
		
		MOVE.L	(A5),D0			;get the current destination
		CMP.L	D0,D4			;all hilite?
		BEQ.S	@0			;if so, it's easy

		CMP.L	D0,D5			;all background?
		BNE.S	InvertHPixels		;if not, it's harder
@0
		AND.L	D7,D1			;mask toggle with region
		EOR.L	D1,D0			;toggle dest
		MOVE.L	D0,(A5)+		;stuff it
NextInvertH
		DBRA	D2,InvertHInner		;loop till done

; all done with the scan line, so bump the appropriate pointers, and loop until done

BumpNextScanLine
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line
		
; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADD.W	VBUMP(A6),D0
		MOVE.W	D0,VERT(A6)

		CMP.W	LASTV(A6),D0		;all done?
		BEQ.S	DoneInvertSL		;if not, skip

; create the region mask for the new scan line

		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		

; set up registers and go handle the next line

		MOVE.L	SRCADDR(A6),A3
		MOVE.L	RGNADDR(A6),A4
		MOVE.L	DSTADDR(A6),A5
		MOVE.W	BUFSIZE(A6),D2
		
		MOVE.L	MODECASE(A6),A2
		JMP	(A2)
		
; all done so strip stack and return

DoneInvertSL		
		MOVE.L	SAVESTK2(A6),A7		
		RTS

; handle the case of the empty region by simply bumping the output pointer

InvertEmpty
		ADDQ	#4,A5			;bump ptr
		DBRA	D2,InvertHInner
		
		BRA.S	BumpNextScanLine
		
; handle the more difficult case of a non-homogenous line, which we must process a pixel
; at a time.  Destination value is in D0, region mask in D1.  Repeat in-line for 4 pixels

; try to do a word at a time, if we can


InvertHPixels
		CMP.W	D4,D0
		BEQ.S	IHBumpWord1
		
		CMP.W	D5,D0
		BEQ.S	IHBumpWord1
		
		CMP.B	D4,D0			;same as hilite?
		BEQ.S	IHBump1			;if so, let it through
		
		CMP.B	D5,D0			;same as background
		BEQ.S	IHBump1			;if so, let it through
		
		CLR.B	D1			;don't use this one
IHBump1
		ROR.L	#8,D0
		ROR.L	#8,D1
		
		CMP.B	D4,D0			;same as hilite?
		BEQ.S	IHBump2			;if so, let it through
		
		CMP.B	D5,D0			;same as background
		BEQ.S	IHBump2			;if so, let it through
		
		CLR.B	D1			;don't use this one
IHBump2
		ROR.L	#8,D0
		ROR.L	#8,D1
IHWord2
		CMP.W	D4,D0
		BEQ.S	IHBumpWord2
		
		CMP.W	D5,D0
		BEQ.S	IHBumpWord2
		
		CMP.B	D4,D0			;same as hilite?
		BEQ.S	IHBump3			;if so, let it through
		
		CMP.B	D5,D0			;same as background
		BEQ.S	IHBump3			;if so, let it through
		
		CLR.B	D1			;don't use this one
IHBump3
		ROR.L	#8,D0
		ROR.L	#8,D1
		
		CMP.B	D4,D0			;same as hilite?
		BEQ.S	IHBump4			;if so, let it through
		
		CMP.B	D5,D0			;same as background?
		BEQ.S	IHBump4			;if so, let it through
		
		CLR.B	D1			;don't use this one
IHBump4
		ROR.L	#8,D0
		ROR.L	#8,D1

; OK, now we can plot it

IHPlotIt
		AND.L	D7,D1			;mask toggle with region
		EOR.L	D1,D0			;toggle dest
		MOVE.L	D0,(A5)+		;stuff it

		DBRA	D2,InvertHInner		;loop till done
		BRA	BumpNextScanLine

; handle word hits

IHBumpWord1
		SWAP	D0
		SWAP	D1
		
		BRA.S	IHWord2
		
IHBumpWord2
		SWAP	D0
		SWAP	D1
		
		BRA.S	IHPlotIt
		
		
;******************************************************************************************
		

; CB1To8Clip ($373) is the clipped copyBits loop used in the 1 to 8 expansion blits,
; common in programs like HyperCard and Servant.  If it's the typical case we can handle
; (black and white, source 1 bit,dest 8 bits), expand on the fly, right onto the screen,
; for a pretty big gain.

; it really shouldn't be named CB1to8, as it's the routine used for any scaling or lookup
; blit.  We also optimize the 8-bit to 8-bit blits that require table lookup, and also
; handle the 8 to 1 case

UseOld373
		LEARom	Old373,A1
		JMP	(A1)
		
CB1To8Clip
		TST.L	D7				;toggle mode?
		BNE.S	UseOld373		;if so, don't handle
		
		MOVE.L	NUMER(A6),D0
		CMP.L	DENOM(A6),D0		;botRights the same?
		BNE.S	UseOld373		;if so, don't handle
		
		MOVE.L	MASKNUMER(A6),D0
		CMP.L	MASKDENOM(A6),D0		;how about topLefts?
		BNE.S	UseOld373		;if so, don't handle

		TST.L	DSTMASKBUF(A6)			;is mask a bitmap?
		BNE.S	UseOld373		;if so, don't handle!
	
		MOVE.W	SRCPIX+PIXELSIZE(A6),D0		;get source bits/pixel

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;destination 1 bits/pixel?
		BNE 	ChkDst1Bit		;if not, skip		
		
		SUBQ	#8,D0
		BEQ 	CB8to8Clip		;if source is 8 bits, go handle
		
		ADDQ	#7,D0			;is it one bit?
		BNE.S 	UseOld373		;if not, don't handle
		
Eight	EQU		$23344			; offset to the expand by eight, non-colormap routine

		CmpRA	Eight,ScaleCase(A6)	; is this doing a 1-8bit stretch?	<PB473 DAF	19Apr88>
		bne.s	UseOld373		; no, can't handle this one.			<PB471 BAL 18Apr88>

		CMP.L	#-1,FCOLOR(A6)	;foreground = black?	
		BNE.S	UseOld373
		
		TST.L	BCOLOR(A6)		;background = white?
		BNE.S	UseOld373
		
		cmp.l	scalebuf(a6),a3	;has src been advanced (i.e. dest < baseAddr)	<PB501 BAL/DVB 13Jun88>
		bne.s	UseOld373		;if so, don't handle							<PB501 BAL/DVB 13Jun88>

		MOVE.L	SRCROW(A6),D0
		SUB.L	D0,SRCADDR(A6)		;back up one line
		
		SUBQ	#1,BUFSIZE(A6)		;one less than they say
		
; its our case, so handle it.  Pick up the shifted source with a bit-field instruction,
; then use it to plot 8 longwords, indirecting a nibble at a time through an expansion
; table.   Special case the edges, so we can really zoom if the middle's region is all ones.

; A2 has the region mask, A4 has the destination; use A3 to hold the source.
; D7 holds the "OK to zoom" (region all ones) flag

CB1to8Outer
		MOVE.L	DSTALIGN(A6),D0
		ASR.L	#3,D0
		
		MOVEQ	#15,D3			;D3 has 4 bit mask
		MOVEQ	#-1,D6			;D6 has -1 for region compare		
		LEA	Expand1to8,A1
		
		MOVE.L	SRCADDR(A6),A3		;get source pointer
		
		MOVE.L	SRCALIGN(A6),D5		;get shift count	
		ADD.L	D0,D5
		
; OK, first do the left edge (one nybble worth)

		BFEXTU	(A3){D5:16},D4		;pick up next word of source
		ADDQ.L	#4,D5			;bump to next nibble
		ROL.W	#4,D4			;get next nibble
		
		MOVE.L	(A2)+,D1		;get region mask
		
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),D0		;get source longword
		AND.L	D1,D0
		
		NOT.L	D1			;flip mask
		AND.L	(A4),D1
		OR.L	D1,D0			;combine source and dest
		MOVE.L	D0,(A4)+		;stuff it

; OK, here's the loop that handles the middle, which is where all the action is		

		MOVE.W	BUFSIZE(A6),D2		;get destination count

		CMP.W	#4,D2			;four or less we can't optimize
		BLE 	FinishLastFew

; if we have a multiple of 4 left to do, don't do last 4

		MOVE.W	D2,D0
		AND	#3,D0
		BNE.S	@1
		
		SUBQ	#1,D2
@1		
		LSR	#2,D2			;do 4 longwords each iteration
		SUBQ	#1,D2

		TST.B	D7			;is region all ones?
		BNE	CB1to8SpLoop0		;if so, we can go super-fast
		
		ST	D7			;assume next like is special
CB1to8Loop
		BFEXTU	(A3){D5:16},D4		;pick up next word of source
		ADDQ	#2,A3			;bump it		
		BEQ	CB1to8AllZeros		;special case all zeros
CB1to8AltEntry
		ROL.W	#4,D4			;get high nibble first		
		
; OK, expand the low 4 bits in D4 into a longword, then plot it.  Fetch the region mask
; first, since it may not even be necessary

CB1to8Inner
		LEA	CB1to8Nib2,A5
		
		MOVE.L	(A2)+,D1		;get region mask
		
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),D0		;get source longword
		
		CMP.L	D6,D1			;mask all ones?
		BNE 	CB1to8HardPlot		;if not, plot it the hard way
		
		MOVE.L	D0,(A4)+		;plot the longword

; now plot the 2nd nibble

CB1to8Nib2
		LEA	CB1to8Nib3,A5
		
		ROL.W	#4,D4			;get next nybble
		
		MOVE.L	(A2)+,D1		;get region mask
		
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),D0		;get source longword
		
		CMP.L	D6,D1			;mask all ones?
		BNE.S  	CB1to8HardPlot	;if not, plot it the hard way
		
		MOVE.L	D0,(A4)+		;plot the longword

; now plot the 3rd nibble

CB1to8Nib3
		LEA	CB1to8Nib4,A5		
		ROL.W	#4,D4			;get next nybble
		
		MOVE.L	(A2)+,D1		;get region mask
		
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),D0	;get source longword
		
		CMP.L	D6,D1			;mask all ones?
		BNE.S	CB1to8HardPlot	;if not, plot it the hard way
		
		MOVE.L	D0,(A4)+		;plot the longword

; now plot the last nibble

CB1to8Nib4
		LEA	CB1to8NibBot,A5
		
		ROL.W	#4,D4			;get next nybble
		
		MOVE.L	(A2)+,D1		;get region mask
		
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),D0		;get source longword
		
		CMP.L	D6,D1			;mask all ones?
		BNE.S 	CB1to8HardPlot		;if not, plot it the hard way
		
		MOVE.L	D0,(A4)+		;plot the longword
CB1to8NibBot		
		DBRA	D2,CB1to8Loop		;loop until done		

; clean up the last 0 to 3 nibbles; 4 remaining handled specially

FinishLastFew
		BFEXTU	(A3){D5:16},D4		;pick up last word of source
		LEA	BotFin1to8Loop,A5		
		MOVE.W	BUFSIZE(A6),D2		;get the number left to do
		BEQ 	CB1to8NextLine		;if zero, we're done
		
		AND.W	#3,D2			;0 to 3 only	
		BNE.S	BotFin1to8Loop

		MOVEQ	#3,D2			;4 to do
TopFin1to8Loop
		ROL.W	#4,D4

		MOVE.L	(A2)+,D1		;get region mask
		
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),D0		;get source longword
		
		CMP.L	D6,D1			;mask all ones?
		BNE.S 	CB1to8HPNoInval		;if not, plot it the hard way (no edge)
		
		MOVE.L	D0,(A4)+		;plot the longword
BotFin1to8Loop		
		DBRA	D2,TopFin1to8Loop
		BRA.S	CB1to8NextLine
				
; handle the case where the region mask is all zeros

CB1to8NoPlot
		ADDQ.L	#4,A4			;bump dest ptr
		JMP	(A5)			;advance to next one
		
; handle the more difficult case of a heterogenous region mask

CB1to8HardPlot
		MOVEQ	#0,D7			;not all ones
CB1to8HPNoInval		
		TST.L	D1
		BEQ.S	CB1to8NoPlot
		
		AND.L	D1,D0
		
		NOT.L	D1			;flip mask
		AND.L	(A4),D1
		OR.L	D1,D0			;combine source and dest
		MOVE.L	D0,(A4)+		;stuff it
		JMP	(A5)		

; to speed things up, we special case words of all zero and blast 4 long words of zero out as
; fast as we can, without having to do any lookups.

CB1to8AllZeros
		MOVE.L	(A2)+,D1		;get region mask
		BEQ.S	CBZEmpty1		;if all zeros, skip
		
		CMP.L	D6,D1			;all ones?
		BNE.S	CBZBIC1			;if not, skip
		
		CLR.L	(A4)+			;plot the zeros
CBZLong2		
		MOVE.L	(A2)+,D1		;get region mask
		BEQ.S	CBZEmpty2		;if all zeros, skip
		
		CMP.L	D6,D1			;all ones?
		BNE.S	CBZBIC2			;if not, skip
		
		CLR.L	(A4)+			;plot the zeros
CBZLong3		
		MOVE.L	(A2)+,D1		;get region mask
		BEQ.S	CBZEmpty3		;if all zeros, skip
		
		CMP.L	D6,D1			;all ones?
		BNE.S	CBZBIC3			;if not, skip
		
		CLR.L	(A4)+			;plot the zeros
CBZLong4		
		MOVE.L	(A2)+,D1		;get region mask
		BEQ.S	CBZEmpty4		;if all zeros, skip
		
		CMP.L	D6,D1			;all ones?
		BNE.S	CBZBIC4			;if not, skip
		
		CLR.L	(A4)+			;plot the zeros
		BRA.S	CB1to8NibBot	;dive back in		
CBZEmpty1
		MOVEQ	#0,D7
		ADDQ	#4,A4
		BRA.S	CBZLong2
CBZEmpty2
		MOVEQ	#0,D7
		ADDQ	#4,A4
		BRA.S	CBZLong3
CBZEmpty3
		MOVEQ	#0,D7
		ADDQ	#4,A4
		BRA.S	CBZLong4
CBZEmpty4
		MOVEQ	#0,D7
		ADDQ	#4,A4
		BRA	CB1to8NibBot
CBZBIC1
		MOVEQ	#0,D7
		NOT.L	D1
		AND.L	D1,(A4)+
		BRA.S	CBZLong2
CBZBIC2
		MOVEQ	#0,D7
		NOT.L	D1
		AND.L	D1,(A4)+
		BRA.S	CBZLong3
CBZBIC3
		MOVEQ	#0,D7
		NOT.L	D1
		AND.L	D1,(A4)+
		BRA.S	CBZLong4
CBZBIC4
		MOVEQ	#0,D7
		NOT.L	D1
		AND.L	D1,(A4)+
		BRA 	CB1to8NibBot
		
		
; all done with this line, so bump the pointers and loop until done 

CB1to8NextLine		
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line of destination
		
		MOVE.L	SRCROW(A6),D0
		ADD.L	D0,SRCADDR(A6)		;bump to next line of source
		
; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADDQ	#1,D0
		MOVE.W	D0,VERT(A6)

		CMP.W	MINRECT+BOTTOM(A6),D0		;all done?
		BEQ.S	Done1To8Clip		;if so, skip

; create the region mask for the new scan line, and maintain the all one's flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB1to8NewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	CB1to8NewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB1to8NewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	CB1to8NewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB1to8NewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BGE.S	Skip1to8Rgn		;if not, skip
CB1to8NewRgn
		MOVEQ	#0,D7			;invalidate region all ones flag
		
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		

; set up registers and go handle the next line

Skip1to8Rgn
		MOVE.L	RGNBUF(A6),A2
		MOVE.L	DSTADDR(A6),A4
		
		BRA	CB1to8Outer		;go process next line
		
; all done so strip stack and return

Done1To8Clip		
		MOVE.L	SAVEA5(A6),A5
		
		TST.B	CRSRFLAG(A6)
		BEQ.S	@0
		
		JSR	([$0F4C])				;SHOWCURSOR
@0
		BSET	#7,HILITEMODE		;$938
	
		MOVE.L	SAVESTK(A6),A7
		MOVEM.L	(SP)+,D0-D7/A1-A5
		UNLK	A6
		RTD	#44

; here's where we go when we've detected that region masking isn't necessary, so we can really
; blast things 4 longwords at a time

CB1to8SpLoop0
		MOVE.W	D2,D7			;remember the count
		
CB1to8SpLoop
		BFEXTU	(A3){D5:16},D4		;pick up next word of source
		ADDQ	#2,A3			;bump it		
		BEQ.S	CB1to8SpAllZeros	;special case all zeros

		CMP.W	D4,D6			;all ones?
		BEQ.S	CB1to8SpAllOnes
		
		ROL.W	#4,D4			;get first nibble
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),(A4)+	;plot expanded longword

		ROL.W	#4,D4			;get next nibble				
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),(A4)+	;plot expanded longword

		ROL.W	#4,D4			;get next nibble			
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),(A4)+	;plot expanded longword

		ROL.W	#4,D4			;get next nibble				
		MOVE.W	D4,D0			;get low 4 bits
		AND.W	D3,D0
		MOVE.L	0(A1,D0.W*4),(A4)+	;plot expanded longword

BotCB1to8SpLoop
		DBRA	D2,CB1to8SpLoop

; finish up the special case by adjusting A2 and diving back into common code

Finish1to8Sp
		ADDQ	#1,D7			;add one for real count
		LSL.W	#4,D7			;4 longs (16 bytes) per iteration
		ADD.W	D7,A2			;bump region pointer
		BRA	FinishLastFew		;finish the last few
		
; handle the case when the source word is all zero and there's no region clipping -- we
; can go as fast as we can.

CB1to8SpAllZeros
		CLR.L	(A4)+
		CLR.L	(A4)+
		CLR.L	(A4)+
		CLR.L	(A4)+
		
		BRA.S	BotCB1to8SpLoop

CB1to8SpAllOnes
		MOVE.L	D6,(A4)+
		MOVE.L	D6,(A4)+
		MOVE.L	D6,(A4)+
		MOVE.L	D6,(A4)+
		
		BRA.S	BotCB1to8SpLoop
		
		
; here is the nybble to longword expansion table

		ALIGN	4
Expand1To8
		DC.L	$00000000,$000000FF,$0000FF00,$0000FFFF
		DC.L	$00FF0000,$00FF00FF,$00FFFF00,$00FFFFFF
		DC.L	$FF000000,$FF0000FF,$FF00FF00,$FF00FFFF
		DC.L	$FFFF0000,$FFFF00FF,$FFFFFF00,$FFFFFFFF
	
;******************************************************************************************

CB8to81st0
		ADDQ	#4,A3			;bump source ptr
		ADDQ	#4,A4			;bump dest ptr
		BRA 	CB8to8Middle	


; Handler for the 8 to 8 copyBits case (with mapping).  The basic strategy is the usual
; region counting, with the added twist of a single element cache for the longword mapping,
; using A1 to hold the pre-map and D7 to hold the post-mapped values.

CB8to8Clip
		TST.L	MASKBITS(A6)			;should we handle it?
		BNE	UseOld373		;if not, skip
	
		MOVE.L	SRCROW(A6),D0
		SUB.L	D0,SRCADDR(A6)		;back up one line

		SUBQ	#1,BUFSIZE(A6)		;one less than they say
		MOVEQ	#-1,D6			;D6 has -1 for region compare		

		MOVEQ	#0,D4
		MOVEQ	#0,D3			;init region counting regs
		
		SUB.L	A1,A1
		SUBQ.L	#1,A1			;all ones for initial
		MOVEQ	#-1,D7			;map cache values
CB8to8Outer	
		MOVE.L	RGNBUF(A6),A2
		MOVE.L	SRCADDR(A6),A3		;get source pointer
		MOVE.L	DSTADDR(A6),A4		;get destptr	
		MOVE.L	SCALETBL(A6),A5		;get mapping table

; offset source pointer according to bit offsets

		MOVE.L	DSTALIGN(A6),D0		;get shift count			
		ASR.L	#3,D0
		MOVE.L	SRCALIGN(A6),D1
		ASR.L	#3,D1
		ADD.L	D1,D0
		ADD.L	D0,A3			;offset source ptr
		
; OK, first do the left edge

		MOVE.W	BUFSIZE(A6),D2		;get the count
		
		MOVEQ	#0,D5
		
		MOVE.L	(A2)+,D1		;get region mask	
		BEQ.S	CB8to81st0		;if zero, handle it
		
; fetch the 1st source longword and map it through the table pointed to by A5

		MOVE.L	(A3)+,D0		;get source longword
		MOVE.L	D0,A1			;remember it

		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
	
		MOVE.L	D0,D7			;remember result of mapping
		
; plot it using the region mask

		AND.L	D1,D0		
		NOT.L	D1			;flip mask
		AND.L	(A4),D1
		OR.L	D1,D0			;combine source and dest
		MOVE.L	D0,(A4)+		;stuff it

		SUBQ	#1,D2
		BMI.S	CB8to8NextLine

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

CB8to8Middle
		TST.W	D4			;is it valid?
		BNE	V8to8PlotRgnRuns	;if so, go super fast
		
		MOVEQ	#-1,D4			;validate it for next time
		MOVEQ	#0,D3			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	(A2)+,D1		;fetch next word of region mask
		BEQ 	V8to8FirstZero0		;if zero, go handle
		
		CMP.L	D6,D1			;all one's?
		BNE	V8to8StartSecondRun	;if not, skip
		
		BRA.S	V8to8FirstOnes1
		
; here's the loop that counts and plots the first run of all ones

V8to8FirstOnes
		MOVE.L	(A2)+,D1
		
		CMP.L	D6,D1			;is it still all ones?
		BNE 	V8to8StartSecondRun	;if not, end the run
V8to8FirstOnes1	
		ADDQ.W	#1,D3			;bump the run count
		
		MOVE.L	(A3)+,D0		;fetch from source
		CMP.L	D0,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D0
		BRA.S	@1
@0
		MOVE.L	D0,A1
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
		MOVE.L	D0,D7
@1
		MOVE.L	D0,(A4)+		;store at destination		
		
		DBRA	D2,V8to8FirstOnes	;loop until we're done

; OK, all done with this line, so bump the pointers and loop until done

CB8to8NextLine
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line of destination
		
		MOVE.L	SRCROW(A6),D0
		ADD.L	D0,SRCADDR(A6)		;bump to next line of source
		
; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADDQ	#1,D0
		MOVE.W	D0,VERT(A6)

		CMP.W	MINRECT+BOTTOM(A6),D0		;all done?
		BEQ 	Done1To8Clip		;if so, use common exit

; create the region mask for the new scan line, and maintain the all ones flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB8to8NewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	CB8to8NewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB8to8NewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	CB8to8NewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB8to8NewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BGE 	CB8to8Outer		;if not, skip
CB8to8NewRgn
		MOVEQ	#0,D4			;invalidate region all ones flag
	
		MOVE.L	A1,-(SP)
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		
		MOVE.L	(SP)+,A1
		
; go handle the next line

		BRA	CB8to8Outer		;go process next line

Fin8to8Zeros
		ADDQ	#4,A4
		BRA.S	CB8to8NextLine
		
; here's the loop that counts and plots the first run of all zeros

V8to8FirstZero
		MOVE.L	(A2)+,D1
		BNE.S	V8to8StartSecondRun
V8to8FirstZero0		
		SUBQ.W	#1,D3			;decrement run count for zeros
		
		ADDQ	#4,A3
		ADDQ	#4,A4
		DBRA	D2,V8to8FirstZero

		BRA.S	CB8to8NextLine	

; the region mask is heterogenous, so plot the word and start the second run.

V8to8StartSecondRun	
		SWAP	D3
		
		MOVE.L	(A3)+,D0		;fetch from source
		CMP.L	D0,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D0
		BRA.S	@1
@0
		MOVE.L	D0,A1
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
		MOVE.L	D0,D7
@1
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A4),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A4)+		;deposit it

		SUBQ	#1,D2
		BMI.S	Done8to8SecondRun

; sample the region and case out for the 2nd time

		MOVE.L	(A2)+,D1		;fetch next word of region mask
		BEQ.S	V8to8Zero0		;if zero, go handle
		
		CMP.L	D6,D1			;all one's?
		BNE.S	V8to8StartLastRun	;if not, skip
	
		BRA.S	V8to8Ones1
		
; here's the loop that counts and plots the second run of all ones

V8to8Ones
		MOVE.L	(A2)+,D1
		
		CMP.L	D6,D1			;is it still all ones?
		BNE.S	V8to8StartLastRun	;if not, end the run
V8to8Ones1	
		ADDQ.W	#1,D3			;bump the run count

		MOVE.L	(A3)+,D0		;fetch from source
		CMP.L	D0,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D0
		BRA.S	@1
@0
		MOVE.L	D0,A1
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
		MOVE.L	D0,D7
@1
		MOVE.L	D0,(A4)+		;store at destination		

		DBRA	D2,V8to8Ones		;loop until we're done
Done8to8SecondRun
		SWAP	D3
		BRA	CB8to8NextLine		;all done
		
; here's the loop that counts the 2nd run of zeros

V8to8Zero
		MOVE.L	(A2)+,D1
		BNE.S	V8to8StartLastRun
V8to8Zero0		
		SUBQ.W	#1,D3
		
		ADDQ	#4,A3
		ADDQ	#4,A4			;bump dest reg
		
		DBRA	D2,V8to8Zero		;loop until it changes

		BRA.S	Done8to8SecondRun

; OK, we've accumulated two runs, so finish up the line without counting

V8to8StartLastRun
		SWAP	D3

		TST.L	D1	
		BEQ.S	V8to8LastZero
		BRA.S	V8to8LastLoopA
V8to8LastLoop
		MOVE.L	(A2)+,D1		;get region		
		BEQ.S	V8to8LastZero
V8to8LastLoopA		
		CMP.L	D6,D1
		BNE.S	V8to8LastHard
		
		MOVE.L	(A3)+,D0		;fetch from source
		CMP.L	D0,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D0
		BRA.S	@1
@0
		MOVE.L	D0,A1
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
		MOVE.L	D0,D7
@1
		MOVE.L	D0,(A4)+		;store at destination		
		DBRA	D2,V8to8LastLoop
		
		BRA	CB8to8NextLine
V8to8LastZero
		ADDQ	#4,A4
		ADDQ	#4,A3
		DBRA	D2,V8to8LastLoop
		BRA	CB8to8NextLine
V8to8LastHard
		MOVE.L	(A3)+,D0		;fetch from source
		CMP.L	D0,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D0
		BRA.S	@1
@0
		MOVE.L	D0,A1
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
		MOVE.L	D0,D7
@1
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A4),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A4)+		;deposit it

		DBRA	D2,V8to8LastLoop
		BRA	CB8to8NextLine
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D3.

V8to8PlotRgnRuns
		TST.W	D3			;which type of run?
		BPL.S	V8to8BlastPat1		;if ones, go blast it
		BEQ 	V8to8PlotRHard1		;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D3,D0
		
		NEG.W	D0			;turn into longword count
		LSL.W	#2,D0			;times 4
		
		ADD.W	D0,A2			;skip over region
		ADD.W	D0,A3			;skip over source
		ADD.W	D0,A4			;skip over destination

		ADD.W	D3,D2			;decrement count
		BMI	CB8to8NextLine		;if done, skip
		
; now handle the second run

V8to8PRRun2
		LEA	@0,A0			;plot the break longword
		BRA 	V8to8PlotHardCommon	
@0
		MOVE.L	D3,D0			;which type of run?
 		BPL.S	V8to8BlastPat2		;if ones, go blast it
		BEQ.S 	V8to8PlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		
		ADD.W	D0,A2			;skip over region
		ADD.W	D0,A3			;skip over source
		ADD.W	D0,A4			;skip over destination

		TST.W	D2	
		BMI	CB8to8NextLine		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA	V8to8LastLoop

; Handle blasting out the first run

V8to8BlastPat1
		MOVE.W	D3,D0			;get the size
		
		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A2			;bump region ptr
		SUB.W	D0,D2
				
		LEA	V8to8PRRun2,A0
		BRA.S	V8to8BlastPatBot
		
; Blast out the second run

V8to8BlastPat2
		SWAP	D0			;use high word for 2nd run

		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A2			;bump region ptr
		SUB.W	D0,D2
		
		LEA	V8to8LastLoop,A0
		BRA.S	V8to8BlastPatBot
V8to8BlastPat
		MOVE.L	(A3)+,D1		;fetch from source
		CMP.L	D1,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D1
		BRA.S	@1
@0
		MOVE.L	D1,A1
		MOVE.B	D1,D5
		MOVE.B	1(A5,D5.W*2),D1		;map 1st byte
		ROL.L	#8,D1	
		
		MOVE.B	D1,D5
		MOVE.B	1(A5,D5.W*2),D1		;map 2nd byte
		ROL.L	#8,D1
		
		MOVE.B	D1,D5
		MOVE.B	1(A5,D5.W*2),D1		;map 3rd byte
		ROL.L	#8,D1
		
		MOVE.B	D1,D5
		MOVE.B	1(A5,D5.W*2),D1		;map 4th byte
		ROL.L	#8,D1
		MOVE.L	D1,D7
@1
		MOVE.L	D1,(A4)+		;store at destination		
V8to8BlastPatBot		
		DBRA	D0,V8to8BlastPat
		
; all done with plotting run of ones

		TST.W	D2
		BMI	CB8to8NextLine
		
		JMP	(A0)
		
; handle the heterogenous plots between runs

V8to8PlotRHard1
		LEA	V8to8PRRun2,A0
		BRA.S	V8to8PlotHardCommon	
V8to8PlotRHard2
		LEA	V8to8LastLoop,A0
V8to8PlotHardCommon
		MOVE.L	(A2)+,D1		;get region mask

		MOVE.L	(A3)+,D0		;fetch from source
		CMP.L	D0,A1			;same as before?
		BNE.S	@0
		
		MOVE.L	D7,D0
		BRA.S	@1
@0
		MOVE.L	D0,A1
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 1st byte
		ROL.L	#8,D0	
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 2nd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 3rd byte
		ROL.L	#8,D0
		
		MOVE.B	D0,D5
		MOVE.B	1(A5,D5.W*2),D0		;map 4th byte
		ROL.L	#8,D0
		MOVE.L	D0,D7
@1
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A4),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A4)+		;deposit it

		SUBQ	#1,D2			;count it
		BMI	CB8to8NextLine	
		
		JMP	(A0)



;******************************************************************************************


; Handler for the 8 to 1 copyBits case (mapped ).  The basic strategy is the usual
; region counting, with the added twist of a single element cache for the longword mapping,
; using A1 to hold the pre-map and D7 to hold the post-mapped values.


CB8to11st0
		ADD.W	#32,A3			;bump source ptr
		ADDQ	#4,A4			;bump dest ptr
		BRA.S 	CB8to1Middle	

ChkDst1Bit
		CMP.W	#1,DSTPIX+PIXELSIZE(A6)		;destination 8 bits/pixel?
		BNE 	UseOld373		;if not, can't handle
		
		SUBQ	#8,D0			;source 8 bits/pixel?
		BNE	UseOld373		;if not, can't handle		
CB8to1Clip
		TST.L	MASKBITS(A6)			;should we handle it?
		BNE	UseOld373		;if not, skip
	
		MOVE.L	SRCROW(A6),D0
		SUB.L	D0,SRCADDR(A6)		;back up one line

		SUBQ	#1,BUFSIZE(A6)		;one less than they say
		MOVEQ	#-1,D6			;D6 has -1 for region compare		

		MOVEQ	#0,D4
		MOVEQ	#0,D3			;init region counting regs
		
		SUB.L	A1,A1
		SUBQ.L	#1,A1			;all ones for initial
		MOVEQ	#-1,D7			;map cache values
CB8to1Outer	
		MOVE.L	RGNBUF(A6),A2
		MOVE.L	SRCADDR(A6),A3		;get source pointer
		MOVE.L	DSTADDR(A6),A4		;get destptr	
		MOVE.L	SCALETBL(A6),A5		;get mapping table

; offset source pointer according to bit offsets

		MOVE.L	DSTALIGN(A6),D0		;get shift count			
		MOVE.L	SRCALIGN(A6),D1
		ASR.L	#3,D1
		ADD.L	D1,D0
		ADD.L	D0,A3			;offset source ptr
		
; OK, first do the left edge

		MOVE.W	BUFSIZE(A6),D2		;get the count
		
		MOVEQ	#0,D5
		
		MOVE.L	(A2)+,D1		;get region mask	
		BEQ.S	CB8to11st0		;if zero, handle it
		
; fetch the 1st source longword and map it through the table pointed to by A5

		BSR	Map8to1
		
; plot it using the region mask

		AND.L	D1,D0		
		NOT.L	D1			;flip mask
		AND.L	(A4),D1
		OR.L	D1,D0			;combine source and dest
		MOVE.L	D0,(A4)+		;stuff it

		SUBQ	#1,D2
		BMI.S	CB8to1NextLine

; if the region runs in D4 are still valid, we can use special code to really plot super
; fast.

CB8to1Middle
		TST.W	D4			;is it valid?
		BNE	V8to1PlotRgnRuns	;if so, go super fast
		
		MOVEQ	#-1,D4			;validate it for next time
		MOVEQ	#0,D3			;zero the run count
		
; see what the next region longword is.  Go to three different loops depending on whether
; the region is all ones, zeros or both

		MOVE.L	(A2)+,D1		;fetch next word of region mask
		BEQ.S 	V8to1FirstZero0		;if zero, go handle
		
		CMP.L	D6,D1			;all one's?
		BNE	V8to1StartSecondRun	;if not, skip
		
		BRA.S	V8to1FirstOnes1
		
; here's the loop that counts and plots the first run of all ones

V8to1FirstOnes
		MOVE.L	(A2)+,D1
		
		CMP.L	D6,D1			;is it still all ones?
		BNE.S 	V8to1StartSecondRun	;if not, end the run
V8to1FirstOnes1	
		ADDQ.W	#1,D3			;bump the run count
		
		BSR	Map8to1
		MOVE.L	D0,(A4)+		;store at destination		
		
		DBRA	D2,V8to1FirstOnes	;loop until we're done

; OK, all done with this line, so bump the pointers and loop until done

CB8to1NextLine
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)		;bump to next line of destination
		
		MOVE.L	SRCROW(A6),D0
		ADD.L	D0,SRCADDR(A6)		;bump to next line of source
		
; bump line count and see if we're done

		MOVE.W	VERT(A6),D0
		ADDQ	#1,D0
		MOVE.W	D0,VERT(A6)

		CMP.W	MINRECT+BOTTOM(A6),D0	;all done?
		BEQ 	Done1To8Clip		;if so, use common exit

; create the region mask for the new scan line, and maintain the all ones flag

		CMP.W	STATEB+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB8to1NewRgn		;if so, go do it
		
		CMP.W	STATEB+THISV(A6),D0		;need to rebuild?
		BLT.S	CB8to1NewRgn		;if so, go do it

		CMP.W	STATEC+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB8to1NewRgn		;if so, go do it
		
		CMP.W	STATEC+THISV(A6),D0		;need to rebuild?
		BLT.S	CB8to1NewRgn		;if so, go do it

		CMP.W	STATEA+NEXTV(A6),D0		;rebuild the region?
		BGE.S	CB8to1NewRgn		;if so, go do it
		
		CMP.W	STATEA+THISV(A6),D0		;need to rebuild?
		BGE 	CB8to1Outer		;if so, go do it
CB8to1NewRgn
		MOVEQ	#0,D4			;invalidate region all ones flag
	
		MOVE.L	A1,-(SP)
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;make new region mask		
		MOVE.L	(SP)+,A1
		
; go handle the next line

		BRA	CB8to1Outer		;go process next line

Fin8to1Zeros
		ADDQ	#4,A4
		BRA.S	CB8to1NextLine
		
; here's the loop that counts and plots the first run of all zeros

V8to1FirstZero
		MOVE.L	(A2)+,D1
		BNE.S	V8to1StartSecondRun
V8to1FirstZero0		
		SUBQ.W	#1,D3			;decrement run count for zeros
		
		ADD.W	#32,A3
		ADDQ	#4,A4
		DBRA	D2,V8to1FirstZero

		BRA.S	CB8to1NextLine	

; the region mask is heterogenous, so plot the word and start the second run.

V8to1StartSecondRun	
		SWAP	D3
		
		BSR	Map8to1
		
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A4),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A4)+		;deposit it

		SUBQ	#1,D2
		BMI.S	Done8to1SecondRun

; sample the region and case out for the 2nd time

		MOVE.L	(A2)+,D1		;fetch next word of region mask
		BEQ.S	V8to1Zero0		;if zero, go handle
		
		CMP.L	D6,D1			;all one's?
		BNE.S	V8to1StartLastRun	;if not, skip
	
		BRA.S	V8to1Ones1
		
; here's the loop that counts and plots the second run of all ones

V8to1Ones
		MOVE.L	(A2)+,D1
		
		CMP.L	D6,D1			;is it still all ones?
		BNE.S	V8to1StartLastRun	;if not, end the run
V8to1Ones1	
		ADDQ.W	#1,D3			;bump the run count
		BSR	Map8to1			;fetch and map it
		MOVE.L	D0,(A4)+		;store at destination		

		DBRA	D2,V8to1Ones		;loop until we're done
Done8to1SecondRun
		SWAP	D3
		BRA	CB8to1NextLine		;all done
		
; here's the loop that counts the 2nd run of zeros

V8to1Zero
		MOVE.L	(A2)+,D1
		BNE.S	V8to1StartLastRun
V8to1Zero0		
		SUBQ.W	#1,D3
		
		ADD.W	#32,A3
		ADDQ	#4,A4			;bump dest reg
		
		DBRA	D2,V8to1Zero		;loop until it changes

		BRA.S	Done8to1SecondRun

; OK, we've accumulated two runs, so finish up the line without counting

V8to1StartLastRun
		SWAP	D3

		TST.L	D1	
		BEQ.S	V8to1LastZero
		BRA.S	V8to1LastLoopA
V8to1LastLoop
		MOVE.L	(A2)+,D1		;get region		
		BEQ.S	V8to1LastZero
V8to1LastLoopA		
		CMP.L	D6,D1
		BNE.S	V8to1LastHard

		BSR	Map8to1
		
		MOVE.L	D0,(A4)+		;store at destination		
		DBRA	D2,V8to1LastLoop
		
		BRA	CB8to1NextLine
V8to1LastZero
		ADDQ	#4,A4
		ADD.W	#32,A3
		DBRA	D2,V8to1LastLoop
		BRA	CB8to1NextLine
V8to1LastHard
		BSR	Map8to1
		
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A4),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A4)+		;deposit it

		DBRA	D2,V8to1LastLoop
		BRA	CB8to1NextLine
		
; Here's where we have the ultra fast plotting by interpreting the 2 region runs in D3.

V8to1PlotRgnRuns
		TST.W	D3			;which type of run?
		BPL.S	V8to1BlastPat1		;if ones, go blast it
		BEQ.S 	V8to1PlotRHard1		;if zero, plot one slowly, then plot 2nd run

; it's negative, so just skip over 4 times the count

		MOVE.W	D3,D0
		
		NEG.W	D0			;turn into longword count
		LSL.W	#2,D0			;times 4
		
		ADD.W	D0,A2			;skip over region
		ADD.W	D0,A4			;skip over destination
		LSL	#3,D0			;times 8 for source
		ADD.W	D0,A3			;skip over source

		ADD.W	D3,D2			;decrement count
		BMI	CB8to1NextLine		;if done, skip
		
; now handle the second run

V8to1PRRun2
		LEA	@0,A0			;plot the break longword
		BRA.S	V8to1PlotHardCommon	
@0
		MOVE.L	D3,D0			;which type of run?
 		BPL.S	V8to1BlastPat2		;if ones, go blast it
		BEQ.S 	V8to1PlotRHard2

; it's negative, so we can skip over like above
		
		SWAP	D0
		NEG.W	D0			;turn into longword count
		SUB.W	D0,D2			;decrement count	
		
		LSL.W	#2,D0			;times 4
		
		ADD.W	D0,A2			;skip over region
		ADD.W	D0,A4			;skip over destination
		LSL	#3,D0			;times 8 for source
		ADD.W	D0,A3			;skip over source

		TST.W	D2	
		BMI	CB8to1NextLine		;if done, skip
		
; we've interpreted both runs, so finish up using common code

		BRA.S	V8to1LastLoop

; Handle blasting out the first run

V8to1BlastPat1
		MOVE.W	D3,D0			;get the size
		
		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A2			;bump region ptr
		SUB.W	D0,D2

		MOVE.W	D0,D1				
		LEA	V8to1PRRun2,A0
		BRA.S	V8to1BlastPatBot
		
; Blast out the second run

V8to1BlastPat2
		SWAP	D0			;use high word for 2nd run

		MOVE.W	D0,D1
		LSL	#2,D1			;times 4
		ADD.W	D1,A2			;bump region ptr
		SUB.W	D0,D2
	
		MOVE.W	D0,D1
		LEA	V8to1LastLoop,A0
		BRA.S	V8to1BlastPatBot
V8to1BlastPat
		BSR.S	Map8to1
		MOVE.L	D0,(A4)+		;store at destination		
V8to1BlastPatBot		
		DBRA	D1,V8to1BlastPat
		
; all done with plotting run of ones

		TST.W	D2
		BMI	CB8to1NextLine
		
		JMP	(A0)
		
; handle the heterogenous plots between runs

V8to1PlotRHard1
		LEA	V8to1PRRun2,A0
		BRA.S	V8to1PlotHardCommon	
V8to1PlotRHard2
		LEA	V8to1LastLoop,A0
V8to1PlotHardCommon
		MOVE.L	(A2)+,D1		;get region mask

		BSR.S	Map8to1
		
		AND.L	D1,D0			;mask it
		NOT.L	D1			;flip mask
		AND.L	(A4),D1			;combine with source
		OR.L	D1,D0			;form dest longword
		MOVE.L	D0,(A4)+		;deposit it

		SUBQ	#1,D2			;count it
		BMI	CB8to1NextLine	
		
		JMP	(A0)

; Map8to1 is the routine that takes 8 longwords from the source (pointed to by A3)
; and returns the single longword result in D0.  

Map8to1
		MOVEQ	#0,D0			;start dest at 0
		TST.W	(A5)			;check mapping for color 0		<d√b> 12Jul88
		BEQ.s	@a				;if white->white, ok			<d√b> 12Jul88
		MOVEQ	#$F,D0			;else, its black				<d√b> 12Jul88
@a								;								<d√b> 12Jul88

		MOVEQ	#7,D7			;8 longs to process
		SUB.L	A1,A1			;set last source to 0
Map8to1Loop
		MOVE.L	(A3)+,D6		;fetch from source
		CMP.L	A1,D6			;same as last time?
		BEQ.S	Map8to1Fast		;if so, we've got the
	
		MOVE.L	D6,A1			;remember for next time

		ROL.L	#8,D6			;get next pixel
		MOVE.B	D6,D5			;get current pixel
		MOVE.B	1(A5,D5.W*2),D5		;get mapped bit
		LSR.W	#1,D5			;get bit into carry
		ROXL.L	#1,D0			;shift it in
		
		ROL.L	#8,D6			;get next pixel
		MOVE.B	D6,D5			;get current pixel
		MOVE.B	1(A5,D5.W*2),D5		;get mapped bit
		LSR.W	#1,D5			;get bit into carry
		ROXL.L	#1,D0			;shift it in	
		
		ROL.L	#8,D6			;get next pixel
		MOVE.B	D6,D5			;get current pixel
		MOVE.B	1(A5,D5.W*2),D5		;get mapped bit
		LSR.W	#1,D5			;get bit into carry
		ROXL.L	#1,D0			;shift it in
			
		ROL.L	#8,D6			;get next pixel
		MOVE.B	D6,D5			;get current pixel
		MOVE.B	1(A5,D5.W*2),D5		;get mapped bit
		LSR.W	#1,D5			;get bit into carry
		ROXL.L	#1,D0			;shift it in

		DBRA	D7,Map8to1Loop
		
		MOVEQ	#-1,D6			;restore comparison mask
		RTS

; handle the case where it was the same as the last one, so we can repeat the
; high 4 bits

Map8to1Fast
		MOVE.B	D0,D5
		AND.W	#15,D5
		LSL.L	#4,D0
		OR.B	D5,D0		

		DBRA	D7,Map8to1Loop
		
		MOVEQ	#-1,D6
		RTS
		
;******************************************************************************************

; Scan line handler for clipped pattern fill copy mode (called by oval, rrect) -- trap $380

UseOld380
		TST.W	D2

		LEARom	Old380,A0
		JMP	(A0)

FillClipScanLine	
FCSL1							;	<< PB452 BAL>>
FCSL2
		AND.L	(A2)+,D3		;use left mask to start with

		SUBQ	#1,D2
		BMI.S	DoFCLast0		

; special case the left edge

		MOVE.L	D6,D0			;get pattern
		AND.L	D3,D0			;mask it
		NOT.L	D3			;flip mask
		AND.L	(A1),D3			;combine with source
		OR.L	D3,D0			;form dest longword
		MOVE.L	D0,(A1)+		;deposit it

		MOVE.L	(A2)+,D3
		
		SUBQ	#1,D2
		BMI.S	DoFCLast0

; see if we're in the unclipped case; if so, use a faster loop

		MOVE.L	SEEKMASK(A6),A0		;get seekRgn address
		CMP.W	#$4E75,(A0)		;is it a RTS?
		BEQ.S	DoFCUnclipped		;if so, handle specially
		
		BRA.S	FCNotOn1	

; here's the loop -- use standard technique of special casing region masks 

FCLineLoop
		MOVE.L	(A2)+,D3		;fetch region mask
		BEQ.S 	FCOff			;if all zero, can optimize
FCNotOff1
		CMP.L	MINUSONE,D3		;all ones?			<< PB452 BAL>>
		BEQ.S 	FCOn			;if so, optimize
FCNotOn1	
		MOVE.L	D6,D0			;get pattern
		AND.L	D3,D0			;mask it
		NOT.L	D3			;flip mask
		AND.L	(A1),D3			;combine with source
		OR.L	D3,D0			;form dest longword
		MOVE.L	D0,(A1)+		;deposit it

		DBRA	D2,FCLineLoop

; handle the last one, using the mask in D1

DoFCLast
		MOVE.L	(A2)+,D3
DoFCLast0
		AND.L	D1,D3			;use right mask
		
		MOVE.L	D6,D0			;get pattern
		AND.L	D3,D0			;mask it
		NOT.L	D3			;flip mask
		AND.L	(A1),D3			;combine with source
		OR.L	D3,D0			;form dest longword
		MOVE.L	D0,(A1)+		;deposit it		
		
		RTS

; handle the case of an all zero region mask

FCOff
		ADDQ	#4,A1			;skip over it
		
		SUBQ	#1,D2
		BMI.S	DoFCLast
		
FCOffLoop
		MOVE.L	(A2)+,D3
		BNE.S	FCNotOff1
		
		ADDQ	#4,A1			;skip it
		
		DBRA	D2,FCOffLoop
		BRA.S	DoFCLast
		
; handle the case of an all one's region mask

FCOn
		MOVE.L	D6,(A1)+
	
		SUBQ	#1,D2
		BMI.S	DoFCLast
FCOnLoop
		MOVE.L	(A2)+,D3
		CMP.L	MINUSONE,D3		;		<< PB452 BAL>>
		BNE.S	FCNotOn1
		
		MOVE.L	D6,(A1)+
		
		DBRA	D2,FCOnLoop
		BRA.S	DoFCLast
		
; handle the unclipped case with faster unwound code

DoFCUnclipped
		LEA	0(A2,D2.W*4),A2		;bump region ptr
	
		ADDQ	#1,D2			;compute count to do
		
		CMP.W	#8,D2
		BLT.S	FinishFCUnClip
		
		MOVE.W	D2,D0
		LSR	#3,D0			;divide by 8
		SUBQ	#1,D0			;bias for DBRA
FCUnClipLoop
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+

		DBRA	D0,FCUnClipLoop
		
; now finish up the last 7 or less

FinishFCUnClip
		AND	#7,D2
		EOR	#7,D2	
		JMP	FinishFCUCTab(D2.W*2)
FinishFCUCTab
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D6,(A1)+

		BRA.S	DoFCLast
		
		
;******************************************************************************************

; Scan line handler for clipped pattern fill OR mode (called by oval, rrect) -- trap $381
; similar to above, but in OR mode.  We can only handle if the foreground pattern
; is all ones; if so, use the copy mode routine to fill.

UseOld381
		TST.W	D2

		LEARom	Old381,A0
		JMP	(A0)

FillClipOrLine	

		CMP.L	#-1,D6			;all foreground?
		BNE.S	UseOld381		;if not, we can't handle
		
		MOVE.L	D4,D6			;set up fill pattern
		BRA	FCSL1			;use common code


;******************************************************************************************

; Scan line handler for clipped pattern fill copy mode (called by oval, rrect) 
; for complex patterns-- trap $384

UseOld384
		TST.W	D2

		LEARom	Old384,A0
		JMP	(A0)

FillClipXLine	

		CMP.W	#4,PATHMASK(A6)		;pattern too complex?
		BGT.S	UseOld384		;if so, don't handle
		
		MOVE.L	D7,-(SP)		;save work register
		
; keep the pattern in D6 and D7		
		
		ADD.W	PATHPOS(A6),D0
		AND	#4,D0

		MOVE.L	EXPAT(A6),A0
		ADD.W	PATVPOS(A6),A0
		
		MOVE.L	0(A0,D0),D6		;get left pattern
		EOR.W	#4,D0
		MOVE.L	0(A0,D0),D7		;get right pattern

; fetch the leftmost region mask	
		
		MOVEQ	#-1,D4			;all ones for comparing
		AND.L	(A2)+,D3		;use left mask to start with

		SUBQ	#1,D2
		BMI.S	DoFCXLast0		

; special case the left edge

		MOVE.L	D6,D0			;get pattern
		AND.L	D3,D0			;mask it
		NOT.L	D3			;flip mask
		AND.L	(A1),D3			;combine with source
		OR.L	D3,D0			;form dest longword
		MOVE.L	D0,(A1)+		;deposit it

		EXG.L	D6,D7
		
		MOVE.L	(A2)+,D3
		
		SUBQ	#1,D2
		BMI.S	DoFCXLast0

; see if we're in the unclipped case; if so, use a faster loop

		MOVE.L	SEEKMASK(A6),A0		;get seekRgn address
		CMP.W	#$4E75,(A0)		;is it a RTS?
		BEQ.S	DoFCXUnclipped	;if so, handle specially
		
		BRA.S	FCXNotOn1	

; here's the loop -- use standard technique of special casing region masks 

FCXLineLoop
		MOVE.L	(A2)+,D3		;fetch region mask
		BEQ.S 	FCXOff			;if all zero, can optimize
FCXNotOff1
		CMP.L	D4,D3			;all ones?
		BEQ.S 	FCXOn			;if so, optimize
FCXNotOn1	
		MOVE.L	D6,D0			;get pattern
		AND.L	D3,D0			;mask it
		NOT.L	D3			;flip mask
		AND.L	(A1),D3			;combine with source
		OR.L	D3,D0			;form dest longword
		MOVE.L	D0,(A1)+		;deposit it

		EXG.L	D6,D7
		DBRA	D2,FCXLineLoop

; handle the last one, using the mask in D1

DoFCXLast
		MOVE.L	(A2)+,D3
DoFCXLast0
		AND.L	D1,D3			;use right mask
		
		MOVE.L	D6,D0			;get pattern
		AND.L	D3,D0			;mask it
		NOT.L	D3			;flip mask
		AND.L	(A1),D3			;combine with source
		OR.L	D3,D0			;form dest longword
		MOVE.L	D0,(A1)+		;deposit it		

		MOVE.L	(SP)+,D7		;restore work reg		
		RTS

; handle the case of an all zero region mask

FCXOff
		ADDQ	#4,A1			;skip over it
		
		SUBQ	#1,D2
		BMI.S	DoFCXLast
		
FCXOffLoop
		MOVE.L	(A2)+,D3
		BNE.S	FCXNotOff1
		
		ADDQ	#4,A1			;skip it
		
		DBRA	D2,FCXOffLoop
		BRA.S	DoFCXLast
		
; handle the case of an all one's region mask

FCXOn
		MOVE.L	D6,(A1)+
		EXG.L	D6,D7
		
		SUBQ	#1,D2
		BMI.S	DoFCXLast
FCXOnLoop
		MOVE.L	(A2)+,D3
		CMP.L	D4,D3
		BNE.S	FCXNotOn1
		
		MOVE.L	D6,(A1)+
		EXG.L	D6,D7
		
		DBRA	D2,FCXOnLoop
		BRA.S	DoFCXLast
		
; handle the unclipped case with faster unwound code

DoFCXUnclipped
		LEA	0(A2,D2.W*4),A2		;bump region ptr
	
		ADDQ	#1,D2			;compute count to do
		
		CMP.W	#8,D2
		BLT.S	FinishFCXUnClip
		
		MOVE.W	D2,D0
		LSR	#3,D0			;divide by 8
		SUBQ	#1,D0			;bias for DBRA
FCXUnClipLoop
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+

		DBRA	D0,FCXUnClipLoop
		
; now finish up the last 7 or less

FinishFCXUnClip
		AND	#7,D2
		EOR	#7,D2	
		
		BTST	#0,D2
		BEQ.S	@0
		
		EXG.L	D6,D7
@0	
		JMP	FinishFCXUCTab(D2.W*2)
FinishFCXUCTab
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+
		MOVE.L	D6,(A1)+
		MOVE.L	D7,(A1)+
		MOVE.L	D6,(A1)+

		EXG.L	D6,D7
		BRA	DoFCXLast

;******************************************************************************************
		
;   Arithmetic transfer modes start here...		

;******************************************************************************************
		
; Here's where we implement the arithmetic transfer mode fills for ovals/rrects
; Use a common loop for all the transfer modes, with specialized handlers to do the 
; pixel arithmetic.

; the first receiver is for AddOver mode for ovals and roundRects

AddOverFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip
		JMPRom	Old38A			; continue in ROM 					<S433>

; OK, first do the pattern setup
@0
		MOVE.L	A0,A3			;set up pattern base
		LEA	AddOverHandler,A0	;use addOver
DoArithMode
		MOVEM.L	D7/A4-A5,-(SP)		;save work regs
		
		BSR.S	ArithModeHandler	;invoke the handler
		
		MOVEM.L	(SP)+,D7/A4-A5		;restore regs
		RTS

; here is the general handler for a scan line of arithmetic fills

ArithModeHandler
		MOVEQ	#0,D6			;init pattern index
		
		MOVE.W	PATROW(A6),D4		;get pattern size in bytes
		SUBQ	#4,D4			;is it a simple one?
		BLE	ArithSimplePat		;if so, handle faster

; sometimes simple patterns come in as 8 byte ones, so check for that

		MOVE.W	D0,D6
		ADD.W	PATHPOS(A6),D6
		
		SUBQ	#4,D4			;is it 8 long?
		BNE.S	ArithComplexPat		;if not, skip

; fetch both halves of the pattern and see if they match

		MOVE.W	PATHMASK(A6),D4		;get pattern mask
		ASR	#3,D4			;turn bit index to byte  index
		AND.W	D4,D6			;mask it

		MOVE.L	EXPAT(A6),A4
		ADD.W	PATVPOS(A6),A4		;compute pattern address
		
		MOVE.L	0(A4,D6),D4		;get source longword
		EOR	#4,D6
		CMP.L	0(A4,D6),D4		;is it really simple?
		BEQ	ArithSimplePat		;if so, go handle

		EOR	#4,D6			;restore D6
		
; set up the pattern variables, since it's a complex pattern

ArithComplexPat
		MOVE.L	EXPAT(A6),A3
		ADD.W	PATVPOS(A6),A3		;compute pattern address
ArithComplex1		
		MOVE.L	D1,-(SP)		;remember right edge mask
		
		MOVEQ	#0,D1
		MOVEQ	#0,D7			;clear for pixCache

; set up A0 to point to the proper handler, depending on the width of the inverse table

		MOVE.L	A0,A4			;remember handler base
		
		MOVE.W	INVSIZE(A6),D4		;get shift count (3,4,5)
		SUBQ	#3,D4
		ADD.W	0(A0,D4.W*2),A0		;point to proper handler

; init the single pixel cache, where D1 is last source, D7 is last dest, and D0 is last result

		MOVEQ	#0,D5
		MOVE.L	COLORTABLE(A6),A5		;get color table ptr	
		
		MOVE.B	D1,D5
		LEA	0(A5,D5.W*8),A4		;point to source color
		
		MOVE.B	D7,D5
		LEA	0(A5,D5.W*8),A5		;point to dest color
		
		JSR	(A0)			;map it
		MOVE.B	([INVCOLOR,A6],D0.W,6),D0	;look up in inverse table
		
; test for the single long case

		TST.W	D2
		BRA 	ArithBot0

; here's the main loop for complex patterns, where we process a longword at a time
; use a single pixel cache for speed using D0, D1 and D7

ArithRight0
		AND.L	(SP)+,D3
ArithLoop0		
		MOVE.W	PATHMASK(A6),D4		;get pattern mask
		ASR	#3,D4			;turn bit index to byte  index
		AND.W	D4,D6			;mask it

		MOVE.L	0(A3,D6),D4		;get source longword
		ADDQ	#4,D6	
		
		MOVE.L	A2,D5			;no clipping?
		BEQ.S	@0			;if none, skip
		
		AND.L	(A2)+,D3		;get region/edge mask in D3
		BEQ 	ArithMask0
@0		
		MOVE.L	(A1),D5			;get dest longword

; map 1st byte

		TST.B	D3
		BEQ.S	@8			;if mask zero, we can skip

; if same as previous, we can short-circuit the mapping

		CMP.B	D4,D1			;source the same?
		BNE.S	@9			;if not, skip
		
		CMP.B	D5,D7			;dest the same?
		BNE.S	@9			;if not, skip
		
; it's the same, so use it

		MOVE.B	D0,D5			;use last result
		BRA.S	@8			;skip the mapping

; it's different than the last one, so map it

@9
		MOVE.B	D4,D1
		
		MOVE.L	COLORTABLE(A6),A5	
		LEA	0(A5,D1.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A5,D7.W*8),A5		;point to dest color
		
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
		MOVE.B	D5,D0
@8
		LSR.L	#8,D3
		LSR.L	#8,D4
		ROR.L	#8,D5

; map 2nd byte

		TST.B	D3
		BEQ.S	@2			;if mask zero, we can skip

; if same as previous, we can short-circuit the mapping

		CMP.B	D4,D1			;source the same?
		BNE.S	@1			;if not, skip
		
		CMP.B	D5,D7			;dest the same?
		BNE.S	@1			;if not, skip
		
; it's the same, so use it

		MOVE.B	D0,D5			;use last result
		BRA.S	@2			;skip the mapping

; it's different than the last one, so map it

@1
		MOVE.B	D4,D1
		MOVE.L	COLORTABLE(A6),A5	

		LEA	0(A5,D1.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A5,D7.W*8),A5		;point to dest color
		
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
		MOVE.B	D5,D0
@2
		LSR.L	#8,D3
		LSR.L	#8,D4
		ROR.L	#8,D5
		
; map 3rd byte

		TST.B	D3
		BEQ.S	@4			;if mask zero, we can skip

; if same as previous, we can short-circuit the mapping

		CMP.B	D4,D1			;source the same?
		BNE.S	@3			;if not, skip
		
		CMP.B	D5,D7			;dest the same?
		BNE.S	@3			;if not, skip
		
; it's the same, so use it

		MOVE.B	D0,D5			;use last result
		BRA.S	@4			;skip the mapping

; it's different than the last one, so map it

@3
		MOVE.B	D4,D1

		MOVE.L	COLORTABLE(A6),A5			
		LEA	0(A5,D1.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A5,D7.W*8),A5		;point to dest color
		
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
		MOVE.B	D5,D0
@4
		LSR.L	#8,D3
		LSR.L	#8,D4
		ROR.L	#8,D5
		
; map final byte

		TST.B	D3
		BEQ.S	@6			;if mask zero, we can skip

; if same as previous, we can short-circuit the mapping

		CMP.B	D4,D1			;source the same?
		BNE.S	@5			;if not, skip
		
		CMP.B	D5,D7			;dest the same?
		BNE.S	@5			;if not, skip
		
; it's the same, so use it

		MOVE.B	D0,D5			;use last result
		BRA.S	@6			;skip the mapping

; it's different than the last one, so map it

@5
		MOVE.B	D4,D1
		
		MOVE.L	COLORTABLE(A6),A5	
		LEA	0(A5,D1.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A5,D7.W*8),A5		;point to dest color
		
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
		MOVE.B	D5,D0
@6
		ROR.L	#8,D5
		
; it's all mapped, so store the result
		
		MOVE.L	D5,(A1)+		;store the destination
ArithBotCommon		
		MOVEQ	#-1,D3			;set up the mask for the middle
		SUBQ	#1,D2
ArithBot0		
		BGT 	ArithLoop0
		BEQ 	ArithRight0

; all done with this scan line

		RTS
		
; handle a region of all zeros

ArithMask0
		ADDQ	#4,A1			;skip over destination
		BRA.S	ArithBotCommon
		
; the pattern is simpler (it fits in a register), so use a separate loop to make things 
;faster.  Use a longword cache instead of the single pixel caches.

ArithSimplePat
		MOVE.L	D1,-(SP)		;save right edge mask
		
		MOVEQ	#0,D7			;clear for pixIndexing
					
		MOVE.L	(A3),D4			;keep pattern in D4
		MOVE.L	COLORTABLE(A6),A3		;use A3 for color table ptr

; set up A0 to point to the proper handler, depending on the width of the inverse table

		MOVE.L	A0,A4			;remember handler base
		
		MOVE.W	INVSIZE(A6),D0		;get shift count (3,4,5)
		SUBQ	#3,D0
		ADD.W	0(A0,D0.W*2),A0		;point to proper handler

; init the longword pattern cache by mapping the four pixels in D4

		MOVEQ	#3,D5
		MOVE.L	D4,D6			;init lastDest
		BRA.S	CacheILoop0		;skip cache check 1st time
		
; if the next pixel in D4 is the same as the previous (in D7), take a shortcut

CacheInitLoop
		CMP.B	D4,D7			;does it match?
		BNE.S	CacheILoop0		;if not, must do the hard way
		
		MOVE.B	D0,D1			;use last result
		
		ROL.L	#8,D1
		ROL.L	#8,D4
		
		DBRA	D5,CacheInitLoop
		BRA.S	CacheIDone
		
; it's not the same, so do it the hard way

CacheILoop0
		MOVE.B	D4,D7
		LEA	0(A3,D7.W*8),A4		;point to source color
		MOVE.L	A4,A5			;source and dest are same
		
		JSR	(A0)			;map next pixel
		MOVE.B	([INVCOLOR,A6],D0.W,6),D1	;look up in inverse table

		MOVE.L	D1,D0			;remember last result
		ROL.L	#8,D1	
		ROL.L	#8,D4

		DBRA	D5,CacheInitLoop

; OK, here's the start of the main loop; first, see if there's only one long to do

CacheIDone
		TST.W	D2
		BNE.S 	ArithLoop1
		
; here's the main loop for simple patterns, where we process a longword at a time
; We use a longword cache in D6

ArithRight1
		AND.L	(SP)+,D3
ArithLoop1
		MOVE.L	A2,D5			;no clipping?
		BEQ.S	@0			;if none, skip
		
		AND.L	(A2)+,D3		;get mask in D4
		BEQ 	ArithMask1
@0		
		MOVE.L	(A1),D5			;get dest longword

		CMP.L	#-1,D3			;mask all ones?
		BNE.S	ArithMapIt1A		;if not, can't use cache
		
		CMP.L	D5,D6			;same as last time?
		BNE.S	ArithMapIt1		;if not, skip

; the long was the same as last time, so we can skip the mapping.  Better make sure
; the mask was the same, too

		MOVE.L	D1,D5			;use last result
		BRA	ArithStoreIt		;skip the mapping

; it was different, so we have to map it the hard way

ArithMapIt1
		MOVE.L	D5,D6			;remember for next time
ArithMapIt1A		
		TST.B	D3
		BEQ.S	@0			;if mask zero, we can skip
		
		MOVE.B	D4,D7
		LEA	0(A3,D7.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A3,D7.W*8),A5		;point to dest color
		
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
@0
		ROR.L	#8,D3
		ROR.L	#8,D4
		ROR.L	#8,D5

; map 2nd byte

		TST.B	D3
		BEQ.S	@2			;if mask zero, we can skip

		MOVE.B	D4,D7
		LEA	0(A3,D7.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A3,D7.W*8),A5		;point to dest color
			
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
@2
		ROR.L	#8,D3
		ROR.L	#8,D4
		ROR.L	#8,D5
		
; map 3rd byte

		TST.B	D3
		BEQ.S	@4			;if mask zero, we can skip

; map it
		MOVE.B	D4,D7
		LEA	0(A3,D7.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A3,D7.W*8),A5		;point to dest color
				
		JSR	(A0)			;map according to Xfer mode	
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
@4
		ROR.L	#8,D3
		ROR.L	#8,D4
		ROR.L	#8,D5
		
; map final byte

		TST.B	D3
		BEQ.S	@6			;if mask zero, we can skip

; it's different than the last one, so map it

		MOVE.B	D4,D7
		LEA	0(A3,D7.W*8),A4		;point to source color
		
		MOVE.B	D5,D7
		LEA	0(A3,D7.W*8),A5		;point to dest color
		
		JSR	(A0)			;map according to Xfer mode
		MOVE.B	([INVCOLOR,A6],D0.W,6),D5	;look up in inverse table
@6
		ROR.L	#8,D4
		ROR.L	#8,D5
		
; it's all mapped, so store the result

ArithStoreIt	
		MOVE.L	D5,(A1)+		;store the destination
		ADDQ.L	#1,D3			;was mask all ones?
		BNE.S	ArithCom1		;if not, skip
		
		MOVE.L	D5,D1			;remember last result
ArithCom1		
		MOVEQ	#-1,D3			;set up the mask for the middle
		SUBQ	#1,D2
ArithBot1		
		BGT 	ArithLoop1
		BEQ		ArithRight1

; all done with this scan line

		RTS

; handle a region of all zeros

ArithMask1
		ADDQ	#4,A1			;skip over destination
		BRA.S	ArithCom1

; Here is the handler for the AddOver mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

AddOverHandler
		DC.W	AddOver3-AddOverHandler
		DC.W	AddOver4-AddOverHandler
		DC.W	AddOver5-AddOverHandler	

AddOver3		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0		;red
		ADD.W	(A5)+,D0
		LSL.L	#3,D0
				
		MOVE.W	(A4)+,D0		;green
		ADD.W	(A5)+,D0
		LSL.L	#3,D0
				
		MOVE.W	(A4),D0			;blue
		ADD.W	(A5),D0
		LSL.L	#3,D0
				
		SWAP	D0			;return inverse table index
		RTS

AddOver4		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0		;red
		ADD.W	(A5)+,D0
		LSL.L	#4,D0
				
		MOVE.W	(A4)+,D0		;green
		ADD.W	(A5)+,D0
		LSL.L	#4,D0
				
		MOVE.W	(A4),D0			;blue
		ADD.W	(A5),D0
		LSL.L	#4,D0
				
		SWAP	D0			;return inverse table index
		RTS

AddOver5		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0		;red
		ADD.W	(A5)+,D0
		LSL.L	#5,D0
				
		MOVE.W	(A4)+,D0		;green
		ADD.W	(A5)+,D0
		LSL.L	#5,D0
				
		MOVE.W	(A4),D0			;blue
		ADD.W	(A5),D0
		LSL.L	#5,D0
				
		SWAP	D0			;return inverse table index
		RTS
		
;*************************************************************************************


; Here is the receiver for the SubOver arithmetic fill mode, for ovals and roundRects.
; It uses mainly common code with the other oval handlers


SubOverFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip			<S433>
		
		JMPRom	Old38E			;						<S433>

; OK, first do the pattern setup

@0		MOVE.L	A0,A3			;set up pattern base
		LEA	SubOverHandler,A0	;use subOver
		BRA	DoArithMode
		
; Here is the handler for the SubOver mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

SubOverHandler
		DC.W	SubOver3-SubOverHandler
		DC.W	SubOver4-SubOverHandler
		DC.W	SubOver5-SubOverHandler	

SubOver3		
		MOVEQ	#0,D0
		
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#3,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#3,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#3,D0
				
		SWAP	D0			;return inverse table index
		RTS

SubOver4		
		MOVEQ	#0,D0
		
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#4,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#4,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#4,D0
				
		SWAP	D0			;return inverse table index
		RTS

SubOver5		
		MOVEQ	#0,D0
		
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#5,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#5,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		LSL.L	#5,D0
				
		SWAP	D0			;return inverse table index
		RTS


;*************************************************************************************

; Here is the receiver for the AddPin arithmetic fill mode, for ovals and roundRects.
; It uses mainly common code with the other oval handlers

AddPinFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip			<S433>
		
		JMPRom	Old389			;						<S433>

; set up handlers and use common code

@0		MOVE.L	A0,A3			;set up pattern base
		LEA	AddPinHandler,A0	;use addPin
		BRA	DoArithMode


; Here is the handler for the AddPin mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

AddPinHandler
		DC.W	AddPin3-AddPinHandler
		DC.W	AddPin4-AddPinHandler
		DC.W	AddPin5-AddPinHandler	

AddPin3		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0		;red
		ADD.W	(A5)+,D0
		BCS.S	@0
		
		CMP.W	WEIGHT+BLUE(A6),D0
		BLS.S	@1
@0
		MOVE.W	WEIGHT+BLUE(A6),D0
@1
		LSL.L	#3,D0
				
		MOVE.W	(A4)+,D0		;green
		ADD.W	(A5)+,D0
		BCS.S	@2
		
		CMP.W	WEIGHT+GREEN(A6),D0
		BLS.S	@3
@2
		MOVE.W	WEIGHT+GREEN(A6),D0
@3	
		LSL.L	#3,D0
				
		MOVE.W	(A4),D0			;blue
		ADD.W	(A5),D0
		BCS.S	@4
		
		CMP.W	WEIGHT+RED(A6),D0
		BLS.S	@5
@4
		MOVE.W	WEIGHT+RED(A6),D0
@5	
		LSL.L	#3,D0
				
		SWAP	D0			;return inverse table index
		RTS

AddPin4		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0		;red
		ADD.W	(A5)+,D0
		BCS.S	@0
		
		CMP.W	WEIGHT+BLUE(A6),D0
		BLS.S	@1
@0
		MOVE.W	WEIGHT+BLUE(A6),D0
@1
		LSL.L	#4,D0
				
		MOVE.W	(A4)+,D0		;green
		ADD.W	(A5)+,D0
		BCS.S	@2
		
		CMP.W	WEIGHT+GREEN(A6),D0
		BLS.S	@3
@2
		MOVE.W	WEIGHT+GREEN(A6),D0
@3	
		LSL.L	#4,D0
				
		MOVE.W	(A4),D0			;blue
		ADD.W	(A5),D0
		BCS.S	@4
		
		CMP.W	WEIGHT+RED(A6),D0
		BLS.S	@5
@4
		MOVE.W	WEIGHT+RED(A6),D0
@5	
		LSL.L	#4,D0
				
		SWAP	D0			;return inverse table index
		RTS

AddPin5		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0		;red
		ADD.W	(A5)+,D0
		BCS.S	@0
		
		CMP.W	WEIGHT+BLUE(A6),D0
		BLS.S	@1
@0
		MOVE.W	WEIGHT+BLUE(A6),D0
@1
		LSL.L	#5,D0
				
		MOVE.W	(A4)+,D0		;green
		ADD.W	(A5)+,D0
		BCS.S	@2
		
		CMP.W	WEIGHT+GREEN(A6),D0
		BLS.S	@3
@2
		MOVE.W	WEIGHT+GREEN(A6),D0
@3	
		LSL.L	#5,D0
				
		MOVE.W	(A4),D0			;blue
		ADD.W	(A5),D0
		BCS.S	@4
		
		CMP.W	WEIGHT+RED(A6),D0
		BLS.S	@5
@4
		MOVE.W	WEIGHT+RED(A6),D0
@5	
		LSL.L	#5,D0
				
		SWAP	D0			;return inverse table index
		RTS

;*************************************************************************************

; Here is the receiver for the SubPin arithmetic fill mode, for ovals and roundRects.
; It uses mainly common code with the other oval handlers

SubPinFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0		;if not, skip			<S433>
		
		JMPRom	Old38B			;						<S433>

; set up handlers and use common code

@0		MOVE.L	A0,A3			;set up pattern base
		LEA	SubPinHandler,A0	;use SubPin
		BRA	DoArithMode


; Here is the handler for the SubPin mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

SubPinHandler
		DC.W	SubPin3-SubPinHandler
		DC.W	SubPin4-SubPinHandler
		DC.W	SubPin5-SubPinHandler	

SubPin3		
		MOVEQ	#0,D0
		
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@0
		
		CMP.W	WEIGHT+BLUE(A6),D0
		BCC.S	@1
@0
		MOVE.W	WEIGHT+BLUE(A6),D0
@1
		LSL.L	#3,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@2
		
		CMP.W	WEIGHT+GREEN(A6),D0
		BCC.S	@3
@2
		MOVE.W	WEIGHT+GREEN(A6),D0
@3	
		LSL.L	#3,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@4
		
		CMP.W	WEIGHT+RED(A6),D0
		BCC.S	@5
@4
		MOVE.W	WEIGHT+RED(A6),D0
@5	
		LSL.L	#3,D0
				
		SWAP	D0			;return inverse table index
		RTS

SubPin4		
		MOVEQ	#0,D0
		
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@0
		
		CMP.W	WEIGHT+BLUE(A6),D0
		BCC.S	@1
@0
		MOVE.W	WEIGHT+BLUE(A6),D0
@1
		LSL.L	#4,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@2
		
		CMP.W	WEIGHT+GREEN(A6),D0
		BCC.S	@3
@2
		MOVE.W	WEIGHT+GREEN(A6),D0
@3	
		LSL.L	#4,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@4
		
		CMP.W	WEIGHT+RED(A6),D0
		BCC.S	@5
@4
		MOVE.W	WEIGHT+RED(A6),D0
@5	
		LSL.L	#4,D0
				
		SWAP	D0			;return inverse table index
		RTS

SubPin5		
		MOVEQ	#0,D0
		
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@0
		
		CMP.W	WEIGHT+BLUE(A6),D0
		BCC.S	@1
@0
		MOVE.W	WEIGHT+BLUE(A6),D0
@1
		LSL.L	#5,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@2
		
		CMP.W	WEIGHT+GREEN(A6),D0
		BCC.S	@3
@2
		MOVE.W	WEIGHT+GREEN(A6),D0
@3	
		LSL.L	#5,D0
				
		MOVE.W	(A5)+,D0		;red
		SUB.W	(A4)+,D0
		BCS.S	@4
		
		CMP.W	WEIGHT+RED(A6),D0
		BCC.S	@5
@4
		MOVE.W	WEIGHT+RED(A6),D0
@5	
		LSL.L	#5,D0
				
		SWAP	D0			;return inverse table index
		RTS

;*************************************************************************************


; Here is the receiver for the AddMax arithmetic fill mode, for ovals and roundRects.
; It uses mainly common code with the other oval handlers

AddMaxFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip			<S433>

		JMPRom	Old38D			;						<S433>
		
; OK, first do the pattern setup

@0		MOVE.L	A0,A3			;set up pattern base
		LEA	AddMaxHandler,A0	;use AddMax
		BRA	DoArithMode
		
; Here is the handler for the AddMax mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

AddMaxHandler
		DC.W	AddMax3-AddMaxHandler
		DC.W	AddMax4-AddMaxHandler
		DC.W	AddMax5-AddMaxHandler	

AddMax3		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@0
		MOVE.W	(A5),D0
@0
		ADDQ	#2,A5
		LSL.L	#3,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@1
		MOVE.W	(A5),D0
@1
		ADDQ	#2,A5
		LSL.L	#3,D0
				
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@2
		MOVE.W	(A5),D0
@2		
		ADDQ	#2,A5
		LSL.L	#3,D0						

		SWAP	D0			;return inverse table index
		RTS

AddMax4		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@0
		MOVE.W	(A5),D0
@0
		ADDQ	#2,A5
		LSL.L	#4,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@1
		MOVE.W	(A5),D0
@1
		ADDQ	#2,A5
		LSL.L	#4,D0
				
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@2
		MOVE.W	(A5),D0
@2		
		ADDQ	#2,A5
		LSL.L	#4,D0						

		SWAP	D0			;return inverse table index
		RTS

AddMax5		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@0
		MOVE.W	(A5),D0
@0
		ADDQ	#2,A5
		LSL.L	#5,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@1
		MOVE.W	(A5),D0
@1
		ADDQ	#2,A5
		LSL.L	#5,D0
				
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BCC.S	@2
		MOVE.W	(A5),D0
@2		
		ADDQ	#2,A5
		LSL.L	#5,D0						

		SWAP	D0			;return inverse table index
		RTS


;*************************************************************************************


; Here is the receiver for the AddMin arithmetic fill mode, for ovals and roundRects.
; It uses mainly common code with the other oval handlers


AddMinFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip		<S433>
		
		JMPRom	Old38F			;					<S433>

; OK, first do the pattern setup

@0		MOVE.L	A0,A3			;set up pattern base
		LEA	AddMinHandler,A0	;use addMin
		BRA	DoArithMode
		
; Here is the handler for the AddMin mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

AddMinHandler
		DC.W	AddMin3-AddMinHandler
		DC.W	AddMin4-AddMinHandler
		DC.W	AddMin5-AddMinHandler	

AddMin3		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@0
		MOVE.W	(A5),D0
@0
		ADDQ	#2,A5
		LSL.L	#3,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@1
		MOVE.W	(A5),D0
@1
		ADDQ	#2,A5
		LSL.L	#3,D0		
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@2
		MOVE.W	(A5),D0
@2		
		ADDQ	#2,A5
		LSL.L	#3,D0						

		SWAP	D0			;return inverse table index
		RTS

AddMin4		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@0
		MOVE.W	(A5),D0
@0
		ADDQ	#2,A5
		LSL.L	#4,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@1
		MOVE.W	(A5),D0
@1
		ADDQ	#2,A5
		LSL.L	#4,D0
				
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@2
		MOVE.W	(A5),D0
@2		
		ADDQ	#2,A5
		LSL.L	#4,D0						

		SWAP	D0			;return inverse table index
		RTS

AddMin5		
		MOVEQ	#0,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@0
		MOVE.W	(A5),D0
@0
		ADDQ	#2,A5
		LSL.L	#5,D0
		
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@1
		MOVE.W	(A5),D0
@1
		ADDQ	#2,A5
		LSL.L	#5,D0
			
		MOVE.W	(A4)+,D0
		CMP.W	(A5),D0
		BLS.S	@2
		MOVE.W	(A5),D0
@2		
		ADDQ	#2,A5
		LSL.L	#5,D0						

		SWAP	D0			;return inverse table index
		RTS


;*************************************************************************************


; Here is the receiver for the blend arithmetic fill mode, for ovals and roundRects.
; It uses mainly common code with the other oval handlers


BlendFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip				<S433>

		JMPRom	Old388			;							<S433>

; OK, first do the pattern setup

@0		MOVE.L	A0,A3			;set up pattern base
		LEA	BlendHandler,A0		;use blend
		BRA	DoArithMode
		
; Here is the handler for the Blend mode.  A4 points to the source RGBColor, while
; A5 points to the destination.  Return the index in D0 (to be looked up in the
; inverse table). First there is a case table for using a static shift count

BlendHandler
		DC.W	Blend3-BlendHandler
		DC.W	Blend4-BlendHandler
		DC.W	Blend5-BlendHandler	

Blend3
		MOVEM.L	D1-D3,-(SP)
		
		MOVEQ	#3,D2			;set up shift count
		BRA.S	BlendCommon
Blend4
		MOVEM.L	D1-D3,-(SP)
		MOVEQ	#4,D2
BlendCommon
		MOVEQ	#0,D0			;clear accum reg

; do red

		MOVE.W	(A4)+,D1
		MULU	WEIGHT+BLUE(A6),D1
		
		MOVE.W	(A5)+,D3
		MULU	NOTWEIGHT+BLUE(A6),D3
		
		ADD.L	D1,D3
		SWAP	D3
		MOVE.W	D3,D0
		ASL.L	D2,D0

; do green

		MOVE.W	(A4)+,D1
		MULU	WEIGHT+GREEN(A6),D1
		
		MOVE.W	(A5)+,D3
		MULU	NOTWEIGHT+GREEN(A6),D3
		
		ADD.L	D1,D3
		SWAP	D3
		MOVE.W	D3,D0
		ASL.L	D2,D0

; do blue

		MOVE.W	(A4)+,D1
		MULU	WEIGHT+RED(A6),D1
		
		MOVE.W	(A5)+,D3
		MULU	NOTWEIGHT+RED(A6),D3
		
		ADD.L	D1,D3
		SWAP	D3
		MOVE.W	D3,D0
		ASL.L	D2,D0

		SWAP	D0
		
		MOVEM.L	(SP)+,D1-D3
		RTS
Blend5
		MOVEM.L	D1-D3,-(SP)
		MOVEQ	#5,D2
		BRA.S	BlendCommon
		
		
;******************************************************************************************
		
; Now we start on the arithmetic fills for clipped rectangles.  Use the common
; scan line handler for ovals/rrects to save code.

; First we handle AddOver mode

UseOld368
		JMPROM	Old368			;						<S433>
				
AddOverFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld368		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld368		;if so, skip   			<PB427	 BAL>

		LEA	AddOverHandler,A0	;set up the handler
ArithFillCommon
		MOVE.L	A0,-(SP)		;remember handler address
		
; set up the registers and invoke the common scan-line handler

		MOVE.L	A4,A2			;set up region pointer
		ASR	#3,D6			;bit index to byte index
		MOVE.L	A5,A1			;set up destination
ArithFillLoop		
		MOVEQ	#-1,D1
		MOVEQ	#-1,D3			;edge masks all ones (edges in region)

		MOVE.W	BUFSIZE(A6),D2		;set up the count
		ADDQ	#4,D2			;make one based			<PB427	 BAL>
		LSR.W	#2,D2
		SUBQ	#1,D2			;make zero based		<PB427	 BAL>
		
		MOVE.L	(SP),A0			;get handler address

; call the appropriate handle, depending on whether the pattern is simple or complex		
	
		CMP.W	#8,PATROW(A6)		;is pattern real complex?
		BGT.S	@0			;if so, go handle it

		TST.B	SRCV(A6)		;test pattern mode
		BMI.S	@0			;treat bitmap as complex
		
		MOVE.L	0(A3,D6),D0		;get left pattern
		EOR	#4,D6
		CMP.L	0(A3,D6),D0		;left same as right?
		BEQ.S	@1			;if so, it's simple

		EOR	#4,D6			;restore D6
@0		
		BSR	ArithComplex1		;invoke scan-line handler for complex pats		
		BRA.S	@2
@1
		EOR	#4,D6
		BSR	ArithSimplePat
		
; bump pointers to next time, and loop until done

@2
		MOVE.L	HEIGHT(A6),D6		;get pattern index
		ASR.L	#3,D6			;bit index to byte index

		MOVE.W	DSTV(A6),D0
		
		TST.B	SRCV(A6)		;test pattern mode
		BEQ.S	AFPat1			;if zero, handle
		BMI.S	AFBitMap1		;if <0, go handle bitmap

; handle bumping the pattern pointers

		MOVE.L	SRCADDR(A6),A3		;set up pattern pointer
		SUB.W	D0,A3
		ADD.W	PATROW(A6),D0
		AND.W	PATVMASK(A6),D0
		MOVE.W	D0,DSTV(A6)
		ADD.W	D0,A3
		
		BRA.S	AFSetPatPtr

; handle second type of pattern

AFPat1
		ADDQ	#1,D0
		AND	#15,D0
		LEA	([EXPAT,A6],D0.W*4),A3
		
		MOVE.W	D0,HEIGHT(A6)
AFSetPatPtr		
		MOVE.L	A3,SRCADDR(A6)
		
; bump to the next scan line

ArithFillNextLine
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)

		MOVE.W	VERT(A6),D0
		ADD.W	VBUMP(A6),D0
		MOVE.W	D0,VERT(A6)
		
		CMP.W	LASTV(A6),D0
		BNE.S	@0

; all done, so strip stack and return

		MOVE.L	SAVESTK2(A6),A7
		RTS

; set up registers and loop for the next line

@0
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;seek new region
		
		MOVE.L	SRCADDR(A6),A3		;set up pattern pointer
		MOVE.L	DSTADDR(A6),A1		;set up dest ptr
		MOVE.L	RGNADDR(A6),A2		;set up region ptr
	
		BRA	ArithFillLoop

; handle bumping the source if it's a bitmap

AFBitMap1
		MOVE.L	SRCROW(A6),D0
		ADD.L	D0,SRCADDR(A6)
		
		BRA.S	ArithFillNextLine
		
;******************************************************************************************
		
; Handle SubOver clipped rectangle fill

UseOld36C
		JMPRom	Old36C			;						<PB433>
		
SubOverFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld36C		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld36c		;if so, skip   			<PB427	 BAL>

		LEA	SubOverHandler,A0	;set up the handler
		BRA	ArithFillCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle AddPin clipped rectangle fill

UseOld367
		JMPRom	Old367			;						<PB433>
		
AddPinFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld367		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld367		;if so, skip   			<PB427	 BAL>

		LEA	AddPinHandler,A0	;set up the handler
		BRA	ArithFillCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle SubPin clipped rectangle fill

UseOld369
		JMPRom	Old369			;						<PB433>
		
SubPinFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld369		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld369		;if so, skip   			<PB427	 BAL>

		LEA	SubPinHandler,A0	;set up the handler
		BRA	ArithFillCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle AddMax clipped rectangle fill

UseOld36B
		JMPRom	Old36B			;						<PB433>
		
AddMaxFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld36B		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld36B		;if so, skip   			<PB427	 BAL>

		LEA	AddMaxHandler,A0	;set up the handler
		BRA	ArithFillCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle AddMin clipped rectangle fill

UseOld36D
		JMPRom	Old36D			;						<PB433>
		
AddMinFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld36D		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld36D		;if so, skip   			<PB427	 BAL>

		LEA	AddMinHandler,A0	;set up the handler
		BRA	ArithFillCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle Blend clipped rectangle fill

UseOld366
		JMPRom	Old366			;						<PB433>
		
BlendFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld366		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld366		;if s0, skip   			<PB427	 BAL>

		LEA	BlendHandler,A0		;set up the handler
		BRA	ArithFillCommon		;use comon code
		

;******************************************************************************************
		
; Now we start on the arithmetic fills for unclipped rectangles.  Use the common
; scan line handler for ovals/rrects to save code.

; First we handle AddOver mode, unclipped

UseOld352
		JMPRom	Old352			;						<PB433>
		
AddOverUnClip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld352		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld352		;if so, skip   			<PB427	 BAL>

		LEA	AddOverHandler,A0	;set up the handler
ArithUCCommon
		MOVE.L	A0,-(SP)		;remember handler address
		
; set up the registers and invoke the common scan-line handler

		SUB.L	A2,A2			;no region pointer
		ASR	#3,D6			;bit index to byte index
		MOVE.L	A4,A3			;set up pattern pointer
		MOVE.L	A5,A1			;set up destination
ArithUCLoop		
		MOVE.L	FIRSTMASK(A6),D3		;set up left edge
		MOVE.L	LASTMASK(A6),D1		;set up right edge

; compute the count from the three pieces: left, mid and right

		MOVE.W	LONGCNT(A6),D2		;get left count
		BPL.S	@3			;if positive, we're cool
		
		MOVEQ	#0,D2			;only one word
		BRA.S	@4
@3		
		ADD.W	MIDCOUNT(A6),D2		;add in the middle
		ADD.W	PIXINLONG(A6),D2		;add in the right
		ADDQ.W	#2,D2			;add for count bias
		LSR.W	#2,D2			;bytes -> longs
@4		
		MOVE.L	(SP),A0			;get handler address

; call the appropriate handle, depending on whether the pattern is simple or complex		
	
		CMP.W	#8,PATROW(A6)		;is pattern real complex?
		BGT.S	@0			;if so, go handle it

		TST.B	ENDSWITCH(A6)		;test pattern mode
		BMI.S	@0			;if bitmap, it's complex
		
		MOVE.L	0(A3,D6),D0		;get left pattern
		EOR	#4,D6
		CMP.L	0(A3,D6),D0		;left same as right?
		BEQ.S	@1			;if so, it's simple

		EOR	#4,D6			;restore D6
@0		
		MOVE.L	A1,-(SP)
		BSR	ArithComplex1		;invoke scan-line handler for complex pats		
		MOVE.L	(SP)+,A1
		
		BRA.S	@2
@1
		EOR	#4,D6
		
		MOVEM.L	A1/A3,-(SP)	
		BSR	ArithSimplePat
		MOVEM.L	(SP)+,A1/A3
		
; bump pointers to next time, and loop until done

@2
		TST.B	ENDSWITCH(A6)		;test pattern mode
		BEQ.S	AFUCPat1		;if zero, handle
		BMI.S	AFUCBitMap1		;if <0, go handle bitmap

; handle bumping the pattern pointers

		MOVE.W	PATPOS(A6),D0
		SUB.W	D0,A3
		ADD.W	PATROW(A6),D0
		AND.W	PATVMASK(A6),D0
		MOVE.W	D0,PATPOS(A6)
		ADD.W	D0,A3
		
		BRA.S	ArithUCNextLine

; handle second type of pattern

AFUCPat1
		MOVE.W	PATPOS(A6),D0
		ADDQ	#1,D0
		AND	#15,D0
		LEA	([EXPAT,A6],D0.W*4),A3
		
		MOVE.W	D0,PATPOS(A6)

; bump to the next scan line

ArithUCNextLine
		MOVE.L	PATOFFSET(A6),D6
		ASR.L	#3,D6			;bits to bytes		
ArithUCNL2
		ADD.W	DSTROW+2(A6),A1		;bump destination
		
		SUBQ.W	#1,HEIGHT(A6)
		BNE	ArithUCLoop
		
		ADDQ	#8,SP
		RTS

; handle unclipped blits source setup

AFUCBitMap1
		ADD.W	D6,A3
		ADD.W	SRCBUMP(A6),A3		;bump to next line <PB448 DBG>
		MOVEQ	#0,D6
		BRA.S	ArithUCNL2
		
		
;******************************************************************************************
		
; Handle SubOver unclipped rectangle fill

UseOld356
		JMPRom	Old356			;						<PB433>
		
SubOverUnclip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld356		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld356		;if so, skip   			<PB427	 BAL>

		LEA	SubOverHandler,A0	;set up the handler
		BRA	ArithUCCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle AddPin unclipped rectangle fill

UseOld351
		JMPRom	Old351			;						<PB433>
		
AddPinUnclip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld351		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld351		;if so, skip   			<PB427	 BAL>

		LEA	AddPinHandler,A0	;set up the handler
		BRA	ArithUCCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle SubPin unclipped rectangle fill

UseOld353
		JMPRom	Old353			;						<PB433>
		
SubPinUnclip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld353		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld353		;if so, skip   			<PB427	 BAL>

		LEA	SubPinHandler,A0	;set up the handler
		BRA	ArithUCCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle AddMax unclipped rectangle fill

UseOld355
		JMPRom	Old355			;						<PB433>
		
AddMaxUnclip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld355		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld355		;if so, skip   			<PB427	 BAL>

		LEA	AddMaxHandler,A0	;set up the handler
		BRA	ArithUCCommon		;use comon code
		
		
;******************************************************************************************
		
; Handle AddMin unclipped rectangle fill

UseOld357
		JMPRom	Old357			;						<PB433>
		
AddMinUnclip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld357		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld357		;if so, skip   			<PB427	 BAL>

		LEA	AddMinHandler,A0	;set up the handler
		BRA	ArithUCCommon		;use comon code

		
;******************************************************************************************
		
; Handle Blend unclipped rectangle fill

UseOld350
		JMPRom	Old350			;						<PB433>
		
BlendUnclip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld350		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld350		;if so, skip   			<PB427	 BAL>

		LEA	BlendHandler,A0		;set up the handler
		BRA	ArithUCCommon		;use comon code

		
;******************************************************************************************

;  Here's where we handle transparent mode.  The basic strategy is to create a mask from
;  the pattern (for one and two long patterns) so we don't have to keep examining it
;  pixel by pixel.  (If the mask is all ones, fall into the standard fills). 
		
; the first one is for transparent mode for ovals and roundRects

TransFillO	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BEQ.S	@0				;if not, skip

		JMPRom	Old38C			;
		
@0		CMP.W	#4,PATROW(A6)		;is it a simple pattern?
		BGT.S	TransComplexPat		;if not, inspect it closer

; it's a simple pattern, so make a mask according to the see-through color

TransSimple1
		MOVE.L	(A0),D6			;fetch the pattern
		MOVEQ	#-1,D4			;mask is initially all ones
		MOVE.B	TRANSCOLOR(A6),D5		;get color to compare with
		
		CMP.B	D6,D5
		BNE.S	@0
		
		CLR.B	D4
@0
		ROR.L	#8,D4
		ROR.L	#8,D6
		
		CMP.B	D6,D5
		BNE.S	@1
		
		CLR.B	D4
@1
		ROR.L	#8,D4
		ROR.L	#8,D6
		
		CMP.B	D6,D5
		BNE.S	@2
		
		CLR.B	D4
@2
		ROR.L	#8,D4
		ROR.L	#8,D6
		
		CMP.B	D6,D5
		BNE.S	@3
		
		CLR.B	D4
@3
		ROR.L	#8,D4
		ROR.L	#8,D6
			
; if the mask is all ones, plot it quickly using the standard fill routine

		MOVE.L	A2,D0			;if no clipping
		BEQ.S	@4			;skip optimization (things not set up)
		
		CMP.L	#-1,D4			;is mask all ones?
		BEQ	FCSL2			;use standard pattern fill

; OK, mask is in D4, A2 points to the region, pattern in D6 and A1 is the destination.  
; use the straightforward loop, since region optimizations aren't worth it since we
; always have to read the destination.

@4
		TST.W	D2			;only one long?
		BNE.S	TransSimpleLoop		;if not, skip
TSL0
		AND.L	D1,D3			;combine edges for last one
TransSimpleLoop
		MOVE.L	A2,D0
		BEQ.S	@0
		
		AND.L	(A2)+,D3		;pick up the region mask
@0		
		AND.L	D4,D3			;punch out transparent part
		
		MOVE.L	D6,D0
		AND.L	D3,D0
		
		NOT.L	D3
		AND.L	(A1),D3
		OR.L	D0,D3
		MOVE.L	D3,(A1)+
		
		MOVEQ	#-1,D3
		
		SUBQ.W	#1,D2			;decrement counter
		BGT.S	TransSimpleLoop		;loop until done
		BEQ.S	TSL0
		
		RTS

; see if the complex pattern is really a simple one, if so, we can speed things up

TransComplexPat
		MOVE.W	D0,D6
		ADD.W	PATHPOS(A6),D6
		
		MOVE.W	PATHMASK(A6),D4		;get pattern mask
		ASR	#3,D4			;turn bit index to byte  index
		AND.W	D4,D6			;mask it

		MOVE.L	EXPAT(A6),A3
		ADD.W	PATVPOS(A6),A3		;compute pattern address

		CMP.W	#8,PATROW(A6)		;is it a double pattern?
		BGT.S	TransComplex1		;if not, must be complex
		
		MOVE.L	0(A3,D6),D4		;get source longword
		EOR	#4,D6
		CMP.L	0(A3,D6),D4		;is it really simple?
		BEQ	TransSimple1		;if so, go handle

		EOR	#4,D6			;restore D6
TransComplex1
		MOVE.L	D7,-(SP)
		MOVE.L	TRANSCOLOR(A6),D5		;get color to compare with
		
		TST.W	D2
		BNE.S	TCPatLoop
		
; it's complex, so plot it ourselves.  First fetch the pattern.

TCPLoop0
		AND.L	D1,D3
TCPatLoop
		MOVE.W	PATHMASK(A6),D4		;get pattern mask
		ASR	#3,D4			;turn bit index to byte  index
		AND.W	D4,D6			;mask it

		MOVE.L	0(A3,D6),D7		;get source longword
		ADDQ	#4,D6	

		CMP.L	D7,D5			;all transparent?
		BEQ.S	TCPSkip
		
; now create a mask for it

		MOVEQ	#-1,D4			;mask is initially all ones
		
		CMP.B	D7,D5
		BNE.S	@0
		
		CLR.B	D4
@0
		ROR.L	#8,D4
		ROR.L	#8,D7
		
		CMP.B	D7,D5
		BNE.S	@1
		
		CLR.B	D4
@1
		ROR.L	#8,D4
		ROR.L	#8,D7
		
		CMP.B	D7,D5
		BNE.S	@2
		
		CLR.B	D4
@2
		ROR.L	#8,D4
		ROR.L	#8,D7
		
		CMP.B	D7,D5
		BNE.S	@3
		
		CLR.B	D4
@3
		ROR.L	#8,D4
		ROR.L	#8,D7
			
; now we can finally plot it

		MOVE.L	A2,D0
		BEQ.S	@8
		
		AND.L	(A2)+,D3		;pick up the region mask
@8		
		AND.L	D4,D3			;punch out transparent part
		
		MOVE.L	D7,D0
		AND.L	D3,D0
		
		NOT.L	D3
		AND.L	(A1),D3
		OR.L	D0,D3
		MOVE.L	D3,(A1)+
		
; loop until done

NextTCP		
		MOVEQ	#-1,D3
		
		SUBQ.W	#1,D2			;decrement counter
		BGT.S	TCPatLoop		;loop until done
		BEQ.S	TCPLoop0
		
		MOVE.L	(SP)+,D7
		RTS

TCPSkip
		MOVE.L	A2,D0
		BEQ.S	@0
		
		ADDQ.L	#4,A2
@0		
		ADDQ	#4,A1
		
		BRA.S	NextTCP

		
;******************************************************************************************

; Here's where we handle the clipped transparent mode rectangle fill
		
UseOld36A
		JMPRom	Old36A			;						<PB433>
		
		
TransFillR	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld36A		;if not, skip
		tst.l	d3				;right to left? 		<PB427	 BAL>
		bmi.s	UseOld36A		;if s0, skip   			<PB427	 BAL>
		
; set up the registers and invoke the common scan-line handler

		MOVE.L	A4,A2			;set up region pointer
		ASR	#3,D6			;bit index to byte index
		MOVE.L	A5,A1			;set up destination
TransFillLoop		
		MOVEQ	#-1,D1
		MOVEQ	#-1,D3			;edge masks all ones (edges in region)

		MOVE.W	BUFSIZE(A6),D2		;set up the count
		ADDQ	#4,D2			;make one based			<PB427	 BAL>
		LSR.W	#2,D2
		SUBQ	#1,D2			;make zero based		<PB427	 BAL>
		
; call the appropriate handle, depending on whether the pattern is simple or complex		
	
		CMP.W	#8,PATROW(A6)		;is pattern real complex?
		BGT.S	@0			;if so, go handle it

		TST.B	SRCV(A6)		;test pattern mode
		BMI.S	@0			;treat bitmap as complex
		
		MOVE.L	0(A3,D6),D0		;get left pattern
		EOR	#4,D6
		CMP.L	0(A3,D6),D0		;left same as right?
		BEQ.S	@1			;if so, it's simple

		EOR	#4,D6			;restore D6
@0		
		BSR	TransComplex1		;invoke scan-line handler for complex pats		
		BRA.S	@2
@1
		EOR	#4,D6
		MOVE.L	A3,A0
		BSR	TransSimple1
		
; bump pointers to next time, and loop until done

@2
		MOVE.W	DSTV(A6),D0
		
		TST.B	SRCV(A6)		;test pattern mode
		BEQ.S	TransPat1		;if zero, handle
		BMI.S	TransBitMap1	;if <0, go handle bitmap

		MOVE.L	HEIGHT(A6),D6		;get pattern index
		ASR.L	#3,D6			;bit index to byte index

; handle bumping the pattern pointers

		MOVE.L	SRCADDR(A6),A3		;set up pattern pointer
		SUB.W	D0,A3
		ADD.W	PATROW(A6),D0
		AND.W	PATVMASK(A6),D0
		MOVE.W	D0,DSTV(A6)
		ADD.W	D0,A3
		
		BRA.S	TransSetPatPtr

; handle second type of pattern

TransPat1
		MOVE.L	HEIGHT(A6),D6		;get pattern index
		ASR.L	#3,D6			;bit index to byte index

		ADDQ	#1,D0
		AND	#15,D0
		LEA	([EXPAT,A6],D0.W*4),A3
		
		MOVE.W	D0,HEIGHT(A6)
TransSetPatPtr		
		MOVE.L	A3,SRCADDR(A6)
		
; bump to the next scan line

TransFillNextLine
		MOVE.L	DSTROW(A6),D0
		ADD.L	D0,DSTADDR(A6)

		MOVE.W	VERT(A6),D0
		ADD.W	VBUMP(A6),D0
		MOVE.W	D0,VERT(A6)
		
		CMP.W	LASTV(A6),D0
		BNE.S	@0

; all done, so strip stack and return

		MOVE.L	SAVESTK2(A6),A7
		RTS

; set up registers and loop for the next line

@0
		MOVE.L	SEEKMASK(A6),A0
		JSR	(A0)			;seek new region
		
		MOVE.L	SRCADDR(A6),A3		;set up pattern pointer
		MOVE.L	DSTADDR(A6),A1		;set up dest ptr
		MOVE.L	RGNADDR(A6),A2		;set up region ptr
	
		BRA	TransFillLoop

; handle bumping the source if it's a bitmap

TransBitMap1
		MOVE.L	SRCROW(A6),D0
									;<PB427	 BAL>
		ADD.L	D0,SRCADDR(A6)
		
		MOVE.l	HEIGHT(A6),D6	
		asr.l	#3,d6				;make byte offset <PB427	 BAL>
		BRA.S	TransFillNextLine
		

;******************************************************************************************
				

UseOld354
		JMPRom	Old354			;						<PB433>

		
TransUnClip	

		CMP.W	#8,DSTPIX+PIXELSIZE(A6)		;is it 8 bit mode?
		BNE.S	UseOld354		;if not, skip
		tst.l	(sp)			;right to left? 		<PB427	 BAL>
		bmi.s	UseOld354		;if so, skip   			<PB427	 BAL>
		
; set up the registers and invoke the common scan-line handler

		SUB.L	A2,A2			;no region pointer
		ASR	#3,D6			;bit index to byte index
		MOVE.L	A4,A3			;set up pattern pointer
		MOVE.L	A5,A1			;set up destination
TransUCLoop		
		MOVE.L	FIRSTMASK(A6),D3		;set up left edge
		MOVE.L	LASTMASK(A6),D1		;set up right edge

; compute the count from the three pieces: left, mid and right

		MOVE.W	LONGCNT(A6),D2		;get left count
		BPL.S	@3			;if positive, we're cool
		
		MOVEQ	#0,D2			;only one word
		BRA.S	@4
@3
		ADD.W	MIDCOUNT(A6),D2		;add in the middle
		ADD.W	PIXINLONG(A6),D2		;add in the right
		ADDQ.W	#2,D2			;add for count bias
		LSR.W	#2,D2			;bytes -> longs

; call the appropriate handle, depending on whether the pattern is simple or complex		

@4	
		CMP.W	#8,PATROW(A6)		;is pattern real complex?
		BGT.S	@0			;if so, go handle it

		TST.B	ENDSWITCH(A6)		;test pattern mode
		BMI.S	@0			;if bitmap, handle as complex
		
		MOVE.L	0(A3,D6),D0		;get left pattern
		EOR	#4,D6
		CMP.L	0(A3,D6),D0		;left same as right?
		BEQ.S	@1			;if so, it's simple

		EOR	#4,D6			;restore D6
@0		
		MOVE.L	A1,-(SP)
		BSR	TransComplex1		;invoke scan-line handler for complex pats		
		MOVE.L	(SP)+,A1
		
		BRA.S	@2
@1
		EOR	#4,D6
		
		MOVEM.L	A1/A3,-(SP)	
		MOVE.L	A3,A0
		BSR	TransSimple1
		MOVEM.L	(SP)+,A1/A3
		
; bump pointers to next time, and loop until done

@2
		TST.B	ENDSWITCH(A6)		;test pattern mode
		BEQ.S	TransUCPat1		;if zero, handle
		BMI.S	TransUCBitMap1		;if <0, go handle bitmap

; handle bumping the pattern pointers

		MOVE.W	PATPOS(A6),D0
		SUB.W	D0,A3
		ADD.W	PATROW(A6),D0
		AND.W	PATVMASK(A6),D0
		MOVE.W	D0,PATPOS(A6)
		ADD.W	D0,A3
		
		BRA.S	TransUCNextLine

; handle second type of pattern

TransUCPat1
		MOVE.W	PATPOS(A6),D0
		ADDQ	#1,D0
		AND	#15,D0
		LEA	([EXPAT,A6],D0.W*4),A3
		
		MOVE.W	D0,PATPOS(A6)

; bump to the next scan line

TransUCNextLine
		MOVE.L	PATOFFSET(A6),D6
		ASR.L	#3,D6			;bits to bytes		
TransUCNL2
		ADD.W	DSTROW+2(A6),A1		;bump destination
		
		SUBQ.W	#1,HEIGHT(A6)
		BNE	TransUCLoop
		
		ADDQ	#4,SP
		RTS

; handle unclipped blits source setup

TransUCBitMap1
		ADD.W	D6,A3
		ADD.W	SRCBUMP(A6),A3		;bump to next line <PB448 DBG>
		MOVEQ	#0,D6
		BRA.S	TransUCNL2
		
;******************************************************************************************

;   End of arithmetic transfer modes!
		
;******************************************************************************************
						
; Special BlockMove subroutine optimized for this situation.  The source is in A0 
; and dest in A1, with byte count in D0.  Note things are already pre-bumped for
; the MoveRight case.  Note that we  assume that no move is bigger than 32KBytes, 
; to save a little speed (no scanline is that big!)

BlockMove
		
		TST.W	D5			;test direction
		BMI	MoveRight		;if right, skip
		
; for small moves, all this casing out is a losing battle, so dive in quickly

		CMP.W	#32,D0			;is it really small?
		BLT.S	FinishUpLeft		;if so, finish up last few

; make sure the destination is always longword aligned by moving up to 3 bytes

		MOVE.W	A1,D1			;get destination
		AND.W	#3,D1			;low two bits only
		BEQ.S	MediumLeft		;if 0, skip
		
		JMP	LeftAlign(D1.W*4)
LeftAlign
		NOP
		NOP
		
		MOVE.B	(A0)+,(A1)+
		SUBQ	#1,D0

		MOVE.B	(A0)+,(A1)+
		SUBQ	#1,D0
		
		MOVE.B	(A0)+,(A1)+
		SUBQ	#1,D0
								
; we've got a medium-sized block to move (at least 32), so handle it with an unwound MOVE.L loop

MediumLeft
		MOVE.W	D0,D1
		LSR.W	#5,D1			;divide by 32
		BRA.S	@2
		
@1
		MOVE.L	(A0)+,(A1)+		;move 32 bytes
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+		
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+
		MOVE.L	(A0)+,(A1)+
@2
		DBRA	D1,@1			;move it

; now we have 31 or less bytes left to move		

		AND	#31,D0
FinishUpLeft
		MOVE.W	LOffsetTable(D0.W*2),D0
		JMP	LastLeft(D0)
LastLeft		
 
Left1F
		MOVE.L	(A0)+,(A1)+
Left1B
		MOVE.L	(A0)+,(A1)+
Left17
		MOVE.L	(A0)+,(A1)+
Left13
		MOVE.L	(A0)+,(A1)+
LeftF
		MOVE.L	(A0)+,(A1)+		;move next 32 (64 total)
LeftB		
		MOVE.L	(A0)+,(A1)+
Left7		
		MOVE.L	(A0)+,(A1)+
Left3		
		MOVE.W	(A0)+,(A1)+
Left1		
		MOVE.B	(A0)+,(A1)+
Left0

DoneBlockMove		
		RTS
Left1E
		MOVE.L	(A0)+,(A1)+
Left1A
		MOVE.L	(A0)+,(A1)+
Left16
		MOVE.L	(A0)+,(A1)+
Left12
		MOVE.L	(A0)+,(A1)+
LeftE
		MOVE.L	(A0)+,(A1)+
LeftA		
		MOVE.L	(A0)+,(A1)+
Left6
		MOVE.L	(A0)+,(A1)+
Left2
		MOVE.W	(A0)+,(A1)+

		RTS		

Left1C
		MOVE.L	(A0)+,(A1)+
Left18		
		MOVE.L	(A0)+,(A1)+
Left14
		MOVE.L	(A0)+,(A1)+
Left10
		MOVE.L	(A0)+,(A1)+
LeftC
		MOVE.L	(A0)+,(A1)+
Left8
		MOVE.L	(A0)+,(A1)+
Left4
		MOVE.L	(A0)+,(A1)+		
		RTS
Left1D
		MOVE.L	(A0)+,(A1)+
Left19
		MOVE.L	(A0)+,(A1)+
Left15
		MOVE.L	(A0)+,(A1)+
Left11
		MOVE.L	(A0)+,(A1)+
LeftD
		MOVE.L	(A0)+,(A1)+
Left9
		MOVE.L	(A0)+,(A1)+
Left5
		MOVE.L	(A0)+,(A1)+
		MOVE.B	(A0)+,(A1)+		
		RTS

LOffsetTable
		DC.W	Left0-LastLeft
		DC.W	Left1-LastLeft
		DC.W	Left2-LastLeft
		DC.W	Left3-LastLeft
		DC.W	Left4-LastLeft
		DC.W	Left5-LastLeft
		DC.W	Left6-LastLeft
		DC.W	Left7-LastLeft
		DC.W	Left8-LastLeft
		DC.W	Left9-LastLeft
		DC.W	LeftA-LastLeft
		DC.W	LeftB-LastLeft
		DC.W	LeftC-LastLeft
		DC.W	LeftD-LastLeft
		DC.W	LeftE-LastLeft
		DC.W	LeftF-LastLeft
		DC.W	Left10-LastLeft
		DC.W	Left11-LastLeft
		DC.W	Left12-LastLeft
		DC.W	Left13-LastLeft
		DC.W	Left14-LastLeft
		DC.W	Left15-LastLeft
		DC.W	Left16-LastLeft
		DC.W	Left17-LastLeft
		DC.W	Left18-LastLeft
		DC.W	Left19-LastLeft
		DC.W	Left1A-LastLeft
		DC.W	Left1B-LastLeft
		DC.W	Left1C-LastLeft
		DC.W	Left1D-LastLeft
		DC.W	Left1E-LastLeft
		DC.W	Left1F-LastLeft
		

; Handle the case of moving to the right

MoveRight
		CMP.W	#32,D0			;is it really small?
		BLT.S 	FinishUpRight		;if so, finish up last few

; make sure the destination is always longword aligned by moving up to 3 bytes

		MOVE.W	A1,D1			;get destination
		AND.W	#3,D1			;low two bits only
		
		EOR.W	#3,D1			;flip sense		
		JMP	RightAlign(D1.W*4)
RightAlign
		MOVE.B	-(A0),-(A1)
		SUBQ	#1,D0

		MOVE.B	-(A0),-(A1)
		SUBQ	#1,D0
		
		MOVE.B	-(A0),-(A1)
		SUBQ	#1,D0
								
; we've got a medium-sized block to move (at least 32), so handle it with an unwound MOVE.L loop

MediumRight
		MOVE.W	D0,D1
		LSR.W	#5,D1			;divide by 32
		BRA.S	@2
@1
		MOVE.L	-(A0),-(A1)		;move 32 bytes
		MOVE.L	-(A0),-(A1)
		MOVE.L	-(A0),-(A1)
		MOVE.L	-(A0),-(A1)
		MOVE.L	-(A0),-(A1)
		MOVE.L	-(A0),-(A1)
		MOVE.L	-(A0),-(A1)
		MOVE.L	-(A0),-(A1)
@2		
		DBRA	D1,@1			;move the bulk of it
		
; now we have 31 or less bytes left to move		

		AND	#31,D0
FinishUpRight
		MOVE.W	ROffsetTable(D0.W*2),D0
;+++		JMP	LastRight(D0)	
		JMP		(QGLastRight,PC,D0)		; this is a hack - this JMP must be immediately before the table
QGLastRight		

Right1F
		MOVE.L	-(A0),-(A1)
Right1B
		MOVE.L	-(A0),-(A1)
Right17
		MOVE.L	-(A0),-(A1)
Right13
		MOVE.L	-(A0),-(A1)
RightF
		MOVE.L	-(A0),-(A1)		;move next 32 (64 total)
RightB		
		MOVE.L	-(A0),-(A1)
Right7		
		MOVE.L	-(A0),-(A1)
Right3		
		MOVE.W	-(A0),-(A1)
Right1		
		MOVE.B	-(A0),-(A1)
Right0
		RTS
Right1E
		MOVE.L	-(A0),-(A1)
Right1A
		MOVE.L	-(A0),-(A1)
Right16
		MOVE.L	-(A0),-(A1)
Right12
		MOVE.L	-(A0),-(A1)
RightE
		MOVE.L	-(A0),-(A1)
RightA		
		MOVE.L	-(A0),-(A1)
Right6
		MOVE.L	-(A0),-(A1)
Right2
		MOVE.W	-(A0),-(A1)

		RTS		

Right1C
		MOVE.L	-(A0),-(A1)
Right18		
		MOVE.L	-(A0),-(A1)
Right14
		MOVE.L	-(A0),-(A1)
Right10
		MOVE.L	-(A0),-(A1)
RightC
		MOVE.L	-(A0),-(A1)
Right8
		MOVE.L	-(A0),-(A1)
Right4
		MOVE.L	-(A0),-(A1)
		
		RTS
Right1D
		MOVE.L	-(A0),-(A1)
Right19
		MOVE.L	-(A0),-(A1)
Right15
		MOVE.L	-(A0),-(A1)
Right11
		MOVE.L	-(A0),-(A1)
RightD
		MOVE.L	-(A0),-(A1)
Right9
		MOVE.L	-(A0),-(A1)
Right5
		MOVE.L	-(A0),-(A1)
		MOVE.B	-(A0),-(A1)		
		
		RTS

ROffsetTable
		DC.W	Right0-QGLastRight
		DC.W	Right1-QGLastRight
		DC.W	Right2-QGLastRight
		DC.W	Right3-QGLastRight
		DC.W	Right4-QGLastRight
		DC.W	Right5-QGLastRight
		DC.W	Right6-QGLastRight
		DC.W	Right7-QGLastRight
		DC.W	Right8-QGLastRight
		DC.W	Right9-QGLastRight
		DC.W	RightA-QGLastRight
		DC.W	RightB-QGLastRight
		DC.W	RightC-QGLastRight
		DC.W	RightD-QGLastRight
		DC.W	RightE-QGLastRight
		DC.W	RightF-QGLastRight
		DC.W	Right10-QGLastRight
		DC.W	Right11-QGLastRight
		DC.W	Right12-QGLastRight
		DC.W	Right13-QGLastRight
		DC.W	Right14-QGLastRight
		DC.W	Right15-QGLastRight
		DC.W	Right16-QGLastRight
		DC.W	Right17-QGLastRight
		DC.W	Right18-QGLastRight
		DC.W	Right19-QGLastRight
		DC.W	Right1A-QGLastRight
		DC.W	Right1B-QGLastRight
		DC.W	Right1C-QGLastRight
		DC.W	Right1D-QGLastRight
		DC.W	Right1E-QGLastRight
		DC.W	Right1F-QGLastRight

EndQPatches


		PRINT	OFF
